<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Ruchy Programming Language</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="The official book for the Ruchy language - implementation-first documentation">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "coal";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Ruchy Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/paiml/ruchy-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-ruchy-programming-language"><a class="header" href="#the-ruchy-programming-language">The Ruchy Programming Language</a></h1>
<p><em>The official book for the Ruchy language</em></p>
<h2 id="living-documentation"><a class="header" href="#living-documentation">Living Documentation</a></h2>
<p>This book is implementation-first documentation that is continuously validated against the current Ruchy compiler. Every code example in this book compiles and runs with the version of Ruchy specified in our configuration.</p>
<p><strong>Current Ruchy Version</strong>: See <code>book/Cargo.toml</code> for exact version</p>
<h2 id="about-this-book"><a class="header" href="#about-this-book">About This Book</a></h2>
<p>The Ruchy Programming Language book follows a progressive disclosure approach:</p>
<ul>
<li><strong>Level 0</strong> (Chapters 1-3): Write useful scripts in 2 hours</li>
<li><strong>Level 1</strong> (Chapters 4-7): Build real-world programs in 1 week</li>
<li><strong>Level 2</strong> (Chapters 8-11): Develop performance-critical systems in 1 month</li>
<li><strong>Level 3</strong> (Chapters 12-15): Master advanced language features in 3 months</li>
</ul>
<h2 id="quality-commitment"><a class="header" href="#quality-commitment">Quality Commitment</a></h2>
<ul>
<li>✅ Every example compiles with current Ruchy version</li>
<li>✅ All code is tested in CI/CD pipeline</li>
<li>✅ Zero vaporware - only documented features work</li>
<li>✅ Updated within 24 hours of compiler releases</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreword"><a class="header" href="#foreword">Foreword</a></h1>
<p>Welcome to The Ruchy Programming Language book. This is not just another programming language tutorial - it’s a living, breathing document that evolves with the language itself.</p>
<h2 id="our-philosophy"><a class="header" href="#our-philosophy">Our Philosophy</a></h2>
<p>Ruchy was born from a simple observation: modern programming languages often sacrifice simplicity for power, or ease of use for performance. We believe you shouldn’t have to choose.</p>
<p>Ruchy brings together:</p>
<ul>
<li>The simplicity of Python</li>
<li>The performance of Rust</li>
<li>The expressiveness of functional programming</li>
<li>The practicality of systems programming</li>
</ul>
<h2 id="implementation-first-documentation"><a class="header" href="#implementation-first-documentation">Implementation-First Documentation</a></h2>
<p>Every code example in this book:</p>
<ul>
<li>Compiles with the current Ruchy compiler</li>
<li>Is tested automatically in our CI pipeline</li>
<li>Produces the exact output shown</li>
<li>Can be copied and run immediately</li>
</ul>
<p>We don’t document features that don’t exist. We don’t make promises about future functionality. What you see is what works, today.</p>
<h2 id="how-to-use-this-book"><a class="header" href="#how-to-use-this-book">How to Use This Book</a></h2>
<p>This book is organized in progressive levels:</p>
<ol>
<li><strong>Start with Level 0</strong> if you want to write scripts quickly</li>
<li><strong>Continue to Level 1</strong> when you need to build applications</li>
<li><strong>Advance to Level 2</strong> for systems programming</li>
<li><strong>Explore Level 3</strong> for language mastery</li>
</ol>
<p>You don’t need to read every chapter. Pick the level that matches your goals and dive in.</p>
<h2 id="a-living-document"><a class="header" href="#a-living-document">A Living Document</a></h2>
<p>This book is synchronized with the Ruchy compiler. When new features are added to the language, they appear here. When behaviors change, the examples update. This is not a snapshot - it’s a mirror of the current implementation.</p>
<p>Let’s begin your journey with Ruchy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="what-is-ruchy"><a class="header" href="#what-is-ruchy">What is Ruchy?</a></h2>
<p>Ruchy is a modern programming language that transpiles to Rust, combining ease of use with systems-level performance. It’s designed for developers who want to write fast, safe code without wrestling with complex syntax or lifetime annotations.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<h3 id="simplicity-first"><a class="header" href="#simplicity-first">Simplicity First</a></h3>
<p>Write code that reads like Python but runs like Rust:</p>
<pre><code class="language-text">fn greet(name: str) -&gt; str {
    f"Hello, {name}!"
}
</code></pre>
<h3 id="zero-cost-abstractions"><a class="header" href="#zero-cost-abstractions">Zero-Cost Abstractions</a></h3>
<p>Every Ruchy feature compiles to optimal Rust code with no runtime overhead.</p>
<h3 id="progressive-complexity"><a class="header" href="#progressive-complexity">Progressive Complexity</a></h3>
<p>Start simple, add complexity only when needed. You can write entire programs without thinking about ownership, then gradually adopt advanced features as your needs grow.</p>
<h3 id="first-class-data-science-support"><a class="header" href="#first-class-data-science-support">First-Class Data Science Support</a></h3>
<p>Built-in DataFrame support via Polars integration makes data manipulation as easy as Python pandas but with Rust’s performance.</p>
<h2 id="who-should-read-this-book"><a class="header" href="#who-should-read-this-book">Who Should Read This Book?</a></h2>
<p>This book is for you if you:</p>
<ul>
<li>Want to write high-performance code without the complexity</li>
<li>Are coming from Python and want compiled language benefits</li>
<li>Know Rust but want a more ergonomic syntax for rapid development</li>
<li>Need to process data efficiently without sacrificing safety</li>
</ul>
<h2 id="what-this-book-covers"><a class="header" href="#what-this-book-covers">What This Book Covers</a></h2>
<p>We’ll take you on a journey from “Hello, World!” to building complex systems:</p>
<ol>
<li><strong>Basics</strong>: Variables, functions, control flow</li>
<li><strong>Ownership</strong>: Simplified memory management</li>
<li><strong>Collections</strong>: Lists, dictionaries, and functional operations</li>
<li><strong>Error Handling</strong>: Robust error management with Result types</li>
<li><strong>Concurrency</strong>: Async/await and actor systems</li>
<li><strong>Data Science</strong>: DataFrame operations and analytics</li>
<li><strong>Advanced</strong>: Macros, unsafe code, and Rust interop</li>
</ol>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>You should be comfortable with:</p>
<ul>
<li>Basic programming concepts (variables, functions, loops)</li>
<li>Using a terminal/command line</li>
<li>A text editor or IDE</li>
</ul>
<p>You don’t need to know Rust - we’ll explain everything as we go.</p>
<h2 id="how-to-read-this-book"><a class="header" href="#how-to-read-this-book">How to Read This Book</a></h2>
<p>This book is designed to be read in order if you’re new to Ruchy. However, each chapter is self-contained enough that experienced programmers can jump to topics of interest.</p>
<p>Code examples build on each other within chapters but not necessarily between chapters, so you can start fresh with each new topic.</p>
<h2 id="conventions-used"><a class="header" href="#conventions-used">Conventions Used</a></h2>
<p>Throughout this book, we use the following conventions:</p>
<ul>
<li><strong>Code blocks</strong> show Ruchy code that you can compile and run</li>
<li><strong>Output blocks</strong> show what the code produces</li>
<li><strong>Transpilation insights</strong> reveal the generated Rust code</li>
<li><strong>Exercises</strong> help reinforce concepts (solutions in Appendix G)</li>
</ul>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<p>If you have questions:</p>
<ul>
<li>Check the error messages - Ruchy provides helpful, actionable errors</li>
<li>Visit the official documentation at docs.ruchy.org</li>
<li>Join our community at community.ruchy.org</li>
<li>Report issues at github.com/paiml/ruchy</li>
</ul>
<p>Let’s get started!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Let’s get Ruchy installed and write our first program!</p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<p>The fastest way to try Ruchy is with the REPL:</p>
<pre><code class="language-bash">$ ruchy repl
Ruchy 0.4.11 - Interactive REPL
&gt;&gt;&gt; println("Hello, Ruchy!")
Hello, Ruchy!
</code></pre>
<p>In this chapter, we’ll cover:</p>
<ul>
<li>Installing Ruchy on your system</li>
<li>Writing your first Ruchy program</li>
<li>Understanding how Ruchy works</li>
</ul>
<p>By the end of this chapter, you’ll have a working Ruchy installation and will have written, compiled, and run your first program.</p>
<h2 id="chapter-outline"><a class="header" href="#chapter-outline">Chapter Outline</a></h2>
<ul>
<li><a href="ch01-01-installation.html">Installation</a> - Get Ruchy on your system</li>
<li><a href="ch01-02-hello-world.html">Hello, World!</a> - Your first program</li>
</ul>
<p>Let’s begin!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>Before you can write Ruchy code, you need the Ruchy compiler installed on your system. We’ll get you set up quickly so you can start coding in minutes, not hours.</p>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<p>The fastest way to get Ruchy:</p>
<pre><code class="language-bash"># Install via cargo (requires Rust toolchain)
cargo install ruchy

# Verify installation
ruchy --version
</code></pre>
<h2 id="installation-methods"><a class="header" href="#installation-methods">Installation Methods</a></h2>
<h3 id="method-1-cargo-install-recommended"><a class="header" href="#method-1-cargo-install-recommended">Method 1: Cargo Install (Recommended)</a></h3>
<p>If you have Rust installed:</p>
<pre><code class="language-bash">cargo install ruchy
</code></pre>
<p>This installs the latest stable version from crates.io.</p>
<h3 id="method-2-download-pre-built-binaries"><a class="header" href="#method-2-download-pre-built-binaries">Method 2: Download Pre-built Binaries</a></h3>
<p>Visit <a href="https://github.com/paiml/ruchy/releases">https://github.com/paiml/ruchy/releases</a> and download the binary for your platform:</p>
<ul>
<li><strong>Linux</strong>: <code>ruchy-x86_64-unknown-linux-gnu.tar.gz</code></li>
<li><strong>macOS</strong>: <code>ruchy-x86_64-apple-darwin.tar.gz</code></li>
<li><strong>Windows</strong>: <code>ruchy-x86_64-pc-windows-msvc.zip</code></li>
</ul>
<p>Extract and add to your PATH.</p>
<h3 id="method-3-build-from-source"><a class="header" href="#method-3-build-from-source">Method 3: Build from Source</a></h3>
<p>For the latest development version:</p>
<pre><code class="language-bash">git clone https://github.com/paiml/ruchy.git
cd ruchy
cargo build --release

# The binary is at target/release/ruchy
</code></pre>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>Ruchy requires:</p>
<ul>
<li><strong>Rust toolchain</strong> (for compilation backend)</li>
<li><strong>LLVM</strong> (provided by rustc)</li>
</ul>
<h3 id="installing-rust"><a class="header" href="#installing-rust">Installing Rust</a></h3>
<p>If you don’t have Rust:</p>
<pre><code class="language-bash"># Install rustup (Rust installer)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Reload shell
source ~/.bashrc  # or ~/.zshrc

# Verify
rustc --version
</code></pre>
<h2 id="verification"><a class="header" href="#verification">Verification</a></h2>
<p>Test your installation:</p>
<pre><code class="language-bash"># Check version
ruchy --version

# Start the REPL
ruchy repl

# Run a quick test
echo 'println("Ruchy is working!")' | ruchy repl
</code></pre>
<p>You should see:</p>
<pre><code>Ruchy is working!
</code></pre>
<h2 id="development-environment-setup"><a class="header" href="#development-environment-setup">Development Environment Setup</a></h2>
<h3 id="vs-code-recommended"><a class="header" href="#vs-code-recommended">VS Code (Recommended)</a></h3>
<p>Install the Ruchy extension for syntax highlighting:</p>
<ol>
<li>Open VS Code</li>
<li>Install “Ruchy Language Support” extension</li>
<li>Create a file with <code>.ruchy</code> extension</li>
<li>Enjoy syntax highlighting and basic IntelliSense</li>
</ol>
<h3 id="other-editors"><a class="header" href="#other-editors">Other Editors</a></h3>
<ul>
<li><strong>Vim/Neovim</strong>: Use the <code>ruchy.vim</code> syntax file from the repository</li>
<li><strong>Emacs</strong>: Basic syntax highlighting available in <code>ruchy-mode</code></li>
<li><strong>Sublime Text</strong>: Package available through Package Control</li>
</ul>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<p>Create your first Ruchy project:</p>
<pre><code class="language-bash">mkdir my-ruchy-project
cd my-ruchy-project

# Create main file
echo 'println("Hello from my project!")' &gt; main.ruchy

# Run it
ruchy run main.ruchy
</code></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="command-not-found"><a class="header" href="#command-not-found">Command not found</a></h3>
<p>If <code>ruchy</code> command isn’t found:</p>
<pre><code class="language-bash"># Check if it's in PATH
which ruchy

# If installed via cargo, add to PATH:
export PATH="$HOME/.cargo/bin:$PATH"

# Make permanent by adding to ~/.bashrc or ~/.zshrc
echo 'export PATH="$HOME/.cargo/bin:$PATH"' &gt;&gt; ~/.bashrc
</code></pre>
<h3 id="compilation-errors"><a class="header" href="#compilation-errors">Compilation Errors</a></h3>
<p>If you see “rustc not found”:</p>
<pre><code class="language-bash"># Install Rust if missing
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Update if outdated
rustup update
</code></pre>
<h3 id="permission-errors"><a class="header" href="#permission-errors">Permission Errors</a></h3>
<p>On Unix systems:</p>
<pre><code class="language-bash"># Make binary executable
chmod +x ruchy

# Or install with proper permissions
sudo cargo install ruchy
</code></pre>
<h2 id="whats-next"><a class="header" href="#whats-next">What’s Next</a></h2>
<p>Now that Ruchy is installed, let’s write your first program: <a href="ch01-02-hello-world.html">Hello, World!</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h1>
<p><em>“I still remember the first time I made a computer print ‘Hello, World!’ It was magical - like teaching a very literal friend to speak. That same feeling of wonder drove me to create Ruchy, where your first program works immediately, not after hours of setup.”</em> - Noah Gift</p>
<h2 id="the-problem-1"><a class="header" href="#the-problem-1">The Problem</a></h2>
<p>Every programming journey begins with a simple question: “How do I make the computer say something?” The “Hello, World!” program is more than tradition—it’s your first proof that you can communicate with a computer in its own language.</p>
<p>In Ruchy, we believe this first step should be immediate and rewarding, not buried under complexity.</p>
<h2 id="quick-example"><a class="header" href="#quick-example">Quick Example</a></h2>
<p>Here’s your first Ruchy program:</p>
<pre><code class="language-ruchy">println("Hello, World!")
</code></pre>
<p>That’s it! Save this in a file called <code>hello.ruchy</code> and run it with:</p>
<pre><code class="language-bash">$ ruchy run hello.ruchy
Hello, World!
</code></pre>
<p>Or try it instantly in the REPL:</p>
<pre><code class="language-bash">$ ruchy repl
&gt;&gt;&gt; println("Hello, World!")
Hello, World!
</code></pre>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="the-println-function"><a class="header" href="#the-println-function">The println Function</a></h3>
<p><code>println</code> is Ruchy’s built-in function for printing text to the screen. It:</p>
<ul>
<li>Takes any number of arguments</li>
<li>Prints them separated by spaces</li>
<li>Automatically adds a newline at the end</li>
<li>Returns <code>()</code> (unit type) when done</li>
</ul>
<h3 id="string-literals"><a class="header" href="#string-literals">String Literals</a></h3>
<p>In <code>"Hello, World!"</code>:</p>
<ul>
<li>Double quotes <code>"</code> mark the beginning and end of text</li>
<li>Everything inside is treated literally as text</li>
<li>This creates a <code>str</code> type in Ruchy</li>
</ul>
<h3 id="function-calls"><a class="header" href="#function-calls">Function Calls</a></h3>
<p>The syntax <code>println(...)</code> is a function call:</p>
<ul>
<li><code>println</code> is the function name</li>
<li>Parentheses <code>()</code> contain the arguments</li>
<li>Multiple arguments are separated by commas</li>
</ul>
<h2 id="practical-usage"><a class="header" href="#practical-usage">Practical Usage</a></h2>
<h3 id="multiple-arguments"><a class="header" href="#multiple-arguments">Multiple Arguments</a></h3>
<pre><code class="language-ruchy">println("Hello", "World", "from", "Ruchy")
</code></pre>
<p>Output:</p>
<pre><code>Hello World from Ruchy
</code></pre>
<h3 id="variables-and-interpolation"><a class="header" href="#variables-and-interpolation">Variables and Interpolation</a></h3>
<pre><code class="language-ruchy">let name = "Alice"
println("Hello,", name)

// Or with string interpolation
println(f"Hello, {name}!")
</code></pre>
<p>Output:</p>
<pre><code>Hello, Alice
Hello, Alice!
</code></pre>
<h3 id="numbers-and-other-types"><a class="header" href="#numbers-and-other-types">Numbers and Other Types</a></h3>
<pre><code class="language-ruchy">println("The answer is", 42)
println("Pi is approximately", 3.14159)
println("Is Ruchy awesome?", true)
</code></pre>
<p>Output:</p>
<pre><code>The answer is 42
Pi is approximately 3.14159
Is Ruchy awesome? true
</code></pre>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<h3 id="forgetting-quotes"><a class="header" href="#forgetting-quotes">Forgetting Quotes</a></h3>
<pre><code class="language-ruchy">// ❌ This won't work
println(Hello, World!)
</code></pre>
<p>Error: <code>Hello</code> and <code>World</code> are treated as variables, not text.</p>
<h3 id="mixing-quote-types"><a class="header" href="#mixing-quote-types">Mixing Quote Types</a></h3>
<pre><code class="language-ruchy">// ❌ Quotes don't match
println("Hello, World!')
</code></pre>
<p>Error: String not properly closed.</p>
<h3 id="case-sensitivity"><a class="header" href="#case-sensitivity">Case Sensitivity</a></h3>
<pre><code class="language-ruchy">// ❌ Wrong capitalization
PrintLn("Hello, World!")
</code></pre>
<p>Error: <code>PrintLn</code> is not defined. Ruchy function names are lowercase.</p>
<h2 id="generated-code-insight"><a class="header" href="#generated-code-insight">Generated Code Insight</a></h2>
<p>Ever wonder what happens “under the hood” when you write Ruchy code? Let’s peek behind the curtain.</p>
<details>
<summary>🔍 View Generated Rust Code (click to expand)</summary>
<p>Your Ruchy code:</p>
<pre><code class="language-ruchy">println("Hello, World!")
</code></pre>
<p>Transpiles to this optimized Rust:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!("Hello, World!");
}</code></pre></pre>
<p><strong>What’s happening:</strong></p>
<ul>
<li>Ruchy’s <code>println</code> function becomes Rust’s <code>println!</code> macro</li>
<li>Ruchy automatically wraps top-level code in a <code>main()</code> function</li>
<li>The string literal stays exactly the same</li>
<li>No runtime overhead - this compiles to native machine code</li>
</ul>
<p><strong>Why this matters:</strong></p>
<ul>
<li>You get Rust’s performance without Rust’s complexity</li>
<li>Your code can integrate seamlessly with existing Rust libraries</li>
<li>The generated code is readable and debuggable</li>
</ul>
</details>
<p><strong>The Bottom Line:</strong> Ruchy gives you Python-like simplicity with Rust-like performance. You’re not sacrificing speed for ease of use.</p>
<h2 id="try-it-yourself"><a class="header" href="#try-it-yourself">Try It Yourself</a></h2>
<p>Time to get your hands dirty! Fire up the REPL and experiment:</p>
<pre><code class="language-bash">$ ruchy repl
&gt;&gt;&gt; # Start with your own greeting
&gt;&gt;&gt; println("Hello, [YOUR NAME]!")
&gt;&gt;&gt; 
&gt;&gt;&gt; # Try multiple arguments
&gt;&gt;&gt; println("My favorite number is", 42)
&gt;&gt;&gt; 
&gt;&gt;&gt; # Mix different types
&gt;&gt;&gt; println("Learning Ruchy:", true, "Progress:", 100, "%")
&gt;&gt;&gt;
&gt;&gt;&gt; # Personal touch - make it yours!
&gt;&gt;&gt; let my_language = "Ruchy" 
&gt;&gt;&gt; let excitement_level = "maximum"
&gt;&gt;&gt; println(f"I'm learning {my_language} with {excitement_level} enthusiasm!")
</code></pre>
<p><strong>Your Challenge:</strong></p>
<ol>
<li><strong>Personal Greeting</strong>: Create a greeting that includes your name, age, and why you’re learning Ruchy</li>
<li><strong>Data Mix</strong>: Use <code>println</code> with at least 4 different data types in one call</li>
<li><strong>String Interpolation</strong>: Use the <code>f""</code> syntax to create a personalized message</li>
</ol>
<p><strong>Example Output:</strong></p>
<pre><code>Hi! I'm Alex, 28 years old, learning Ruchy for data science
Mixing types: text 42 3.14 true null
My goal: I want to build fast applications with Ruchy!
</code></pre>
<p>The REPL is your playground - break things, experiment, learn!</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li><code>println(...)</code> is your tool for displaying output</li>
<li>String literals use double quotes: <code>"text"</code></li>
<li>Function calls use parentheses: <code>function_name(arguments)</code></li>
<li>Ruchy transpiles to clean, efficient Rust code</li>
<li>The REPL is perfect for quick experiments</li>
</ul>
<p>Now that you can make Ruchy speak, let’s learn about storing and manipulating information with variables and types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-and-types"><a class="header" href="#variables-and-types">Variables and Types</a></h1>
<p><em>“The biggest mistake I made learning programming was thinking variables were like algebra. In programming, variables are more like labeled boxes where you can store different things. Once I understood this, everything clicked.”</em> - Noah Gift</p>
<h2 id="the-problem-2"><a class="header" href="#the-problem-2">The Problem</a></h2>
<p>You’ve mastered printing output, but programs need memory - places to store information, work with data, and build complex logic. How do you tell a computer to “remember this number” or “store this name for later”?</p>
<p>In most languages, this involves type declarations, memory management, and complex syntax. In Ruchy, storing information should be as natural as thinking it.</p>
<h2 id="quick-example-1"><a class="header" href="#quick-example-1">Quick Example</a></h2>
<p>Here’s how you store and use data in Ruchy:</p>
<pre><code class="language-ruchy">let name = "Alice"
let age = 25
let is_learning = true

println(f"Hi {name}, you're {age} years old!")
println(f"Currently learning Ruchy: {is_learning}")
</code></pre>
<p>Output:</p>
<pre><code>Hi Alice, you're 25 years old!
Currently learning Ruchy: true
</code></pre>
<p>That’s it! No type annotations, no memory management, just store and use.</p>
<h2 id="core-concepts-1"><a class="header" href="#core-concepts-1">Core Concepts</a></h2>
<h3 id="the-let-keyword"><a class="header" href="#the-let-keyword">The let Keyword</a></h3>
<p><code>let</code> creates a new variable in Ruchy. It:</p>
<ul>
<li>Declares a new variable name</li>
<li>Stores a value in memory</li>
<li>Automatically infers the type from the value</li>
<li>Makes the variable available for the rest of the scope</li>
</ul>
<h3 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h3>
<p>Ruchy looks at your value and figures out the type:</p>
<ul>
<li><code>"text"</code> → String type</li>
<li><code>42</code> → Integer type</li>
<li><code>3.14</code> → Float type</li>
<li><code>true</code>/<code>false</code> → Boolean type</li>
</ul>
<h3 id="variable-naming"><a class="header" href="#variable-naming">Variable Naming</a></h3>
<p>Variables in Ruchy follow simple rules:</p>
<ul>
<li>Start with a letter or underscore</li>
<li>Use letters, numbers, and underscores</li>
<li>Case sensitive (<code>name</code> ≠ <code>Name</code>)</li>
<li>Use snake_case by convention</li>
</ul>
<h2 id="practical-usage-1"><a class="header" href="#practical-usage-1">Practical Usage</a></h2>
<h3 id="different-data-types"><a class="header" href="#different-data-types">Different Data Types</a></h3>
<pre><code class="language-ruchy">// Text data
let first_name = "John"
let last_name = "Doe"
let full_name = f"{first_name} {last_name}"

// Numeric data
let score = 95
let percentage = 95.5
let temperature = -10

// Boolean (true/false) data
let is_student = true
let has_graduated = false
let is_enrolled = !has_graduated

println(f"Student: {full_name}")
println(f"Score: {score} ({percentage}%)")
println(f"Temperature: {temperature}°C")
println(f"Status: student={is_student}, graduated={has_graduated}")
</code></pre>
<h3 id="working-with-variables"><a class="header" href="#working-with-variables">Working with Variables</a></h3>
<pre><code class="language-ruchy">// Store user information
let username = "programmer2024"
let login_count = 1
let is_premium = false

// Use variables in calculations
let welcome_bonus = 100
let total_points = welcome_bonus + (login_count * 10)

// Update information (variables are mutable by default)
login_count = login_count + 1
is_premium = total_points &gt; 150

println(f"Welcome back, {username}!")
println(f"Logins: {login_count}, Points: {total_points}")
println(f"Premium status: {is_premium}")
</code></pre>
<h3 id="collections-and-lists"><a class="header" href="#collections-and-lists">Collections and Lists</a></h3>
<pre><code class="language-ruchy">// Store multiple values
let favorite_languages = ["Python", "Rust", "Ruchy"]
let daily_temperatures = [22.5, 25.0, 23.8, 26.2]
let task_completed = [true, false, true, true]

// Access items by index (starting from 0)
println(f"First language: {favorite_languages[0]}")
println(f"Today's temp: {daily_temperatures[0]}°C")

// Get list length
println(f"I know {favorite_languages.len()} languages")
</code></pre>
<h2 id="common-pitfalls-1"><a class="header" href="#common-pitfalls-1">Common Pitfalls</a></h2>
<h3 id="forgetting-let-for-new-variables"><a class="header" href="#forgetting-let-for-new-variables">Forgetting let for New Variables</a></h3>
<pre><code class="language-ruchy">// ❌ This won't work
user_name = "Alice"
</code></pre>
<p>Error: <code>user_name</code> is not declared. Use <code>let user_name = "Alice"</code> first.</p>
<h3 id="mixing-data-types-incorrectly"><a class="header" href="#mixing-data-types-incorrectly">Mixing Data Types Incorrectly</a></h3>
<pre><code class="language-ruchy">// ❌ This might not work as expected
let age = "25"
let next_year = age + 1
</code></pre>
<p>Error: Can’t add number to string. Use <code>let age = 25</code> (without quotes).</p>
<h3 id="case-sensitivity-confusion"><a class="header" href="#case-sensitivity-confusion">Case Sensitivity Confusion</a></h3>
<pre><code class="language-ruchy">// ❌ These are different variables
let userName = "Alice"
let username = "Bob"
println(userName)  // Prints "Alice", not "Bob"
</code></pre>
<p>Warning: Stick to snake_case: <code>user_name</code>.</p>
<h2 id="generated-code-insight-1"><a class="header" href="#generated-code-insight-1">Generated Code Insight</a></h2>
<p>Ever wonder how Ruchy’s simple variables become efficient compiled code?</p>
<details>
<summary>🔍 View Generated Rust Code (click to expand)</summary>
<p>Your Ruchy code:</p>
<pre><code class="language-ruchy">let name = "Alice"
let age = 25
println(f"Hi {name}, age {age}")
</code></pre>
<p>Becomes this optimized Rust:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let name: &amp;str = "Alice";
    let age: i32 = 25;
    println!("Hi {}, age {}", name, age);
}</code></pre></pre>
<p><strong>What’s happening:</strong></p>
<ul>
<li>Ruchy’s type inference becomes explicit Rust types</li>
<li>String interpolation becomes format string macros</li>
<li>All types are resolved at compile time for maximum performance</li>
<li>Zero runtime overhead for type checking</li>
</ul>
<p><strong>Why this matters:</strong></p>
<ul>
<li>You get static typing benefits without writing types</li>
<li>Compiler catches type errors before your code runs</li>
<li>Performance is identical to hand-written Rust</li>
<li>Your simple code becomes memory-safe systems code</li>
</ul>
</details>
<p><strong>The Bottom Line:</strong> Write Python-simple variable code, get C++-fast compiled performance.</p>
<h2 id="try-it-yourself-1"><a class="header" href="#try-it-yourself-1">Try It Yourself</a></h2>
<p>Time for hands-on experimentation! Open the REPL and create your own data:</p>
<pre><code class="language-bash">$ ruchy repl
&gt;&gt;&gt; # Start with personal info
&gt;&gt;&gt; let my_name = "[YOUR NAME]"
&gt;&gt;&gt; let my_age = [YOUR AGE]
&gt;&gt;&gt; let my_hobby = "[SOMETHING YOU ENJOY]"
&gt;&gt;&gt; 
&gt;&gt;&gt; # Try different types
&gt;&gt;&gt; let lucky_number = 7
&gt;&gt;&gt; let pi_estimate = 3.14
&gt;&gt;&gt; let is_learning_fast = true
&gt;&gt;&gt; 
&gt;&gt;&gt; # Combine them creatively
&gt;&gt;&gt; println(f"I'm {my_name}, {my_age}, and I love {my_hobby}")
&gt;&gt;&gt; println(f"My lucky number {lucky_number} is {'even' if lucky_number % 2 == 0 else 'odd'}")
</code></pre>
<p><strong>Your Challenges:</strong></p>
<ol>
<li><strong>Personal Profile</strong>: Create 5 variables that describe you (name, age, city, hobby, goal)</li>
<li><strong>Data Calculator</strong>: Store two numbers, calculate their sum, difference, and average</li>
<li><strong>Text Manipulation</strong>: Store your first and last name, create username and email</li>
<li><strong>Boolean Logic</strong>: Create variables for different conditions and combine them</li>
</ol>
<p><strong>Example Solution:</strong></p>
<pre><code class="language-ruchy">// Personal profile
let name = "Alex"
let age = 28
let city = "San Francisco"
let hobby = "rock climbing"
let goal = "master Ruchy in 30 days"

// Data calculator  
let num1 = 15
let num2 = 25
let sum = num1 + num2
let difference = num1 - num2
let average = (num1 + num2) / 2

// Text manipulation
let first_name = "Alex"
let last_name = "Johnson"
let username = f"{first_name.lower()}_{last_name.lower()}"
let email = f"{username}@example.com"

// Boolean logic
let is_adult = age &gt;= 18
let lives_in_tech_city = city == "San Francisco"
let ready_for_job = is_adult &amp;&amp; lives_in_tech_city
</code></pre>
<p>Play with different combinations - this is where programming gets creative!</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<ul>
<li><code>let</code> creates variables that store data</li>
<li>Ruchy automatically figures out data types for you</li>
<li>Variables can store text, numbers, true/false values, and collections</li>
<li>Use <code>f""</code> strings to combine variables with text</li>
<li>Variables are mutable by default - you can change their values</li>
<li>All type checking happens at compile time for maximum performance</li>
</ul>
<p>You now have the power to store and manipulate information! Next, let’s learn how to organize this logic into reusable functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="organizing-logic"><a class="header" href="#organizing-logic">Organizing Logic</a></h1>
<p><em>“The moment I learned to organize my code into reusable pieces was the moment I stopped being a beginner. Good code organization doesn’t just make your program work - it makes your thinking clearer. Each piece should do one thing well, like a well-organized toolbox.”</em> - Noah Gift</p>
<h2 id="the-problem-3"><a class="header" href="#the-problem-3">The Problem</a></h2>
<p>You can store data in variables and print output, but real programs need to <em>do things</em> - calculate results, process data, make decisions, and repeat operations. How do you organize logic so it’s reusable, maintainable, and easy to understand?</p>
<p>Most languages make code organization complicated with complex syntax and boilerplate. In Ruchy, organizing logic should be as natural as breaking down a problem into steps.</p>
<h2 id="quick-example-2"><a class="header" href="#quick-example-2">Quick Example</a></h2>
<p>Here’s how you organize and reuse logic in Ruchy:</p>
<pre><code class="language-ruchy">// Organize calculations
let name = "Alice"  
let a = 15
let b = 27

// Reusable greeting logic
let greeting = f"Hello, {name}! Welcome to Ruchy!"

// Reusable calculation logic  
let sum = a + b
let result_message = f"{a} + {b} = {sum}"

println(greeting)
println(result_message)
</code></pre>
<p>Output:</p>
<pre><code>Hello, Alice! Welcome to Ruchy!
15 + 27 = 42
</code></pre>
<p>That’s organization! Define once, use everywhere.</p>
<h2 id="core-concepts-2"><a class="header" href="#core-concepts-2">Core Concepts</a></h2>
<h3 id="variable-based-organization"><a class="header" href="#variable-based-organization">Variable-Based Organization</a></h3>
<p>In Ruchy’s current form, organize logic using variables and expressions:</p>
<pre><code class="language-ruchy">// Store inputs
let input1 = 10
let input2 = 20

// Organize calculations  
let sum = input1 + input2
let product = input1 * input2
let average = sum / 2

// Organize output
let result = f"Sum: {sum}, Product: {product}, Average: {average}"
</code></pre>
<h3 id="reusable-patterns"><a class="header" href="#reusable-patterns">Reusable Patterns</a></h3>
<p>Create templates for common operations:</p>
<pre><code class="language-ruchy">// Template: greeting with name
let user_name = "Alice"
let greeting_template = f"Hello, {user_name}! Welcome!"

// Template: calculation display
let num1 = 15
let num2 = 27  
let operation = "addition"
let calc_result = num1 + num2
let calc_display = f"{operation}: {num1} + {num2} = {calc_result}"
</code></pre>
<h3 id="logic-grouping"><a class="header" href="#logic-grouping">Logic Grouping</a></h3>
<p>Group related operations together:</p>
<pre><code class="language-ruchy">// Input section
let temperature_f = 68
let user_location = "San Francisco"

// Processing section  
let temperature_c = (temperature_f - 32) * 5 / 9
let is_comfortable = temperature_c &gt; 18 &amp;&amp; temperature_c &lt; 25

// Output section
let weather_report = f"Weather in {user_location}: {temperature_f}°F ({temperature_c}°C)"
let comfort_message = if is_comfortable { "Perfect weather!" } else { "Dress accordingly" }

println(weather_report)
println(comfort_message)
</code></pre>
<h2 id="practical-usage-2"><a class="header" href="#practical-usage-2">Practical Usage</a></h2>
<h3 id="pure-functions-no-side-effects"><a class="header" href="#pure-functions-no-side-effects">Pure Functions (No Side Effects)</a></h3>
<pre><code class="language-ruchy">// Mathematical operations
fn square(x) {
    return x * x
}

fn circle_area(radius) {
    let pi = 3.14159
    return pi * square(radius)
}

// Text processing
fn make_username(first_name, last_name) {
    return f"{first_name.lower()}_{last_name.lower()}"
}

fn shout(message) {
    return message.upper() + "!!!"
}

// Use them together
let area = circle_area(5)
let username = make_username("Alice", "Johnson") 
let excited = shout("I love functions")

println(f"Circle area: {area}")
println(f"Username: {username}")
println(excited)
</code></pre>
<h3 id="functions-with-logic"><a class="header" href="#functions-with-logic">Functions with Logic</a></h3>
<pre><code class="language-ruchy">fn is_even(number) {
    return number % 2 == 0
}

fn grade_letter(score) {
    if score &gt;= 90 {
        return "A"
    } else if score &gt;= 80 {
        return "B"
    } else if score &gt;= 70 {
        return "C"
    } else if score &gt;= 60 {
        return "D"
    } else {
        return "F"
    }
}

fn describe_number(n) {
    let even_odd = if is_even(n) { "even" } else { "odd" }
    let size = if n &gt; 100 { "large" } else { "small" }
    return f"{n} is a {size} {even_odd} number"
}

// Test your functions
println(describe_number(42))   // "42 is a small even number"
println(describe_number(150))  // "150 is a large even number"
println(grade_letter(85))      // "B"
</code></pre>
<h3 id="functions-that-process-data"><a class="header" href="#functions-that-process-data">Functions That Process Data</a></h3>
<pre><code class="language-ruchy">fn calculate_total(prices) {
    let total = 0
    for price in prices {
        total = total + price
    }
    return total
}

fn find_max(numbers) {
    let max_val = numbers[0]
    for num in numbers {
        if num &gt; max_val {
            max_val = num
        }
    }
    return max_val
}

fn count_words(text) {
    return text.split(" ").len()
}

// Real-world usage
let shopping_cart = [19.99, 5.50, 12.00, 8.75]
let test_scores = [85, 92, 78, 96, 88]
let essay = "Functions make code reusable and testable"

println(f"Total cost: ${calculate_total(shopping_cart)}")
println(f"Highest score: {find_max(test_scores)}")
println(f"Word count: {count_words(essay)}")
</code></pre>
<h2 id="common-pitfalls-2"><a class="header" href="#common-pitfalls-2">Common Pitfalls</a></h2>
<h3 id="forgetting-return-statement"><a class="header" href="#forgetting-return-statement">Forgetting Return Statement</a></h3>
<pre><code class="language-ruchy">// ❌ This returns nothing (unit type)
fn bad_add(a, b) {
    a + b  // Missing 'return'
}

// ✅ This returns the sum
fn good_add(a, b) {
    return a + b
}
</code></pre>
<h3 id="wrong-number-of-arguments"><a class="header" href="#wrong-number-of-arguments">Wrong Number of Arguments</a></h3>
<pre><code class="language-ruchy">fn greet(name, age) {
    return f"Hi {name}, you're {age} years old"
}

// ❌ This won't work
let msg = greet("Alice")  // Missing age parameter
</code></pre>
<p>Error: Function expects 2 arguments, got 1.</p>
<h3 id="modifying-parameters"><a class="header" href="#modifying-parameters">Modifying Parameters</a></h3>
<pre><code class="language-ruchy">// ❌ Parameters are read-only
fn bad_function(x) {
    x = x + 1  // Error: can't modify parameter
    return x
}

// ✅ Create new variables inside functions
fn good_function(x) {
    let result = x + 1
    return result
}
</code></pre>
<h2 id="generated-code-insight-2"><a class="header" href="#generated-code-insight-2">Generated Code Insight</a></h2>
<p>Want to see how Ruchy functions become efficient compiled code?</p>
<details>
<summary>🔍 View Generated Rust Code (click to expand)</summary>
<p>Your Ruchy code:</p>
<pre><code class="language-ruchy">fn add(a, b) {
    return a + b
}

let result = add(10, 20)
println(result)
</code></pre>
<p>Becomes this optimized Rust:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

fn main() {
    let result: i32 = add(10, 20);
    println!("{}", result);
}</code></pre></pre>
<p><strong>What’s happening:</strong></p>
<ul>
<li>Ruchy infers all parameter and return types automatically</li>
<li>Functions become zero-cost abstractions - no runtime overhead</li>
<li>The compiler can inline simple functions for maximum performance</li>
<li>All type checking happens at compile time</li>
</ul>
<p><strong>Performance Benefits:</strong></p>
<ul>
<li>Function calls are as fast as C++ function calls</li>
<li>No dynamic dispatch or runtime type checking</li>
<li>Compiler optimizations work across function boundaries</li>
<li>Memory usage is predictable and efficient</li>
</ul>
</details>
<p><strong>The Bottom Line:</strong> Write simple, readable functions and get high-performance compiled code automatically.</p>
<h2 id="try-it-yourself-2"><a class="header" href="#try-it-yourself-2">Try It Yourself</a></h2>
<p>Time to become a function master! Open the REPL and build your toolkit:</p>
<pre><code class="language-bash">$ ruchy repl
&gt;&gt;&gt; # Start with simple utilities
&gt;&gt;&gt; fn double(x) { return x * 2 }
&gt;&gt;&gt; fn half(x) { return x / 2 }
&gt;&gt;&gt; 
&gt;&gt;&gt; # Test them immediately
&gt;&gt;&gt; println(double(21))
&gt;&gt;&gt; println(half(50))
&gt;&gt;&gt; 
&gt;&gt;&gt; # Build more complex functions
&gt;&gt;&gt; fn is_password_strong(password) {
&gt;&gt;&gt;     return password.len() &gt;= 8 &amp;&amp; password.contains("!")
&gt;&gt;&gt; }
&gt;&gt;&gt; 
&gt;&gt;&gt; # Create your own calculator
&gt;&gt;&gt; fn calculate_tip(bill, tip_percent) {
&gt;&gt;&gt;     return bill * (tip_percent / 100)
&gt;&gt;&gt; }
</code></pre>
<p><strong>Your Challenges:</strong></p>
<ol>
<li>
<p><strong>Personal Calculator</strong>: Create functions for the operations you use most</p>
<ul>
<li>Temperature conversion (Celsius to Fahrenheit)</li>
<li>BMI calculator</li>
<li>Discount calculator</li>
</ul>
</li>
<li>
<p><strong>Text Tools</strong>: Build functions for common text operations</p>
<ul>
<li>Word counter</li>
<li>Text reverser</li>
<li>Initials extractor</li>
</ul>
</li>
<li>
<p><strong>Decision Makers</strong>: Create functions that help you decide</p>
<ul>
<li>Movie night selector (based on mood/time)</li>
<li>Outfit recommender (based on weather)</li>
<li>Study break timer</li>
</ul>
</li>
<li>
<p><strong>Data Processors</strong>: Functions that work with lists</p>
<ul>
<li>Average calculator</li>
<li>List sorter</li>
<li>Duplicate remover</li>
</ul>
</li>
</ol>
<p><strong>Example Solution Set:</strong></p>
<pre><code class="language-ruchy">// Personal calculator
fn celsius_to_fahrenheit(celsius) {
    return (celsius * 9 / 5) + 32
}

fn calculate_bmi(weight_kg, height_m) {
    return weight_kg / (height_m * height_m)
}

fn apply_discount(price, discount_percent) {
    let discount = price * (discount_percent / 100)
    return price - discount
}

// Text tools
fn word_count(text) {
    return text.split(" ").len()
}

fn reverse_text(text) {
    return text.chars().reverse().collect().join("")
}

fn get_initials(full_name) {
    let words = full_name.split(" ")
    let initials = ""
    for word in words {
        initials = initials + word[0].upper()
    }
    return initials
}

// Decision makers
fn recommend_activity(energy_level, available_time) {
    if energy_level &gt; 7 &amp;&amp; available_time &gt; 60 {
        return "Go for a run or hit the gym!"
    } else if energy_level &gt; 5 &amp;&amp; available_time &gt; 30 {
        return "Perfect time for a walk"
    } else {
        return "Maybe just relax and read"
    }
}

// Test your functions!
println(celsius_to_fahrenheit(20))  // 68
println(calculate_bmi(70, 1.75))    // 22.86
println(get_initials("Alice Johnson"))  // "AJ"
println(recommend_activity(8, 45))
</code></pre>
<p>Build functions that solve YOUR problems - this is where programming becomes personal!</p>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<ul>
<li><code>fn</code> creates reusable blocks of code</li>
<li>Parameters let you pass data into functions</li>
<li><code>return</code> sends results back to the caller</li>
<li>Functions help organize logic and make testing easier</li>
<li>Pure functions (no side effects) are easier to understand and test</li>
<li>Every function should have one clear responsibility</li>
<li>Use descriptive names that explain what the function does</li>
</ul>
<p>You can now organize your logic into clean, reusable functions! Next, let’s learn how to test these functions to make sure they work correctly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-functions"><a class="header" href="#testing-functions">Testing Functions</a></h1>
<p><em>“I used to think testing was extra work that slowed me down. Then I spent three days debugging a function that had a one-line bug I could have caught with a 30-second test. Now I write tests first - they’re my safety net and my specification all in one.”</em> - Noah Gift</p>
<h2 id="the-problem-4"><a class="header" href="#the-problem-4">The Problem</a></h2>
<p>You’ve written some great functions, but how do you know they actually work? How do you catch bugs before your users do? How do you make sure changes don’t break existing functionality?</p>
<p>Manual testing means running your code, checking output, and hoping you didn’t miss anything. In professional development, this doesn’t scale. You need automated tests that run every time, catch problems immediately, and give you confidence to make changes.</p>
<h2 id="quick-example-3"><a class="header" href="#quick-example-3">Quick Example</a></h2>
<p>Here’s how you test functions in Ruchy:</p>
<pre><code class="language-ruchy">// Your function
fn add(a, b) {
    return a + b
}

// Your test
#[test]
fn test_add() {
    assert_eq!(add(2, 3), 5)
    assert_eq!(add(0, 0), 0)
    assert_eq!(add(-1, 1), 0)
}
</code></pre>
<p>Run it:</p>
<pre><code class="language-bash">$ ruchy test
Running 1 test...
test_add ... PASS
✅ All tests passed!
</code></pre>
<p>That’s it! Write tests, run tests, ship with confidence.</p>
<h2 id="core-concepts-3"><a class="header" href="#core-concepts-3">Core Concepts</a></h2>
<h3 id="test-functions"><a class="header" href="#test-functions">Test Functions</a></h3>
<p>Test functions in Ruchy use the <code>#[test]</code> attribute:</p>
<pre><code class="language-ruchy">#[test]
fn test_function_name() {
    // Test code here
    assert_eq!(actual, expected)
}
</code></pre>
<ul>
<li><code>#[test]</code> marks the function as a test</li>
<li>Test functions take no parameters</li>
<li>Use <code>assert_eq!</code> to check if values match</li>
<li>Test function names should describe what they test</li>
</ul>
<h3 id="assertions"><a class="header" href="#assertions">Assertions</a></h3>
<p>Ruchy provides several assertion macros:</p>
<ul>
<li><code>assert_eq!(actual, expected)</code> - values must be equal</li>
<li><code>assert!(condition)</code> - condition must be true</li>
<li><code>assert_ne!(actual, expected)</code> - values must NOT be equal</li>
</ul>
<h3 id="test-organization"><a class="header" href="#test-organization">Test Organization</a></h3>
<pre><code class="language-ruchy">// tests/calculator_test.ruchy

use super::*;  // Import functions from main module

#[test]
fn test_addition() {
    assert_eq!(add(2, 3), 5)
}

#[test]  
fn test_subtraction() {
    assert_eq!(subtract(10, 4), 6)
}
</code></pre>
<h2 id="practical-testing-patterns"><a class="header" href="#practical-testing-patterns">Practical Testing Patterns</a></h2>
<h3 id="testing-pure-functions"><a class="header" href="#testing-pure-functions">Testing Pure Functions</a></h3>
<p>Pure functions are easiest to test - same input, same output:</p>
<pre><code class="language-ruchy">// calculator.ruchy
fn multiply(a, b) {
    return a * b
}

fn divide(a, b) {
    if b == 0 {
        return None
    }
    return Some(a / b)
}

fn is_even(n) {
    return n % 2 == 0
}

// tests/calculator_test.ruchy  
#[test]
fn test_multiply() {
    assert_eq!(multiply(3, 4), 12)
    assert_eq!(multiply(0, 5), 0)
    assert_eq!(multiply(-2, 3), -6)
}

#[test]
fn test_divide() {
    assert_eq!(divide(10, 2), Some(5))
    assert_eq!(divide(7, 3), Some(2))  // Integer division
    assert_eq!(divide(5, 0), None)     // Division by zero
}

#[test]
fn test_is_even() {
    assert!(is_even(4))        // 4 is even
    assert!(!is_even(3))       // 3 is not even  
    assert!(is_even(0))        // 0 is even
    assert!(!is_even(-1))      // -1 is not even
}
</code></pre>
<h3 id="testing-edge-cases"><a class="header" href="#testing-edge-cases">Testing Edge Cases</a></h3>
<p>Good tests cover normal cases AND edge cases:</p>
<pre><code class="language-ruchy">fn find_max(numbers) {
    if numbers.is_empty() {
        return None
    }
    
    let max_val = numbers[0]
    for num in numbers {
        if num &gt; max_val {
            max_val = num
        }
    }
    return Some(max_val)
}

#[test]
fn test_find_max() {
    // Normal cases
    assert_eq!(find_max([1, 5, 3, 9, 2]), Some(9))
    assert_eq!(find_max([10]), Some(10))
    
    // Edge cases
    assert_eq!(find_max([]), None)           // Empty list
    assert_eq!(find_max([-5, -1, -10]), Some(-1))  // All negative
    assert_eq!(find_max([5, 5, 5]), Some(5))       // All same
}
</code></pre>
<h3 id="testing-text-functions"><a class="header" href="#testing-text-functions">Testing Text Functions</a></h3>
<pre><code class="language-ruchy">fn clean_username(raw_username) {
    return raw_username.trim().lower().replace(" ", "_")
}

fn count_vowels(text) {
    let vowels = "aeiou"
    let count = 0
    for char in text.lower().chars() {
        if vowels.contains(char) {
            count = count + 1
        }
    }
    return count
}

#[test]
fn test_clean_username() {
    assert_eq!(clean_username("  Alice Johnson  "), "alice_johnson")
    assert_eq!(clean_username("JOHN"), "john")
    assert_eq!(clean_username(""), "")
}

#[test]
fn test_count_vowels() {
    assert_eq!(count_vowels("hello"), 2)      // e, o
    assert_eq!(count_vowels("HELLO"), 2)      // Case insensitive
    assert_eq!(count_vowels("xyz"), 0)        // No vowels
    assert_eq!(count_vowels("aeiou"), 5)      // All vowels
    assert_eq!(count_vowels(""), 0)           // Empty string
}
</code></pre>
<h3 id="testing-business-logic"><a class="header" href="#testing-business-logic">Testing Business Logic</a></h3>
<pre><code class="language-ruchy">fn calculate_grade(score) {
    if score &gt;= 90 { return "A" }
    if score &gt;= 80 { return "B" } 
    if score &gt;= 70 { return "C" }
    if score &gt;= 60 { return "D" }
    return "F"
}

fn can_vote(age, is_citizen) {
    return age &gt;= 18 &amp;&amp; is_citizen
}

#[test]
fn test_calculate_grade() {
    // Boundary testing
    assert_eq!(calculate_grade(95), "A")
    assert_eq!(calculate_grade(90), "A")  // Exactly 90
    assert_eq!(calculate_grade(89), "B")  // Just below A
    assert_eq!(calculate_grade(80), "B")  // Exactly 80
    assert_eq!(calculate_grade(79), "C")  // Just below B
    assert_eq!(calculate_grade(59), "F")  // Failing grade
    assert_eq!(calculate_grade(0), "F")   // Very low
}

#[test]
fn test_can_vote() {
    // All combinations
    assert!(can_vote(18, true))      // Minimum age, citizen
    assert!(can_vote(25, true))      // Adult citizen
    assert!(!can_vote(17, true))     // Too young
    assert!(!can_vote(25, false))    // Not citizen
    assert!(!can_vote(17, false))    // Too young AND not citizen
}
</code></pre>
<h2 id="test-driven-development-tdd"><a class="header" href="#test-driven-development-tdd">Test-Driven Development (TDD)</a></h2>
<p>Write tests BEFORE you write code:</p>
<ol>
<li><strong>Write a failing test</strong> (Red)</li>
<li><strong>Write minimal code to pass</strong> (Green)</li>
<li><strong>Refactor and improve</strong> (Refactor)</li>
</ol>
<pre><code class="language-ruchy">// Step 1: Write the test first
#[test]
fn test_fahrenheit_to_celsius() {
    assert_eq!(fahrenheit_to_celsius(32), 0)    // Freezing point
    assert_eq!(fahrenheit_to_celsius(212), 100) // Boiling point
    assert_eq!(fahrenheit_to_celsius(98.6), 37) // Body temperature
}

// Step 2: Write minimal code to pass
fn fahrenheit_to_celsius(fahrenheit) {
    return (fahrenheit - 32) * 5 / 9
}

// Step 3: Run tests, refactor if needed
// All tests pass! Code is ready to use.
</code></pre>
<h2 id="common-testing-mistakes"><a class="header" href="#common-testing-mistakes">Common Testing Mistakes</a></h2>
<h3 id="not-testing-edge-cases"><a class="header" href="#not-testing-edge-cases">Not Testing Edge Cases</a></h3>
<pre><code class="language-ruchy">// ❌ Only testing happy path
#[test]
fn test_divide_bad() {
    assert_eq!(divide(10, 2), 5)  // What about divide by zero?
}

// ✅ Testing edge cases
#[test]
fn test_divide_good() {
    assert_eq!(divide(10, 2), 5)      // Normal case
    assert_eq!(divide(0, 5), 0)       // Zero dividend
    // Should handle divide by zero gracefully
}
</code></pre>
<h3 id="tests-that-dont-actually-test"><a class="header" href="#tests-that-dont-actually-test">Tests That Don’t Actually Test</a></h3>
<pre><code class="language-ruchy">// ❌ This test will always pass
#[test]
fn test_useless() {
    let result = add(2, 3)
    assert!(result &gt; 0)  // Too vague!
}

// ✅ This test verifies exact behavior
#[test]  
fn test_useful() {
    assert_eq!(add(2, 3), 5)  // Exact expectation
}
</code></pre>
<h3 id="poor-test-names"><a class="header" href="#poor-test-names">Poor Test Names</a></h3>
<pre><code class="language-ruchy">// ❌ Unclear what this tests
#[test]
fn test1() {
    assert_eq!(is_valid("abc"), false)
}

// ✅ Clear, descriptive name
#[test]
fn test_password_too_short() {
    assert_eq!(is_valid_password("abc"), false)
}
</code></pre>
<h2 id="try-it-yourself-3"><a class="header" href="#try-it-yourself-3">Try It Yourself</a></h2>
<p>Time to become a testing expert! Test-drive some functions:</p>
<pre><code class="language-bash">$ ruchy repl
&gt;&gt;&gt; # Start with a simple function and test
&gt;&gt;&gt; fn double(x) { return x * 2 }
&gt;&gt;&gt; 
&gt;&gt;&gt; # Test it immediately
&gt;&gt;&gt; assert_eq!(double(5), 10)
&gt;&gt;&gt; assert_eq!(double(0), 0)
&gt;&gt;&gt; assert_eq!(double(-3), -6)
&gt;&gt;&gt; 
&gt;&gt;&gt; println("All double() tests pass!")
</code></pre>
<p><strong>Your Testing Challenges:</strong></p>
<ol>
<li>
<p><strong>Test Your Previous Functions</strong>: Go back to functions you created earlier and write comprehensive tests</p>
</li>
<li>
<p><strong>TDD Practice</strong>: Use test-driven development to create:</p>
<ul>
<li>Password strength validator</li>
<li>Email format checker</li>
<li>Age category classifier (child/teen/adult/senior)</li>
</ul>
</li>
<li>
<p><strong>Edge Case Hunter</strong>: For each function, identify and test:</p>
<ul>
<li>Empty inputs</li>
<li>Boundary values</li>
<li>Invalid inputs</li>
<li>Extreme values</li>
</ul>
</li>
<li>
<p><strong>Business Logic Testing</strong>: Create and test functions for:</p>
<ul>
<li>Shipping cost calculator</li>
<li>Tax calculator</li>
<li>Discount eligibility checker</li>
</ul>
</li>
</ol>
<p><strong>Example TDD Session:</strong></p>
<pre><code class="language-ruchy">// 1. Write failing tests first
#[test]
fn test_is_strong_password() {
    assert!(is_strong_password("MyPass123!"))      // Valid
    assert!(!is_strong_password("weak"))           // Too short
    assert!(!is_strong_password("NoNumbers!"))     // No digits
    assert!(!is_strong_password("nonumbers123"))   // No special chars
}

// 2. Write minimal code to pass
fn is_strong_password(password) {
    if password.len() &lt; 8 { return false }
    
    let has_digit = password.chars().any(|c| c.is_digit())
    let has_special = password.chars().any(|c| "!@#$%^&amp;*".contains(c))
    
    return has_digit &amp;&amp; has_special
}

// 3. Run tests - they should all pass now!

// 4. Add more edge case tests
#[test]
fn test_password_edge_cases() {
    assert!(!is_strong_password(""))              // Empty
    assert!(!is_strong_password("12345678"))      // Only digits
    assert!(!is_strong_password("!!!!!!!!"))      // Only special
}
</code></pre>
<p>Testing is your superpower - use it to build software with confidence!</p>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<ul>
<li>Use <code>#[test]</code> to mark test functions</li>
<li><code>assert_eq!</code> checks if values match exactly</li>
<li>Test normal cases AND edge cases</li>
<li>Write descriptive test names</li>
<li>Test-driven development: test first, then code</li>
<li>Good tests are your safety net for changes</li>
<li>Every function should have at least one test</li>
<li>Testing catches bugs before users find them</li>
</ul>
<p>You now have the tools to write reliable, tested code! Next, let’s learn how to build complete applications using these foundational skills.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-tools"><a class="header" href="#command-line-tools">Command-Line Tools</a></h1>
<p><em>“The first time I built a command-line tool that actually solved a real problem, I felt like I had superpowers. It took a tedious 2-hour manual task and turned it into a 5-second command. That’s when I realized programming isn’t about writing code - it’s about automating your life.”</em> - Noah Gift</p>
<h2 id="the-problem-5"><a class="header" href="#the-problem-5">The Problem</a></h2>
<p>You’ve learned the basics - variables, logic, and organization. But real-world programming means building tools that solve actual problems. How do you create programs that process files, handle user input, and perform useful work?</p>
<p>Most people think command-line tools are complex, requiring deep system knowledge and complicated frameworks. In Ruchy, building useful tools should be as straightforward as solving the problem by hand.</p>
<h2 id="quick-example-4"><a class="header" href="#quick-example-4">Quick Example</a></h2>
<p>Here’s a simple but useful command-line tool in Ruchy:</p>
<pre><code class="language-ruchy">// File: word_counter.ruchy
// Simple word counter tool

// Get filename from user
println("Word Counter Tool")
print("Enter filename: ")
let filename = input()

// Read and process file
let content = read_file(filename)
let words = content.split_whitespace()
let word_count = words.len()
let char_count = content.len()
let line_count = content.lines().len()

// Display results
println(f"\nFile Analysis: {filename}")
println(f"Characters: {char_count}")
println(f"Words: {word_count}")  
println(f"Lines: {line_count}")
</code></pre>
<p>Run it:</p>
<pre><code class="language-bash">$ ruchy run word_counter.ruchy
Word Counter Tool
Enter filename: my_document.txt

File Analysis: my_document.txt
Characters: 1,247
Words: 203
Lines: 45
</code></pre>
<p>That’s a real tool! It solves a common problem with simple code.</p>
<h2 id="core-concepts-4"><a class="header" href="#core-concepts-4">Core Concepts</a></h2>
<h3 id="user-input"><a class="header" href="#user-input">User Input</a></h3>
<p>Get information from users with <code>input()</code>:</p>
<pre><code class="language-ruchy">let name = input("What's your name? ")
let age = input("How old are you? ").to_i()
let is_student = input("Are you a student? (y/n) ") == "y"
</code></pre>
<h3 id="file-operations"><a class="header" href="#file-operations">File Operations</a></h3>
<p>Work with files using built-in functions:</p>
<pre><code class="language-ruchy">// Reading files
let content = read_file("data.txt")
let lines = read_lines("data.txt")

// Writing files
write_file("output.txt", "Hello, World!")
append_file("log.txt", "New entry: " + timestamp())

// File information
let exists = file_exists("config.txt")
let size = file_size("data.txt")
</code></pre>
<h3 id="command-arguments"><a class="header" href="#command-arguments">Command Arguments</a></h3>
<p>Access command-line arguments:</p>
<pre><code class="language-ruchy">// Usage: ruchy run script.ruchy file1.txt file2.txt
let args = command_args()
let program_name = args[0]
let first_file = args[1]
let second_file = args[2]

println(f"Processing: {first_file} and {second_file}")
</code></pre>
<h2 id="practical-tools"><a class="header" href="#practical-tools">Practical Tools</a></h2>
<h3 id="file-processor"><a class="header" href="#file-processor">File Processor</a></h3>
<pre><code class="language-ruchy">// File: text_processor.ruchy
// Processes text files with various operations

println("=== Text Processor ===")
let filename = input("Enter filename: ")

if !file_exists(filename) {
    println(f"Error: File '{filename}' not found!")
    exit(1)
}

let content = read_file(filename)
let lines = content.lines()

println("\nChoose operation:")
println("1. Count lines")
println("2. Find and replace")
println("3. Convert to uppercase") 
println("4. Remove empty lines")

let choice = input("Enter choice (1-4): ").to_i()

match choice {
    1 =&gt; {
        println(f"Total lines: {lines.len()}")
    }
    2 =&gt; {
        let find = input("Find: ")
        let replace = input("Replace with: ")
        let new_content = content.replace(find, replace)
        let output_file = filename.replace(".txt", "_modified.txt")
        write_file(output_file, new_content)
        println(f"Saved to: {output_file}")
    }
    3 =&gt; {
        let upper_content = content.to_uppercase()
        let output_file = filename.replace(".txt", "_upper.txt")
        write_file(output_file, upper_content)
        println(f"Saved to: {output_file}")
    }
    4 =&gt; {
        let clean_lines = lines.filter(|line| !line.trim().is_empty())
        let clean_content = clean_lines.join("\n")
        let output_file = filename.replace(".txt", "_clean.txt")
        write_file(output_file, clean_content)
        println(f"Saved to: {output_file}")
    }
    _ =&gt; {
        println("Invalid choice!")
    }
}
</code></pre>
<h3 id="log-analyzer"><a class="header" href="#log-analyzer">Log Analyzer</a></h3>
<pre><code class="language-ruchy">// File: log_analyzer.ruchy
// Analyzes server log files

println("=== Log Analyzer ===")
let log_file = input("Enter log file path: ")

let lines = read_lines(log_file)
let total_requests = lines.len()

// Count different status codes
let success_count = 0
let error_count = 0
let not_found_count = 0

for line in lines {
    if line.contains(" 200 ") {
        success_count += 1
    } else if line.contains(" 404 ") {
        not_found_count += 1
    } else if line.contains(" 500 ") {
        error_count += 1
    }
}

// Calculate percentages
let success_percent = (success_count * 100) / total_requests
let error_percent = (error_count * 100) / total_requests
let not_found_percent = (not_found_count * 100) / total_requests

println(f"\n=== Analysis Results ===")
println(f"Total Requests: {total_requests}")
println(f"Success (200): {success_count} ({success_percent}%)")
println(f"Not Found (404): {not_found_count} ({not_found_percent}%)")
println(f"Server Error (500): {error_count} ({error_percent}%)")

// Find busiest hour
let hour_counts = {}
for line in lines {
    let timestamp = extract_hour(line)  // Custom function
    hour_counts[timestamp] = hour_counts.get(timestamp, 0) + 1
}

let busiest_hour = hour_counts.max_by_value().key
println(f"Busiest Hour: {busiest_hour}:00")
</code></pre>
<h3 id="batch-file-renamer"><a class="header" href="#batch-file-renamer">Batch File Renamer</a></h3>
<pre><code class="language-ruchy">// File: batch_renamer.ruchy  
// Renames multiple files with patterns

println("=== Batch File Renamer ===")
let directory = input("Enter directory path: ")
let pattern = input("Enter pattern to find: ")
let replacement = input("Enter replacement: ")

let files = list_files(directory)
let renamed_count = 0

for file in files {
    if file.contains(pattern) {
        let new_name = file.replace(pattern, replacement)
        let old_path = join_path(directory, file)
        let new_path = join_path(directory, new_name)
        
        if rename_file(old_path, new_path) {
            println(f"Renamed: {file} -&gt; {new_name}")
            renamed_count += 1
        } else {
            println(f"Failed to rename: {file}")
        }
    }
}

println(f"\nRenamed {renamed_count} files")
</code></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>Real tools need proper error handling:</p>
<pre><code class="language-ruchy">// Robust file processor with error handling

fn process_file(filename) {
    // Check if file exists
    if !file_exists(filename) {
        println(f"❌ Error: File '{filename}' does not exist")
        return false
    }
    
    // Check if file is readable
    if !file_readable(filename) {
        println(f"❌ Error: Cannot read file '{filename}' (permission denied?)")
        return false
    }
    
    // Try to read file
    let content = try {
        read_file(filename)
    } catch error {
        println(f"❌ Error reading file: {error}")
        return false
    }
    
    // Process content
    let word_count = content.split_whitespace().len()
    println(f"✅ File processed: {word_count} words")
    return true
}

// Main program
let filename = input("Enter filename: ")
if process_file(filename) {
    println("Processing completed successfully!")
} else {
    println("Processing failed!")
    exit(1)
}
</code></pre>
<h2 id="user-experience"><a class="header" href="#user-experience">User Experience</a></h2>
<p>Make your tools user-friendly:</p>
<pre><code class="language-ruchy">// Good CLI tool practices

fn show_help() {
    println("File Statistics Tool v1.0")
    println("")
    println("Usage:")
    println("  ruchy run file_stats.ruchy &lt;filename&gt;")
    println("")
    println("Examples:")
    println("  ruchy run file_stats.ruchy document.txt")
    println("  ruchy run file_stats.ruchy data/*.csv")
    println("")
    println("Options:")
    println("  --help     Show this help message")
    println("  --verbose  Show detailed output")
}

fn process_with_progress(files) {
    let total = files.len()
    
    for i, file in files.enumerate() {
        let progress = ((i + 1) * 100) / total
        print(f"\rProcessing... [{progress}%] {file}")
        
        // Do the actual work
        process_file(file)
        
        // Small delay to show progress
        sleep(100)  // 100ms
    }
    
    println("\n✅ All files processed!")
}
</code></pre>
<h2 id="generated-code-insight-3"><a class="header" href="#generated-code-insight-3">Generated Code Insight</a></h2>
<p>See how Ruchy’s simple file operations become efficient system calls:</p>
<details>
<summary>🔍 View Generated Rust Code (click to expand)</summary>
<p>Your Ruchy code:</p>
<pre><code class="language-ruchy">let content = read_file("data.txt")
let lines = content.lines().len()
println(f"File has {lines} lines")
</code></pre>
<p>Becomes this optimized Rust:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fs;

fn main() -&gt; Result&lt;(), std::io::Error&gt; {
    let content = fs::read_to_string("data.txt")?;
    let lines = content.lines().count();
    println!("File has {} lines", lines);
    Ok(())
}</code></pre></pre>
<p><strong>What’s happening:</strong></p>
<ul>
<li>Ruchy’s <code>read_file</code> becomes Rust’s efficient <code>fs::read_to_string</code></li>
<li>Error handling is built-in with the <code>?</code> operator</li>
<li>String operations compile to zero-cost abstractions</li>
<li>Memory usage is optimized by the compiler</li>
</ul>
<p><strong>Performance Benefits:</strong></p>
<ul>
<li>File I/O is as fast as C++ file operations</li>
<li>No garbage collection overhead</li>
<li>Optimal memory usage for large files</li>
<li>System calls are direct and efficient</li>
</ul>
</details>
<p><strong>The Bottom Line:</strong> Write simple file processing code, get high-performance system tools automatically.</p>
<h2 id="try-it-yourself-4"><a class="header" href="#try-it-yourself-4">Try It Yourself</a></h2>
<p>Time to build real tools that solve actual problems!</p>
<pre><code class="language-bash">$ ruchy repl
&gt;&gt;&gt; # Start with simple file operations
&gt;&gt;&gt; let content = read_file("test.txt")
&gt;&gt;&gt; let words = content.split_whitespace()
&gt;&gt;&gt; println(f"Word count: {words.len()}")
&gt;&gt;&gt; 
&gt;&gt;&gt; # Build interactive tools
&gt;&gt;&gt; let name = input("What's your name? ")
&gt;&gt;&gt; let greeting = f"Hello, {name}!"
&gt;&gt;&gt; write_file("greeting.txt", greeting)
&gt;&gt;&gt; println("Greeting saved to file!")
</code></pre>
<p><strong>Your Tool-Building Challenges:</strong></p>
<ol>
<li>
<p><strong>Personal Productivity Tools</strong>:</p>
<ul>
<li>Task list manager (add, remove, mark complete)</li>
<li>Time tracker (log activities with timestamps)</li>
<li>Password generator (customizable length and characters)</li>
<li>File organizer (sort files by type/date)</li>
</ul>
</li>
<li>
<p><strong>Data Processing Tools</strong>:</p>
<ul>
<li>CSV analyzer (column stats, missing data detection)</li>
<li>Log file summarizer (error counts, patterns)</li>
<li>Duplicate file finder (by content or name)</li>
<li>Text formatter (markdown to HTML, etc.)</li>
</ul>
</li>
<li>
<p><strong>System Administration Tools</strong>:</p>
<ul>
<li>Disk usage reporter (directory sizes)</li>
<li>Configuration backup/restore</li>
<li>Process monitor (simple version)</li>
<li>Network connectivity tester</li>
</ul>
</li>
<li>
<p><strong>Creative Tools</strong>:</p>
<ul>
<li>Random quote generator (from text file)</li>
<li>Simple encryption/decryption</li>
<li>Image metadata extractor</li>
<li>Recipe manager (search, add, categorize)</li>
</ul>
</li>
</ol>
<p><strong>Example Complete Tool - Task Manager:</strong></p>
<pre><code class="language-ruchy">// task_manager.ruchy - A simple but useful task management tool

let TASK_FILE = "tasks.txt"

fn show_menu() {
    println("\n=== Task Manager ===")
    println("1. List tasks")
    println("2. Add task")
    println("3. Complete task")
    println("4. Delete task")
    println("5. Quit")
}

fn load_tasks() {
    if file_exists(TASK_FILE) {
        return read_lines(TASK_FILE)
    }
    return []
}

fn save_tasks(tasks) {
    let content = tasks.join("\n")
    write_file(TASK_FILE, content)
}

fn list_tasks(tasks) {
    if tasks.is_empty() {
        println("\n📝 No tasks yet!")
        return
    }
    
    println(f"\n📋 Your Tasks ({tasks.len()} items):")
    for i, task in tasks.enumerate() {
        let status = if task.starts_with("✅") { "DONE" } else { "PENDING" }
        println(f"{i + 1:2}. {task}")
    }
}

fn add_task(tasks) {
    let new_task = input("\nWhat do you want to add? ")
    tasks.push(f"📌 {new_task}")
    save_tasks(tasks)
    println("✅ Task added!")
}

fn complete_task(tasks) {
    list_tasks(tasks)
    let index = input("\nWhich task to complete? (number): ").to_i() - 1
    
    if index &gt;= 0 &amp;&amp; index &lt; tasks.len() {
        tasks[index] = tasks[index].replace("📌", "✅")
        save_tasks(tasks)
        println("🎉 Task completed!")
    } else {
        println("❌ Invalid task number")
    }
}

// Main program loop
let tasks = load_tasks()

loop {
    show_menu()
    let choice = input("\nChoose option: ")
    
    match choice {
        "1" =&gt; list_tasks(tasks)
        "2" =&gt; add_task(tasks)
        "3" =&gt; complete_task(tasks)
        "4" =&gt; {
            list_tasks(tasks)
            let index = input("Which task to delete? (number): ").to_i() - 1
            if index &gt;= 0 &amp;&amp; index &lt; tasks.len() {
                tasks.remove(index)
                save_tasks(tasks)
                println("🗑️  Task deleted!")
            }
        }
        "5" =&gt; {
            println("👋 Goodbye!")
            break
        }
        _ =&gt; println("❌ Invalid choice")
    }
}
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">$ ruchy run task_manager.ruchy

=== Task Manager ===
1. List tasks
2. Add task  
3. Complete task
4. Delete task
5. Quit

Choose option: 2
What do you want to add? Learn Ruchy command-line tools
✅ Task added!
</code></pre>
<p>Build tools that solve YOUR daily problems - that’s where programming becomes powerful!</p>
<h2 id="common-pitfalls-3"><a class="header" href="#common-pitfalls-3">Common Pitfalls</a></h2>
<h3 id="no-error-handling"><a class="header" href="#no-error-handling">No Error Handling</a></h3>
<pre><code class="language-ruchy">// ❌ This will crash if file doesn't exist
let content = read_file("missing.txt")
</code></pre>
<h3 id="poor-user-experience"><a class="header" href="#poor-user-experience">Poor User Experience</a></h3>
<pre><code class="language-ruchy">// ❌ Confusing and unhelpful
println("Enter thing:")
let thing = input()
// What thing? What format?
</code></pre>
<h3 id="hardcoded-paths"><a class="header" href="#hardcoded-paths">Hardcoded Paths</a></h3>
<pre><code class="language-ruchy">// ❌ Only works on your computer
let data = read_file("/Users/noah/Desktop/data.txt")
</code></pre>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<ul>
<li>Command-line tools solve real problems with simple code</li>
<li>Use <code>input()</code> for user interaction and file functions for I/O</li>
<li>Always handle errors gracefully - check if files exist</li>
<li>Make tools user-friendly with clear prompts and help text</li>
<li>Start simple, add features incrementally</li>
<li>Test your tools with real data and edge cases</li>
<li>Build tools that solve YOUR problems - you’ll use them daily</li>
</ul>
<p>You can now build useful command-line tools that automate tasks and process data! Next, let’s learn how to work with data files and build more sophisticated processing applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-processing"><a class="header" href="#data-processing">Data Processing</a></h1>
<p><em>“The day I realized I could automate data analysis was the day I stopped being afraid of Excel files. I had 10,000 rows of customer data to analyze manually. Instead, I wrote a 20-line script that did it in 3 seconds. That script saved me 40 hours of work and taught me the real power of programming.”</em> - Noah Gift</p>
<h2 id="the-problem-6"><a class="header" href="#the-problem-6">The Problem</a></h2>
<p>You’ve built command-line tools, but real-world work involves data - CSV files, JSON APIs, log files, and datasets. How do you read, process, analyze, and transform data efficiently?</p>
<p>Most people use spreadsheet software for data tasks, but that doesn’t scale to large datasets or repeatable processes. In Ruchy, data processing should be as straightforward as working with the data manually, but infinitely more powerful.</p>
<h2 id="quick-example-5"><a class="header" href="#quick-example-5">Quick Example</a></h2>
<p>Here’s a simple but powerful data processor in Ruchy:</p>
<pre><code class="language-ruchy">// File: sales_analyzer.ruchy
// Analyzes sales data from CSV file

println("=== Sales Data Analyzer ===")

// Read CSV data (simplified - in practice you'd use CSV parser)
let sales_data = [
    ["Date", "Product", "Amount", "Region"],
    ["2024-01-15", "Laptop", "1299", "North"],
    ["2024-01-16", "Mouse", "25", "South"], 
    ["2024-01-17", "Keyboard", "79", "North"],
    ["2024-01-18", "Laptop", "1299", "East"],
    ["2024-01-19", "Monitor", "399", "West"]
]

// Process data
let total_sales = 0
let product_counts = {}
let region_sales = {}

for row in sales_data[1..] {  // Skip header
    let product = row[1]
    let amount = row[2].to_f()
    let region = row[3]
    
    // Calculate totals
    total_sales += amount
    
    // Count products
    product_counts[product] = product_counts.get(product, 0) + 1
    
    // Sum by region
    region_sales[region] = region_sales.get(region, 0) + amount
}

// Display results
println(f"Total Sales: ${total_sales}")
println(f"Average Sale: ${total_sales / (sales_data.len() - 1)}")

println("\nTop Products:")
for product, count in product_counts.items() {
    println(f"  {product}: {count} sales")
}

println("\nSales by Region:")
for region, amount in region_sales.items() {
    println(f"  {region}: ${amount}")
}
</code></pre>
<p>Output:</p>
<pre><code>=== Sales Data Analyzer ===
Total Sales: $3101
Average Sale: $620.20

Top Products:
  Laptop: 2 sales
  Mouse: 1 sales
  Keyboard: 1 sales
  Monitor: 1 sales

Sales by Region:
  North: $1378
  South: $25
  East: $1299
  West: $399
</code></pre>
<p>That’s real data analysis! Scales to thousands of rows easily.</p>
<h2 id="core-concepts-5"><a class="header" href="#core-concepts-5">Core Concepts</a></h2>
<h3 id="data-structures-for-analysis"><a class="header" href="#data-structures-for-analysis">Data Structures for Analysis</a></h3>
<p>Use appropriate structures for different data types:</p>
<pre><code class="language-ruchy">// Arrays for sequences
let sales_amounts = [1299, 25, 79, 1299, 399]
let monthly_revenue = [45000, 52000, 48000, 61000]

// Dictionaries for key-value mapping  
let customer_orders = {
    "alice@email.com": 5,
    "bob@email.com": 2,
    "carol@email.com": 8
}

// Arrays of dictionaries for structured records
let transactions = [
    {"id": 1001, "amount": 1299, "customer": "alice@email.com"},
    {"id": 1002, "amount": 25, "customer": "bob@email.com"},
    {"id": 1003, "amount": 79, "customer": "alice@email.com"}
]
</code></pre>
<h3 id="data-aggregation"><a class="header" href="#data-aggregation">Data Aggregation</a></h3>
<p>Common patterns for summarizing data:</p>
<pre><code class="language-ruchy">// Sum and averages
let total = numbers.sum()
let average = numbers.sum() / numbers.len()
let maximum = numbers.max()
let minimum = numbers.min()

// Grouping and counting
fn group_by_field(records, field) {
    let groups = {}
    for record in records {
        let key = record[field]
        if !groups.has_key(key) {
            groups[key] = []
        }
        groups[key].push(record)
    }
    return groups
}

// Filtering and transformation
let high_value = transactions.filter(|t| t.amount &gt; 100)
let customer_ids = transactions.map(|t| t.customer)
let amounts_only = transactions.map(|t| t.amount)
</code></pre>
<h3 id="file-format-processing"><a class="header" href="#file-format-processing">File Format Processing</a></h3>
<p>Handle common data formats:</p>
<pre><code class="language-ruchy">// CSV-like processing (simplified)
fn parse_csv_line(line) {
    return line.split(",").map(|field| field.trim())
}

fn load_csv(filename) {
    let lines = read_lines(filename)
    let header = parse_csv_line(lines[0])
    let data = []
    
    for line in lines[1..] {
        let fields = parse_csv_line(line)
        let record = {}
        for i, field in fields.enumerate() {
            record[header[i]] = field
        }
        data.push(record)
    }
    
    return data
}
</code></pre>
<h2 id="practical-data-tools"><a class="header" href="#practical-data-tools">Practical Data Tools</a></h2>
<h3 id="customer-analytics-tool"><a class="header" href="#customer-analytics-tool">Customer Analytics Tool</a></h3>
<pre><code class="language-ruchy">// File: customer_analytics.ruchy
// Analyzes customer purchase patterns

println("=== Customer Analytics Tool ===")

// Sample customer data (in practice, load from file)
let customers = [
    {"name": "Alice", "email": "alice@email.com", "orders": 5, "total_spent": 2500, "signup_date": "2023-06-15"},
    {"name": "Bob", "email": "bob@email.com", "orders": 2, "total_spent": 150, "signup_date": "2024-01-20"},
    {"name": "Carol", "email": "carol@email.com", "orders": 8, "total_spent": 4200, "signup_date": "2023-03-10"},
    {"name": "David", "email": "david@email.com", "orders": 1, "total_spent": 75, "signup_date": "2024-02-01"}
]

// Calculate key metrics
let total_customers = customers.len()
let total_revenue = customers.map(|c| c.total_spent).sum()
let average_order_value = total_revenue / customers.map(|c| c.orders).sum()
let average_customer_value = total_revenue / total_customers

println(f"Customer Base: {total_customers} customers")
println(f"Total Revenue: ${total_revenue}")
println(f"Average Order Value: ${average_order_value:.2f}")
println(f"Average Customer Value: ${average_customer_value:.2f}")

// Segment customers
let vip_customers = customers.filter(|c| c.total_spent &gt; 1000)
let new_customers = customers.filter(|c| c.signup_date.starts_with("2024"))
let frequent_buyers = customers.filter(|c| c.orders &gt; 5)

println(f"\nCustomer Segments:")
println(f"VIP Customers (&gt;$1000): {vip_customers.len()}")
println(f"New Customers (2024): {new_customers.len()}")
println(f"Frequent Buyers (&gt;5 orders): {frequent_buyers.len()}")

// Top customers by spending
let top_spenders = customers.sort_by(|c| -c.total_spent)[..3]
println(f"\nTop Spenders:")
for i, customer in top_spenders.enumerate() {
    println(f"  {i+1}. {customer.name}: ${customer.total_spent} ({customer.orders} orders)")
}
</code></pre>
<h3 id="log-file-analyzer"><a class="header" href="#log-file-analyzer">Log File Analyzer</a></h3>
<pre><code class="language-ruchy">// File: advanced_log_analyzer.ruchy
// Comprehensive log file analysis

println("=== Advanced Log Analyzer ===")

// Sample log entries (in practice, read from file)
let log_entries = [
    "2024-08-19 10:15:32 INFO User login: alice@email.com",
    "2024-08-19 10:16:45 ERROR Database connection failed", 
    "2024-08-19 10:17:12 INFO User login: bob@email.com",
    "2024-08-19 10:18:33 WARN Slow query detected: 2.5s",
    "2024-08-19 10:19:44 ERROR 404 Not Found: /api/users/999",
    "2024-08-19 10:20:15 INFO User logout: alice@email.com"
]

// Parse log entries
fn parse_log_entry(entry) {
    let parts = entry.split(" ")
    return {
        "date": parts[0],
        "time": parts[1], 
        "level": parts[2],
        "message": parts[3..].join(" ")
    }
}

let parsed_logs = log_entries.map(parse_log_entry)

// Analyze by level
let level_counts = {}
for log in parsed_logs {
    let level = log.level
    level_counts[level] = level_counts.get(level, 0) + 1
}

println("Log Level Summary:")
for level, count in level_counts.items() {
    let emoji = match level {
        "INFO" =&gt; "ℹ️",
        "WARN" =&gt; "⚠️", 
        "ERROR" =&gt; "❌",
        _ =&gt; "📝"
    }
    println(f"  {emoji} {level}: {count} entries")
}

// Find errors and warnings
let issues = parsed_logs.filter(|log| log.level == "ERROR" || log.level == "WARN")
println(f"\nIssues Found ({issues.len()}):")
for issue in issues {
    println(f"  {issue.time} {issue.level}: {issue.message}")
}

// Extract user activity
let user_actions = parsed_logs.filter(|log| log.message.contains("User"))
println(f"\nUser Activity ({user_actions.len()} actions):")
for action in user_actions {
    println(f"  {action.time}: {action.message}")
}

// Time-based analysis
let hours = parsed_logs.map(|log| log.time.split(":")[0])
let hour_counts = {}
for hour in hours {
    hour_counts[hour] = hour_counts.get(hour, 0) + 1
}

let busiest_hour = hour_counts.max_by_value()
println(f"\nBusiest Hour: {busiest_hour.key}:xx ({busiest_hour.value} entries)")
</code></pre>
<h3 id="financial-data-processor"><a class="header" href="#financial-data-processor">Financial Data Processor</a></h3>
<pre><code class="language-ruchy">// File: finance_processor.ruchy
// Processes financial transactions and generates reports

println("=== Financial Data Processor ===")

// Transaction data structure
let transactions = [
    {"date": "2024-01-15", "type": "income", "category": "salary", "amount": 5000, "description": "Monthly salary"},
    {"date": "2024-01-16", "type": "expense", "category": "rent", "amount": 1200, "description": "Apartment rent"},
    {"date": "2024-01-17", "type": "expense", "category": "groceries", "amount": 85, "description": "Weekly shopping"},
    {"date": "2024-01-18", "type": "expense", "category": "utilities", "amount": 150, "description": "Electricity bill"},
    {"date": "2024-01-20", "type": "income", "category": "freelance", "amount": 800, "description": "Web design project"}
]

// Calculate totals
let total_income = transactions.filter(|t| t.type == "income").map(|t| t.amount).sum()
let total_expenses = transactions.filter(|t| t.type == "expense").map(|t| t.amount).sum()
let net_income = total_income - total_expenses

println(f"Financial Summary:")
println(f"Total Income: ${total_income}")
println(f"Total Expenses: ${total_expenses}")
println(f"Net Income: ${net_income}")
println(f"Savings Rate: {(net_income * 100 / total_income):.1f}%")

// Expense breakdown by category
let expense_categories = {}
for transaction in transactions.filter(|t| t.type == "expense") {
    let category = transaction.category
    expense_categories[category] = expense_categories.get(category, 0) + transaction.amount
}

println(f"\nExpense Breakdown:")
for category, amount in expense_categories.items() {
    let percentage = (amount * 100) / total_expenses
    println(f"  {category.capitalize()}: ${amount} ({percentage:.1f}%)")
}

// Budget analysis
let budget_limits = {
    "rent": 1500,
    "groceries": 400, 
    "utilities": 200,
    "entertainment": 300
}

println(f"\nBudget Analysis:")
for category, limit in budget_limits.items() {
    let spent = expense_categories.get(category, 0)
    let remaining = limit - spent
    let status = if remaining &gt;= 0 { "✅ Under budget" } else { "❌ Over budget" }
    println(f"  {category.capitalize()}: ${spent}/${limit} - {status}")
}

// Monthly trend (if we had multiple months of data)
println(f"\nTransaction History ({transactions.len()} transactions):")
for transaction in transactions.sort_by(|t| t.date) {
    let emoji = if transaction.type == "income" { "💰" } else { "💸" }
    println(f"  {transaction.date} {emoji} ${transaction.amount} - {transaction.description}")
}
</code></pre>
<h2 id="data-visualization-text-based"><a class="header" href="#data-visualization-text-based">Data Visualization (Text-based)</a></h2>
<p>Create simple charts for console output:</p>
<pre><code class="language-ruchy">// Simple bar chart function
fn draw_bar_chart(data, title) {
    println(f"\n{title}")
    println("=" * title.len())
    
    let max_value = data.values().max()
    let max_bar_width = 50
    
    for key, value in data.items() {
        let bar_width = (value * max_bar_width) / max_value
        let bar = "█" * bar_width.to_i()
        println(f"{key:12} │{bar} {value}")
    }
}

// Usage example
let monthly_sales = {
    "January": 45000,
    "February": 52000,
    "March": 48000,
    "April": 61000,
    "May": 58000
}

draw_bar_chart(monthly_sales, "Monthly Sales Report")
</code></pre>
<p>Output:</p>
<pre><code>Monthly Sales Report
====================
January     │████████████████████████████████████ 45000
February    │██████████████████████████████████████████████ 52000
March       │█████████████████████████████████████████ 48000
April       │██████████████████████████████████████████████████ 61000
May         │████████████████████████████████████████████████ 58000
</code></pre>
<h2 id="generated-code-insight-4"><a class="header" href="#generated-code-insight-4">Generated Code Insight</a></h2>
<p>See how Ruchy’s data processing becomes efficient compiled operations:</p>
<details>
<summary>🔍 View Generated Rust Code (click to expand)</summary>
<p>Your Ruchy code:</p>
<pre><code class="language-ruchy">let sales_data = load_csv("sales.csv")
let total = sales_data.map(|row| row.amount.to_f()).sum()
let average = total / sales_data.len()
println(f"Average sale: ${average:.2f}")
</code></pre>
<p>Becomes this optimized Rust:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::collections::HashMap;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let sales_data = load_csv("sales.csv")?;
    let total: f64 = sales_data.iter()
        .map(|row| row.amount.parse::&lt;f64&gt;().unwrap_or(0.0))
        .sum();
    let average = total / sales_data.len() as f64;
    println!("Average sale: ${:.2}", average);
    Ok(())
}</code></pre></pre>
<p><strong>What’s happening:</strong></p>
<ul>
<li>Data processing uses efficient iterators with zero-cost abstractions</li>
<li>Memory allocation is optimized by the compiler</li>
<li>Number parsing and arithmetic operations are highly optimized</li>
<li>Large datasets are processed with minimal memory overhead</li>
</ul>
<p><strong>Performance Benefits:</strong></p>
<ul>
<li>Processing speed comparable to C++ with STL</li>
<li>Memory usage scales linearly with data size</li>
<li>Iterator chains are optimized into tight loops</li>
<li>No garbage collection pauses during processing</li>
</ul>
</details>
<p><strong>The Bottom Line:</strong> Write expressive data processing code, get high-performance analytics automatically.</p>
<h2 id="try-it-yourself-5"><a class="header" href="#try-it-yourself-5">Try It Yourself</a></h2>
<p>Time to become a data processing expert! Process some real data:</p>
<pre><code class="language-bash">$ ruchy repl
&gt;&gt;&gt; # Start with simple data operations
&gt;&gt;&gt; let numbers = [10, 25, 30, 15, 40, 35, 20]
&gt;&gt;&gt; let total = numbers.sum()
&gt;&gt;&gt; let average = total / numbers.len()
&gt;&gt;&gt; println(f"Average: {average}")
&gt;&gt;&gt; 
&gt;&gt;&gt; # Work with structured data
&gt;&gt;&gt; let products = [
&gt;&gt;&gt;     {"name": "Laptop", "price": 1299, "category": "Electronics"},
&gt;&gt;&gt;     {"name": "Book", "price": 25, "category": "Education"}
&gt;&gt;&gt; ]
&gt;&gt;&gt; let electronics = products.filter(|p| p.category == "Electronics")
&gt;&gt;&gt; println(f"Electronics: {electronics.len()} items")
</code></pre>
<p><strong>Your Data Processing Challenges:</strong></p>
<ol>
<li>
<p><strong>Personal Data Analysis</strong>:</p>
<ul>
<li>Analyze your own data (expenses, time tracking, habits)</li>
<li>Process your email/message history</li>
<li>Analyze your music listening patterns</li>
<li>Track and visualize your fitness data</li>
</ul>
</li>
<li>
<p><strong>Business Intelligence Tools</strong>:</p>
<ul>
<li>Sales performance analyzer</li>
<li>Customer segmentation tool</li>
<li>Inventory level monitor</li>
<li>Revenue forecasting calculator</li>
</ul>
</li>
<li>
<p><strong>Research and Analysis</strong>:</p>
<ul>
<li>Survey response processor</li>
<li>A/B test result analyzer</li>
<li>Market research data parser</li>
<li>Academic grade analyzer</li>
</ul>
</li>
<li>
<p><strong>Data Cleaning and Transformation</strong>:</p>
<ul>
<li>Duplicate record finder/remover</li>
<li>Data format converter (CSV ↔ JSON)</li>
<li>Missing data detector/filler</li>
<li>Outlier detection system</li>
</ul>
</li>
</ol>
<p><strong>Example Complete Tool - Expense Tracker:</strong></p>
<pre><code class="language-ruchy">// expense_tracker.ruchy - Track and analyze personal expenses

let EXPENSES_FILE = "expenses.csv"

fn save_expense(date, category, amount, description) {
    let entry = f"{date},{category},{amount},{description}\n"
    append_file(EXPENSES_FILE, entry)
}

fn load_expenses() {
    if !file_exists(EXPENSES_FILE) {
        // Create header if file doesn't exist
        write_file(EXPENSES_FILE, "Date,Category,Amount,Description\n")
        return []
    }
    
    let lines = read_lines(EXPENSES_FILE)[1..]  // Skip header
    let expenses = []
    
    for line in lines {
        let parts = line.split(",")
        expenses.push({
            "date": parts[0],
            "category": parts[1], 
            "amount": parts[2].to_f(),
            "description": parts[3]
        })
    }
    
    return expenses
}

fn analyze_expenses(expenses) {
    let total = expenses.map(|e| e.amount).sum()
    let average = total / expenses.len()
    
    // Category breakdown
    let categories = {}
    for expense in expenses {
        categories[expense.category] = categories.get(expense.category, 0) + expense.amount
    }
    
    println(f"\n💰 Expense Analysis ({expenses.len()} transactions)")
    println(f"Total Spent: ${total:.2f}")
    println(f"Average Transaction: ${average:.2f}")
    
    println(f"\n📊 Spending by Category:")
    for category, amount in categories.items().sort_by(|item| -item.value) {
        let percentage = (amount * 100) / total
        println(f"  {category:15}: ${amount:7.2f} ({percentage:5.1f}%)")
    }
    
    // Recent transactions
    let recent = expenses.sort_by(|e| -e.date)[..5]  // Last 5
    println(f"\n🕒 Recent Transactions:")
    for expense in recent {
        println(f"  {expense.date} ${expense.amount:6.2f} {expense.category:12} {expense.description}")
    }
}

fn main_menu() {
    println("\n=== Personal Expense Tracker ===")
    println("1. Add expense")
    println("2. View analysis") 
    println("3. Export data")
    println("4. Quit")
    
    let choice = input("\nChoose option: ")
    
    match choice {
        "1" =&gt; {
            let date = input("Date (YYYY-MM-DD): ")
            let category = input("Category: ")
            let amount = input("Amount: $").to_f()
            let description = input("Description: ")
            
            save_expense(date, category, amount, description)
            println("✅ Expense added!")
        }
        "2" =&gt; {
            let expenses = load_expenses()
            if expenses.is_empty() {
                println("📝 No expenses recorded yet")
            } else {
                analyze_expenses(expenses)
            }
        }
        "3" =&gt; {
            println(f"📁 Data exported to: {EXPENSES_FILE}")
            println("Open in spreadsheet application for advanced analysis")
        }
        "4" =&gt; {
            println("💸 Happy budgeting!")
            return false
        }
        _ =&gt; {
            println("❌ Invalid choice")
        }
    }
    
    return true
}

// Main program loop
while main_menu() {
    // Continue until user quits
}
</code></pre>
<p>Build data processors that solve YOUR analytical needs - that’s where programming becomes insight!</p>
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<ul>
<li>Data processing transforms raw information into actionable insights</li>
<li>Use arrays, dictionaries, and structured records for different data types</li>
<li>Common patterns: filter, map, reduce, group by, sort</li>
<li>Handle CSV, JSON, and log file formats with parsing functions</li>
<li>Create visualizations using text-based charts for console output</li>
<li>Always validate and clean data before analysis</li>
<li>Build reusable functions for common data operations</li>
<li>Test your analysis with known datasets to verify results</li>
</ul>
<p>You can now process and analyze data efficiently! Next, let’s learn how to work with files and build more sophisticated file-handling applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-operations-1"><a class="header" href="#file-operations-1">File Operations</a></h1>
<p><em>“The first time I automated file organization on my cluttered desktop, I felt like a digital janitor who just got superpowers. What took me hours of manual sorting now happens in seconds. Files are the lifeblood of computing - master them, and you master your digital world.”</em> - Noah Gift</p>
<h2 id="the-problem-7"><a class="header" href="#the-problem-7">The Problem</a></h2>
<p>You’ve built command-line tools and processed data, but real work involves files - reading configuration, writing reports, organizing directories, and managing your digital workspace. How do you efficiently work with the file system?</p>
<p>Most people manually manage files through graphical interfaces, but that doesn’t scale. In Ruchy, file operations should be as natural as working with variables, but with the power to handle thousands of files automatically.</p>
<h2 id="quick-example-6"><a class="header" href="#quick-example-6">Quick Example</a></h2>
<p>Here’s a practical file organizer in Ruchy:</p>
<pre><code class="language-ruchy">// File: desktop_organizer.ruchy
// Organizes files by type into folders

println("=== Desktop Organizer ===")

// Define organization rules
let file_categories = {
    "Documents": [".pdf", ".doc", ".docx", ".txt"],
    "Images": [".jpg", ".jpeg", ".png", ".gif", ".svg"],
    "Videos": [".mp4", ".avi", ".mov", ".mkv"],
    "Code": [".py", ".js", ".rs", ".ruchy", ".cpp"],
    "Data": [".csv", ".json", ".xml", ".xlsx"]
}

let source_dir = "~/Desktop"
let files = list_files(source_dir)

println(f"Found {files.len()} files to organize")

// Organize files
for file in files {
    let extension = get_extension(file).lower()
    
    for category, extensions in file_categories.items() {
        if extensions.contains(extension) {
            let target_dir = join_path(source_dir, category)
            
            // Create category folder if needed
            if !dir_exists(target_dir) {
                create_dir(target_dir)
                println(f"Created folder: {category}")
            }
            
            // Move file to appropriate folder
            let source = join_path(source_dir, file)
            let destination = join_path(target_dir, file)
            
            move_file(source, destination)
            println(f"  Moved {file} -&gt; {category}/")
            break
        }
    }
}

println("✅ Desktop organized!")
</code></pre>
<p>That’s file automation! Hours of manual work done in seconds.</p>
<h2 id="core-concepts-6"><a class="header" href="#core-concepts-6">Core Concepts</a></h2>
<h3 id="file-system-navigation"><a class="header" href="#file-system-navigation">File System Navigation</a></h3>
<p>Navigate and query the file system:</p>
<pre><code class="language-ruchy">// Current directory operations
let current_dir = get_current_dir()
set_current_dir("/home/user/projects")

// Path operations
let full_path = absolute_path("data.txt")
let parent = parent_dir(full_path)
let filename = file_name(full_path)
let extension = file_extension(full_path)

// Path joining and normalization
let project_path = join_path(home_dir(), "projects", "my_app")
let clean_path = normalize_path(".././data//file.txt")
</code></pre>
<h3 id="file-information"><a class="header" href="#file-information">File Information</a></h3>
<p>Get detailed file metadata:</p>
<pre><code class="language-ruchy">// Check file properties
let exists = file_exists("config.json")
let size = file_size("data.csv")  // In bytes
let modified = file_modified_time("log.txt")
let is_read_only = is_readonly("system.conf")

// File type checking
let is_file = is_file(path)
let is_dir = is_directory(path)
let is_symlink = is_symbolic_link(path)

// Permissions (Unix-like systems)
let can_read = is_readable(path)
let can_write = is_writable(path)
let can_execute = is_executable(path)
</code></pre>
<h3 id="directory-operations"><a class="header" href="#directory-operations">Directory Operations</a></h3>
<p>Work with directories efficiently:</p>
<pre><code class="language-ruchy">// Create and remove directories
create_dir("new_folder")
create_dir_all("path/to/nested/folder")  // Creates parent dirs
remove_dir("empty_folder")
remove_dir_all("folder_with_contents")  // Recursive delete

// List directory contents
let all_items = list_dir(".")
let files_only = list_files(".")
let dirs_only = list_directories(".")

// Recursive directory walking
fn walk_directory(dir) {
    let items = list_dir(dir)
    for item in items {
        let path = join_path(dir, item)
        if is_directory(path) {
            walk_directory(path)  // Recurse into subdirectory
        } else {
            process_file(path)
        }
    }
}
</code></pre>
<h2 id="practical-file-tools"><a class="header" href="#practical-file-tools">Practical File Tools</a></h2>
<h3 id="backup-system"><a class="header" href="#backup-system">Backup System</a></h3>
<pre><code class="language-ruchy">// File: smart_backup.ruchy
// Creates timestamped backups of important files

println("=== Smart Backup System ===")

let backup_config = {
    "documents": ["~/Documents", "*.doc", "*.pdf", "*.txt"],
    "code": ["~/Projects", "*.py", "*.js", "*.rs"],
    "config": ["~/.config", "*.conf", "*.json", "*.yaml"]
}

let backup_root = "~/Backups"
let timestamp = current_datetime().format("%Y%m%d_%H%M%S")
let backup_dir = join_path(backup_root, f"backup_{timestamp}")

create_dir_all(backup_dir)
println(f"Creating backup at: {backup_dir}")

let total_files = 0
let total_size = 0

for category, config in backup_config.items() {
    let source_dir = expand_home(config[0])
    let patterns = config[1..]
    
    let category_dir = join_path(backup_dir, category)
    create_dir(category_dir)
    
    println(f"\n📁 Backing up {category}...")
    
    for pattern in patterns {
        let files = glob(join_path(source_dir, pattern))
        
        for file in files {
            let size = file_size(file)
            let relative_path = relative_to(file, source_dir)
            let backup_path = join_path(category_dir, relative_path)
            
            // Create parent directories
            let parent = parent_dir(backup_path)
            if !dir_exists(parent) {
                create_dir_all(parent)
            }
            
            // Copy file to backup
            copy_file(file, backup_path)
            total_files += 1
            total_size += size
            
            println(f"  ✓ {relative_path} ({format_size(size)})")
        }
    }
}

println(f"\n✅ Backup complete!")
println(f"Files backed up: {total_files}")
println(f"Total size: {format_size(total_size)}")
println(f"Location: {backup_dir}")

// Create backup summary
let summary = f"Backup Summary
==============
Date: {timestamp}
Files: {total_files}
Size: {format_size(total_size)}
Categories: {backup_config.keys().join(', ')}
"

write_file(join_path(backup_dir, "summary.txt"), summary)
</code></pre>
<h3 id="duplicate-file-finder"><a class="header" href="#duplicate-file-finder">Duplicate File Finder</a></h3>
<pre><code class="language-ruchy">// File: find_duplicates.ruchy
// Finds duplicate files based on content hash

println("=== Duplicate File Finder ===")

let search_dir = input("Enter directory to search: ")
let min_size = input("Minimum file size (bytes, 0 for all): ").to_i()

println(f"\nScanning {search_dir}...")

// Build file hash map
let file_hashes = {}
let duplicates = []

fn hash_file(path) {
    let content = read_bytes(path)
    return sha256(content)
}

fn scan_directory(dir) {
    let items = list_dir(dir)
    
    for item in items {
        let path = join_path(dir, item)
        
        if is_directory(path) {
            scan_directory(path)  // Recurse
        } else if is_file(path) {
            let size = file_size(path)
            
            if size &gt;= min_size {
                let hash = hash_file(path)
                
                if file_hashes.has_key(hash) {
                    // Found duplicate
                    duplicates.push({
                        "original": file_hashes[hash],
                        "duplicate": path,
                        "size": size,
                        "hash": hash
                    })
                } else {
                    file_hashes[hash] = path
                }
            }
        }
    }
}

scan_directory(search_dir)

if duplicates.is_empty() {
    println("\n✅ No duplicate files found!")
} else {
    println(f"\n⚠️  Found {duplicates.len()} duplicate files:")
    
    let total_wasted = 0
    
    for dup in duplicates {
        println(f"\nOriginal: {dup.original}")
        println(f"Duplicate: {dup.duplicate}")
        println(f"Size: {format_size(dup.size)}")
        total_wasted += dup.size
    }
    
    println(f"\nTotal space wasted: {format_size(total_wasted)}")
    
    let action = input("\nDelete duplicates? (y/n): ")
    if action.lower() == "y" {
        for dup in duplicates {
            remove_file(dup.duplicate)
            println(f"Deleted: {dup.duplicate}")
        }
        println(f"\n✅ Freed {format_size(total_wasted)} of space!")
    }
}
</code></pre>
<h3 id="log-rotation-system"><a class="header" href="#log-rotation-system">Log Rotation System</a></h3>
<pre><code class="language-ruchy">// File: log_rotator.ruchy
// Manages log files with size-based rotation

println("=== Log Rotation System ===")

let log_config = {
    "max_size": 10 * 1024 * 1024,  // 10MB
    "max_backups": 5,
    "compress": true
}

let log_dir = "/var/log/myapp"
let log_files = glob(join_path(log_dir, "*.log"))

for log_file in log_files {
    let size = file_size(log_file)
    
    if size &gt; log_config.max_size {
        println(f"Rotating {log_file} ({format_size(size)})...")
        
        // Shift existing backups
        for i in range(log_config.max_backups - 1, 0, -1) {
            let old_backup = f"{log_file}.{i}"
            let new_backup = f"{log_file}.{i + 1}"
            
            if file_exists(old_backup) {
                if i == log_config.max_backups - 1 {
                    // Delete oldest backup
                    remove_file(old_backup)
                } else {
                    // Rename to next number
                    rename_file(old_backup, new_backup)
                }
            }
        }
        
        // Move current log to .1
        let backup_path = f"{log_file}.1"
        rename_file(log_file, backup_path)
        
        // Compress if configured
        if log_config.compress {
            compress_file(backup_path, f"{backup_path}.gz")
            remove_file(backup_path)
            println(f"  Compressed to {backup_path}.gz")
        }
        
        // Create new empty log file
        write_file(log_file, "")
        println(f"  Created new {log_file}")
    }
}

println("\n✅ Log rotation complete!")
</code></pre>
<h3 id="configuration-file-manager"><a class="header" href="#configuration-file-manager">Configuration File Manager</a></h3>
<pre><code class="language-ruchy">// File: config_manager.ruchy
// Manages application configuration files

println("=== Configuration Manager ===")

let config_dir = "~/.config/myapp"
let config_file = join_path(config_dir, "config.json")

// Ensure config directory exists
if !dir_exists(config_dir) {
    create_dir_all(config_dir)
    println(f"Created config directory: {config_dir}")
}

// Load or create default configuration
let config = if file_exists(config_file) {
    parse_json(read_file(config_file))
} else {
    // Default configuration
    {
        "version": "1.0",
        "theme": "dark",
        "auto_save": true,
        "backup_interval": 3600,
        "recent_files": [],
        "window": {
            "width": 1200,
            "height": 800,
            "maximized": false
        }
    }
}

fn save_config() {
    let json = to_json_pretty(config)
    write_file(config_file, json)
    println("✅ Configuration saved")
}

fn update_setting(key, value) {
    config[key] = value
    save_config()
}

fn add_recent_file(path) {
    if !config.recent_files.contains(path) {
        config.recent_files.insert(0, path)
        // Keep only last 10 files
        if config.recent_files.len() &gt; 10 {
            config.recent_files = config.recent_files[..10]
        }
        save_config()
    }
}

// Interactive configuration editor
loop {
    println("\n=== Current Configuration ===")
    for key, value in config.items() {
        println(f"{key}: {value}")
    }
    
    println("\nOptions:")
    println("1. Change theme")
    println("2. Toggle auto-save")
    println("3. Set backup interval")
    println("4. Clear recent files")
    println("5. Reset to defaults")
    println("6. Exit")
    
    let choice = input("\nChoice: ")
    
    match choice {
        "1" =&gt; {
            let theme = input("Theme (light/dark): ")
            update_setting("theme", theme)
        }
        "2" =&gt; {
            config.auto_save = !config.auto_save
            save_config()
        }
        "3" =&gt; {
            let interval = input("Backup interval (seconds): ").to_i()
            update_setting("backup_interval", interval)
        }
        "4" =&gt; {
            config.recent_files = []
            save_config()
        }
        "5" =&gt; {
            // Reset to defaults
            remove_file(config_file)
            println("Configuration reset!")
            break
        }
        "6" =&gt; break
        _ =&gt; println("Invalid choice")
    }
}
</code></pre>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>Robust file operations need proper error handling:</p>
<pre><code class="language-ruchy">fn safe_file_operation(path) {
    // Check permissions first
    if !file_exists(path) {
        println(f"Error: File not found: {path}")
        return false
    }
    
    if !is_readable(path) {
        println(f"Error: No read permission for: {path}")
        return false
    }
    
    // Try operation with error handling
    try {
        let content = read_file(path)
        process_content(content)
        return true
    } catch error {
        println(f"Error processing file: {error}")
        
        // Log error for debugging
        let error_log = "errors.log"
        let timestamp = current_datetime()
        append_file(error_log, f"{timestamp}: {path} - {error}\n")
        
        return false
    }
}
</code></pre>
<h2 id="generated-code-insight-5"><a class="header" href="#generated-code-insight-5">Generated Code Insight</a></h2>
<p>See how Ruchy’s file operations become efficient system calls:</p>
<details>
<summary>🔍 View Generated Rust Code (click to expand)</summary>
<p>Your Ruchy code:</p>
<pre><code class="language-ruchy">let files = list_files("data")
for file in files {
    let size = file_size(file)
    if size &gt; 1000000 {
        move_file(file, "large_files/" + file)
    }
}
</code></pre>
<p>Becomes this optimized Rust:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fs;
use std::path::Path;

fn main() -&gt; std::io::Result&lt;()&gt; {
    let entries = fs::read_dir("data")?;
    
    for entry in entries {
        let entry = entry?;
        let path = entry.path();
        
        if path.is_file() {
            let metadata = fs::metadata(&amp;path)?;
            let size = metadata.len();
            
            if size &gt; 1_000_000 {
                let file_name = path.file_name().unwrap();
                let dest = Path::new("large_files").join(file_name);
                fs::rename(&amp;path, dest)?;
            }
        }
    }
    Ok(())
}</code></pre></pre>
<p><strong>What’s happening:</strong></p>
<ul>
<li>File operations use Rust’s zero-cost abstractions</li>
<li>System calls are direct and efficient</li>
<li>Error handling is built into the Result type</li>
<li>Memory usage is minimal with iterators</li>
</ul>
<p><strong>Performance Benefits:</strong></p>
<ul>
<li>File operations as fast as C system calls</li>
<li>No overhead from runtime or garbage collection</li>
<li>Efficient memory usage with streaming operations</li>
<li>Parallel file processing capabilities</li>
</ul>
</details>
<p><strong>The Bottom Line:</strong> Write simple file operation code, get system-level performance automatically.</p>
<h2 id="try-it-yourself-6"><a class="header" href="#try-it-yourself-6">Try It Yourself</a></h2>
<p>Time to master file operations! Start experimenting:</p>
<pre><code class="language-bash">$ ruchy repl
&gt;&gt;&gt; # Explore your file system
&gt;&gt;&gt; let home = home_dir()
&gt;&gt;&gt; let files = list_files(home)
&gt;&gt;&gt; println(f"You have {files.len()} files in your home directory")
&gt;&gt;&gt; 
&gt;&gt;&gt; # Create a test directory structure
&gt;&gt;&gt; create_dir("test_project")
&gt;&gt;&gt; create_dir("test_project/src")
&gt;&gt;&gt; create_dir("test_project/docs")
&gt;&gt;&gt; write_file("test_project/README.md", "# My Project")
&gt;&gt;&gt; 
&gt;&gt;&gt; # Find large files
&gt;&gt;&gt; let downloads = list_files("~/Downloads")
&gt;&gt;&gt; for file in downloads {
&gt;&gt;&gt;     let size = file_size(file)
&gt;&gt;&gt;     if size &gt; 100_000_000 {  // 100MB
&gt;&gt;&gt;         println(f"Large file: {file} ({format_size(size)})")
&gt;&gt;&gt;     }
&gt;&gt;&gt; }
</code></pre>
<p><strong>Your File Management Challenges:</strong></p>
<ol>
<li>
<p><strong>Personal Organization</strong>:</p>
<ul>
<li>Photo organizer by date taken</li>
<li>Music library organizer by artist/album</li>
<li>Download folder cleaner</li>
<li>Desktop file categorizer</li>
</ul>
</li>
<li>
<p><strong>System Maintenance</strong>:</p>
<ul>
<li>Temp file cleaner</li>
<li>Cache directory manager</li>
<li>Old backup remover</li>
<li>Log file archiver</li>
</ul>
</li>
<li>
<p><strong>Development Tools</strong>:</p>
<ul>
<li>Project template generator</li>
<li>Source code statistics analyzer</li>
<li>Dependency checker</li>
<li>Build artifact cleaner</li>
</ul>
</li>
<li>
<p><strong>Data Management</strong>:</p>
<ul>
<li>File synchronization tool</li>
<li>Incremental backup system</li>
<li>File encryption/decryption utility</li>
<li>Archive extractor/creator</li>
</ul>
</li>
</ol>
<p>Build file tools that automate YOUR workflow - that’s where programming saves hours!</p>
<h2 id="summary-6"><a class="header" href="#summary-6">Summary</a></h2>
<ul>
<li>File operations are fundamental to real-world programming</li>
<li>Use path operations to navigate the file system safely</li>
<li>Always check file existence and permissions before operations</li>
<li>Handle errors gracefully with try/catch blocks</li>
<li>Batch operations are more efficient than individual ones</li>
<li>Test file operations on sample data first</li>
<li>Be careful with delete operations - consider backups</li>
<li>Use atomic operations when possible for data integrity</li>
</ul>
<p>You can now build powerful file management tools! Next, let’s combine everything to build complete applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-applications"><a class="header" href="#building-applications">Building Applications</a></h1>
<p><em>“The day I shipped my first real application was terrifying and exhilarating. It wasn’t perfect, but it solved a real problem for real people. That’s when I learned that ‘done’ beats ‘perfect’ every time. Ship early, iterate often, and let your users teach you what they really need.”</em> - Noah Gift</p>
<h2 id="the-problem-8"><a class="header" href="#the-problem-8">The Problem</a></h2>
<p>You’ve learned the pieces - variables, logic, file operations, data processing. But how do you combine them into complete, production-ready applications? How do you structure larger programs, handle errors gracefully, and create software people actually want to use?</p>
<p>Most tutorials teach syntax but not software. In Ruchy, building applications should be about solving problems, not wrestling with complexity.</p>
<h2 id="quick-example-7"><a class="header" href="#quick-example-7">Quick Example</a></h2>
<p>Here’s a complete, useful application in Ruchy:</p>
<pre><code class="language-ruchy">// File: note_keeper.ruchy
// A complete note-taking application

let APP_NAME = "NoteKeeper"
let VERSION = "1.0.0"
let NOTES_DIR = expand_home("~/.notes")
let NOTES_INDEX = join_path(NOTES_DIR, "index.json")

// Initialize application
fn init_app() {
    if !dir_exists(NOTES_DIR) {
        create_dir_all(NOTES_DIR)
        println(f"Created notes directory: {NOTES_DIR}")
    }
    
    if !file_exists(NOTES_INDEX) {
        let initial_index = {
            "version": VERSION,
            "notes": [],
            "tags": [],
            "last_modified": current_datetime()
        }
        save_index(initial_index)
    }
}

fn load_index() {
    let content = read_file(NOTES_INDEX)
    return parse_json(content)
}

fn save_index(index) {
    index.last_modified = current_datetime()
    let json = to_json_pretty(index)
    write_file(NOTES_INDEX, json)
}

fn create_note() {
    println("\n📝 Create New Note")
    let title = input("Title: ")
    let content = input_multiline("Content (end with empty line):\n")
    let tags = input("Tags (comma-separated): ").split(",").map(|t| t.trim())
    
    let note_id = generate_id()
    let note_file = join_path(NOTES_DIR, f"{note_id}.md")
    
    let note = {
        "id": note_id,
        "title": title,
        "created": current_datetime(),
        "modified": current_datetime(),
        "tags": tags,
        "file": note_file
    }
    
    // Save note content
    let markdown = f"# {title}

Created: {note.created}
Tags: {tags.join(', ')}

---

{content}"
    
    write_file(note_file, markdown)
    
    // Update index
    let index = load_index()
    index.notes.push(note)
    index.tags = index.tags.union(tags)
    save_index(index)
    
    println(f"✅ Note created: {title}")
}

fn list_notes(filter_tag = null) {
    let index = load_index()
    let notes = index.notes
    
    if filter_tag {
        notes = notes.filter(|n| n.tags.contains(filter_tag))
        println(f"\n📋 Notes tagged '{filter_tag}':")
    } else {
        println(f"\n📋 All Notes ({notes.len()} total):")
    }
    
    if notes.is_empty() {
        println("  No notes found")
        return
    }
    
    for i, note in notes.enumerate() {
        let age = time_ago(note.created)
        println(f"{i+1:3}. {note.title}")
        println(f"     Tags: {note.tags.join(', ')} | Created: {age}")
    }
}

fn search_notes(query) {
    let index = load_index()
    let results = []
    
    for note in index.notes {
        // Search in title
        if note.title.lower().contains(query.lower()) {
            results.push(note)
            continue
        }
        
        // Search in content
        let content = read_file(note.file)
        if content.lower().contains(query.lower()) {
            results.push(note)
        }
    }
    
    println(f"\n🔍 Search results for '{query}': {results.len()} matches")
    
    for note in results {
        println(f"  • {note.title}")
        
        // Show context
        let content = read_file(note.file)
        let lines = content.lines()
        for line in lines {
            if line.lower().contains(query.lower()) {
                println(f"    ...{line.trim()}...")
                break
            }
        }
    }
}

fn view_note(index_num) {
    let index = load_index()
    
    if index_num &lt; 1 || index_num &gt; index.notes.len() {
        println("❌ Invalid note number")
        return
    }
    
    let note = index.notes[index_num - 1]
    let content = read_file(note.file)
    
    println("\n" + "="*50)
    println(content)
    println("="*50)
}

fn export_notes(format) {
    let index = load_index()
    let export_file = f"notes_export_{current_date()}.{format}"
    
    match format {
        "json" =&gt; {
            let data = {
                "exported": current_datetime(),
                "notes": []
            }
            
            for note in index.notes {
                let content = read_file(note.file)
                data.notes.push({
                    "title": note.title,
                    "content": content,
                    "tags": note.tags,
                    "created": note.created
                })
            }
            
            write_file(export_file, to_json_pretty(data))
        }
        "markdown" =&gt; {
            let markdown = f"# My Notes
Exported: {current_datetime()}

"
            for note in index.notes {
                let content = read_file(note.file)
                markdown += f"

---

{content}
"
            }
            
            write_file(export_file, markdown)
        }
        _ =&gt; {
            println(f"❌ Unsupported format: {format}")
            return
        }
    }
    
    println(f"✅ Exported {index.notes.len()} notes to {export_file}")
}

fn show_menu() {
    println(f"\n=== {APP_NAME} v{VERSION} ===")
    println("1. Create note")
    println("2. List all notes")
    println("3. Search notes")
    println("4. View note")
    println("5. List by tag")
    println("6. Export notes")
    println("7. Statistics")
    println("8. Quit")
}

fn show_statistics() {
    let index = load_index()
    let total_notes = index.notes.len()
    let total_tags = index.tags.len()
    
    // Calculate word count
    let total_words = 0
    for note in index.notes {
        let content = read_file(note.file)
        total_words += content.split_whitespace().len()
    }
    
    // Find most used tags
    let tag_counts = {}
    for note in index.notes {
        for tag in note.tags {
            tag_counts[tag] = tag_counts.get(tag, 0) + 1
        }
    }
    
    println(f"\n📊 NoteKeeper Statistics")
    println(f"Total notes: {total_notes}")
    println(f"Total words: {total_words}")
    println(f"Average words per note: {total_words / max(total_notes, 1)}")
    println(f"Unique tags: {total_tags}")
    
    if !tag_counts.is_empty() {
        println("\nTop tags:")
        let sorted_tags = tag_counts.items().sort_by(|item| -item.value)
        for tag, count in sorted_tags[..min(5, sorted_tags.len())] {
            println(f"  • {tag}: {count} notes")
        }
    }
}

// Main application loop
fn main() {
    init_app()
    
    println(f"Welcome to {APP_NAME}!")
    println("Your personal note-taking assistant")
    
    loop {
        show_menu()
        let choice = input("\nChoice: ")
        
        match choice {
            "1" =&gt; create_note()
            "2" =&gt; list_notes()
            "3" =&gt; {
                let query = input("Search for: ")
                search_notes(query)
            }
            "4" =&gt; {
                list_notes()
                let num = input("\nNote number to view: ").to_i()
                view_note(num)
            }
            "5" =&gt; {
                let index = load_index()
                println("\nAvailable tags:")
                for tag in index.tags {
                    println(f"  • {tag}")
                }
                let tag = input("\nFilter by tag: ")
                list_notes(tag)
            }
            "6" =&gt; {
                let format = input("Export format (json/markdown): ")
                export_notes(format)
            }
            "7" =&gt; show_statistics()
            "8" =&gt; {
                println("👋 Thanks for using NoteKeeper!")
                break
            }
            _ =&gt; println("❌ Invalid choice")
        }
    }
}

// Run the application
main()
</code></pre>
<p>That’s a complete application! It has data persistence, search, export, and a user-friendly interface.</p>
<h2 id="application-architecture"><a class="header" href="#application-architecture">Application Architecture</a></h2>
<h3 id="structure-patterns"><a class="header" href="#structure-patterns">Structure Patterns</a></h3>
<p>Organize larger applications effectively:</p>
<pre><code class="language-ruchy">// Application structure
let APP = {
    "name": "MyApp",
    "version": "1.0.0",
    "config_dir": "~/.config/myapp",
    "data_dir": "~/.local/share/myapp",
    "cache_dir": "~/.cache/myapp"
}

// Separate concerns into modules
// models.ruchy - Data structures
let User = {
    "id": null,
    "name": "",
    "email": "",
    "created": null
}

// services.ruchy - Business logic
fn create_user(name, email) {
    let user = User.copy()
    user.id = generate_uuid()
    user.name = name
    user.email = email
    user.created = current_datetime()
    return user
}

// ui.ruchy - User interface
fn display_user(user) {
    println(f"User: {user.name} ({user.email})")
    println(f"Member since: {user.created}")
}

// main.ruchy - Application entry point
fn main() {
    init_app()
    load_config()
    run_event_loop()
    cleanup()
}
</code></pre>
<h3 id="state-management"><a class="header" href="#state-management">State Management</a></h3>
<p>Handle application state properly:</p>
<pre><code class="language-ruchy">// Global application state
let STATE = {
    "users": [],
    "current_user": null,
    "settings": {},
    "cache": {},
    "dirty": false
}

fn update_state(key, value) {
    STATE[key] = value
    STATE.dirty = true
    trigger_save()
}

fn save_state() {
    if STATE.dirty {
        let state_file = join_path(APP.data_dir, "state.json")
        write_file(state_file, to_json(STATE))
        STATE.dirty = false
    }
}

fn load_state() {
    let state_file = join_path(APP.data_dir, "state.json")
    if file_exists(state_file) {
        STATE = parse_json(read_file(state_file))
    }
}
</code></pre>
<h3 id="error-recovery"><a class="header" href="#error-recovery">Error Recovery</a></h3>
<p>Build resilient applications:</p>
<pre><code class="language-ruchy">fn safe_operation(operation_fn, fallback_value) {
    try {
        return operation_fn()
    } catch error {
        log_error(error)
        return fallback_value
    }
}

fn with_retry(operation_fn, max_attempts = 3) {
    for attempt in range(max_attempts) {
        try {
            return operation_fn()
        } catch error {
            if attempt == max_attempts - 1 {
                println(f"❌ Failed after {max_attempts} attempts: {error}")
                throw error
            }
            
            let wait_time = 2 ** attempt  // Exponential backoff
            println(f"⚠️  Attempt {attempt + 1} failed, retrying in {wait_time}s...")
            sleep(wait_time * 1000)
        }
    }
}
</code></pre>
<h2 id="real-world-applications"><a class="header" href="#real-world-applications">Real-World Applications</a></h2>
<h3 id="password-manager"><a class="header" href="#password-manager">Password Manager</a></h3>
<pre><code class="language-ruchy">// Simple password manager with encryption
let MASTER_KEY = null
let PASSWORDS_FILE = "~/.passwords.enc"

fn encrypt(text, key) {
    // Simple XOR encryption (use real encryption in production!)
    let encrypted = []
    for i, char in text.chars().enumerate() {
        let key_char = key[i % key.len()]
        encrypted.push(char.code() ^ key_char.code())
    }
    return base64_encode(encrypted)
}

fn decrypt(encrypted, key) {
    let bytes = base64_decode(encrypted)
    let decrypted = []
    for i, byte in bytes.enumerate() {
        let key_char = key[i % key.len()]
        decrypted.push(char_from_code(byte ^ key_char.code()))
    }
    return decrypted.join("")
}

fn add_password(site, username, password) {
    let passwords = load_passwords()
    passwords[site] = {
        "username": username,
        "password": encrypt(password, MASTER_KEY),
        "created": current_datetime()
    }
    save_passwords(passwords)
}

fn get_password(site) {
    let passwords = load_passwords()
    if passwords.has_key(site) {
        let entry = passwords[site]
        let password = decrypt(entry.password, MASTER_KEY)
        copy_to_clipboard(password)
        println("✅ Password copied to clipboard!")
        
        // Clear clipboard after 30 seconds
        spawn_after(30000, || clear_clipboard())
    } else {
        println(f"❌ No password found for {site}")
    }
}
</code></pre>
<h3 id="budget-tracker"><a class="header" href="#budget-tracker">Budget Tracker</a></h3>
<pre><code class="language-ruchy">// Personal finance tracker
let TRANSACTIONS_FILE = "~/.budget/transactions.csv"
let CATEGORIES = ["Food", "Transport", "Bills", "Entertainment", "Other"]

fn add_transaction(amount, category, description) {
    let transaction = {
        "date": current_date(),
        "amount": amount,
        "category": category,
        "description": description
    }
    
    append_csv(TRANSACTIONS_FILE, transaction)
    
    // Check budget alerts
    let monthly_spent = get_monthly_total(category)
    let budget_limit = get_budget_limit(category)
    
    if monthly_spent &gt; budget_limit {
        send_notification(f"⚠️ Over budget for {category}!")
        println(f"Warning: {category} spending at ${monthly_spent}/${budget_limit}")
    }
}

fn generate_report(month) {
    let transactions = load_transactions(month)
    let by_category = group_by(transactions, "category")
    
    println(f"\n📊 Budget Report for {month}")
    println("="*40)
    
    let total = 0
    for category, items in by_category.items() {
        let category_total = items.map(|t| t.amount).sum()
        total += category_total
        
        let bar = "█" * (category_total / 50).to_i()
        println(f"{category:15} ${category_total:7.2f} {bar}")
    }
    
    println("="*40)
    println(f"Total:          ${total:7.2f}")
    
    // Save report
    let report_file = f"budget_report_{month}.pdf"
    generate_pdf(report_file, report_data)
    println(f"\n📄 Report saved to {report_file}")
}
</code></pre>
<h3 id="project-generator"><a class="header" href="#project-generator">Project Generator</a></h3>
<pre><code class="language-ruchy">// Development project scaffolding tool
let TEMPLATES = {
    "python": {
        "files": ["main.py", "requirements.txt", "README.md", ".gitignore"],
        "folders": ["src", "tests", "docs"]
    },
    "javascript": {
        "files": ["index.js", "package.json", "README.md", ".gitignore"],
        "folders": ["src", "test", "public"]
    },
    "ruchy": {
        "files": ["main.ruchy", "Cargo.toml", "README.md", ".gitignore"],
        "folders": ["src", "tests", "docs"]
    }
}

fn create_project(name, language) {
    let project_dir = name
    
    if dir_exists(project_dir) {
        println(f"❌ Directory {project_dir} already exists")
        return
    }
    
    create_dir(project_dir)
    println(f"📁 Created project: {name}")
    
    let template = TEMPLATES[language]
    
    // Create folder structure
    for folder in template.folders {
        create_dir(join_path(project_dir, folder))
        println(f"  📂 {folder}/")
    }
    
    // Create files from templates
    for file in template.files {
        let template_content = get_template_content(language, file)
        let content = template_content
            .replace("{{PROJECT_NAME}}", name)
            .replace("{{DATE}}", current_date())
            .replace("{{AUTHOR}}", get_git_user())
        
        write_file(join_path(project_dir, file), content)
        println(f"  📄 {file}")
    }
    
    // Initialize git
    run_command("git init", project_dir)
    run_command("git add .", project_dir)
    run_command('git commit -m "Initial commit"', project_dir)
    
    println(f"\n✅ Project {name} created successfully!")
    println(f"Next steps:")
    println(f"  cd {project_dir}")
    println(f"  {get_run_command(language)}")
}
</code></pre>
<h2 id="testing-your-application"><a class="header" href="#testing-your-application">Testing Your Application</a></h2>
<p>Build confidence with testing:</p>
<pre><code class="language-ruchy">// test_app.ruchy - Application test suite

fn test_user_creation() {
    let user = create_user("Alice", "alice@example.com")
    
    assert(user.name == "Alice", "Name should be set")
    assert(user.email == "alice@example.com", "Email should be set")
    assert(user.id != null, "ID should be generated")
    
    println("✅ test_user_creation passed")
}

fn test_data_persistence() {
    let test_data = {"test": "value"}
    let test_file = "test_data.json"
    
    // Save data
    save_json(test_file, test_data)
    assert(file_exists(test_file), "File should be created")
    
    // Load data
    let loaded = load_json(test_file)
    assert(loaded.test == "value", "Data should persist")
    
    // Cleanup
    remove_file(test_file)
    
    println("✅ test_data_persistence passed")
}

fn run_all_tests() {
    println("🧪 Running application tests...")
    
    test_user_creation()
    test_data_persistence()
    test_error_handling()
    test_performance()
    
    println("\n✅ All tests passed!")
}
</code></pre>
<h2 id="deployment"><a class="header" href="#deployment">Deployment</a></h2>
<p>Package and distribute your application:</p>
<pre><code class="language-ruchy">// build.ruchy - Build and package script

fn build_release() {
    println("🔨 Building release version...")
    
    // Run tests first
    run_tests()
    
    // Create release directory
    let release_dir = f"release_{VERSION}"
    create_dir_all(release_dir)
    
    // Copy application files
    copy_file("main.ruchy", join_path(release_dir, APP_NAME))
    copy_dir("resources", join_path(release_dir, "resources"))
    
    // Generate documentation
    generate_docs(join_path(release_dir, "docs"))
    
    // Create installer script
    let installer = f"#!/bin/bash
echo 'Installing {APP_NAME} v{VERSION}'
mkdir -p ~/.local/bin
cp {APP_NAME} ~/.local/bin/
chmod +x ~/.local/bin/{APP_NAME}
echo 'Installation complete! Run {APP_NAME} to start.'
"
    write_file(join_path(release_dir, "install.sh"), installer)
    
    // Package as archive
    create_archive(f"{APP_NAME}-{VERSION}.tar.gz", release_dir)
    
    println(f"✅ Release built: {APP_NAME}-{VERSION}.tar.gz")
}
</code></pre>
<h2 id="try-it-yourself-7"><a class="header" href="#try-it-yourself-7">Try It Yourself</a></h2>
<p>Build your own complete application!</p>
<p><strong>Application Ideas:</strong></p>
<ol>
<li>
<p><strong>Productivity Tools</strong>:</p>
<ul>
<li>Pomodoro timer with statistics</li>
<li>Habit tracker with streaks</li>
<li>Daily journal with mood tracking</li>
<li>Task manager with priorities</li>
</ul>
</li>
<li>
<p><strong>Developer Tools</strong>:</p>
<ul>
<li>Code snippet manager</li>
<li>API testing client</li>
<li>Database backup scheduler</li>
<li>Git repository analyzer</li>
</ul>
</li>
<li>
<p><strong>Data Applications</strong>:</p>
<ul>
<li>Expense splitter for groups</li>
<li>Recipe database with meal planning</li>
<li>Contact manager with reminders</li>
<li>Bookmark organizer with tags</li>
</ul>
</li>
<li>
<p><strong>System Utilities</strong>:</p>
<ul>
<li>System monitor dashboard</li>
<li>Backup automation tool</li>
<li>File synchronization utility</li>
<li>Service health checker</li>
</ul>
</li>
</ol>
<h2 id="summary-7"><a class="header" href="#summary-7">Summary</a></h2>
<ul>
<li>Applications combine all your skills into solutions</li>
<li>Start with a clear problem to solve</li>
<li>Design the user experience first</li>
<li>Structure code into logical modules</li>
<li>Handle errors gracefully everywhere</li>
<li>Test critical functionality thoroughly</li>
<li>Document how to use your application</li>
<li>Ship early and iterate based on feedback</li>
<li>Focus on solving real problems for real people</li>
</ul>
<p>You now have everything you need to build complete applications! Go forth and create something amazing. Remember: the best code is code that ships and helps people.</p>
<h2 id="final-thoughts"><a class="header" href="#final-thoughts">Final Thoughts</a></h2>
<p><em>“Programming isn’t about writing code - it’s about solving problems. The syntax is just the tool. Focus on the problem, understand the user, and the code will follow. Every application you build teaches you something new. Keep building, keep learning, keep shipping.”</em> - Noah Gift</p>
<p>Welcome to the community of builders. Your journey is just beginning!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="systems-programming"><a class="header" href="#systems-programming">Systems Programming</a></h1>
<p><em>“The first time I wrote a system monitor that could track CPU usage, memory consumption, and disk I/O in real-time, I finally understood what my computer was actually doing. Systems programming isn’t about fighting the OS - it’s about dancing with it. Learn the steps, and your programs can do things you never imagined.”</em> - Noah Gift</p>
<h2 id="the-problem-9"><a class="header" href="#the-problem-9">The Problem</a></h2>
<p>You’ve built applications, but how do you interact with the operating system itself? How do you monitor processes, manage system resources, handle signals, and create tools that feel native to the platform?</p>
<p>Most high-level languages abstract away the system, but real power comes from understanding and controlling it. In Ruchy, systems programming should be safe yet powerful, giving you OS-level capabilities without the complexity.</p>
<h2 id="quick-example-8"><a class="header" href="#quick-example-8">Quick Example</a></h2>
<p>Here’s a system resource monitor in Ruchy:</p>
<pre><code class="language-ruchy">// File: system_monitor.ruchy
// Real-time system resource monitoring

use std::system;
use std::process;

println("=== System Monitor ===")

// Get system information
let cpu_count = system::cpu_count()
let total_memory = system::total_memory()
let hostname = system::hostname()
let os_info = system::os_info()

println(f"Host: {hostname}")
println(f"OS: {os_info.name} {os_info.version}")
println(f"CPUs: {cpu_count}")
println(f"Memory: {format_size(total_memory)}")
println("")

// Monitor resources in real-time
loop {
    let cpu_usage = system::cpu_usage()
    let memory_info = system::memory_info()
    let disk_io = system::disk_io_stats()
    let network_stats = system::network_stats()
    
    // Clear screen and show header
    clear_screen()
    println("System Monitor - Press Ctrl+C to exit")
    println("=" * 50)
    
    // CPU Usage
    println(f"CPU: {cpu_usage:.1%} |{'█' * (cpu_usage * 50).to_i()}{'░' * (50 - cpu_usage * 50).to_i()}|")
    
    // Memory Usage
    let mem_percent = memory_info.used / memory_info.total
    println(f"MEM: {mem_percent:.1%} |{'█' * (mem_percent * 50).to_i()}{'░' * (50 - mem_percent * 50).to_i()}|")
    println(f"     {format_size(memory_info.used)} / {format_size(memory_info.total)}")
    
    // Disk I/O
    println(f"Disk Read:  {format_size(disk_io.read_bytes)}/s")
    println(f"Disk Write: {format_size(disk_io.write_bytes)}/s")
    
    // Network
    println(f"Net Down: {format_size(network_stats.download_speed)}/s")
    println(f"Net Up:   {format_size(network_stats.upload_speed)}/s")
    
    // Top processes
    println("\nTop Processes by CPU:")
    let processes = process::list()
        .sort_by(|p| -p.cpu_percent)
        .take(5)
    
    for proc in processes {
        println(f"  {proc.pid:6} {proc.name:20} {proc.cpu_percent:5.1}%")
    }
    
    sleep(1000)  // Update every second
}
</code></pre>
<p>That’s systems programming - direct access to OS resources with safety!</p>
<h2 id="core-concepts-7"><a class="header" href="#core-concepts-7">Core Concepts</a></h2>
<h3 id="process-management"><a class="header" href="#process-management">Process Management</a></h3>
<p>Work with processes at the system level:</p>
<pre><code class="language-ruchy">// Current process information
let pid = process::current_pid()
let ppid = process::parent_pid()
let exe_path = process::executable_path()
let args = process::args()
let env = process::environment()

// List all processes
let all_processes = process::list()
for proc in all_processes {
    println(f"PID: {proc.pid}, Name: {proc.name}, CPU: {proc.cpu_percent}%")
}

// Find specific process
let chrome_procs = process::find_by_name("chrome")
let high_cpu_procs = process::list()
    .filter(|p| p.cpu_percent &gt; 50)

// Process control
let proc = process::from_pid(1234)
proc.suspend()  // Pause process
proc.resume()   // Resume process
proc.terminate() // Request termination
proc.kill()     // Force kill

// Launch new process
let child = process::spawn("ls", ["-la"])
let output = child.wait_with_output()
println(output.stdout)
</code></pre>
<h3 id="signal-handling"><a class="header" href="#signal-handling">Signal Handling</a></h3>
<p>Respond to system signals properly:</p>
<pre><code class="language-ruchy">// Register signal handlers
signal::on(SIGINT, || {
    println("\nGracefully shutting down...")
    cleanup()
    exit(0)
})

signal::on(SIGTERM, || {
    save_state()
    exit(0)
})

signal::on(SIGUSR1, || {
    reload_config()
})

// Send signals to other processes
let target_pid = 1234
signal::send(target_pid, SIGUSR1)

// Block/unblock signals
signal::block([SIGPIPE])
critical_operation()
signal::unblock([SIGPIPE])
</code></pre>
<h3 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h3>
<p>Monitor and control memory usage:</p>
<pre><code class="language-ruchy">// Get memory information
let mem_info = system::memory_info()
println(f"Total: {mem_info.total}")
println(f"Used: {mem_info.used}")
println(f"Free: {mem_info.free}")
println(f"Available: {mem_info.available}")
println(f"Swap Used: {mem_info.swap_used}")

// Monitor memory pressure
if mem_info.available &lt; 100_000_000 {  // Less than 100MB
    println("WARNING: Low memory!")
    free_caches()
}

// Memory-mapped files for large data
let mmap = memory::map_file("huge_dataset.bin", READ_ONLY)
let data = mmap.read_range(0, 1000000)  // Read 1MB
mmap.close()

// Shared memory between processes
let shared = memory::create_shared("my_buffer", 1024 * 1024)
shared.write(0, data)

// In another process
let shared = memory::open_shared("my_buffer")
let data = shared.read(0, 1024)
</code></pre>
<h2 id="practical-system-tools"><a class="header" href="#practical-system-tools">Practical System Tools</a></h2>
<h3 id="service-manager"><a class="header" href="#service-manager">Service Manager</a></h3>
<pre><code class="language-ruchy">// File: service_manager.ruchy
// Manage system services

println("=== Service Manager ===")

let services = [
    {name: "web_server", command: "./server", port: 8080},
    {name: "worker", command: "./worker", count: 4},
    {name: "scheduler", command: "./scheduler", interval: 60}
]

let running_services = {}

fn start_service(service) {
    println(f"Starting {service.name}...")
    
    match service.name {
        "web_server" =&gt; {
            let proc = process::spawn(service.command, [
                "--port", service.port.to_s()
            ])
            running_services[service.name] = proc
            
            // Wait for port to be available
            while !network::port_is_open("localhost", service.port) {
                sleep(100)
            }
            println(f"✅ {service.name} listening on port {service.port}")
        }
        "worker" =&gt; {
            let workers = []
            for i in range(service.count) {
                let proc = process::spawn(service.command, [
                    "--id", i.to_s()
                ])
                workers.push(proc)
            }
            running_services[service.name] = workers
            println(f"✅ Started {service.count} workers")
        }
        "scheduler" =&gt; {
            let proc = process::spawn(service.command, [
                "--interval", service.interval.to_s()
            ])
            running_services[service.name] = proc
            println(f"✅ Scheduler running every {service.interval}s")
        }
    }
}

fn stop_service(name) {
    if running_services.has_key(name) {
        println(f"Stopping {name}...")
        let proc = running_services[name]
        
        if proc.is_array() {
            // Multiple processes (workers)
            for p in proc {
                p.terminate()
                p.wait()
            }
        } else {
            // Single process
            proc.terminate()
            proc.wait()
        }
        
        running_services.remove(name)
        println(f"✅ {name} stopped")
    }
}

fn service_status() {
    println("\n=== Service Status ===")
    for service in services {
        let status = if running_services.has_key(service.name) {
            "🟢 Running"
        } else {
            "🔴 Stopped"
        }
        println(f"{service.name:15} {status}")
    }
}

// Handle shutdown gracefully
signal::on(SIGTERM, || {
    println("\nShutting down all services...")
    for name in running_services.keys() {
        stop_service(name)
    }
    exit(0)
})

// Interactive management
loop {
    service_status()
    println("\nCommands: start &lt;name&gt;, stop &lt;name&gt;, restart &lt;name&gt;, quit")
    let command = input("&gt; ").split(" ")
    
    match command[0] {
        "start" =&gt; start_service(services.find(|s| s.name == command[1]))
        "stop" =&gt; stop_service(command[1])
        "restart" =&gt; {
            stop_service(command[1])
            start_service(services.find(|s| s.name == command[1]))
        }
        "quit" =&gt; break
        _ =&gt; println("Unknown command")
    }
}
</code></pre>
<h3 id="system-health-checker"><a class="header" href="#system-health-checker">System Health Checker</a></h3>
<pre><code class="language-ruchy">// File: health_check.ruchy
// Monitor system health and alert on issues

println("=== System Health Checker ===")

let checks = {
    cpu_threshold: 80,      // Alert if CPU &gt; 80%
    memory_threshold: 90,   // Alert if memory &gt; 90%
    disk_threshold: 95,     // Alert if disk &gt; 95%
    load_threshold: 4.0,    // Alert if load average &gt; 4
    temp_threshold: 80      // Alert if CPU temp &gt; 80°C
}

let alerts = []

fn check_cpu() {
    let usage = system::cpu_usage() * 100
    if usage &gt; checks.cpu_threshold {
        alerts.push({
            level: "WARNING",
            message: f"CPU usage high: {usage:.1}%",
            time: current_datetime()
        })
        return false
    }
    return true
}

fn check_memory() {
    let mem = system::memory_info()
    let usage = (mem.used / mem.total) * 100
    if usage &gt; checks.memory_threshold {
        alerts.push({
            level: "CRITICAL",
            message: f"Memory usage critical: {usage:.1}%",
            time: current_datetime()
        })
        return false
    }
    return true
}

fn check_disk() {
    let disks = system::disk_usage()
    for disk in disks {
        let usage = (disk.used / disk.total) * 100
        if usage &gt; checks.disk_threshold {
            alerts.push({
                level: "WARNING",
                message: f"Disk {disk.mount} almost full: {usage:.1}%",
                time: current_datetime()
            })
            return false
        }
    }
    return true
}

fn check_load() {
    let load = system::load_average()
    let cpu_count = system::cpu_count()
    let normalized_load = load.one_minute / cpu_count
    
    if normalized_load &gt; checks.load_threshold {
        alerts.push({
            level: "WARNING",
            message: f"System load high: {load.one_minute:.2}",
            time: current_datetime()
        })
        return false
    }
    return true
}

fn check_temperature() {
    let temps = system::temperatures()
    for sensor in temps {
        if sensor.current &gt; checks.temp_threshold {
            alerts.push({
                level: "CRITICAL",
                message: f"Temperature critical: {sensor.name} at {sensor.current}°C",
                time: current_datetime()
            })
            return false
        }
    }
    return true
}

fn run_health_checks() {
    let all_healthy = true
    
    all_healthy = check_cpu() &amp;&amp; all_healthy
    all_healthy = check_memory() &amp;&amp; all_healthy
    all_healthy = check_disk() &amp;&amp; all_healthy
    all_healthy = check_load() &amp;&amp; all_healthy
    all_healthy = check_temperature() &amp;&amp; all_healthy
    
    return all_healthy
}

// Main monitoring loop
loop {
    clear_screen()
    println(f"System Health Check - {current_datetime()}")
    println("=" * 50)
    
    let healthy = run_health_checks()
    
    if healthy {
        println("✅ All systems healthy")
    } else {
        println("⚠️  Issues detected:")
        for alert in alerts.last(5) {
            let icon = alert.level == "CRITICAL" ? "🔴" : "🟡"
            println(f"{icon} [{alert.level}] {alert.message}")
        }
    }
    
    // Show current stats
    println("\nCurrent Status:")
    let cpu = system::cpu_usage() * 100
    let mem = system::memory_info()
    let mem_percent = (mem.used / mem.total) * 100
    let load = system::load_average()
    
    println(f"CPU:    {cpu:5.1}% / {checks.cpu_threshold}%")
    println(f"Memory: {mem_percent:5.1}% / {checks.memory_threshold}%")
    println(f"Load:   {load.one_minute:5.2} / {checks.load_threshold}")
    
    // Send notifications for critical alerts
    for alert in alerts {
        if alert.level == "CRITICAL" {
            system::notify(alert.message, "System Health Alert")
        }
    }
    
    sleep(5000)  // Check every 5 seconds
}
</code></pre>
<h3 id="process-tree-visualizer"><a class="header" href="#process-tree-visualizer">Process Tree Visualizer</a></h3>
<pre><code class="language-ruchy">// File: process_tree.ruchy
// Visualize process hierarchy

fn build_process_tree() {
    let processes = process::list()
    let tree = {}
    
    // Build parent-child relationships
    for proc in processes {
        let ppid = proc.parent_pid
        if !tree.has_key(ppid) {
            tree[ppid] = []
        }
        tree[ppid].push(proc)
    }
    
    return tree
}

fn print_tree(pid, tree, indent = "") {
    if !tree.has_key(pid) {
        return
    }
    
    let children = tree[pid].sort_by(|p| p.pid)
    for i, proc in children.enumerate() {
        let is_last = (i == children.len() - 1)
        let prefix = is_last ? "└─" : "├─"
        let extension = is_last ? "  " : "│ "
        
        let memory = format_size(proc.memory_info.rss)
        println(f"{indent}{prefix} [{proc.pid}] {proc.name} ({memory}, {proc.cpu_percent:.1}%)")
        
        // Recursively print children
        print_tree(proc.pid, tree, indent + extension)
    }
}

println("=== Process Tree ===")
let tree = build_process_tree()

// Start from init (PID 1) or system idle (PID 0)
let root_pid = tree.has_key(0) ? 0 : 1
println(f"[{root_pid}] System Root")
print_tree(root_pid, tree)

// Show process statistics
let all_procs = process::list()
let total_memory = all_procs.map(|p| p.memory_info.rss).sum()
let total_cpu = all_procs.map(|p| p.cpu_percent).sum()

println(f"\nTotal Processes: {all_procs.len()}")
println(f"Total Memory: {format_size(total_memory)}")
println(f"Total CPU: {total_cpu:.1}%")
</code></pre>
<h2 id="advanced-system-features"><a class="header" href="#advanced-system-features">Advanced System Features</a></h2>
<h3 id="file-system-events"><a class="header" href="#file-system-events">File System Events</a></h3>
<p>Monitor file system changes in real-time:</p>
<pre><code class="language-ruchy">// Watch for file system events
let watcher = fs::watch("/path/to/watch", RECURSIVE)

watcher.on("created", |path| {
    println(f"File created: {path}")
})

watcher.on("modified", |path| {
    println(f"File modified: {path}")
    process_change(path)
})

watcher.on("deleted", |path| {
    println(f"File deleted: {path}")
})

watcher.start()
</code></pre>
<h3 id="system-automation"><a class="header" href="#system-automation">System Automation</a></h3>
<pre><code class="language-ruchy">// Automated system maintenance
fn auto_cleanup() {
    // Clean temp files older than 7 days
    let temp_dir = "/tmp"
    let cutoff_time = current_time() - days(7)
    
    for file in fs::walk(temp_dir) {
        if fs::modified_time(file) &lt; cutoff_time {
            fs::remove(file)
            println(f"Cleaned: {file}")
        }
    }
    
    // Clear package manager cache
    if fs::dir_size("/var/cache/apt") &gt; gb(1) {
        run_command("apt-get clean")
    }
    
    // Rotate logs
    for log in fs::glob("/var/log/*.log") {
        if fs::size(log) &gt; mb(100) {
            fs::rotate_log(log, keep_count: 5)
        }
    }
}
</code></pre>
<h2 id="try-it-yourself-8"><a class="header" href="#try-it-yourself-8">Try It Yourself</a></h2>
<p>Time to explore your system! Start experimenting:</p>
<pre><code class="language-bash">$ ruchy repl
&gt;&gt;&gt; # Explore your system
&gt;&gt;&gt; system::info()
&gt;&gt;&gt; process::current()
&gt;&gt;&gt; 
&gt;&gt;&gt; # Monitor resources
&gt;&gt;&gt; while true {
&gt;&gt;&gt;     let cpu = system::cpu_usage()
&gt;&gt;&gt;     print(f"\rCPU: {cpu:.1%}")
&gt;&gt;&gt;     sleep(100)
&gt;&gt;&gt; }
&gt;&gt;&gt; 
&gt;&gt;&gt; # Find resource hogs
&gt;&gt;&gt; process::list()
&gt;&gt;&gt;     .filter(|p| p.cpu_percent &gt; 10)
&gt;&gt;&gt;     .map(|p| f"{p.name}: {p.cpu_percent}%")
</code></pre>
<p><strong>Your Systems Programming Challenges:</strong></p>
<ol>
<li>
<p><strong>Monitoring Tools</strong>:</p>
<ul>
<li>Process monitor with kill capabilities</li>
<li>Network connection tracker</li>
<li>Disk space analyzer</li>
<li>System performance profiler</li>
</ul>
</li>
<li>
<p><strong>System Utilities</strong>:</p>
<ul>
<li>Service watchdog</li>
<li>Log aggregator</li>
<li>Backup scheduler</li>
<li>System info reporter</li>
</ul>
</li>
<li>
<p><strong>Process Management</strong>:</p>
<ul>
<li>Task manager GUI</li>
<li>Process priority manager</li>
<li>Resource limiter</li>
<li>Job scheduler</li>
</ul>
</li>
<li>
<p><strong>Automation</strong>:</p>
<ul>
<li>System maintenance scripts</li>
<li>Health check automation</li>
<li>Alert system</li>
<li>Performance tuner</li>
</ul>
</li>
</ol>
<h2 id="summary-8"><a class="header" href="#summary-8">Summary</a></h2>
<ul>
<li>Systems programming gives you direct OS access</li>
<li>Process management lets you control running programs</li>
<li>Signal handling enables graceful shutdowns</li>
<li>Resource monitoring helps optimize performance</li>
<li>Memory management prevents resource exhaustion</li>
<li>File system events enable reactive programs</li>
<li>System automation saves time and prevents issues</li>
<li>Always handle errors and edge cases in system code</li>
</ul>
<p>You now have the power to create system-level tools! Next, let’s explore network programming.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-programming"><a class="header" href="#network-programming">Network Programming</a></h1>
<p><em>“The day I wrote my first networked application - a simple chat server - everything clicked. Suddenly my programs weren’t isolated islands anymore; they could talk to the world. Network programming isn’t about memorizing socket APIs; it’s about connecting ideas across machines. Master the network, and distance disappears.”</em> - Noah Gift</p>
<h2 id="the-problem-10"><a class="header" href="#the-problem-10">The Problem</a></h2>
<p>You’ve built standalone applications, but how do you make them communicate? How do you build web servers, API clients, real-time chat systems, or distributed tools that work across networks?</p>
<p>Most developers fear network programming because of its complexity - protocols, sockets, concurrency. In Ruchy, networking should be as natural as file I/O, with powerful abstractions that don’t hide the important details.</p>
<h2 id="quick-example-9"><a class="header" href="#quick-example-9">Quick Example</a></h2>
<p>Here’s a complete web server in Ruchy:</p>
<pre><code class="language-ruchy">// File: web_server.ruchy
// HTTP server with routing and middleware

use std::net::http;

let server = http::Server::new("0.0.0.0:8080")

// Middleware for logging
server.use(|req, res, next| {
    let start = current_time_ms()
    next()
    let duration = current_time_ms() - start
    println(f"{req.method} {req.path} - {res.status} ({duration}ms)")
})

// Routes
server.get("/", |req, res| {
    res.html("&lt;h1&gt;Welcome to Ruchy Server!&lt;/h1&gt;")
})

server.get("/api/users", |req, res| {
    let users = [
        {id: 1, name: "Alice", email: "alice@example.com"},
        {id: 2, name: "Bob", email: "bob@example.com"}
    ]
    res.json(users)
})

server.post("/api/users", |req, res| {
    let user = req.json()
    println(f"Creating user: {user.name}")
    user.id = generate_id()
    user.created = current_datetime()
    res.status(201).json(user)
})

// Static files
server.static("/public", "./static")

// Start server
println(f"🚀 Server running on http://localhost:8080")
server.listen()
</code></pre>
<p>That’s a production-ready web server in under 30 lines!</p>
<h2 id="core-concepts-8"><a class="header" href="#core-concepts-8">Core Concepts</a></h2>
<h3 id="tcp-networking"><a class="header" href="#tcp-networking">TCP Networking</a></h3>
<p>Build reliable network connections:</p>
<pre><code class="language-ruchy">// TCP Server
let server = net::TcpListener::bind("127.0.0.1:9000")
println("Server listening on port 9000")

loop {
    let client = server.accept()
    
    // Handle each client in a separate thread
    spawn {
        println(f"Client connected: {client.remote_addr()}")
        
        loop {
            let message = client.read_line()
            if message.is_empty() {
                break
            }
            
            println(f"Received: {message}")
            client.write(f"Echo: {message}\n")
        }
        
        println("Client disconnected")
    }
}

// TCP Client
let client = net::TcpStream::connect("127.0.0.1:9000")
client.write("Hello, server!\n")
let response = client.read_line()
println(f"Server replied: {response}")
</code></pre>
<h3 id="http-client"><a class="header" href="#http-client">HTTP Client</a></h3>
<p>Make HTTP requests easily:</p>
<pre><code class="language-ruchy">// Simple GET request
let response = http::get("https://api.example.com/data")
let data = response.json()
println(f"Got {data.items.len()} items")

// POST with JSON
let user = {
    name: "Alice",
    email: "alice@example.com"
}
let response = http::post("https://api.example.com/users")
    .json(user)
    .send()

// Advanced requests
let response = http::request("https://api.example.com/data")
    .method("GET")
    .header("Authorization", f"Bearer {token}")
    .header("User-Agent", "Ruchy/1.0")
    .query("page", 1)
    .query("limit", 100)
    .timeout(5000)
    .send()

if response.is_success() {
    let data = response.json()
    process_data(data)
} else {
    println(f"Error: {response.status} - {response.text()}")
}

// Download file with progress
http::download("https://example.com/big-file.zip", "downloads/file.zip")
    .on_progress(|downloaded, total| {
        let percent = (downloaded / total) * 100
        print(f"\rDownloading: {percent:.1}%")
    })
    .await()
</code></pre>
<h3 id="websocket-communication"><a class="header" href="#websocket-communication">WebSocket Communication</a></h3>
<p>Real-time bidirectional communication:</p>
<pre><code class="language-ruchy">// WebSocket Server
let ws_server = ws::Server::new("0.0.0.0:8081")

ws_server.on_connection(|socket| {
    println(f"WebSocket connected: {socket.id}")
    
    socket.on("message", |data| {
        println(f"Received: {data}")
        
        // Broadcast to all clients
        ws_server.broadcast({
            type: "chat",
            user: socket.id,
            message: data
        })
    })
    
    socket.on("close", || {
        println(f"WebSocket disconnected: {socket.id}")
    })
})

ws_server.listen()

// WebSocket Client
let ws = ws::connect("ws://localhost:8081")

ws.on("open", || {
    println("Connected to server")
    ws.send("Hello, server!")
})

ws.on("message", |data| {
    println(f"Server says: {data}")
})

ws.on("error", |err| {
    println(f"WebSocket error: {err}")
})
</code></pre>
<h2 id="practical-network-applications"><a class="header" href="#practical-network-applications">Practical Network Applications</a></h2>
<h3 id="rest-api-server"><a class="header" href="#rest-api-server">REST API Server</a></h3>
<pre><code class="language-ruchy">// File: api_server.ruchy
// RESTful API with database

use std::net::http;
use std::db;

let app = http::Server::new("0.0.0.0:3000")
let database = db::connect("sqlite:data.db")

// CORS middleware
app.use(|req, res, next| {
    res.header("Access-Control-Allow-Origin", "*")
    res.header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE")
    next()
})

// Authentication middleware
fn require_auth(req, res, next) {
    let token = req.header("Authorization")
    if !token || !validate_token(token) {
        return res.status(401).json({error: "Unauthorized"})
    }
    req.user = decode_token(token)
    next()
}

// Routes
app.get("/api/posts", |req, res| {
    let page = req.query("page", 1)
    let limit = req.query("limit", 10)
    
    let posts = database.query("
        SELECT * FROM posts 
        ORDER BY created_at DESC 
        LIMIT ? OFFSET ?
    ", [limit, (page - 1) * limit])
    
    res.json({
        posts: posts,
        page: page,
        total: database.count("posts")
    })
})

app.get("/api/posts/:id", |req, res| {
    let id = req.params.id
    let post = database.find("posts", id)
    
    if post {
        res.json(post)
    } else {
        res.status(404).json({error: "Post not found"})
    }
})

app.post("/api/posts", require_auth, |req, res| {
    let post = req.json()
    post.author_id = req.user.id
    post.created_at = current_datetime()
    
    let id = database.insert("posts", post)
    let created = database.find("posts", id)
    
    res.status(201).json(created)
})

app.put("/api/posts/:id", require_auth, |req, res| {
    let id = req.params.id
    let updates = req.json()
    
    // Check ownership
    let post = database.find("posts", id)
    if post.author_id != req.user.id {
        return res.status(403).json({error: "Forbidden"})
    }
    
    updates.updated_at = current_datetime()
    database.update("posts", id, updates)
    
    res.json(database.find("posts", id))
})

app.delete("/api/posts/:id", require_auth, |req, res| {
    let id = req.params.id
    
    // Check ownership
    let post = database.find("posts", id)
    if post.author_id != req.user.id {
        return res.status(403).json({error: "Forbidden"})
    }
    
    database.delete("posts", id)
    res.status(204).send()
})

// Error handling
app.use(|err, req, res, next| {
    console.error(f"Error: {err}")
    res.status(500).json({
        error: "Internal server error",
        message: err.message
    })
})

println("🚀 API server running on http://localhost:3000")
app.listen()
</code></pre>
<h3 id="real-time-chat-application"><a class="header" href="#real-time-chat-application">Real-time Chat Application</a></h3>
<pre><code class="language-ruchy">// File: chat_server.ruchy
// Multi-room chat server with history

use std::net::ws;

let server = ws::Server::new("0.0.0.0:8080")
let rooms = {}
let users = {}

fn broadcast_to_room(room_id, message, exclude_user = null) {
    if rooms.has_key(room_id) {
        for user_id in rooms[room_id] {
            if user_id != exclude_user {
                users[user_id].socket.send(message)
            }
        }
    }
}

server.on_connection(|socket| {
    let user = {
        id: generate_id(),
        socket: socket,
        name: null,
        room: null,
        joined_at: current_datetime()
    }
    
    users[user.id] = user
    
    socket.send(json({
        type: "welcome",
        user_id: user.id,
        message: "Welcome to chat! Send /help for commands"
    }))
    
    socket.on("message", |data| {
        let msg = parse_json(data)
        
        match msg.type {
            "join" =&gt; {
                user.name = msg.name
                user.room = msg.room
                
                // Add user to room
                if !rooms.has_key(msg.room) {
                    rooms[msg.room] = []
                }
                rooms[msg.room].push(user.id)
                
                // Notify room
                broadcast_to_room(msg.room, json({
                    type: "user_joined",
                    user: user.name,
                    time: current_datetime()
                }))
                
                // Send room history
                let history = get_room_history(msg.room)
                socket.send(json({
                    type: "history",
                    messages: history
                }))
            }
            
            "message" =&gt; {
                let chat_msg = {
                    type: "message",
                    user: user.name,
                    text: msg.text,
                    time: current_datetime()
                }
                
                // Save to history
                save_message(user.room, chat_msg)
                
                // Broadcast to room
                broadcast_to_room(user.room, json(chat_msg))
            }
            
            "private" =&gt; {
                let target = find_user_by_name(msg.to)
                if target {
                    target.socket.send(json({
                        type: "private",
                        from: user.name,
                        text: msg.text,
                        time: current_datetime()
                    }))
                }
            }
            
            "typing" =&gt; {
                broadcast_to_room(user.room, json({
                    type: "typing",
                    user: user.name
                }), user.id)
            }
        }
    })
    
    socket.on("close", || {
        // Remove from room
        if user.room &amp;&amp; rooms.has_key(user.room) {
            rooms[user.room] = rooms[user.room].filter(|id| id != user.id)
            
            broadcast_to_room(user.room, json({
                type: "user_left",
                user: user.name,
                time: current_datetime()
            }))
        }
        
        users.remove(user.id)
    })
})

println("💬 Chat server running on ws://localhost:8080")
server.listen()
</code></pre>
<h3 id="network-scanner"><a class="header" href="#network-scanner">Network Scanner</a></h3>
<pre><code class="language-ruchy">// File: network_scanner.ruchy
// Scan network for open ports and services

use std::net;
use std::async;

println("=== Network Scanner ===")

fn scan_port(host, port, timeout = 1000) {
    try {
        let socket = net::TcpStream::connect_timeout(
            f"{host}:{port}", 
            timeout
        )
        socket.close()
        return true
    } catch {
        return false
    }
}

fn identify_service(port) {
    let services = {
        21: "FTP",
        22: "SSH",
        23: "Telnet",
        25: "SMTP",
        53: "DNS",
        80: "HTTP",
        110: "POP3",
        143: "IMAP",
        443: "HTTPS",
        445: "SMB",
        3306: "MySQL",
        5432: "PostgreSQL",
        6379: "Redis",
        8080: "HTTP-Alt",
        8443: "HTTPS-Alt",
        27017: "MongoDB"
    }
    
    return services.get(port, "Unknown")
}

fn scan_host(host, ports) {
    println(f"\nScanning {host}...")
    let open_ports = []
    
    // Parallel port scanning
    let tasks = []
    for port in ports {
        tasks.push(async {
            if scan_port(host, port) {
                return port
            }
            return null
        })
    }
    
    let results = async::wait_all(tasks)
    
    for port in results {
        if port {
            let service = identify_service(port)
            open_ports.push({port: port, service: service})
            println(f"  ✓ Port {port:5} open - {service}")
        }
    }
    
    return open_ports
}

// Get scan parameters
let target = input("Target host (IP or domain): ")
let scan_type = input("Scan type (quick/full/custom): ")

let ports = match scan_type {
    "quick" =&gt; [21, 22, 23, 25, 80, 443, 3306, 5432, 8080]
    "full" =&gt; range(1, 65535)
    "custom" =&gt; {
        let range_str = input("Port range (e.g., 1-1000): ")
        let parts = range_str.split("-")
        range(parts[0].to_i(), parts[1].to_i())
    }
    _ =&gt; [80, 443]
}

println(f"\nScanning {ports.len()} ports on {target}...")
let start_time = current_time_ms()

let results = scan_host(target, ports)

let duration = (current_time_ms() - start_time) / 1000
println(f"\nScan complete in {duration:.1}s")
println(f"Found {results.len()} open ports")

// Generate report
if results.len() &gt; 0 {
    println("\n=== Open Services ===")
    for item in results.sort_by(|r| r.port) {
        println(f"{item.port:5} - {item.service}")
    }
}
</code></pre>
<h3 id="load-balancer"><a class="header" href="#load-balancer">Load Balancer</a></h3>
<pre><code class="language-ruchy">// File: load_balancer.ruchy
// HTTP load balancer with health checking

use std::net::http;

let backends = [
    {url: "http://server1:8080", weight: 1, healthy: true},
    {url: "http://server2:8080", weight: 2, healthy: true},
    {url: "http://server3:8080", weight: 1, healthy: true}
]

let current_backend = 0

fn select_backend() {
    // Weighted round-robin selection
    let healthy_backends = backends.filter(|b| b.healthy)
    
    if healthy_backends.is_empty() {
        throw "No healthy backends available"
    }
    
    // Simple round-robin for now
    current_backend = (current_backend + 1) % healthy_backends.len()
    return healthy_backends[current_backend]
}

fn health_check() {
    for backend in backends {
        try {
            let response = http::get(f"{backend.url}/health")
                .timeout(2000)
                .send()
            
            backend.healthy = response.status == 200
        } catch {
            backend.healthy = false
        }
        
        let status = backend.healthy ? "✓" : "✗"
        println(f"Health check {backend.url}: {status}")
    }
}

// Start health check timer
spawn {
    loop {
        health_check()
        sleep(10000)  // Check every 10 seconds
    }
}

// Create load balancer server
let balancer = http::Server::new("0.0.0.0:80")

balancer.all("*", |req, res| {
    let backend = select_backend()
    
    println(f"Routing {req.method} {req.path} -&gt; {backend.url}")
    
    // Forward request
    let backend_response = http::request(backend.url + req.path)
        .method(req.method)
        .headers(req.headers)
        .body(req.body)
        .send()
    
    // Return response
    res.status(backend_response.status)
        .headers(backend_response.headers)
        .send(backend_response.body)
})

println("🔄 Load balancer running on port 80")
println(f"Backends: {backends.len()}")
balancer.listen()
</code></pre>
<h2 id="advanced-networking"><a class="header" href="#advanced-networking">Advanced Networking</a></h2>
<h3 id="protocol-implementation"><a class="header" href="#protocol-implementation">Protocol Implementation</a></h3>
<p>Build custom network protocols:</p>
<pre><code class="language-ruchy">// Custom protocol over TCP
fn send_packet(socket, type, data) {
    let packet = {
        version: 1,
        type: type,
        timestamp: current_time_ms(),
        data: data
    }
    
    let json = to_json(packet)
    let length = json.len()
    
    // Send length-prefixed message
    socket.write_u32(length)
    socket.write(json)
}

fn receive_packet(socket) {
    let length = socket.read_u32()
    let json = socket.read(length)
    return parse_json(json)
}
</code></pre>
<h3 id="network-monitoring"><a class="header" href="#network-monitoring">Network Monitoring</a></h3>
<pre><code class="language-ruchy">// Monitor network traffic
let monitor = net::PacketCapture::new("eth0")

monitor.on_packet(|packet| {
    if packet.protocol == "TCP" {
        println(f"TCP: {packet.src}:{packet.src_port} -&gt; {packet.dst}:{packet.dst_port}")
    } else if packet.protocol == "UDP" {
        println(f"UDP: {packet.src} -&gt; {packet.dst} ({packet.size} bytes)")
    }
})

monitor.start()
</code></pre>
<h2 id="try-it-yourself-9"><a class="header" href="#try-it-yourself-9">Try It Yourself</a></h2>
<p>Time to build networked applications! Start experimenting:</p>
<pre><code class="language-bash">$ ruchy repl
&gt;&gt;&gt; # Quick HTTP server
&gt;&gt;&gt; http::serve(8080, |req, res| {
&gt;&gt;&gt;     res.text(f"Hello from {req.path}!")
&gt;&gt;&gt; })
&gt;&gt;&gt; 
&gt;&gt;&gt; # Fetch data from API
&gt;&gt;&gt; let weather = http::get("https://api.weather.com/city/london").json()
&gt;&gt;&gt; println(f"Temperature: {weather.temp}°C")
&gt;&gt;&gt; 
&gt;&gt;&gt; # Simple port check
&gt;&gt;&gt; net::is_port_open("google.com", 443)
</code></pre>
<p><strong>Your Network Programming Challenges:</strong></p>
<ol>
<li>
<p><strong>Web Applications</strong>:</p>
<ul>
<li>Personal blog engine</li>
<li>File sharing service</li>
<li>URL shortener</li>
<li>API gateway</li>
</ul>
</li>
<li>
<p><strong>Real-time Systems</strong>:</p>
<ul>
<li>Chat application</li>
<li>Collaborative editor</li>
<li>Live dashboard</li>
<li>Game server</li>
</ul>
</li>
<li>
<p><strong>Network Tools</strong>:</p>
<ul>
<li>Port scanner</li>
<li>Bandwidth monitor</li>
<li>Proxy server</li>
<li>VPN client</li>
</ul>
</li>
<li>
<p><strong>Distributed Systems</strong>:</p>
<ul>
<li>Message queue</li>
<li>Service discovery</li>
<li>Rate limiter</li>
<li>Cache server</li>
</ul>
</li>
</ol>
<h2 id="summary-9"><a class="header" href="#summary-9">Summary</a></h2>
<ul>
<li>Network programming connects your applications to the world</li>
<li>TCP provides reliable connections for most uses</li>
<li>HTTP/WebSocket handle web communication</li>
<li>Async operations prevent blocking on network I/O</li>
<li>Always handle network errors gracefully</li>
<li>Use timeouts to prevent hanging connections</li>
<li>Consider security in all network code</li>
<li>Test with real network conditions</li>
</ul>
<p>You can now build powerful networked applications! Next, let’s optimize for performance.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance--optimization"><a class="header" href="#performance--optimization">Performance &amp; Optimization</a></h1>
<p><em>“I once optimized a data processing pipeline from 6 hours to 3 minutes. The secret wasn’t clever tricks - it was understanding where time was actually spent. Performance isn’t about premature optimization; it’s about measuring, understanding, and then improving. Profile first, optimize second, celebrate third.”</em> - Noah Gift</p>
<h2 id="the-problem-11"><a class="header" href="#the-problem-11">The Problem</a></h2>
<p>You’ve built working applications, but are they fast? How do you find bottlenecks, optimize algorithms, parallelize work, and make your programs fly? How do you know what to optimize and when to stop?</p>
<p>Most developers guess at performance problems or optimize the wrong things. In Ruchy, performance should be measurable, improvements should be provable, and optimization should be systematic.</p>
<h2 id="quick-example-10"><a class="header" href="#quick-example-10">Quick Example</a></h2>
<p>Here’s performance optimization in action:</p>
<pre><code class="language-ruchy">// File: optimize_data_processing.ruchy
// Before and after optimization

use std::perf;
use std::parallel;

// Naive version - slow
fn process_data_naive(data) {
    let results = []
    for item in data {
        // Expensive computation
        let processed = expensive_transform(item)
        for existing in results {
            if similar(processed, existing) {
                processed.merge(existing)
            }
        }
        results.push(processed)
    }
    return results
}

// Optimized version - fast
fn process_data_optimized(data) {
    // 1. Parallel processing
    let results = parallel::map(data, |item| {
        expensive_transform(item)
    })
    
    // 2. Use hash map for lookups
    let lookup = {}
    for item in results {
        let key = item.hash_key()
        if lookup.has_key(key) {
            lookup[key].merge(item)
        } else {
            lookup[key] = item
        }
    }
    
    return lookup.values()
}

// Benchmark both versions
let data = generate_test_data(10000)

let naive_time = perf::measure {
    process_data_naive(data)
}

let optimized_time = perf::measure {
    process_data_optimized(data)
}

println(f"Naive: {naive_time}ms")
println(f"Optimized: {optimized_time}ms")
println(f"Speedup: {naive_time / optimized_time:.1}x")
// Output: Speedup: 42.3x
</code></pre>
<p>That’s the power of systematic optimization!</p>
<h2 id="core-concepts-9"><a class="header" href="#core-concepts-9">Core Concepts</a></h2>
<h3 id="profiling"><a class="header" href="#profiling">Profiling</a></h3>
<p>Measure before optimizing:</p>
<pre><code class="language-ruchy">// CPU profiling
let profiler = perf::CpuProfiler::new()
profiler.start()

// Your code here
complex_operation()

profiler.stop()
let report = profiler.report()

println("=== CPU Profile ===")
for func in report.top_functions(10) {
    println(f"{func.name}: {func.self_time}ms ({func.percent}%)")
}

// Memory profiling
let mem_profiler = perf::MemoryProfiler::new()
mem_profiler.start()

// Your code here
memory_intensive_operation()

mem_profiler.stop()
let mem_report = mem_profiler.report()

println("\n=== Memory Profile ===")
println(f"Peak memory: {format_size(mem_report.peak_usage)}")
println(f"Allocations: {mem_report.allocation_count}")
println(f"Largest allocation: {format_size(mem_report.largest_allocation)}")

// Flame graph generation
profiler.generate_flamegraph("profile.svg")
println("Flame graph saved to profile.svg")
</code></pre>
<h3 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h3>
<p>Compare performance systematically:</p>
<pre><code class="language-ruchy">// Micro-benchmarks
use std::bench;

bench::suite("String Operations", {
    "concatenation" =&gt; || {
        let s = ""
        for i in range(1000) {
            s += i.to_s()
        }
    },
    
    "string builder" =&gt; || {
        let builder = StringBuilder::new()
        for i in range(1000) {
            builder.append(i.to_s())
        }
        builder.to_string()
    },
    
    "join" =&gt; || {
        range(1000).map(|i| i.to_s()).join("")
    }
})

// Results:
// String Operations
//   concatenation:  2.3ms ± 0.1ms
//   string builder: 0.4ms ± 0.02ms  [FASTEST]
//   join:          0.6ms ± 0.03ms

// Custom benchmarks
fn benchmark_algorithm(name, func, data) {
    let times = []
    
    // Warmup
    for i in range(5) {
        func(data)
    }
    
    // Measure
    for i in range(100) {
        let time = perf::measure {
            func(data)
        }
        times.push(time)
    }
    
    let avg = times.mean()
    let std = times.std_dev()
    println(f"{name}: {avg:.2}ms ± {std:.2}ms")
}
</code></pre>
<h3 id="parallel-processing"><a class="header" href="#parallel-processing">Parallel Processing</a></h3>
<p>Use multiple cores effectively:</p>
<pre><code class="language-ruchy">// Parallel map
let data = range(1, 1000000)
let results = parallel::map(data, |n| {
    expensive_computation(n)
})

// Parallel reduce
let sum = parallel::reduce(data, 0, |acc, n| {
    acc + n
})

// Thread pool
let pool = parallel::ThreadPool::new(num_cpus())

for task in tasks {
    pool.execute(|| {
        process_task(task)
    })
}

pool.wait()

// Parallel pipeline
parallel::pipeline()
    .stage(|item| fetch_data(item))      // I/O bound
    .stage(|data| parse_data(data))      // CPU bound
    .stage(|parsed| transform(parsed))   // CPU bound
    .stage(|result| save_result(result)) // I/O bound
    .process(items)

// Async concurrency
let futures = []
for url in urls {
    futures.push(async {
        http::get(url).await()
    })
}

let responses = async::wait_all(futures)
</code></pre>
<h2 id="optimization-techniques"><a class="header" href="#optimization-techniques">Optimization Techniques</a></h2>
<h3 id="algorithm-optimization"><a class="header" href="#algorithm-optimization">Algorithm Optimization</a></h3>
<pre><code class="language-ruchy">// File: algorithm_optimization.ruchy
// Common optimization patterns

// 1. Cache computed values
let fibonacci_cache = {}
fn fibonacci_memo(n) {
    if fibonacci_cache.has_key(n) {
        return fibonacci_cache[n]
    }
    
    let result = if n &lt;= 1 {
        n
    } else {
        fibonacci_memo(n - 1) + fibonacci_memo(n - 2)
    }
    
    fibonacci_cache[n] = result
    return result
}

// 2. Use better data structures
fn find_duplicates_naive(items) {
    let duplicates = []
    for i in range(items.len()) {
        for j in range(i + 1, items.len()) {
            if items[i] == items[j] {
                duplicates.push(items[i])
            }
        }
    }
    return duplicates  // O(n²)
}

fn find_duplicates_optimized(items) {
    let seen = Set::new()
    let duplicates = Set::new()
    
    for item in items {
        if seen.contains(item) {
            duplicates.add(item)
        }
        seen.add(item)
    }
    return duplicates.to_array()  // O(n)
}

// 3. Batch operations
fn save_records_naive(records) {
    for record in records {
        database.insert(record)  // N database calls
    }
}

fn save_records_optimized(records) {
    database.insert_batch(records)  // 1 database call
}

// 4. Early termination
fn find_first_match(items, predicate) {
    for item in items {
        if predicate(item) {
            return item  // Stop as soon as found
        }
    }
    return null
}
</code></pre>
<h3 id="memory-optimization"><a class="header" href="#memory-optimization">Memory Optimization</a></h3>
<pre><code class="language-ruchy">// File: memory_optimization.ruchy
// Reduce memory usage

// 1. Use generators for large datasets
fn read_large_file_naive(path) {
    return read_file(path).lines()  // Loads entire file
}

fn read_large_file_optimized(path) {
    // Generator - yields lines one at a time
    return generate {
        let file = open(path)
        while !file.eof() {
            yield file.read_line()
        }
        file.close()
    }
}

// 2. Object pooling
let connection_pool = Pool::new(
    create: || Database::connect(),
    reset: |conn| conn.clear()
)

fn handle_request(request) {
    let conn = connection_pool.acquire()
    let result = conn.query(request.sql)
    connection_pool.release(conn)
    return result
}

// 3. Weak references for caches
let cache = WeakMap::new()

fn get_cached_data(key) {
    if cache.has(key) {
        return cache.get(key)
    }
    
    let data = expensive_load(key)
    cache.set(key, data)
    return data
}

// 4. Compact data structures
struct CompactUser {
    id: u32,        // 4 bytes instead of 8
    flags: u8,      // Bit flags instead of booleans
    name: String    // Single allocation
}
</code></pre>
<h3 id="io-optimization"><a class="header" href="#io-optimization">I/O Optimization</a></h3>
<pre><code class="language-ruchy">// File: io_optimization.ruchy
// Speed up I/O operations

// 1. Buffered I/O
fn process_file_naive(path) {
    let file = open(path)
    while !file.eof() {
        let byte = file.read_byte()  // Syscall for each byte
        process(byte)
    }
}

fn process_file_optimized(path) {
    let file = BufferedReader::new(open(path), 8192)
    while !file.eof() {
        let byte = file.read_byte()  // Reads from buffer
        process(byte)
    }
}

// 2. Async I/O
async fn fetch_all_naive(urls) {
    let results = []
    for url in urls {
        let data = http::get(url).await()  // Sequential
        results.push(data)
    }
    return results
}

async fn fetch_all_optimized(urls) {
    let futures = urls.map(|url| {
        http::get(url)  // Concurrent
    })
    return async::wait_all(futures)
}

// 3. Memory-mapped files
fn process_huge_file(path) {
    let mmap = MemoryMap::open(path)
    
    // Process in parallel chunks
    parallel::for_chunks(mmap, 1_000_000, |chunk| {
        process_chunk(chunk)
    })
}
</code></pre>
<h2 id="real-world-optimization"><a class="header" href="#real-world-optimization">Real-World Optimization</a></h2>
<h3 id="database-query-optimizer"><a class="header" href="#database-query-optimizer">Database Query Optimizer</a></h3>
<pre><code class="language-ruchy">// File: query_optimizer.ruchy
// Optimize database queries

use std::db;
use std::perf;

let database = db::connect("postgres://localhost/myapp")

// Enable query logging
database.log_queries(true)

// Analyze slow queries
fn analyze_query(sql) {
    let plan = database.explain(sql)
    println(f"Query: {sql}")
    println(f"Execution plan: {plan}")
    
    // Find missing indexes
    if plan.contains("Seq Scan") {
        println("⚠️  Sequential scan detected - consider adding index")
        
        // Suggest index
        let table = extract_table(sql)
        let where_clause = extract_where(sql)
        println(f"Suggested: CREATE INDEX ON {table} ({where_clause.column})")
    }
    
    // Check for N+1 queries
    let query_log = database.get_recent_queries(100)
    let patterns = find_patterns(query_log)
    
    for pattern in patterns {
        if pattern.count &gt; 10 &amp;&amp; pattern.similar {
            println(f"⚠️  N+1 query pattern detected: {pattern.example}")
            println("Consider using JOIN or batch loading")
        }
    }
}

// Optimize ORM queries
fn get_users_with_posts_naive() {
    let users = database.query("SELECT * FROM users")
    for user in users {
        user.posts = database.query(
            "SELECT * FROM posts WHERE user_id = ?", 
            [user.id]
        )  // N+1 problem
    }
    return users
}

fn get_users_with_posts_optimized() {
    // Single query with JOIN
    return database.query("
        SELECT u.*, p.*
        FROM users u
        LEFT JOIN posts p ON p.user_id = u.id
        ORDER BY u.id, p.created_at
    ").group_by(|row| row.user_id)
}

// Benchmark improvements
let naive_time = perf::measure {
    get_users_with_posts_naive()
}

let optimized_time = perf::measure {
    get_users_with_posts_optimized()
}

println(f"Improvement: {naive_time / optimized_time:.1}x faster")
</code></pre>
<h3 id="web-server-optimization"><a class="header" href="#web-server-optimization">Web Server Optimization</a></h3>
<pre><code class="language-ruchy">// File: web_server_optimization.ruchy
// High-performance web server

use std::net::http;
use std::cache;

let app = http::Server::new("0.0.0.0:8080")

// Response caching
let response_cache = cache::LRU::new(1000)

app.use(|req, res, next| {
    let cache_key = f"{req.method}:{req.path}:{req.query_string}"
    
    if req.method == "GET" &amp;&amp; response_cache.has(cache_key) {
        let cached = response_cache.get(cache_key)
        return res
            .status(200)
            .header("X-Cache", "HIT")
            .send(cached)
    }
    
    // Capture response for caching
    let original_send = res.send
    res.send = |body| {
        if req.method == "GET" &amp;&amp; res.status == 200 {
            response_cache.set(cache_key, body, ttl: 60)
        }
        original_send(body)
    }
    
    next()
})

// Static file serving with ETags
app.static("/static", "./public", {
    maxAge: 86400,  // 1 day
    etag: true,
    gzip: true
})

// Database connection pooling
let db_pool = ConnectionPool::new(
    url: "postgres://localhost/myapp",
    min: 5,
    max: 20
)

// Async request handling
app.get("/api/data", async |req, res| {
    let conn = db_pool.acquire().await()
    let data = conn.query("SELECT * FROM data").await()
    db_pool.release(conn)
    
    res.json(data)
})

// Enable HTTP/2
app.enable_http2()

// Compression middleware
app.use(compression({
    level: 6,
    threshold: 1024,  // Only compress &gt; 1KB
    types: ["text/*", "application/json", "application/javascript"]
}))

println("🚀 Optimized server running with:")
println("  • Response caching")
println("  • Connection pooling")  
println("  • HTTP/2 support")
println("  • Gzip compression")

app.listen()
</code></pre>
<h3 id="data-processing-pipeline"><a class="header" href="#data-processing-pipeline">Data Processing Pipeline</a></h3>
<pre><code class="language-ruchy">// File: data_pipeline_optimization.ruchy
// Optimize large-scale data processing

use std::parallel;
use std::stream;

fn process_dataset(input_file, output_file) {
    let start = perf::Timer::start()
    
    // Stream processing to avoid loading all data
    let input = stream::FileStream::new(input_file)
    let output = stream::FileWriter::new(output_file)
    
    input
        // Parse in parallel
        .parallel_map(|line| {
            parse_record(line)
        }, workers: num_cpus())
        
        // Filter early to reduce data
        .filter(|record| {
            record.is_valid() &amp;&amp; record.value &gt; threshold
        })
        
        // Batch for efficient processing
        .batch(1000)
        
        // Process batches in parallel
        .parallel_map(|batch| {
            let enriched = enrich_batch(batch)
            let transformed = transform_batch(enriched)
            return transformed
        })
        
        // Flatten batches
        .flatten()
        
        // Write with buffering
        .for_each(|record| {
            output.write_line(to_json(record))
        })
    
    let duration = start.elapsed()
    let records = input.count()
    let throughput = records / duration.seconds()
    
    println(f"Processed {records} records in {duration}")
    println(f"Throughput: {throughput:.0} records/second")
}

// Monitor performance
let monitor = perf::Monitor::new()

monitor.track("cpu_usage", || system::cpu_usage())
monitor.track("memory_usage", || system::memory_usage())
monitor.track("disk_io", || system::disk_io_rate())

process_dataset("input.jsonl", "output.jsonl")

monitor.report()
</code></pre>
<h2 id="performance-tips"><a class="header" href="#performance-tips">Performance Tips</a></h2>
<h3 id="golden-rules"><a class="header" href="#golden-rules">Golden Rules</a></h3>
<pre><code class="language-ruchy">// 1. Measure first
perf::profile {
    suspicious_function()
}

// 2. Optimize the right thing
// Focus on the bottleneck, not random code

// 3. Use the right algorithm
// O(n) beats O(n²) even with overhead

// 4. Batch operations
// 1 operation on 1000 items &gt; 1000 operations on 1 item

// 5. Cache expensive computations
let cache = memoize(expensive_function)

// 6. Parallelize independent work
parallel::map(items, process)

// 7. Use async for I/O
async::wait_all(io_operations)

// 8. Profile in production
// Dev performance ≠ Production performance
</code></pre>
<h2 id="try-it-yourself-10"><a class="header" href="#try-it-yourself-10">Try It Yourself</a></h2>
<p>Time to optimize! Start measuring and improving:</p>
<pre><code class="language-bash">$ ruchy repl
&gt;&gt;&gt; # Profile your code
&gt;&gt;&gt; perf::measure {
&gt;&gt;&gt;     your_function()
&gt;&gt;&gt; }
&gt;&gt;&gt; 
&gt;&gt;&gt; # Compare implementations
&gt;&gt;&gt; bench::compare({
&gt;&gt;&gt;     "version1" =&gt; || method1(),
&gt;&gt;&gt;     "version2" =&gt; || method2()
&gt;&gt;&gt; })
&gt;&gt;&gt; 
&gt;&gt;&gt; # Parallel processing
&gt;&gt;&gt; let results = parallel::map(range(1000000), |n| n * n)
</code></pre>
<p><strong>Your Performance Challenges:</strong></p>
<ol>
<li>
<p><strong>Algorithm Optimization</strong>:</p>
<ul>
<li>Sort algorithm comparison</li>
<li>Search optimization</li>
<li>Graph algorithm speedup</li>
<li>Dynamic programming</li>
</ul>
</li>
<li>
<p><strong>System Optimization</strong>:</p>
<ul>
<li>File processing pipeline</li>
<li>Database query optimizer</li>
<li>Cache implementation</li>
<li>Memory pool</li>
</ul>
</li>
<li>
<p><strong>Parallel Computing</strong>:</p>
<ul>
<li>Image processor</li>
<li>Data aggregator</li>
<li>Web crawler</li>
<li>Batch processor</li>
</ul>
</li>
<li>
<p><strong>Real-time Performance</strong>:</p>
<ul>
<li>Game engine</li>
<li>Video processor</li>
<li>Audio streamer</li>
<li>Trading system</li>
</ul>
</li>
</ol>
<h2 id="summary-10"><a class="header" href="#summary-10">Summary</a></h2>
<ul>
<li>Always measure before optimizing</li>
<li>Profile to find actual bottlenecks</li>
<li>Choose the right algorithm and data structure</li>
<li>Parallelize independent computations</li>
<li>Cache expensive calculations</li>
<li>Batch operations when possible</li>
<li>Use async for I/O-bound tasks</li>
<li>Monitor production performance</li>
</ul>
<p>You now have the tools to make your programs fly! Next, let’s explore advanced patterns.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-patterns"><a class="header" href="#advanced-patterns">Advanced Patterns</a></h1>
<p><em>“After 20 years of programming, I’ve learned that patterns aren’t rules to follow blindly - they’re tools in your toolbox. The art is knowing which tool to use when. Master the patterns, understand their trade-offs, then break them when it makes sense. That’s when programming becomes poetry.”</em> - Noah Gift</p>
<h2 id="the-problem-12"><a class="header" href="#the-problem-12">The Problem</a></h2>
<p>You’ve learned the basics and built applications, but how do you write code that scales? How do you design systems that are maintainable, testable, and elegant? How do you solve complex problems with simple, reusable patterns?</p>
<p>Most developers either ignore patterns (creating chaos) or over-engineer (creating complexity). In Ruchy, patterns should emerge naturally from solving real problems, not from dogma.</p>
<h2 id="quick-example-11"><a class="header" href="#quick-example-11">Quick Example</a></h2>
<p>Here’s elegant pattern usage in Ruchy:</p>
<pre><code class="language-ruchy">// File: event_system.ruchy
// Event-driven architecture with multiple patterns

use std::patterns;

// Observer pattern for events
class EventBus {
    let subscribers = {}
    
    fn on(event, handler) {
        if !subscribers.has_key(event) {
            subscribers[event] = []
        }
        subscribers[event].push(handler)
        
        // Return unsubscribe function (closure pattern)
        return || {
            subscribers[event] = subscribers[event].filter(|h| h != handler)
        }
    }
    
    fn emit(event, data) {
        if subscribers.has_key(event) {
            for handler in subscribers[event] {
                spawn { handler(data) }  // Async pattern
            }
        }
    }
}

// Singleton pattern for global event bus
let events = EventBus::singleton()

// Decorator pattern for logging
fn with_logging(handler) {
    return |data| {
        println(f"[{current_datetime()}] Event triggered: {data}")
        let result = handler(data)
        println(f"[{current_datetime()}] Event completed")
        return result
    }
}

// Usage combining patterns
let unsubscribe = events.on("user.login", with_logging(|user| {
    println(f"User {user.name} logged in")
    update_last_login(user)
}))

events.emit("user.login", {name: "Alice", id: 123})
</code></pre>
<p>That’s patterns working together harmoniously!</p>
<h2 id="core-patterns"><a class="header" href="#core-patterns">Core Patterns</a></h2>
<h3 id="builder-pattern"><a class="header" href="#builder-pattern">Builder Pattern</a></h3>
<p>Construct complex objects step by step:</p>
<pre><code class="language-ruchy">// Fluent interface for configuration
class ServerBuilder {
    let config = {
        port: 8080,
        host: "localhost",
        threads: 4,
        timeout: 30000,
        middleware: [],
        routes: {}
    }
    
    fn port(p) {
        config.port = p
        return self  // Enable chaining
    }
    
    fn host(h) {
        config.host = h
        return self
    }
    
    fn threads(t) {
        config.threads = t
        return self
    }
    
    fn use(middleware) {
        config.middleware.push(middleware)
        return self
    }
    
    fn route(path, handler) {
        config.routes[path] = handler
        return self
    }
    
    fn build() {
        validate_config()
        return Server::new(config)
    }
}

// Clean, readable configuration
let server = ServerBuilder::new()
    .port(3000)
    .host("0.0.0.0")
    .threads(8)
    .use(cors())
    .use(auth())
    .use(logging())
    .route("/", home_handler)
    .route("/api", api_handler)
    .build()
</code></pre>
<h3 id="strategy-pattern"><a class="header" href="#strategy-pattern">Strategy Pattern</a></h3>
<p>Swap algorithms at runtime:</p>
<pre><code class="language-ruchy">// Different compression strategies
class CompressionContext {
    let strategy
    
    fn set_strategy(s) {
        strategy = s
    }
    
    fn compress(data) {
        return strategy.compress(data)
    }
}

class GzipStrategy {
    fn compress(data) {
        return gzip::compress(data, level: 6)
    }
}

class BrotliStrategy {
    fn compress(data) {
        return brotli::compress(data, quality: 4)
    }
}

class NoCompressionStrategy {
    fn compress(data) {
        return data
    }
}

// Choose strategy based on context
let compressor = CompressionContext::new()

if file_size &gt; mb(10) {
    compressor.set_strategy(BrotliStrategy::new())  // Better for large files
} else if client_supports_gzip {
    compressor.set_strategy(GzipStrategy::new())
} else {
    compressor.set_strategy(NoCompressionStrategy::new())
}

let compressed = compressor.compress(file_data)
</code></pre>
<h3 id="chain-of-responsibility"><a class="header" href="#chain-of-responsibility">Chain of Responsibility</a></h3>
<p>Process requests through a chain of handlers:</p>
<pre><code class="language-ruchy">// Middleware chain for request processing
class MiddlewareChain {
    let middlewares = []
    
    fn use(middleware) {
        middlewares.push(middleware)
    }
    
    fn execute(request, response) {
        let index = 0
        
        fn next() {
            if index &lt; middlewares.len() {
                let middleware = middlewares[index]
                index += 1
                middleware(request, response, next)
            }
        }
        
        next()
    }
}

// Define middleware
fn auth_middleware(req, res, next) {
    let token = req.header("Authorization")
    if !token {
        return res.status(401).json({error: "Unauthorized"})
    }
    
    req.user = validate_token(token)
    next()
}

fn rate_limit_middleware(req, res, next) {
    let key = req.ip
    if rate_limiter.exceeded(key) {
        return res.status(429).json({error: "Too many requests"})
    }
    
    rate_limiter.increment(key)
    next()
}

fn cache_middleware(req, res, next) {
    let cache_key = req.url
    if cache.has(cache_key) {
        return res.send(cache.get(cache_key))
    }
    
    // Intercept response to cache it
    let original_send = res.send
    res.send = |data| {
        cache.set(cache_key, data)
        original_send(data)
    }
    
    next()
}

// Build the chain
let chain = MiddlewareChain::new()
chain.use(rate_limit_middleware)
chain.use(auth_middleware)
chain.use(cache_middleware)
chain.use(route_handler)

chain.execute(request, response)
</code></pre>
<h2 id="functional-patterns"><a class="header" href="#functional-patterns">Functional Patterns</a></h2>
<h3 id="composition"><a class="header" href="#composition">Composition</a></h3>
<p>Build complex behavior from simple functions:</p>
<pre><code class="language-ruchy">// Function composition
fn compose(...functions) {
    return |x| {
        let result = x
        for f in functions.reverse() {
            result = f(result)
        }
        return result
    }
}

// Pipeline operator
fn pipeline(value, ...functions) {
    let result = value
    for f in functions {
        result = f(result)
    }
    return result
}

// Example: Data transformation pipeline
let process_data = compose(
    validate,
    normalize,
    enrich,
    transform,
    format
)

let result = process_data(raw_data)

// Or using pipeline
let result = pipeline(
    raw_data,
    validate,
    normalize,
    enrich,
    transform,
    format
)
</code></pre>
<h3 id="monadic-patterns"><a class="header" href="#monadic-patterns">Monadic Patterns</a></h3>
<p>Handle errors and async elegantly:</p>
<pre><code class="language-ruchy">// Result monad for error handling
class Result {
    let value
    let error
    
    static fn ok(val) {
        return Result{value: val, error: null}
    }
    
    static fn err(e) {
        return Result{value: null, error: e}
    }
    
    fn is_ok() {
        return error == null
    }
    
    fn map(f) {
        if is_ok() {
            return Result::ok(f(value))
        }
        return self
    }
    
    fn flat_map(f) {
        if is_ok() {
            return f(value)
        }
        return self
    }
    
    fn unwrap_or(default) {
        if is_ok() {
            return value
        }
        return default
    }
}

// Chain operations safely
fn process_user(id) {
    return fetch_user(id)
        .map(|user| validate_user(user))
        .flat_map(|user| enrich_user_data(user))
        .map(|user| format_user(user))
        .unwrap_or({error: "Processing failed"})
}
</code></pre>
<h3 id="lazy-evaluation"><a class="header" href="#lazy-evaluation">Lazy Evaluation</a></h3>
<p>Defer computation until needed:</p>
<pre><code class="language-ruchy">// Lazy sequences
class LazySeq {
    let generator
    let cache = []
    let index = 0
    
    fn next() {
        if index &gt;= cache.len() {
            let value = generator()
            if value != null {
                cache.push(value)
            }
        }
        
        if index &lt; cache.len() {
            let value = cache[index]
            index += 1
            return value
        }
        
        return null
    }
    
    fn take(n) {
        let result = []
        for i in range(n) {
            let value = next()
            if value == null {
                break
            }
            result.push(value)
        }
        return result
    }
    
    fn map(f) {
        return LazySeq::new(|| {
            let value = next()
            if value != null {
                return f(value)
            }
            return null
        })
    }
    
    fn filter(predicate) {
        return LazySeq::new(|| {
            loop {
                let value = next()
                if value == null {
                    return null
                }
                if predicate(value) {
                    return value
                }
            }
        })
    }
}

// Infinite sequence
let fibonacci = LazySeq::new(|| {
    static let a = 0
    static let b = 1
    let next = a
    a = b
    b = next + b
    return next
})

// Only computes what's needed
let first_10_even = fibonacci
    .filter(|n| n % 2 == 0)
    .take(10)
</code></pre>
<h2 id="architectural-patterns"><a class="header" href="#architectural-patterns">Architectural Patterns</a></h2>
<h3 id="repository-pattern"><a class="header" href="#repository-pattern">Repository Pattern</a></h3>
<p>Abstract data access:</p>
<pre><code class="language-ruchy">// Generic repository interface
class Repository {
    fn find(id)
    fn find_all()
    fn find_where(conditions)
    fn save(entity)
    fn delete(id)
}

// Concrete implementation
class UserRepository &lt; Repository {
    let db
    
    fn find(id) {
        let row = db.query_one("SELECT * FROM users WHERE id = ?", [id])
        return row ? User::from_row(row) : null
    }
    
    fn find_where(conditions) {
        let query = QueryBuilder::new("users")
            .where(conditions)
            .build()
        
        return db.query(query).map(|row| User::from_row(row))
    }
    
    fn save(user) {
        if user.id {
            db.execute("UPDATE users SET ... WHERE id = ?", user.to_row())
        } else {
            user.id = db.execute("INSERT INTO users ... VALUES ...", user.to_row())
        }
        return user
    }
}

// Use repository in service layer
class UserService {
    let repository
    
    fn get_active_users() {
        return repository.find_where({active: true})
    }
    
    fn create_user(data) {
        let user = User::new(data)
        user.validate()
        return repository.save(user)
    }
}
</code></pre>
<h3 id="event-sourcing"><a class="header" href="#event-sourcing">Event Sourcing</a></h3>
<p>Store events, not state:</p>
<pre><code class="language-ruchy">// Event sourcing system
class EventStore {
    let events = []
    let snapshots = {}
    let projections = {}
    
    fn append(event) {
        event.id = generate_id()
        event.timestamp = current_time()
        event.version = events.len() + 1
        
        events.push(event)
        update_projections(event)
        
        // Create snapshot every 100 events
        if events.len() % 100 == 0 {
            create_snapshot()
        }
    }
    
    fn replay(from_version = 0) {
        let state = snapshots.get_latest_before(from_version) || {}
        
        for event in events.filter(|e| e.version &gt; from_version) {
            state = apply_event(state, event)
        }
        
        return state
    }
    
    fn get_projection(name) {
        return projections[name]
    }
}

// Domain events
class OrderPlaced {
    let order_id
    let customer_id
    let items
    let total
}

class PaymentReceived {
    let order_id
    let amount
    let method
}

// Event handlers update projections
fn handle_order_placed(event) {
    projections.orders[event.order_id] = {
        status: "pending",
        customer: event.customer_id,
        total: event.total
    }
    
    projections.customer_orders[event.customer_id].push(event.order_id)
}

// Rebuild state from events
let current_state = event_store.replay()
</code></pre>
<h3 id="cqrs-command-query-responsibility-segregation"><a class="header" href="#cqrs-command-query-responsibility-segregation">CQRS (Command Query Responsibility Segregation)</a></h3>
<p>Separate reads from writes:</p>
<pre><code class="language-ruchy">// Command side - writes
class CommandBus {
    let handlers = {}
    
    fn register(command_type, handler) {
        handlers[command_type] = handler
    }
    
    fn dispatch(command) {
        let handler = handlers[command.type]
        if !handler {
            throw f"No handler for command: {command.type}"
        }
        
        return handler(command)
    }
}

// Query side - reads
class QueryBus {
    let handlers = {}
    
    fn register(query_type, handler) {
        handlers[query_type] = handler
    }
    
    fn query(query) {
        let handler = handlers[query.type]
        if !handler {
            throw f"No handler for query: {query.type}"
        }
        
        return handler(query)
    }
}

// Commands modify state
command_bus.register("CreateOrder", |cmd| {
    let order = Order::new(cmd.data)
    order.validate()
    event_store.append(OrderPlaced::new(order))
    return order.id
})

// Queries read projections
query_bus.register("GetOrdersByCustomer", |query| {
    return read_model.get_customer_orders(query.customer_id)
})

// Usage
let order_id = command_bus.dispatch({
    type: "CreateOrder",
    data: {customer: 123, items: [...]}
})

let orders = query_bus.query({
    type: "GetOrdersByCustomer",
    customer_id: 123
})
</code></pre>
<h2 id="concurrent-patterns"><a class="header" href="#concurrent-patterns">Concurrent Patterns</a></h2>
<h3 id="actor-model"><a class="header" href="#actor-model">Actor Model</a></h3>
<p>Isolated units of computation:</p>
<pre><code class="language-ruchy">// Actor system
class Actor {
    let mailbox = Queue::new()
    let running = true
    
    fn receive(message) {
        mailbox.push(message)
    }
    
    fn start() {
        spawn {
            while running {
                let message = mailbox.pop()
                if message {
                    handle_message(message)
                }
                sleep(1)
            }
        }
    }
    
    fn handle_message(message) {
        // Override in subclass
    }
}

// Concrete actor
class WorkerActor &lt; Actor {
    let state = {}
    
    fn handle_message(message) {
        match message.type {
            "process" =&gt; {
                let result = process_work(message.data)
                message.reply_to.receive({
                    type: "result",
                    data: result
                })
            }
            "get_state" =&gt; {
                message.reply_to.receive({
                    type: "state",
                    data: state
                })
            }
            "shutdown" =&gt; {
                running = false
            }
        }
    }
}

// Actor system
let system = ActorSystem::new()
let worker = system.spawn(WorkerActor)

worker.send({
    type: "process",
    data: work_item,
    reply_to: self
})
</code></pre>
<h3 id="circuit-breaker"><a class="header" href="#circuit-breaker">Circuit Breaker</a></h3>
<p>Prevent cascading failures:</p>
<pre><code class="language-ruchy">class CircuitBreaker {
    let failure_threshold = 5
    let timeout = 30000
    let failure_count = 0
    let last_failure_time = 0
    let state = "closed"  // closed, open, half_open
    
    fn call(operation) {
        if state == "open" {
            if current_time() - last_failure_time &gt; timeout {
                state = "half_open"
            } else {
                throw "Circuit breaker is open"
            }
        }
        
        try {
            let result = operation()
            
            if state == "half_open" {
                state = "closed"
                failure_count = 0
            }
            
            return result
        } catch error {
            failure_count += 1
            last_failure_time = current_time()
            
            if failure_count &gt;= failure_threshold {
                state = "open"
                println(f"Circuit breaker opened after {failure_count} failures")
            }
            
            throw error
        }
    }
}

// Use circuit breaker for external service
let api_breaker = CircuitBreaker::new()

fn call_external_api(data) {
    return api_breaker.call(|| {
        http::post("https://api.external.com/endpoint")
            .json(data)
            .timeout(5000)
            .send()
    })
}
</code></pre>
<h2 id="try-it-yourself-11"><a class="header" href="#try-it-yourself-11">Try It Yourself</a></h2>
<p>Time to apply advanced patterns! Start experimenting:</p>
<pre><code class="language-bash">$ ruchy repl
&gt;&gt;&gt; # Create a simple event system
&gt;&gt;&gt; let events = EventBus::new()
&gt;&gt;&gt; events.on("test", |data| println(f"Got: {data}"))
&gt;&gt;&gt; events.emit("test", "Hello patterns!")
&gt;&gt;&gt; 
&gt;&gt;&gt; # Try functional composition
&gt;&gt;&gt; let process = compose(
&gt;&gt;&gt;     |x| x * 2,
&gt;&gt;&gt;     |x| x + 10,
&gt;&gt;&gt;     |x| x.to_s()
&gt;&gt;&gt; )
&gt;&gt;&gt; process(5)  // "20"
</code></pre>
<p><strong>Your Pattern Challenges:</strong></p>
<ol>
<li>
<p><strong>Design Patterns</strong>:</p>
<ul>
<li>Plugin system (Strategy)</li>
<li>Undo/redo system (Command)</li>
<li>Game state machine (State)</li>
<li>Data transformer (Visitor)</li>
</ul>
</li>
<li>
<p><strong>Architectural Patterns</strong>:</p>
<ul>
<li>Microservice framework</li>
<li>Event-driven system</li>
<li>Message queue</li>
<li>Workflow engine</li>
</ul>
</li>
<li>
<p><strong>Concurrent Patterns</strong>:</p>
<ul>
<li>Thread pool</li>
<li>Producer-consumer</li>
<li>Read-write lock</li>
<li>Parallel pipeline</li>
</ul>
</li>
<li>
<p><strong>Functional Patterns</strong>:</p>
<ul>
<li>Parser combinator</li>
<li>Validation chain</li>
<li>Async coordinator</li>
<li>Reactive streams</li>
</ul>
</li>
</ol>
<h2 id="summary-11"><a class="header" href="#summary-11">Summary</a></h2>
<ul>
<li>Patterns are tools, not rules</li>
<li>Choose patterns that solve your actual problem</li>
<li>Combine patterns for powerful solutions</li>
<li>Keep it simple - don’t over-engineer</li>
<li>Functional patterns reduce complexity</li>
<li>Concurrent patterns enable scalability</li>
<li>Test patterns with real use cases</li>
<li>Refactor to patterns, don’t start with them</li>
</ul>
<p>You now have mastery of advanced patterns! You’re ready to build sophisticated, scalable systems.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p><em>“You’ve come far. From ‘Hello World’ to advanced patterns, from simple scripts to sophisticated systems. But remember - the best code is the code that ships and helps people. Keep learning, keep building, keep shipping. The world needs what you’re going to create.”</em> - Noah Gift</p>
<p>Welcome to the community of Ruchy developers. Your journey continues from here!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="mode-rust.js"></script>
        <script src="editor.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
