// State machine DSL
macro! state_machine {
    (
        states: [$($state:ident),*]
        transitions: [
            $($from:ident -> $to:ident on $event:ident),*
        ]
        initial: $initial:ident
    ) => {
        enum State {
            $($state),*
        }
        
        enum Event {
            $($event),*
        }
        
        struct StateMachine {
            state: State
        }
        
        impl StateMachine {
            fn new() -> Self {
                Self { state: State::$initial }
            }
            
            fn transition(&mut self, event: Event) {
                self.state = match (&self.state, event) {
                    $(
                        (State::$from, Event::$event) => State::$to,
                    )*
                    _ => panic("Invalid transition")
                }
            }
        }
    }
}

state_machine! {
    states: [Idle, Running, Paused, Stopped]
    transitions: [
        Idle -> Running on Start,
        Running -> Paused on Pause,
        Paused -> Running on Resume,
        Running -> Stopped on Stop,
        Paused -> Stopped on Stop
    ]
    initial: Idle
}

// Configuration DSL
macro! config {
    {
        $($section:ident {
            $($key:ident : $value:expr),*
        })*
    } => {
        {
            let mut config = Config::new()
            $(
                let mut section = ConfigSection::new(stringify!($section))
                $(
                    section.set(stringify!($key), $value)
                )*
                config.add_section(section)
            )*
            config
        }
    }
}

let config = config! {
    server {
        host: "localhost",
        port: 8080,
        workers: 4
    }
    database {
        url: "postgres://localhost/myapp",
        pool_size: 20
    }
}