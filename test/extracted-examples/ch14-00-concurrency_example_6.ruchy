struct ThreadPool {
    workers: Vec<Worker>
    sender: Sender<Job>
}

impl ThreadPool {
    fn new(size: usize) -> ThreadPool {
        let (sender, receiver) = channel()
        let receiver = Arc::new(Mutex::new(receiver))
        
        let workers = Vec::with_capacity(size)
        for id in range(size) {
            workers.push(Worker::new(id, receiver.clone()))
        }
        
        ThreadPool { workers, sender }
    }
    
    fn execute<F>(&self, f: F)
    where F: FnOnce() + Send + 'static
    {
        self.sender.send(Box::new(f))
    }
    
    fn parallel_map<T, R, F>(&self, items: Vec<T>, f: F) -> Vec<R>
    where
        F: Fn(T) -> R + Send + Clone + 'static,
        T: Send + 'static,
        R: Send + 'static
    {
        let (tx, rx) = channel()
        
        for item in items {
            let tx = tx.clone()
            let f = f.clone()
            self.execute(move || {
                let result = f(item)
                tx.send(result)
            })
        }
        
        let results = Vec::new()
        for _ in items.len() {
            results.push(rx.recv())
        }
        
        return results
    }
}

// Use thread pool
let pool = ThreadPool::new(4)

for i in range(100) {
    pool.execute(move || {
        println(f"Task {i} on thread {current_thread_id()}")
        heavy_work()
    })
}