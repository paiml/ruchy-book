// api_server.ruchy - Complete web service
use warp::{Filter, Reply, Rejection};
use sqlx::{PgPool, FromRow};
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize, FromRow)]
struct User {
    id: i32,
    username: String,
    email: String,
    created_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Deserialize)]
struct CreateUser {
    username: String,
    email: String,
    password: String,
}

#[derive(Clone)]
struct AppState {
    db: PgPool,
    jwt_secret: String,
}

async fn create_user(
    user: CreateUser,
    state: AppState,
) -> Result<impl Reply, Rejection> {
    let hashed_password = hash_password(&user.password)?;
    
    let result = sqlx::query_as!(
        User,
        r#"
        INSERT INTO users (username, email, password_hash)
        VALUES ($1, $2, $3)
        RETURNING id, username, email, created_at
        "#,
        user.username,
        user.email,
        hashed_password
    )
    .fetch_one(&state.db)
    .await
    .map_err(|e| reject::custom(DatabaseError(e)))?;
    
    Ok(warp::reply::json(&result))
}

async fn get_user(
    id: i32,
    state: AppState,
) -> Result<impl Reply, Rejection> {
    let user = sqlx::query_as!(
        User,
        "SELECT id, username, email, created_at FROM users WHERE id = $1",
        id
    )
    .fetch_one(&state.db)
    .await
    .map_err(|e| reject::custom(DatabaseError(e)))?;
    
    Ok(warp::reply::json(&user))
}

async fn list_users(
    state: AppState,
) -> Result<impl Reply, Rejection> {
    let users = sqlx::query_as!(
        User,
        "SELECT id, username, email, created_at FROM users ORDER BY created_at DESC"
    )
    .fetch_all(&state.db)
    .await
    .map_err(|e| reject::custom(DatabaseError(e)))?;
    
    Ok(warp::reply::json(&users))
}

fn with_state(
    state: AppState,
) -> impl Filter<Extract = (AppState,), Error = Infallible> + Clone {
    warp::any().map(move || state.clone())
}

fn routes(state: AppState) -> impl Filter<Extract = impl Reply> + Clone {
    let users_create = warp::path("users")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_state(state.clone()))
        .and_then(create_user);
    
    let users_get = warp::path!("users" / i32)
        .and(warp::get())
        .and(with_state(state.clone()))
        .and_then(get_user);
    
    let users_list = warp::path("users")
        .and(warp::get())
        .and(with_state(state.clone()))
        .and_then(list_users);
    
    let health = warp::path("health")
        .and(warp::get())
        .map(|| "OK");
    
    users_create
        .or(users_get)
        .or(users_list)
        .or(health)
        .with(warp::cors().allow_any_origin())
        .with(warp::log("api"))
        .recover(handle_rejection)
}

async fn handle_rejection(err: Rejection) -> Result<impl Reply, Infallible> {
    let code;
    let message;
    
    if err.is_not_found() {
        code = StatusCode::NOT_FOUND;
        message = "Not Found";
    } else if let Some(DatabaseError(_)) = err.find() {
        code = StatusCode::INTERNAL_SERVER_ERROR;
        message = "Database Error";
    } else {
        code = StatusCode::INTERNAL_SERVER_ERROR;
        message = "Internal Server Error";
    }
    
    let json = warp::reply::json(&ErrorResponse {
        message: message.to_string(),
    });
    
    Ok(warp::reply::with_status(json, code))
}

#[tokio::main]
async fn main() -> Result<()> {
    env_logger::init();
    
    let database_url = env::var("DATABASE_URL")
        .expect("DATABASE_URL must be set");
    
    let pool = PgPool::connect(&database_url).await?;
    
    // Run migrations
    sqlx::migrate!("./migrations").run(&pool).await?;
    
    let state = AppState {
        db: pool,
        jwt_secret: env::var("JWT_SECRET")
            .expect("JWT_SECRET must be set"),
    };
    
    let routes = routes(state);
    
    println!("ðŸš€ Server running on http://localhost:3030");
    
    warp::serve(routes)
        .run(([0, 0, 0, 0], 3030))
        .await;
    
    Ok(())
}