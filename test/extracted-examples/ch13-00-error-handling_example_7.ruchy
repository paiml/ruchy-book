// Retry with exponential backoff
fn fetch_with_retry<T>(
    operation: Fn() -> Result<T, Error>,
    max_attempts: i32
) -> Result<T, Error> {
    let mut attempt = 0
    let mut delay = 1000  // Start with 1 second
    
    loop {
        match operation() {
            Ok(result) => return Ok(result)
            Err(e) if attempt >= max_attempts => {
                return Err(e)
            }
            Err(e) => {
                println(f"Attempt {attempt + 1} failed: {e}")
                sleep(delay)
                delay *= 2  // Exponential backoff
                attempt += 1
            }
        }
    }
}

// Fallback strategies
fn get_config() -> Config {
    load_config_file()
        .or_else(|| load_env_config())
        .or_else(|| fetch_remote_config())
        .unwrap_or_else(|| Config::default())
}

// Circuit breaker pattern
struct CircuitBreaker {
    failure_count: i32
    last_failure: Option<Instant>
    state: State
}

impl CircuitBreaker {
    fn call<T>(mut self, f: Fn() -> Result<T, Error>) -> Result<T, Error> {
        match self.state {
            State::Open => {
                if self.should_attempt() {
                    self.state = State::HalfOpen
                } else {
                    return Err(Error::CircuitOpen)
                }
            }
            _ => {}
        }
        
        match f() {
            Ok(result) => {
                self.reset()
                Ok(result)
            }
            Err(e) => {
                self.record_failure()
                Err(e)
            }
        }
    }
}