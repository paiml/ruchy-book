=== ch02-00-variables-types-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found `let` statement
 --> /tmp/.tmp32lOHh/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let mut result = value1 + value2 ; if let Some (s) = (& result as & dyn std...
  |                                                               ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

error[E0425]: cannot find value `value1` in this scope
 --> /tmp/.tmp32lOHh/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let mut result = value1 + value2 ; if let Some (s) = (& result as & dyn std...
  |                                                                                ^^^^^^ not found in this scope

error[E0425]: cannot find value `value2` in this scope
 --> /tmp/.tmp32lOHh/main.rs:1:89
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let mut result = value1 + value2 ; if let Some (s) = (& result as & dyn std...
  |                                                                                         ^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp32lOHh/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let mut result = value1 + value2 ; if let Some (s) = (& result as & dyn std...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 3 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch02-00-variables-types-tdd example 7 ===
✗ Compilation failed: Compilation failed:
error: expected one of `!`, `.`, `::`, `;`, `?`, `else`, `{`, or an operator, found `}`
 --> /tmp/.tmpG3LFLS/main.rs:1:182
  |
1 | ...ustment ; let mut final_result = step2 / divisor } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < Strin...
  |                                                     ^ expected one of 8 possible tokens

error[E0425]: cannot find value `initial_value` in this scope
 --> /tmp/.tmpG3LFLS/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut step1 = initial_value * factor ; let mut step2 = step1 + adjustme...
  |                                                                                 ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `factor` in this scope
 --> /tmp/.tmpG3LFLS/main.rs:1:97
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut step1 = initial_value * factor ; let mut step2 = step1 + adjustme...
  |                                                                                                 ^^^^^^ not found in this scope

error[E0425]: cannot find value `adjustment` in this scope
 --> /tmp/.tmpG3LFLS/main.rs:1:130
  |
1 | ... initial_value * factor ; let mut step2 = step1 + adjustment ; let mut final_result = step2 / divisor } ; if let Some (s) = (& result ...
  |                                                      ^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpG3LFLS/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut step1 = initial_value * factor ; let mut step2 = step1 + adjustme...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 4 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch02-00-variables-types-tdd example 8 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmppcQnuw/main.rs:1:117
  |
1 | ...3.14159f64 ; let mut GRAVITY = 9.81f64 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmppcQnuw/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut PI = 3.14159f64 ; let mut GRAVITY = 9.81f64 } ; if let Some (s) =...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch10-00-performance-optimization example 1 ===
✗ Compilation failed: Compilation failed:
error[E0432]: unresolved import `std::perf`
 --> /tmp/.tmp02lR4E/main.rs:1:985
  |
1 | ...eturn lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32)...
  |                                                      ^^^^^^^^^^^ no `perf` in the root

error[E0432]: unresolved import `std::parallel`
 --> /tmp/.tmp02lR4E/main.rs:1:1005
  |
1 | ... } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = ...
  |                                                  ^^^^^^^^^^^^^^^ no `parallel` in the root

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp02lR4E/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp02lR4E/main.rs:1:207
  |
1 | ... { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } ...
  |       ^^                                                                                                                                                                                                                                                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp02lR4E/main.rs:1:257
  |
1 | ... { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ...
  |       ^^                                                                                                                                                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp02lR4E/main.rs:1:334
  |
1 | ...; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed...
  |                                  ^^                                                                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { if similar (processed , existing) { { processed . merge (existing) } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp02lR4E/main.rs:1:372
  |
1 | ...in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; retur...
  |                                                       ^^                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { processed . merge (existing) } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp02lR4E/main.rs:1:647
  |
1 | ... { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp02lR4E/main.rs:1:778
  |
1 | ... { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ...
  |       ^^                                                                                                                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp02lR4E/main.rs:1:841
  |
1 | ...em . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } ...
  |                                                   ^^                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { lookup [key as usize] . merge (item) } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp02lR4E/main.rs:1:891
  |
1 | ... { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn mai...
  |                                                       ^^                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { lookup [key as usize] = item } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmp02lR4E/main.rs:1:999
  |
1 | ... . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut n...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmp02lR4E/main.rs:1:1023
  |
1 | ...main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: meas...
  |                                                        ^ help: remove this semicolon

error[E0277]: `T` is not an iterator
 --> /tmp/.tmp02lR4E/main.rs:1:250
  |
1 | ...T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results...
  |                                                         ^^^^ `T` is not an iterator
  |
  = note: required for `T` to implement `IntoIterator`
help: consider further restricting type parameter `T` with trait `Iterator`
  |
1 | use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |                                                                                                                                                                                           +++++++++++++++++++++

error[E0425]: cannot find function `expensive_transform` in this scope
 --> /tmp/.tmp02lR4E/main.rs:1:277
  |
1 | ...] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existi...
  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `similar` in this scope
 --> /tmp/.tmp02lR4E/main.rs:1:339
  |
1 | ...ransform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results ....
  |                                                       ^^^^^^^ not found in this scope

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `parallel`
 --> /tmp/.tmp02lR4E/main.rs:1:665
  |
1 | ...(data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for ite...
  |                                        ^^^^^^^^ use of unresolved module or unlinked crate `parallel`
  |
  = help: you might be missing a crate named `parallel`

error[E0425]: cannot find function `expensive_transform` in this scope
 --> /tmp/.tmp02lR4E/main.rs:1:700
  |
1 | ...results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key...
  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `has_key` found for unit type `()` in the current scope
 --> /tmp/.tmp02lR4E/main.rs:1:825
  |
1 | ...s { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as ...
  |                                                       ^^^^^^^ method not found in `()`

error[E0599]: no method named `values` found for unit type `()` in the current scope
 --> /tmp/.tmp02lR4E/main.rs:1:950
  |
1 | ... [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut ...
  |                                                       ^^^^^^ method not found in `()`

error[E0425]: cannot find function `generate_test_data` in this scope
 --> /tmp/.tmp02lR4E/main.rs:1:1040
  |
1 | ...rf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_na...
  |                                                  ^^^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 10 previous errors; 11 warnings emitted

Some errors have detailed explanations: E0277, E0425, E0432, E0433, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch10-00-performance-optimization example 2 ===

thread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:
"perf::CpuProfiler" is not a valid Ident
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


=== ch10-00-performance-optimization example 3 ===

thread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:
"string builder" is not a valid Ident
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


=== ch10-00-performance-optimization example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `fibonacci_cache` in this scope
 --> /tmp/.tmp9u7QTC/main.rs:1:205
  |
1 | ... :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let resul...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `fibonacci_cache` in this scope
 --> /tmp/.tmp9u7QTC/main.rs:1:246
  |
1 | ... { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { forma...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `fibonacci_cache` in this scope
 --> /tmp/.tmp9u7QTC/main.rs:1:410
  |
1 | ...n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive ...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmp9u7QTC/main.rs:1:689
  |
1 | ...) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmp9u7QTC/main.rs:1:725
  |
1 | ...[] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] ...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmp9u7QTC/main.rs:1:1485
  |
1 | ...> (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Ad...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmp9u7QTC/main.rs:1:1699
  |
1 | ...d :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add <...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `null` in this scope
 --> /tmp/.tmp9u7QTC/main.rs:1:1999
  |
1 | ...if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::ptr::null;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp9u7QTC/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp9u7QTC/main.rs:1:237
  |
1 | ...T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else ...
  |                                                   ^^                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { return fibonacci_cache [n as usize] } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp9u7QTC/main.rs:1:311
  |
1 | ...ibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibona...
  |                                                                    ^^ ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { n } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp9u7QTC/main.rs:1:326
  |
1 | ... n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as ...
  |                                ^^                                                                         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp9u7QTC/main.rs:1:646
  |
1 | ... { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } ...
  |       ^^                                                                                                                                                                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp9u7QTC/main.rs:1:714
  |
1 | ... { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ...
  |       ^^                                                                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp9u7QTC/main.rs:1:761
  |
1 | ..., items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return dupl...
  |                        ^^                                                                                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp9u7QTC/main.rs:1:809
  |
1 | ...if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find...
  |                                                  ^^                                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { duplicates . push (items [i as usize]) } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp9u7QTC/main.rs:1:1068
  |
1 | ... { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } ...
  |       ^^                                                                                                                                                                                                                 ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp9u7QTC/main.rs:1:1188
  |
1 | ... ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_ar...
  |                                                         ^^                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { duplicates . add (item) } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp9u7QTC/main.rs:1:1457
  |
1 | ...Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : st...
  |                                         ^^                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { for record in records { { database . insert (record) } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp9u7QTC/main.rs:1:1483
  |
1 | ...ne > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops ::...
  |                                                        ^^                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { database . insert (record) } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp9u7QTC/main.rs:1:1697
  |
1 | ... :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < ...
  |                                                    ^^                                 ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { database . insert_batch (records) } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp9u7QTC/main.rs:1:1944
  |
1 | ... predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibo...
  |                                                 ^^                                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { if predicate (item) { { return item } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp9u7QTC/main.rs:1:1968
  |
1 | ... : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cach...
  |                                                               ^^           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { return item } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

error[E0369]: binary operation `<=` cannot be applied to type `T`
 --> /tmp/.tmp9u7QTC/main.rs:1:301
  |
1 | ...return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) ...
  |                                                                - ^^ ---- i32
  |                                                                |
  |                                                                T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                                                                                                                                                       +++++++++++++++++++++++++++

error[E0369]: cannot subtract `i32` from `T`
 --> /tmp/.tmp9u7QTC/main.rs:1:365
  |
1 | ...= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usiz...
  |                                                                 - ^ ---- i32
  |                                                                 |
  |                                                                 T
  |
help: consider further restricting type parameter `T` with trait `Sub`
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Sub<i32> > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                                                                                                                                                       ++++++++++++++++++++

error[E0369]: cannot subtract `i32` from `T`
 --> /tmp/.tmp9u7QTC/main.rs:1:393
  |
1 | ...rmat ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result ...
  |                                                                 - ^ ---- i32
  |                                                                 |
  |                                                                 T
  |
help: consider further restricting type parameter `T` with trait `Sub`
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Sub<i32> > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                                                                                                                                                       ++++++++++++++++++++

error[E0308]: `if` and `else` have incompatible types
 --> /tmp/.tmp9u7QTC/main.rs:1:328
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } ...
  |       -                                                                                                                                                                                                                                                               -              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `String`
  |       |                                                                                                                                                                                                                                                               |
  |       expected this type parameter                                                                                                                                                                                                                                    expected because of this
  |
  = note: expected type parameter `T`
                     found struct `String`
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0605]: non-primitive cast: `T` as `usize`
 --> /tmp/.tmp9u7QTC/main.rs:1:263
  |
1 | ...ache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (...
  |          ^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0605]: non-primitive cast: `T` as `usize`
 --> /tmp/.tmp9u7QTC/main.rs:1:427
  |
1 | ...ache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul...
  |          ^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmp9u7QTC/main.rs:1:704
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                             ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 +++++++++++++++++++

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmp9u7QTC/main.rs:1:751
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                                                                            ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 +++++++++++++++++++

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmp9u7QTC/main.rs:1:772
  |
1 | ... { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usi...
  |                                                                 ^^^^^^^^^^^^

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmp9u7QTC/main.rs:1:794
  |
1 | ... + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; ret...
  |                                                                 ^^^^^^^^^^^^

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmp9u7QTC/main.rs:1:836
  |
1 | ...as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_...
  |                                                                 ^^^^^^^^^^^^

error[E0433]: failed to resolve: use of undeclared type `Set`
 --> /tmp/.tmp9u7QTC/main.rs:1:1083
  |
1 | ... Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if see...
  |                                                       ^^^ use of undeclared type `Set`

error[E0433]: failed to resolve: use of undeclared type `Set`
 --> /tmp/.tmp9u7QTC/main.rs:1:1122
  |
1 | ... let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . ad...
  |                                                       ^^^ use of undeclared type `Set`

error[E0277]: `T` is not an iterator
 --> /tmp/.tmp9u7QTC/main.rs:1:1150
  |
1 | ...; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add ...
  |                                                         ^^^^^ `T` is not an iterator
  |
  = note: required for `T` to implement `IntoIterator`
help: consider further restricting type parameter `T` with trait `Iterator`
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       +++++++++++++++++++++

error[E0277]: `T` is not an iterator
 --> /tmp/.tmp9u7QTC/main.rs:1:1473
  |
1 | ...ebug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std...
  |                                                        ^^^^^^^ `T` is not an iterator
  |
  = note: required for `T` to implement `IntoIterator`
help: consider further restricting type parameter `T` with trait `Iterator`
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmp9u7QTC/main.rs:1:1459
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } ...
  |       -                                                                                                                                                -     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |       |                                                                                                                                                |
  |       expected this type parameter                                                                                                                     expected `T` because of return type
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: the caller chooses a type for `T` which can be different from `()`
  = note: `for` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } /* `T` value */ } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            +++++++++++++++

error[E0277]: `T` is not an iterator
 --> /tmp/.tmp9u7QTC/main.rs:1:1936
  |
1 | ...e > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main (...
  |                                                         ^^^^^ `T` is not an iterator
  |
  = note: required for `T` to implement `IntoIterator`
help: consider further restricting type parameter `T` with trait `Iterator`
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_memo (n - 1i32) , fibonacci_memo (n - 2i32)) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             +++++++++++++++++++++

error[E0618]: expected function, found `T`
 --> /tmp/.tmp9u7QTC/main.rs:1:1949
  |
1 | ...e > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main (...
  |                     ---------                                        ^^^^^^^^^-------
  |                     |                                                |
  |                     `predicate` has type `T`                         call expression requires function

warning: unused variable: `fibonacci_cache`
 --> /tmp/.tmp9u7QTC/main.rs:1:2029
  |
1 | ...n main () { let mut fibonacci_cache = () ; }
  |                        ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_fibonacci_cache`
  |
  = note: `#[warn(unused_variables)]` on by default

warning: variable does not need to be mutable
 --> /tmp/.tmp9u7QTC/main.rs:1:2025
  |
1 | ...turn item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                         ----^^^^^^^^^^^^^^^
  |                                                         |
  |                                                         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

error: aborting due to 26 previous errors; 17 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0369, E0425, E0433, E0599, E0605, E0608, E0618.
For more information about an error, try `rustc --explain E0277`.



=== ch10-00-performance-optimization example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 8 ===
✗ Compilation failed: Compilation failed:
error[E0432]: unresolved import `std::db`
 --> /tmp/.tmp8LZwr5/main.rs:1:1509
  |
1 | ... []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp"...
  |                                          ^^^^^^^--
  |                                          |      |
  |                                          |      help: a similar name exists in the module: `dbg`
  |                                          no `db` in the root

error[E0432]: unresolved import `std::perf`
 --> /tmp/.tmp8LZwr5/main.rs:1:1527
  |
1 | ... unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_...
  |                                                      ^^^^^^^^^^^ no `perf` in the root

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmp8LZwr5/main.rs:1:216
  |
1 | ...:: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql))...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmp8LZwr5/main.rs:1:675
  |
1 | ...ere_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_lo...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmp8LZwr5/main.rs:1:1064
  |
1 | ...fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = d...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmp8LZwr5/main.rs:1:1146
  |
1 | ...M users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmp8LZwr5/main.rs:1:1300
  |
1 | ... } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JO...
  |                                                       ^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp8LZwr5/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: f...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp8LZwr5/main.rs:1:201
  |
1 | ... { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
1 + use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp8LZwr5/main.rs:1:789
  |
1 | ... { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } ...
  |       ^^                                                                                                                                                                                                                 ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
1 + use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp8LZwr5/main.rs:1:1048
  |
1 | ... { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } ...
  |       ^^                                                                                                                                                                                                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
1 + use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp8LZwr5/main.rs:1:1129
  |
1 | ...r user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users }...
  |                      ^^                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
1 + use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp8LZwr5/main.rs:1:1291
  |
1 | ... { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } ...
  |       ^^                                                                                                                                                                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
1 + use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmp8LZwr5/main.rs:1:1521
  |
1 | ...(& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myap...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmp8LZwr5/main.rs:1:1541
  |
1 | ... } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ;...
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `extract_table` in this scope
 --> /tmp/.tmp8LZwr5/main.rs:1:495
  |
1 | ...ected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Sugge...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `extract_where` in this scope
 --> /tmp/.tmp8LZwr5/main.rs:1:542
  |
1 | ... extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `find_patterns` in this scope
 --> /tmp/.tmp8LZwr5/main.rs:1:735
  |
1 | ...et_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && ...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmp8LZwr5/main.rs:1:763
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } ...
  |       - expected this type parameter                                                                                                               - expected `T` because of return type                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: the caller chooses a type for `T` which can be different from `()`
  = note: `for` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } /* `T` value */ } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             +++++++++++++++

error: aborting due to 11 previous errors; 8 warnings emitted

Some errors have detailed explanations: E0308, E0425, E0432.
For more information about an error, try `rustc --explain E0308`.



=== ch10-00-performance-optimization example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch04-00-modules-tdd example 3 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found keyword `mod`
 --> /tmp/.tmpcfXN7x/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod module_name { { pub fn public_function () { () } ; fn private_function ...
  |                                                               ^^^ expected expression

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpcfXN7x/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod module_name { { pub fn public_function () { () } ; fn private_function ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch04-00-modules-tdd example 4 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpX1wdp5/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpX1wdp5/main.rs:1:50
  |
1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }
  |                                                  ^^                                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }
1 + use std :: collections :: HashMap ; fn main () { module_name :: public_function () }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `module_name`
 --> /tmp/.tmpX1wdp5/main.rs:1:52
  |
1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }
  |                                                    ^^^^^^^^^^^ use of unresolved module or unlinked crate `module_name`
  |
  = help: you might be missing a crate named `module_name`

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0433`.



=== ch04-00-modules-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found keyword `mod`
 --> /tmp/.tmp7vlR9H/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod math { { pub fn add (a : i32 , b : i32) -> i32 { { a + b } } ; pub fn s...
  |                                                               ^^^ expected expression

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp7vlR9H/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod math { { pub fn add (a : i32 , b : i32) -> i32 { { a + b } } ; pub fn s...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch04-00-modules-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found keyword `mod`
 --> /tmp/.tmpzupMur/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod strings { { pub fn greet () { { println ! ("Hello!") } } ; pub fn farew...
  |                                                               ^^^ expected expression

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpzupMur/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod strings { { pub fn greet () { { println ! ("Hello!") } } ; pub fn farew...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch09-00-collections-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `start` in this scope
 --> /tmp/.tmpuQht0q/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{}" , variable) } } ; if let S...
  |                                                                               ^^^^^ not found in this scope

error[E0425]: cannot find value `end` in this scope
 --> /tmp/.tmpuQht0q/main.rs:1:88
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{}" , variable) } } ; if let S...
  |                                                                                        ^^^ not found in this scope
  |
help: you might have meant to write `.` instead of `..`
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{}" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for variable in start.end { { println ! ("{}" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpuQht0q/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{}" , variable) } } ; if let S...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpuQht0q/main.rs:1:94
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{}" , variable) } } ; if let S...
  |                                                                                              ^^                           ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{}" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { println ! ("{}" , variable) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error: aborting due to 2 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `initial_value` in this scope
 --> /tmp/.tmpU9V6lm/main.rs:1:87
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut accumulator = initial_value ; let mut counter = start ; while cou...
  |                                                                                       ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `start` in this scope
 --> /tmp/.tmpU9V6lm/main.rs:1:121
  |
1 | ...mut accumulator = initial_value ; let mut counter = start ; while counter <= end { { accumulator = update (accumulator , counter) ; co...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `end` in this scope
 --> /tmp/.tmpU9V6lm/main.rs:1:146
  |
1 | ...l_value ; let mut counter = start ; while counter <= end { { accumulator = update (accumulator , counter) ; counter = counter + 1i32 }...
  |                                                         ^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpU9V6lm/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut accumulator = initial_value ; let mut counter = start ; while cou...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `update` in this scope
 --> /tmp/.tmpU9V6lm/main.rs:1:168
  |
1 | ...er = start ; while counter <= end { { accumulator = update (accumulator , counter) ; counter = counter + 1i32 } } } ; if let Some (s) ...
  |                                                        ^^^^^^ not found in this scope

error: aborting due to 4 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `height` in this scope
 --> /tmp/.tmpCt7zVu/main.rs:1:84
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (out...
  |                                                                                    ^^^^^^ not found in this scope

error[E0425]: cannot find value `width` in this scope
 --> /tmp/.tmpCt7zVu/main.rs:1:116
  |
1 | ...or outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn s...
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpCt7zVu/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (out...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpCt7zVu/main.rs:1:93
  |
1 | ...ult = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as ...
  |                                        ^^                                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { for inner in 0i32 .. width { { process (outer , inner) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpCt7zVu/main.rs:1:124
  |
1 | ...r in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: a...
  |                                                         ^^                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { process (outer , inner) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `process` in this scope
 --> /tmp/.tmpCt7zVu/main.rs:1:126
  |
1 | ... 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :...
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 7 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpm31f4L/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! ("{}" , r...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpm31f4L/main.rs:1:88
  |
1 | ...et result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! ("{}" , result) } } } ; if let Some (s) = (& result as &...
  |                                         ^^                                                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! ("{}" , result) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { let result = process (i) ; println ! ("{}" , result) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `process` in this scope
 --> /tmp/.tmpm31f4L/main.rs:1:105
  |
1 | ...result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! ("{}" , result) } } } ; if let Some (s) = (& result as & dy...
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 9 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `height` in this scope
 --> /tmp/.tmpjSUwO3/main.rs:1:82
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = ca...
  |                                                                                  ^^^^^^ not found in this scope

error[E0425]: cannot find value `width` in this scope
 --> /tmp/.tmpjSUwO3/main.rs:1:112
  |
1 | ... = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let...
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpjSUwO3/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = ca...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpjSUwO3/main.rs:1:91
  |
1 | ... in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) ...
  |                         ^^                                                                                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpjSUwO3/main.rs:1:120
  |
1 | ...eight { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result a...
  |                                         ^^                                                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { let value = calculate (row , col) ; display (value) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `calculate` in this scope
 --> /tmp/.tmpjSUwO3/main.rs:1:136
  |
1 | ...ht { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as &...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `display` in this scope
 --> /tmp/.tmpjSUwO3/main.rs:1:160
  |
1 | ..... width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any)...
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 4 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 10 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpytDZ3T/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { c...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpytDZ3T/main.rs:1:114
  |
1 | ... count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & dyn...
  |                                              ^^                                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { if condition (i) { { count = count + 1i32 } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpytDZ3T/main.rs:1:135
  |
1 | ... 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & dyn std :: ...
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { count = count + 1i32 } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `condition` in this scope
 --> /tmp/.tmpytDZ3T/main.rs:1:119
  |
1 | ...mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & ...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch19-00-real-world-projects example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch19-00-real-world-projects example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch19-00-real-world-projects example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch19-00-real-world-projects example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== conclusion example 2 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpuborpR/main.rs:1:562
  |
1 | ...()) ; let mut add_one = | x | x + 1i32 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`
 --> /tmp/.tmpuborpR/main.rs:1:478
  |
1 | ...pop () ; } } input } ; let mut contents = fs :: read_to_string ("file.txt" . to_string ()) ; let mut add_one = | x | x + 1i32 } ; if l...
  |                                              ^^ use of unresolved module or unlinked crate `fs`
  |
  = help: you might be missing a crate named `fs`
help: consider importing this module
  |
1 + use std::fs;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpuborpR/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut arr = vec ! [1i32 , 2i32 , 3i32] ; let mut name = { print ! ("{}"...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0433`.



=== ch11-00-advanced-patterns example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 12 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 3 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `xFF` in this scope
 --> /tmp/.tmpga5wBf/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...
  |                                                                                ^^^ not found in this scope

error[E0425]: cannot find value `o77` in this scope
 --> /tmp/.tmpga5wBf/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...
  |                                                                                             ^^^ not found in this scope

error[E0425]: cannot find value `b1010` in this scope
 --> /tmp/.tmpga5wBf/main.rs:1:106
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...
  |                                                                                                          ^^^^^ not found in this scope

error[E0425]: cannot find value `_000_000` in this scope
 --> /tmp/.tmpga5wBf/main.rs:1:121
  |
1 | ... ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f64 ; 2f64 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; i32 ; 3.14f64 ; ...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `e6` in this scope
 --> /tmp/.tmpga5wBf/main.rs:1:156
  |
1 | ...2 ; b1010 ; 1i32 ; _000_000 ; 3.14f64 ; 2f64 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; i32 ; 3.14f64 ; f64 ; 100i32 ; u8 } ; if let Som...
  |                                                          ^^ not found in this scope

error[E0423]: expected value, found builtin type `i32`
 --> /tmp/.tmpga5wBf/main.rs:1:188
  |
1 | ... ; 3.14f64 ; 2f64 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; i32 ; 3.14f64 ; f64 ; 100i32 ; u8 } ; if let Some (s) = (& result as & dyn ...
  |                                                               ^^^ not a value

error[E0423]: expected value, found builtin type `f64`
 --> /tmp/.tmpga5wBf/main.rs:1:204
  |
1 | ...4 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; i32 ; 3.14f64 ; f64 ; 100i32 ; u8 } ; if let Some (s) = (& result as & dyn std :: any :: An...
  |                                                               ^^^ not a value

error[E0423]: expected value, found builtin type `u8`
 --> /tmp/.tmpga5wBf/main.rs:1:219
  |
1 | ...; 0.00000000015f64 ; 42i32 ; i32 ; 3.14f64 ; f64 ; 100i32 ; u8 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_...
  |                                                                ^^ not a value

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpga5wBf/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 8 previous errors; 1 warning emitted

Some errors have detailed explanations: E0423, E0425.
For more information about an error, try `rustc --explain E0423`.



=== appendix-b-syntax-reference example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 6 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found `let` statement
 --> /tmp/.tmpPWG75H/main.rs:1:275
  |
1 | ...147483648i64 ; let mut uint = 4294967295i64 ; let mut long = - ! let mut ulong = ! let mut size = - 1i32 ; let mut usize = 1i32 ; let ...
  |                                                                     ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

error: expected expression, found `let` statement
 --> /tmp/.tmpPWG75H/main.rs:1:293
  |
1 | ... mut uint = 4294967295i64 ; let mut long = - ! let mut ulong = ! let mut size = - 1i32 ; let mut usize = 1i32 ; let mut single = 3.14f...
  |                                                                     ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpPWG75H/main.rs:1:499
  |
1 | ...let mut owned = "world" . to_string () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpPWG75H/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut flag = true ; let mut small = - 128i32 ; let mut byte = 255i32 ; ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 3 previous errors; 1 warning emitted




=== appendix-b-syntax-reference example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 11 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `value` in this scope
 --> /tmp/.tmpwQPaQt/main.rs:1:71
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { match value { 0i32 => "zero" , 1i32 | 2i32 => "one or two" , 3i32 ..= 10i...
  |                                                                       ^^^^^ not found in this scope

error[E0425]: cannot find value `point` in this scope
 --> /tmp/.tmpwQPaQt/main.rs:1:234
  |
1 | ...=> "big number" , _ => "something else" , } ; match point { Point { x : 0i32 , y : 0i32 } => "origin" , Point { x , y : 0i32 } => form...
  |                                                        ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmpwQPaQt/main.rs:1:242
  |
1 | ...number" , _ => "something else" , } ; match point { Point { x : 0i32 , y : 0i32 } => "origin" , Point { x , y : 0i32 } => format ! ("{...
  |                                                        ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmpwQPaQt/main.rs:1:286
  |
1 | ...point { Point { x : 0i32 , y : 0i32 } => "origin" , Point { x , y : 0i32 } => format ! ("{}{}" , format ! ("{}{}" , "on x-axis at " , ...
  |                                                        ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmpwQPaQt/main.rs:1:390
  |
1 | ...! ("{}{}" , "on x-axis at " , x . to_s ()) , ",") , Point { x : 0i32 , y } => format ! ("{}{}" , format ! ("{}{}" , "on y-axis at " , ...
  |                                                        ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmpwQPaQt/main.rs:1:494
  |
1 | ...! ("{}{}" , "on y-axis at " , y . to_s ()) , ",") , Point { x , y } => format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "point...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `number` in this scope
 --> /tmp/.tmpwQPaQt/main.rs:1:639
  |
1 | .... to_s ()) , ", ") + y . to_s () , ")") , } ; match number { n if n < 0i32 => "negative" , n if n > 0i32 => "positive" , _ => "zero" ,...
  |                                                        ^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpwQPaQt/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { match value { 0i32 => "zero" , 1i32 | 2i32 => "one or two" , 3i32 ..= 10i...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0308]: `match` arms have incompatible types
 --> /tmp/.tmpwQPaQt/main.rs:1:312
  |
1 | ... ; match point { Point { x : 0i32 , y : 0i32 } => "origin" , Point { x , y : 0i32 } => format ! ("{}{}" , format ! ("{}{}" , "on x-axis at " , x . to_s ()) , ",") , ...
  |       -----------                                    --------                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `String`
  |       |                                              |
  |       |                                              this is found to be of type `&str`
  |       `match` arms have incompatible types
  |
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 8 previous errors; 1 warning emitted

Some errors have detailed explanations: E0308, E0422, E0425.
For more information about an error, try `rustc --explain E0308`.



=== appendix-b-syntax-reference example 12 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 13 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 14 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 15 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 16 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 17 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 18 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 19 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 20 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 21 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 22 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 23 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 24 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 25 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 26 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 27 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 28 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 29 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 30 ===
✗ Compilation failed: Failed to transpile to Rust


=== appendix-b-syntax-reference example 31 ===
✗ Compilation failed: Failed to transpile to Rust


=== appendix-b-syntax-reference example 32 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 33 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 34 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 35 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-input-output-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `variable` in this scope
 --> /tmp/.tmpnUDIk5/main.rs:1:112
  |
1 | ...= { println ! ("text message") ; println ! ("{}" , variable) ; println ! ("{}" , 42i32) ; println ! ("{}" , true) } ; if let Some (s) ...
  |                                                       ^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpnUDIk5/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("text message") ; println ! ("{}" , variable) ; println ! ("{}...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch10-00-input-output-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `value` in this scope
 --> /tmp/.tmp5KusmW/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut data = value ; println ! ("Label:") ; println ! ("{}" , data) } ;...
  |                                                                                ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp5KusmW/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut data = value ; println ! ("Label:") ; println ! ("{}" , data) } ;...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch10-00-input-output-tdd example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch18-00-deployment-devops example 1 ===
✗ Compilation failed: Compilation failed:
error[E0432]: unresolved import `std::deploy`
 --> /tmp/.tmpQpDzyl/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: deploy ; ; let mut config = DeployConfig { app : "my-app" . to...
  |                                                                     ^^^^^^^^^^^^^ no `deploy` in the root

error[E0422]: cannot find struct, variant or union type `DeployConfig` in this scope
 --> /tmp/.tmpQpDzyl/main.rs:1:104
  |
1 | ...esult = { use std :: deploy ; ; let mut config = DeployConfig { app : "my-app" . to_string () , environment : env :: var ("DEPLOY_ENV"...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `env`
 --> /tmp/.tmpQpDzyl/main.rs:1:165
  |
1 | ... "my-app" . to_string () , environment : env :: var ("DEPLOY_ENV" . to_string ()) , strategy : BlueGreen , health_check : "/health" . ...
  |                                             ^^^ use of unresolved module or unlinked crate `env`
  |
  = help: you might be missing a crate named `env`
help: consider importing this module
  |
1 + use std::env;
  |

error[E0425]: cannot find value `BlueGreen` in this scope
 --> /tmp/.tmpQpDzyl/main.rs:1:219
  |
1 | ...:: var ("DEPLOY_ENV" . to_string ()) , strategy : BlueGreen , health_check : "/health" . to_string () , rollback_on_failure : true , }...
  |                                                      ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpQpDzyl/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: deploy ; ; let mut config = DeployConfig { app : "my-app" . to...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpQpDzyl/main.rs:1:85
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: deploy ; ; let mut config = DeployConfig { app : "my-app" . to...
  |                                                                                     ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error: aborting due to 4 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0422, E0425, E0432, E0433.
For more information about an error, try `rustc --explain E0422`.



=== ch18-00-deployment-devops example 2 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `sleep` in this scope
 --> /tmp/.tmpoxNk0Z/main.rs:1:399
  |
1 | ...healthy") } } ; LoadBalancer :: switch_to (green) ; sleep (Duration :: from_mins (5i32)) ; if green . error_rate () > 0.01f64 { { Load...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::sleep;
  |

error[E0433]: failed to resolve: use of undeclared type `Duration`
 --> /tmp/.tmpoxNk0Z/main.rs:1:406
  |
1 | ... ; LoadBalancer :: switch_to (green) ; sleep (Duration :: from_mins (5i32)) ; if green . error_rate () > 0.01f64 { { LoadBalancer :: s...
  |                                                  ^^^^^^^^ use of undeclared type `Duration`
  |
help: consider importing this struct
  |
1 + use std::time::Duration;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpoxNk0Z/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn deploy_blue_green (new_version : String) { { { let blue = Environment :: current () ; { let mut gr...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpoxNk0Z/main.rs:1:83
  |
1 | ... { { { let blue = Environment :: current () ; { let mut green = Environment :: provision (new_version) ; green . deploy () ; green . run_health_checks () ; green . run_smoke_tests () ; if ! green . is_healthy () { { green . destroy () ; panic ! ("Green environment unhealthy") } } ; LoadBalancer :: switch_to (green) ; sleep (Duration :: from_mins (5i32)) ; if green . error_rate () > 0.01f64 { { LoadBalancer :: switch_to (blue) ; green . destroy () ; panic ! ("High error rate, rolled back") } } ; blue . destroy () ; println ! ("✅ Deployed version {}" , new_version) } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn deploy_blue_green (new_version : String) { { { let blue = Environment :: current () ; { let mut green = Environment :: provision (new_version) ; green . deploy () ; green . run_health_checks () ; green . run_smoke_tests () ; if ! green . is_healthy () { { green . destroy () ; panic ! ("Green environment unhealthy") } } ; LoadBalancer :: switch_to (green) ; sleep (Duration :: from_mins (5i32)) ; if green . error_rate () > 0.01f64 { { LoadBalancer :: switch_to (blue) ; green . destroy () ; panic ! ("High error rate, rolled back") } } ; blue . destroy () ; println ! ("✅ Deployed version {}" , new_version) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn deploy_blue_green (new_version : String) { { let blue = Environment :: current () ; { let mut green = Environment :: provision (new_version) ; green . deploy () ; green . run_health_checks () ; green . run_smoke_tests () ; if ! green . is_healthy () { { green . destroy () ; panic ! ("Green environment unhealthy") } } ; LoadBalancer :: switch_to (green) ; sleep (Duration :: from_mins (5i32)) ; if green . error_rate () > 0.01f64 { { LoadBalancer :: switch_to (blue) ; green . destroy () ; panic ! ("High error rate, rolled back") } } ; blue . destroy () ; println ! ("✅ Deployed version {}" , new_version) } } } fn main () { }
  |

error[E0433]: failed to resolve: use of undeclared type `Environment`
 --> /tmp/.tmpoxNk0Z/main.rs:1:98
  |
1 | ...en (new_version : String) { { { let blue = Environment :: current () ; { let mut green = Environment :: provision (new_version) ; gree...
  |                                               ^^^^^^^^^^^ use of undeclared type `Environment`

error[E0433]: failed to resolve: use of undeclared type `Environment`
 --> /tmp/.tmpoxNk0Z/main.rs:1:144
  |
1 | ...ironment :: current () ; { let mut green = Environment :: provision (new_version) ; green . deploy () ; green . run_health_checks () ;...
  |                                               ^^^^^^^^^^^ use of undeclared type `Environment`

error[E0433]: failed to resolve: use of undeclared type `LoadBalancer`
 --> /tmp/.tmpoxNk0Z/main.rs:1:363
  |
1 | ...c ! ("Green environment unhealthy") } } ; LoadBalancer :: switch_to (green) ; sleep (Duration :: from_mins (5i32)) ; if green . error_...
  |                                              ^^^^^^^^^^^^ use of undeclared type `LoadBalancer`

error[E0433]: failed to resolve: use of undeclared type `LoadBalancer`
 --> /tmp/.tmpoxNk0Z/main.rs:1:477
  |
1 | ... ; if green . error_rate () > 0.01f64 { { LoadBalancer :: switch_to (blue) ; green . destroy () ; panic ! ("High error rate, rolled ba...
  |                                              ^^^^^^^^^^^^ use of undeclared type `LoadBalancer`

error: aborting due to 6 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0425, E0433.
For more information about an error, try `rustc --explain E0425`.



=== ch18-00-deployment-devops example 3 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `sleep` in this scope
 --> /tmp/.tmpVELTvZ/main.rs:1:375
  |
1 | ... deployment . set_traffic_percentage (percentage) ; sleep (Duration :: from_mins (10i32)) ; { let current = Metrics :: current () ; { ...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::sleep;
  |

error[E0433]: failed to resolve: use of undeclared type `Duration`
 --> /tmp/.tmpVELTvZ/main.rs:1:382
  |
1 | ... set_traffic_percentage (percentage) ; sleep (Duration :: from_mins (10i32)) ; { let current = Metrics :: current () ; { if current . ...
  |                                                  ^^^^^^^^ use of undeclared type `Duration`
  |
help: consider importing this struct
  |
1 + use std::time::Duration;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpVELTvZ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn deploy_canary (new_version : String) { { { let deployment = CanaryDeployment :: new (new_version) ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpVELTvZ/main.rs:1:79
  |
1 | ... { { { let deployment = CanaryDeployment :: new (new_version) ; { deployment . set_traffic_percentage (5i32) ; deployment . deploy () ; let mut baseline = Metrics :: baseline () ; for percentage in vec ! [5i32 , 10i32 , 25i32 , 50i32 , 100i32] { { deployment . set_traffic_percentage (percentage) ; sleep (Duration :: from_mins (10i32)) ; { let current = Metrics :: current () ; { if current . error_rate > baseline . error_rate * 1.1f64 { { deployment . rollback () ; panic ! ("Error rate increased by >10%") } } ; if current . p99_latency > baseline . p99_latency * 1.2f64 { { deployment . rollback () ; panic ! ("Latency increased by >20%") } } ; println ! ("✅ Canary at {}% - metrics healthy" , percentage) } } } } ; deployment . finalize () } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn deploy_canary (new_version : String) { { { let deployment = CanaryDeployment :: new (new_version) ; { deployment . set_traffic_percentage (5i32) ; deployment . deploy () ; let mut baseline = Metrics :: baseline () ; for percentage in vec ! [5i32 , 10i32 , 25i32 , 50i32 , 100i32] { { deployment . set_traffic_percentage (percentage) ; sleep (Duration :: from_mins (10i32)) ; { let current = Metrics :: current () ; { if current . error_rate > baseline . error_rate * 1.1f64 { { deployment . rollback () ; panic ! ("Error rate increased by >10%") } } ; if current . p99_latency > baseline . p99_latency * 1.2f64 { { deployment . rollback () ; panic ! ("Latency increased by >20%") } } ; println ! ("✅ Canary at {}% - metrics healthy" , percentage) } } } } ; deployment . finalize () } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn deploy_canary (new_version : String) { { let deployment = CanaryDeployment :: new (new_version) ; { deployment . set_traffic_percentage (5i32) ; deployment . deploy () ; let mut baseline = Metrics :: baseline () ; for percentage in vec ! [5i32 , 10i32 , 25i32 , 50i32 , 100i32] { { deployment . set_traffic_percentage (percentage) ; sleep (Duration :: from_mins (10i32)) ; { let current = Metrics :: current () ; { if current . error_rate > baseline . error_rate * 1.1f64 { { deployment . rollback () ; panic ! ("Error rate increased by >10%") } } ; if current . p99_latency > baseline . p99_latency * 1.2f64 { { deployment . rollback () ; panic ! ("Latency increased by >20%") } } ; println ! ("✅ Canary at {}% - metrics healthy" , percentage) } } } } ; deployment . finalize () } } } fn main () { }
  |

error[E0433]: failed to resolve: use of undeclared type `CanaryDeployment`
 --> /tmp/.tmpVELTvZ/main.rs:1:100
  |
1 | ...sion : String) { { { let deployment = CanaryDeployment :: new (new_version) ; { deployment . set_traffic_percentage (5i32) ; deploymen...
  |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `CanaryDeployment`

error[E0433]: failed to resolve: use of undeclared type `Metrics`
 --> /tmp/.tmpVELTvZ/main.rs:1:231
  |
1 | ... ; deployment . deploy () ; let mut baseline = Metrics :: baseline () ; for percentage in vec ! [5i32 , 10i32 , 25i32 , 50i32 , 100i32...
  |                                                   ^^^^^^^ use of undeclared type `Metrics`

error[E0433]: failed to resolve: use of undeclared type `Metrics`
 --> /tmp/.tmpVELTvZ/main.rs:1:431
  |
1 | ...ration :: from_mins (10i32)) ; { let current = Metrics :: current () ; { if current . error_rate > baseline . error_rate * 1.1f64 { { ...
  |                                                   ^^^^^^^ use of undeclared type `Metrics`

error: aborting due to 5 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0425, E0433.
For more information about an error, try `rustc --explain E0425`.



=== ch18-00-deployment-devops example 4 ===
✗ Compilation failed: Compilation failed:
error[E0432]: unresolved import `feature_flags`
 --> /tmp/.tmpgiI5T8/main.rs:1:69
  |
1 | ...n main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ("api_key" . to_string ()) ; let m...
  |                                   ^^^^^^^^^^^^^ use of unresolved module or unlinked crate `feature_flags`
  |
help: you might be missing a crate named `feature_flags`, add it to your project and import it in your code
  |
1 + extern crate feature_flags;
  |

error[E0425]: cannot find value `user` in this scope
 --> /tmp/.tmpgiI5T8/main.rs:1:456
  |
1 | ...) , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percen...
  |                                                         ^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpgiI5T8/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpgiI5T8/main.rs:1:106
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ...
  |                                                                                                          ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpgiI5T8/main.rs:1:464
  |
1 | ...ue)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage i...
  |                                                           ^^                    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ("api_key" . to_string ()) ; let mut new_algorithm = Flag :: new ("new-algorithm" . to_string ()) . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new ("beta_users" . to_string () , true) , Rule :: new ("internal_users" . to_string () , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ("api_key" . to_string ()) ; let mut new_algorithm = Flag :: new ("new-algorithm" . to_string ()) . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new ("beta_users" . to_string () , true) , Rule :: new ("internal_users" . to_string () , true)]) ; if flags . is_enabled (new_algorithm , user) { use_new_algorithm () } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpgiI5T8/main.rs:1:498
  |
1 | ..._algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 7...
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ("api_key" . to_string ()) ; let mut new_algorithm = Flag :: new ("new-algorithm" . to_string ()) . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new ("beta_users" . to_string () , true) , Rule :: new ("internal_users" . to_string () , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ("api_key" . to_string ()) ; let mut new_algorithm = Flag :: new ("new-algorithm" . to_string ()) . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new ("beta_users" . to_string () , true) , Rule :: new ("internal_users" . to_string () , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { use_old_algorithm () } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0433]: failed to resolve: use of undeclared type `Rule`
 --> /tmp/.tmpgiI5T8/main.rs:1:309
  |
1 | ...lout_percentage (10i32) . targeting_rules (vec ! [Rule :: new ("beta_users" . to_string () , true) , Rule :: new ("internal_users" . t...
  |                                                      ^^^^ use of undeclared type `Rule`

error[E0433]: failed to resolve: use of undeclared type `Rule`
 --> /tmp/.tmpgiI5T8/main.rs:1:360
  |
1 | ...ule :: new ("beta_users" . to_string () , true) , Rule :: new ("internal_users" . to_string () , true)]) ; if flags . is_enabled (new_...
  |                                                      ^^^^ use of undeclared type `Rule`

error[E0425]: cannot find function `use_new_algorithm` in this scope
 --> /tmp/.tmpgiI5T8/main.rs:1:466
  |
1 | ...ew_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 ,...
  |                             ^^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists: `new_algorithm`

error[E0425]: cannot find function `use_old_algorithm` in this scope
 --> /tmp/.tmpgiI5T8/main.rs:1:500
  |
1 | ..., user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `monitor_metrics` in this scope
 --> /tmp/.tmpgiI5T8/main.rs:1:647
  |
1 | ...s . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `metrics_degraded` in this scope
 --> /tmp/.tmpgiI5T8/main.rs:1:671
  |
1 | ...orithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 8 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0425, E0432, E0433.
For more information about an error, try `rustc --explain E0425`.



=== ch18-00-deployment-devops example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch18-00-deployment-devops example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch18-00-deployment-devops example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch18-00-deployment-devops example 8 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch01-03-interpreter-scripting example 1 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `ruchy` in this scope
 --> /tmp/.tmppHKvwN/main.rs:1:65
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "2 + 2" } ; if let Some (s) = (& result as & dyn std :: any :...
  |                                                                 ^^^^^ not found in this scope

error[E0425]: cannot find value `e` in this scope
 --> /tmp/.tmppHKvwN/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "2 + 2" } ; if let Some (s) = (& result as & dyn std :: any :...
  |                                                                         ^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmppHKvwN/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "2 + 2" } ; if let Some (s) = (& result as & dyn std :: any :...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 2 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `ruchy` in this scope
 --> /tmp/.tmpH4poAo/main.rs:1:65
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let name = \"World\"; \"Hello \" + name + \"!\"" } ; if let ...
  |                                                                 ^^^^^ not found in this scope

error[E0425]: cannot find value `e` in this scope
 --> /tmp/.tmpH4poAo/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let name = \"World\"; \"Hello \" + name + \"!\"" } ; if let ...
  |                                                                         ^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpH4poAo/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let name = \"World\"; \"Hello \" + name + \"!\"" } ; if let ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 3 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `ruchy` in this scope
 --> /tmp/.tmpw969vb/main.rs:1:65
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let nums = [1, 2, 3]; nums[1]" } ; if let Some (s) = (& resu...
  |                                                                 ^^^^^ not found in this scope

error[E0425]: cannot find value `e` in this scope
 --> /tmp/.tmpw969vb/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let nums = [1, 2, 3]; nums[1]" } ; if let Some (s) = (& resu...
  |                                                                         ^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpw969vb/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let nums = [1, 2, 3]; nums[1]" } ; if let Some (s) = (& resu...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 5 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpTydWkW/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Disp...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpTydWkW/main.rs:1:197
  |
1 | ...isplay + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ...
  |                                                                  ^^     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { a + b } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTydWkW/main.rs:1:374
  |
1 | ...isplay + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ...
  |                                                                  ^^     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { a - b } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTydWkW/main.rs:1:551
  |
1 | ...isplay + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: op...
  |                                                                  ^^     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { a * b } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTydWkW/main.rs:1:726
  |
1 | ...(a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let...
  |                           ^^                                                                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTydWkW/main.rs:1:801
  |
1 | ...2 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; pr...
  |                                                                  ^^     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { a / b } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTydWkW/main.rs:1:830
  |
1 | ... { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } }
  |

error[E0369]: cannot subtract `T` from `T`
 --> /tmp/.tmpTydWkW/main.rs:1:378
  |
1 | ...splay + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: o...
  |                                                                   - ^ - T
  |                                                                   |
  |                                                                   T
  |
help: consider further restricting type parameter `T` with trait `Sub`
  |
1 | use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Sub<Output = T> > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
  |                                                                                                                                                                                                                                                                                                                                                             +++++++++++++++++++++++++++

error[E0369]: binary operation `==` cannot be applied to type `T`
 --> /tmp/.tmpTydWkW/main.rs:1:733
  |
1 | ...+ std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a ...
  |                                                                - ^^ ---- i32
  |                                                                |
  |                                                                T
  |
help: consider further restricting type parameter `T` with trait `PartialEq`
  |
1 | use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialEq<i32> > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpTydWkW/main.rs:1:785
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } ...
  |       - expected this type parameter                                                                                                                     - expected `T` because of return type                          ^^^^ expected type parameter `T`, found `i32`
  |
  = note: expected type parameter `T`
                       found type `i32`
  = note: the caller chooses a type for `T` which can be different from `i32`

error[E0369]: cannot divide `T` by `T`
 --> /tmp/.tmpTydWkW/main.rs:1:805
  |
1 | ... { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; pri...
  |                                                                   - ^ - T
  |                                                                   |
  |                                                                   T
  |
help: consider further restricting type parameter `T` with trait `Div`
  |
1 | use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Div<Output = T> > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             +++++++++++++++++++++++++++

warning: variable does not need to be mutable
 --> /tmp/.tmpTydWkW/main.rs:1:856
  |
1 | ...a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println...
  |                                                         ----^
  |                                                         |
  |                                                         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

error: aborting due to 4 previous errors; 8 warnings emitted

Some errors have detailed explanations: E0308, E0369.
For more information about an error, try `rustc --explain E0308`.



=== ch01-03-interpreter-scripting example 7 ===
✗ Compilation failed: Compilation failed:
error[E0434]: can't capture dynamic environment in a fn item
 --> /tmp/.tmpZ4KhLx/main.rs:1:244
  |
1 | ...sted () { { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ...
  |                                                                  ^^^^^^^^^
  |
  = help: use the `|| { ... }` closure form instead

error[E0425]: cannot find value `global_var` in this scope
 --> /tmp/.tmpZ4KhLx/main.rs:1:132
  |
1 | ...ring () ; { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; fn nested () { { println ! ("{}" , global_var) ; println ! ...
  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `local_var`

error[E0425]: cannot find value `global_var` in this scope
 --> /tmp/.tmpZ4KhLx/main.rs:1:212
  |
1 | ...sted () { { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ...
  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `local_var`

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpZ4KhLx/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn demonstrate_scope () { { { let local_var = "I'm local" . to_string () ; { println ! ("{}" , global...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpZ4KhLx/main.rs:1:63
  |
1 | ... { { { let local_var = "I'm local" . to_string () ; { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; fn nested () { { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ("{}" , nested_var) } } } ; nested () } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn demonstrate_scope () { { { let local_var = "I'm local" . to_string () ; { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; fn nested () { { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ("{}" , nested_var) } } } ; nested () } } } } fn main () { let mut global_var = "I'm global" . to_string () ; { demonstrate_scope () } }
1 + use std :: collections :: HashMap ; fn demonstrate_scope () { { let local_var = "I'm local" . to_string () ; { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; fn nested () { { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ("{}" , nested_var) } } } ; nested () } } } fn main () { let mut global_var = "I'm global" . to_string () ; { demonstrate_scope () } }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpZ4KhLx/main.rs:1:342
  |
1 | ... to_string () ; println ! ("{}" , nested_var) } } } ; nested () } } } } fn main () { let mut global_var = "I'm global" . to_string () ...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpZ4KhLx/main.rs:1:426
  |
1 | ...) { let mut global_var = "I'm global" . to_string () ; { demonstrate_scope () } }
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn demonstrate_scope () { { { let local_var = "I'm local" . to_string () ; { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; fn nested () { { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ("{}" , nested_var) } } } ; nested () } } } } fn main () { let mut global_var = "I'm global" . to_string () ; { demonstrate_scope () } }
1 + use std :: collections :: HashMap ; fn demonstrate_scope () { { { let local_var = "I'm local" . to_string () ; { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; fn nested () { { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ("{}" , nested_var) } } } ; nested () } } } } fn main () { let mut global_var = "I'm global" . to_string () ; demonstrate_scope () }
  |

warning: unused variable: `global_var`
 --> /tmp/.tmpZ4KhLx/main.rs:1:383
  |
1 | ...} } fn main () { let mut global_var = "I'm global" . to_string () ; { demonstrate_scope () } }
  |                             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_global_var`
  |
  = note: `#[warn(unused_variables)]` on by default

warning: variable does not need to be mutable
 --> /tmp/.tmpZ4KhLx/main.rs:1:379
  |
1 | ...sted_var) } } } ; nested () } } } } fn main () { let mut global_var = "I'm global" . to_string () ; { demonstrate_scope () } }
  |                                                         ----^^^^^^^^^^
  |                                                         |
  |                                                         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

error: aborting due to 3 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0425, E0434.
For more information about an error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 8 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpAceHHD/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpAceHHD/main.rs:1:50
  |
1 | ... { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } } }
  |       ^^                                                                                                                                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } } }
1 + use std :: collections :: HashMap ; fn main () { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpAceHHD/main.rs:1:118
  |
1 | ...i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") ...
  |                                                  ^^                                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { println ! ("{}" , arr [5i32 as usize]) } else { { println ! ("Index out of bounds") } } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpAceHHD/main.rs:1:170
  |
1 | ...intln ! ("{}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } } }
  |                                                    ^^                                 ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , arr [5i32 as usize]) } } else { println ! ("Index out of bounds") } } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpAceHHD/main.rs:1:103
  |
1 | ...let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , arr [5i32 as usize]) } } else { { println ! ("Inde...
  |                                              ----   ^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                              |
  |                                              expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len ().try_into().unwrap() { { println ! ("{}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } } }
  |                                                                                                                   ++++++++++++++++++++

error: aborting due to 1 previous error; 4 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch01-03-interpreter-scripting example 10 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp91kEL5/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn get_double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp91kEL5/main.rs:1:196
  |
1 | ...mt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } } fn process_and_print < T : std :: ops :: Add < Output = T ...
  |                                                                 ^^        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn get_double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } } fn process_and_print < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; { println ! ("Doubled:") ; println ! ("{}" , doubled) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn get_double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { x * 2i32 } fn process_and_print < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; { println ! ("Doubled:") ; println ! ("{}" , doubled) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp91kEL5/main.rs:1:377
  |
1 | ...Clone > (x : T) -> T { { { let doubled = x * 2i32 ; { println ! ("Doubled:") ; println ! ("{}" , doubled) } } } } fn main () { }
  |                           ^^                                                                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn get_double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } } fn process_and_print < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; { println ! ("Doubled:") ; println ! ("{}" , doubled) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn get_double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } } fn process_and_print < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { let doubled = x * 2i32 ; { println ! ("Doubled:") ; println ! ("{}" , doubled) } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp91kEL5/main.rs:1:202
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } ...
  |       -                                                                                                                                                -   ^^^^ expected type parameter `T`, found `i32`
  |       |                                                                                                                                                |
  |       expected this type parameter                                                                                                                     expected because this is `T`
  |
  = note: expected type parameter `T`
                       found type `i32`

error[E0308]: mismatched types
 --> /tmp/.tmp91kEL5/main.rs:1:399
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; ...
  |       -                                                                                                                                                                -   ^^^^ expected type parameter `T`, found `i32`
  |       |                                                                                                                                                                |
  |       expected this type parameter                                                                                                                                     expected because this is `T`
  |
  = note: expected type parameter `T`
                       found type `i32`

error[E0308]: mismatched types
 --> /tmp/.tmp91kEL5/main.rs:1:433
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; { println ! ("Doubled:") ; println ! ("{}" , doubled) } ...
  |       - expected this type parameter                                                                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 3 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch01-03-interpreter-scripting example 12 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpT2hm3f/main.rs:1:183
  |
1 | ...t mut x = 42i32 ; let mut y = calc (z) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0425]: cannot find value `items` in this scope
 --> /tmp/.tmpT2hm3f/main.rs:1:133
  |
1 | ...nt = 42i32 ; let mut total_price = calculate_price (items) ; let mut x = 42i32 ; let mut y = calc (z) } ; if let Some (s) = (& result ...
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpT2hm3f/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut user_count = 42i32 ; let mut total_price = calculate_price (items...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `calculate_price` in this scope
 --> /tmp/.tmpT2hm3f/main.rs:1:116
  |
1 | ...mut user_count = 42i32 ; let mut total_price = calculate_price (items) ; let mut x = 42i32 ; let mut y = calc (z) } ; if let Some (s) ...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 13 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpmpI3LI/main.rs:1:208
  |
1 | ...ut last_grade = grades [4i32 as usize] } } } }
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpmpI3LI/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let mut first_grade =...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpmpI3LI/main.rs:1:50
  |
1 | ... { { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let mut first_grade = grades [0i32 as usize] ; let mut last_grade = grades [4i32 as usize] } } } }
  |       ^^                                                                                                                                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let mut first_grade = grades [0i32 as usize] ; let mut last_grade = grades [4i32 as usize] } } } }
1 + use std :: collections :: HashMap ; fn main () { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let mut first_grade = grades [0i32 as usize] ; let mut last_grade = grades [4i32 as usize] } } }
  |

error: aborting due to 1 previous error; 2 warnings emitted




=== ch01-03-interpreter-scripting example 14 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpCCTyrU/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: D...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpCCTyrU/main.rs:1:192
  |
1 | ...mt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } } fn main () { { { let x = 5i32 ; { let mut result = double ...
  |                                                                 ^^        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } } fn main () { { { let x = 5i32 ; { let mut result = double (x) ; println ! ("{}" , result) } } } }
1 + use std :: collections :: HashMap ; fn double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { n * 2i32 } fn main () { { { let x = 5i32 ; { let mut result = double (x) ; println ! ("{}" , result) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpCCTyrU/main.rs:1:220
  |
1 | ...n * 2i32 } } fn main () { { { let x = 5i32 ; { let mut result = double (x) ; println ! ("{}" , result) } } } }
  |                              ^^                                                                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } } fn main () { { { let x = 5i32 ; { let mut result = double (x) ; println ! ("{}" , result) } } } }
1 + use std :: collections :: HashMap ; fn double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } } fn main () { { let x = 5i32 ; { let mut result = double (x) ; println ! ("{}" , result) } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpCCTyrU/main.rs:1:198
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } ...
  |       -                                                                                                                                                -   ^^^^ expected type parameter `T`, found `i32`
  |       |                                                                                                                                                |
  |       expected this type parameter                                                                                                                     expected because this is `T`
  |
  = note: expected type parameter `T`
                       found type `i32`

warning: variable does not need to be mutable
 --> /tmp/.tmpCCTyrU/main.rs:1:245
  |
1 | ...{ n * 2i32 } } fn main () { { { let x = 5i32 ; { let mut result = double (x) ; println ! ("{}" , result) } } } }
  |                                                         ----^^^^^^
  |                                                         |
  |                                                         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

error: aborting due to 1 previous error; 4 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch17-00-documentation example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 5 ===
✗ Compilation failed: Compilation failed:
error: expected item, found `{`
 --> /tmp/.tmpIpcylP/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { mod handlers { { } } ; mod services { { } } } ; if let Some (s) = (& resu...
  |                                                                                ^ expected item
  |
  = note: for a full list of items that can appear in modules, see <https://doc.rust-lang.org/reference/items.html>

error: expected item, found `{`
 --> /tmp/.tmpIpcylP/main.rs:1:103
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { mod handlers { { } } ; mod services { { } } } ; if let Some (s) = (& resu...
  |                                                                                                       ^ expected item
  |
  = note: for a full list of items that can appear in modules, see <https://doc.rust-lang.org/reference/items.html>

error: expected item, found `}`
 --> /tmp/.tmpIpcylP/main.rs:1:109
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { mod handlers { { } } ; mod services { { } } } ; if let Some (s) = (& resu...
  |                                                                                                             ^ expected item
  |
  = note: for a full list of items that can appear in modules, see <https://doc.rust-lang.org/reference/items.html>

error: aborting due to 3 previous errors




=== ch17-00-documentation example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 9 ===
✗ Compilation failed: Compilation failed:
error[E0670]: `async fn` is not permitted in Rust 2015
 --> /tmp/.tmpODijVq/main.rs:1:37
  |
1 | use std :: collections :: HashMap ; async fn request_flow () { { client . send_request () ; server . validate () ; server . process () ; ...
  |                                     ^^^^^ to use `async fn`, switch to Rust 2018 or later
  |
  = help: pass `--edition 2024` to `rustc`
  = note: for more on editions, read https://doc.rust-lang.org/edition-guide

error[E0425]: cannot find value `client` in this scope
 --> /tmp/.tmpODijVq/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; async fn request_flow () { { client . send_request () ; server . validate () ; server . process () ; ...
  |                                                                  ^^^^^^ not found in this scope

error[E0425]: cannot find value `server` in this scope
 --> /tmp/.tmpODijVq/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; async fn request_flow () { { client . send_request () ; server . validate () ; server . process () ; ...
  |                                                                                             ^^^^^^ not found in this scope

error[E0425]: cannot find value `server` in this scope
 --> /tmp/.tmpODijVq/main.rs:1:116
  |
1 | ...{ client . send_request () ; server . validate () ; server . process () ; server . respond () } } fn main () { impl ConfigBuilder { } ; }
  |                                                        ^^^^^^ not found in this scope

error[E0425]: cannot find value `server` in this scope
 --> /tmp/.tmpODijVq/main.rs:1:138
  |
1 | ...t () ; server . validate () ; server . process () ; server . respond () } } fn main () { impl ConfigBuilder { } ; }
  |                                                        ^^^^^^ not found in this scope

error[E0412]: cannot find type `ConfigBuilder` in this scope
 --> /tmp/.tmpODijVq/main.rs:1:180
  |
1 | ... () ; server . respond () } } fn main () { impl ConfigBuilder { } ; }
  |                                                    ^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpODijVq/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; async fn request_flow () { { client . send_request () ; server . validate () ; server . process () ; ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpODijVq/main.rs:1:198
  |
1 | ... respond () } } fn main () { impl ConfigBuilder { } ; }
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error: aborting due to 6 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0412, E0425, E0670.
For more information about an error, try `rustc --explain E0412`.



=== ch17-00-documentation example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch06-00-file-operations example 1 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmpeCf3i7/main.rs:1:133
  |
1 | ... = { Documents : vec ! [".pdf" , ".doc" , ".docx" , ".txt"] , Images : vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"] , Videos : vec ! [".mp4" , ".avi" , ".mov" , ".mkv"] , Code : vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"] , Data : vec ! [".csv" , ".json" , ".xml" , ".xlsx"] , } ; ...
  |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Desktop Organizer ===") ; let mut file_categories = { SomeStruct { Documents : vec ! [".pdf" , ".doc" , ".docx" , ".txt"] , Images : vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"] , Videos : vec ! [".mp4" , ".avi" , ".mov" , ".mkv"] , Code : vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"] , Data : vec ! [".csv" , ".json" , ".xml" , ".xlsx"] , } } ; let mut source_dir = "~/Desktop" . to_string () ; let mut files = list_files (source_dir) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } } } } ; println ! ("✅ Desktop organized!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |                                                                                                                                     ++++++++++++                                                                                                                                                                                                                                                                                                  +

error[E0425]: cannot find function `create_dir` in this scope
 --> /tmp/.tmpeCf3i7/main.rs:1:903
  |
1 | ... , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , format ! ("{}{}" , "Created folder: " , ...
  |                                                      ^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::create_dir;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpeCf3i7/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Desktop Organizer ===") ; let mut file_categories = { Doc...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpeCf3i7/main.rs:1:656
  |
1 | ... { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Desktop Organizer ===") ; let mut file_categories = { Documents : vec ! [".pdf" , ".doc" , ".docx" , ".txt"] , Images : vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"] , Videos : vec ! [".mp4" , ".avi" , ".mov" , ".mkv"] , Code : vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"] , Data : vec ! [".csv" , ".json" , ".xml" , ".xlsx"] , } ; let mut source_dir = "~/Desktop" . to_string () ; let mut files = list_files (source_dir) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } } } } ; println ! ("✅ Desktop organized!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Desktop Organizer ===") ; let mut file_categories = { Documents : vec ! [".pdf" , ".doc" , ".docx" , ".txt"] , Images : vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"] , Videos : vec ! [".mp4" , ".avi" , ".mov" , ".mkv"] , Code : vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"] , Data : vec ! [".csv" , ".json" , ".xml" , ".xlsx"] , } ; let mut source_dir = "~/Desktop" . to_string () ; let mut files = list_files (source_dir) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } } } ; println ! ("✅ Desktop organized!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpeCf3i7/main.rs:1:770
  |
1 | ... { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Desktop Organizer ===") ; let mut file_categories = { Documents : vec ! [".pdf" , ".doc" , ".docx" , ".txt"] , Images : vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"] , Videos : vec ! [".mp4" , ".avi" , ".mov" , ".mkv"] , Code : vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"] , Data : vec ! [".csv" , ".json" , ".xml" , ".xlsx"] , } ; let mut source_dir = "~/Desktop" . to_string () ; let mut files = list_files (source_dir) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } } } } ; println ! ("✅ Desktop organized!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Desktop Organizer ===") ; let mut file_categories = { Documents : vec ! [".pdf" , ".doc" , ".docx" , ".txt"] , Images : vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"] , Videos : vec ! [".mp4" , ".avi" , ".mov" , ".mkv"] , Code : vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"] , Data : vec ! [".csv" , ".json" , ".xml" , ".xlsx"] , } ; let mut source_dir = "~/Desktop" . to_string () ; let mut files = list_files (source_dir) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } } } ; println ! ("✅ Desktop organized!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpeCf3i7/main.rs:1:811
  |
1 | ... { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Desktop Organizer ===") ; let mut file_categories = { Documents : vec ! [".pdf" , ".doc" , ".docx" , ".txt"] , Images : vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"] , Videos : vec ! [".mp4" , ".avi" , ".mov" , ".mkv"] , Code : vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"] , Data : vec ! [".csv" , ".json" , ".xml" , ".xlsx"] , } ; let mut source_dir = "~/Desktop" . to_string () ; let mut files = list_files (source_dir) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } } } } ; println ! ("✅ Desktop organized!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Desktop Organizer ===") ; let mut file_categories = { Documents : vec ! [".pdf" , ".doc" , ".docx" , ".txt"] , Images : vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"] , Videos : vec ! [".mp4" , ".avi" , ".mov" , ".mkv"] , Code : vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"] , Data : vec ! [".csv" , ".json" , ".xml" , ".xlsx"] , } ; let mut source_dir = "~/Desktop" . to_string () ; let mut files = list_files (source_dir) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } } } ; println ! ("✅ Desktop organized!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `list_files` in this scope
 --> /tmp/.tmpeCf3i7/main.rs:1:490
  |
1 | ...ir = "~/Desktop" . to_string () ; let mut files = list_files (source_dir) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "F...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `get_extension` in this scope
 --> /tmp/.tmpeCf3i7/main.rs:1:676
  |
1 | ...ze")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . ite...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpeCf3i7/main.rs:1:832
  |
1 | ...ons . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (t...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `dir_exists` in this scope
 --> /tmp/.tmpeCf3i7/main.rs:1:875
  |
1 | ..._dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , format ! ("{...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpeCf3i7/main.rs:1:1021
  |
1 | ...ted folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpeCf3i7/main.rs:1:1075
  |
1 | ..._path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" ,...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `move_file` in this scope
 --> /tmp/.tmpeCf3i7/main.rs:1:1107
  |
1 | ...mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , format ! ("{}{}" , format ! ("{...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 9 previous errors; 4 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch06-00-file-operations example 2 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpYW4gZS/main.rs:1:541
  |
1 | ...(".././data//file.txt" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0425]: cannot find function `set_current_dir` in this scope
 --> /tmp/.tmpYW4gZS/main.rs:1:108
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; set_current_dir ("/home/user/p...
  |                                                                                                            ^^^^^^^^^^^^^^^
  |
help: a local variable with a similar name exists
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; set_current_dir ("/home/user/projects" . to_string ()) ; let mut full_path = absolute_path ("data.txt" . to_string ()) ; let mut parent = parent_dir (full_path) ; let mut filename = file_name (full_path) ; let mut extension = file_extension (full_path) ; let mut project_path = join_path (home_dir () , "projects" . to_string () , "my_app" . to_string ()) ; let mut clean_path = normalize_path (".././data//file.txt" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; current_dir ("/home/user/projects" . to_string ()) ; let mut full_path = absolute_path ("data.txt" . to_string ()) ; let mut parent = parent_dir (full_path) ; let mut filename = file_name (full_path) ; let mut extension = file_extension (full_path) ; let mut project_path = join_path (home_dir () , "projects" . to_string () , "my_app" . to_string ()) ; let mut clean_path = normalize_path (".././data//file.txt" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |
help: consider importing this function
  |
1 + use std::env::set_current_dir;
  |

error[E0425]: cannot find function `home_dir` in this scope
 --> /tmp/.tmpYW4gZS/main.rs:1:397
  |
1 | ...on (full_path) ; let mut project_path = join_path (home_dir () , "projects" . to_string () , "my_app" . to_string ()) ; let mut clean_...
  |                                                       ^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::env::home_dir;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpYW4gZS/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; set_current_dir ("/home/user/p...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `get_current_dir` in this scope
 --> /tmp/.tmpYW4gZS/main.rs:1:87
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; set_current_dir ("/home/user/p...
  |                                                                                       ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `absolute_path` in this scope
 --> /tmp/.tmpYW4gZS/main.rs:1:185
  |
1 | ...projects" . to_string ()) ; let mut full_path = absolute_path ("data.txt" . to_string ()) ; let mut parent = parent_dir (full_path) ; ...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `parent_dir` in this scope
 --> /tmp/.tmpYW4gZS/main.rs:1:246
  |
1 | ...tring ()) ; let mut parent = parent_dir (full_path) ; let mut filename = file_name (full_path) ; let mut extension = file_extension (f...
  |                                 ^^^^^^^^^^ help: a local variable with a similar name exists: `current_dir`

error[E0425]: cannot find function `file_name` in this scope
 --> /tmp/.tmpYW4gZS/main.rs:1:290
  |
1 | ...ent = parent_dir (full_path) ; let mut filename = file_name (full_path) ; let mut extension = file_extension (full_path) ; let mut pro...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_extension` in this scope
 --> /tmp/.tmpYW4gZS/main.rs:1:334
  |
1 | ...e = file_name (full_path) ; let mut extension = file_extension (full_path) ; let mut project_path = join_path (home_dir () , "projects...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpYW4gZS/main.rs:1:386
  |
1 | ...le_extension (full_path) ; let mut project_path = join_path (home_dir () , "projects" . to_string () , "my_app" . to_string ()) ; let ...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 9 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch06-00-file-operations example 3 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpcfPO6y/main.rs:1:562
  |
1 | ...mut can_execute = is_executable (path) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpcfPO6y/main.rs:1:344
  |
1 | ..."system.conf" . to_string ()) ; let mut is_file = is_file (path) ; let mut is_dir = is_directory (path) ; let mut is_symlink = is_symb...
  |                                                               ^^^^ not a value

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpcfPO6y/main.rs:1:383
  |
1 | ... is_file = is_file (path) ; let mut is_dir = is_directory (path) ; let mut is_symlink = is_symbolic_link (path) ; let mut can_read = i...
  |                                                               ^^^^ not a value

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpcfPO6y/main.rs:1:430
  |
1 | ..._directory (path) ; let mut is_symlink = is_symbolic_link (path) ; let mut can_read = is_readable (path) ; let mut can_write = is_writ...
  |                                                               ^^^^ not a value

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpcfPO6y/main.rs:1:470
  |
1 | ... is_symbolic_link (path) ; let mut can_read = is_readable (path) ; let mut can_write = is_writable (path) ; let mut can_execute = is_e...
  |                                                               ^^^^ not a value

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpcfPO6y/main.rs:1:511
  |
1 | ...ad = is_readable (path) ; let mut can_write = is_writable (path) ; let mut can_execute = is_executable (path) } ; if let Some (s) = (&...
  |                                                               ^^^^ not a value

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpcfPO6y/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut exists = file_exists ("config.json" . to_string ()) ; let mut siz...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpcfPO6y/main.rs:1:82
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut exists = file_exists ("config.json" . to_string ()) ; let mut siz...
  |                                                                                  ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_size` in this scope
 --> /tmp/.tmpcfPO6y/main.rs:1:142
  |
1 | ...s ("config.json" . to_string ()) ; let mut size = file_size ("data.csv" . to_string ()) ; let mut modified = file_modified_time ("log....
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_modified_time` in this scope
 --> /tmp/.tmpcfPO6y/main.rs:1:201
  |
1 | ...ata.csv" . to_string ()) ; let mut modified = file_modified_time ("log.txt" . to_string ()) ; let mut is_read_only = is_readonly ("sys...
  |                                                  ^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_readonly` in this scope
 --> /tmp/.tmpcfPO6y/main.rs:1:272
  |
1 | ...og.txt" . to_string ()) ; let mut is_read_only = is_readonly ("system.conf" . to_string ()) ; let mut is_file = is_file (path) ; let m...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_file` in this scope
 --> /tmp/.tmpcfPO6y/main.rs:1:335
  |
1 | ...("system.conf" . to_string ()) ; let mut is_file = is_file (path) ; let mut is_dir = is_directory (path) ; let mut is_symlink = is_sym...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_directory` in this scope
 --> /tmp/.tmpcfPO6y/main.rs:1:369
  |
1 | ... mut is_file = is_file (path) ; let mut is_dir = is_directory (path) ; let mut is_symlink = is_symbolic_link (path) ; let mut can_read...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_symbolic_link` in this scope
 --> /tmp/.tmpcfPO6y/main.rs:1:412
  |
1 | ...r = is_directory (path) ; let mut is_symlink = is_symbolic_link (path) ; let mut can_read = is_readable (path) ; let mut can_write = i...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_readable` in this scope
 --> /tmp/.tmpcfPO6y/main.rs:1:457
  |
1 | ...k = is_symbolic_link (path) ; let mut can_read = is_readable (path) ; let mut can_write = is_writable (path) ; let mut can_execute = i...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_writable` in this scope
 --> /tmp/.tmpcfPO6y/main.rs:1:498
  |
1 | ..._read = is_readable (path) ; let mut can_write = is_writable (path) ; let mut can_execute = is_executable (path) } ; if let Some (s) =...
  |                                                     ^^^^^^^^^^^ not found in this scope

error: aborting due to 15 previous errors; 1 warning emitted

Some errors have detailed explanations: E0423, E0425.
For more information about an error, try `rustc --explain E0423`.



=== ch06-00-file-operations example 4 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `create_dir` in this scope
 --> /tmp/.tmpAo3k12/main.rs:1:406
  |
1 | ... process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" ....
  |                                                      ^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::create_dir;
  |

error[E0425]: cannot find function `create_dir_all` in this scope
 --> /tmp/.tmpAo3k12/main.rs:1:449
  |
1 | ...() { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" ....
  |                                                    ^^^^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::create_dir_all;
  |

error[E0425]: cannot find function `remove_dir` in this scope
 --> /tmp/.tmpAo3k12/main.rs:1:507
  |
1 | ...ir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" ...
  |                                                      ^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_dir;
  |

error[E0425]: cannot find function `remove_dir_all` in this scope
 --> /tmp/.tmpAo3k12/main.rs:1:552
  |
1 | ... ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_dir_all;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpAo3k12/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpAo3k12/main.rs:1:202
  |
1 | ... { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } ...
  |       ^^                                                                                                                                                                                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
1 + use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpAo3k12/main.rs:1:255
  |
1 | ... { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } ...
  |       ^^                                                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
1 + use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpAo3k12/main.rs:1:320
  |
1 | ...h = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
1 + use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { walk_directory (path) } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpAo3k12/main.rs:1:355
  |
1 | ..._directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . t...
  |                                                           ^^                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
1 + use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { process_file (path) } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
  |

error[E0425]: cannot find function `list_dir` in this scope
 --> /tmp/.tmpAo3k12/main.rs:1:218
  |
1 | ...: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpAo3k12/main.rs:1:270
  |
1 | ...st_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else {...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_directory` in this scope
 --> /tmp/.tmpAo3k12/main.rs:1:298
  |
1 | ...ems { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } ...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0277]: cannot add `()` to `()`
 --> /tmp/.tmpAo3k12/main.rs:1:338
  |
1 | ... , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (...
  |                                          --------------  ^^^^ no implementation for `() + ()`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `()`
note: required by a bound in `walk_directory`
 --> /tmp/.tmpAo3k12/main.rs:1:61
  |
1 | ...ap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt ...
  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `walk_directory`

error[E0277]: cannot multiply `()` by `()`
 --> /tmp/.tmpAo3k12/main.rs:1:338
  |
1 | ... , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (...
  |                                          --------------  ^^^^ no implementation for `() * ()`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `()`
note: required by a bound in `walk_directory`
 --> /tmp/.tmpAo3k12/main.rs:1:96
  |
1 | ... ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T {...
  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `walk_directory`

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpAo3k12/main.rs:1:338
  |
1 | ... if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folde...
  |                                --------------  ^^^^ the trait `std::fmt::Display` is not implemented for `()`
  |                                |
  |                                required by a bound introduced by this call
  |
note: required by a bound in `walk_directory`
 --> /tmp/.tmpAo3k12/main.rs:1:131
  |
1 | ...std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (di...
  |                                       ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `walk_directory`

error[E0425]: cannot find function `process_file` in this scope
 --> /tmp/.tmpAo3k12/main.rs:1:357
  |
1 | ...ry (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpAo3k12/main.rs:1:235
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } ...
  |       -                                                                                                                                            -                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |       |                                                                                                                                            |
  |       expected this type parameter                                                                                                                 expected `T` because of return type
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: the caller chooses a type for `T` which can be different from `()`
  = note: `for` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } /* `T` value */ } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                   +++++++++++++++

error[E0425]: cannot find function `list_dir` in this scope
 --> /tmp/.tmpAo3k12/main.rs:1:629
  |
1 | ...th_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `list_files` in this scope
 --> /tmp/.tmpAo3k12/main.rs:1:682
  |
1 | ...t_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_str...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `list_directories` in this scope
 --> /tmp/.tmpAo3k12/main.rs:1:736
  |
1 | ...les ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 15 previous errors; 5 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0425.
For more information about an error, try `rustc --explain E0277`.



=== ch06-00-file-operations example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch06-00-file-operations example 6 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmpc7aTcH/main.rs:1:749
  |
1 | ...{ duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { { file_ha...
  |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ SomeStruct { original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , } }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ++++++++++++                                                                                             +

error[E0425]: cannot find value `min_size` in this scope
 --> /tmp/.tmpc7aTcH/main.rs:1:649
  |
1 | ...th) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { du...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `file_hashes` in this scope
 --> /tmp/.tmpc7aTcH/main.rs:1:697
  |
1 | ... min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `duplicates` in this scope
 --> /tmp/.tmpc7aTcH/main.rs:1:730
  |
1 | ...file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , siz...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `file_hashes` in this scope
 --> /tmp/.tmpc7aTcH/main.rs:1:855
  |
1 | ...th , size : size , hash : hash , }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `remove_file` in this scope
 --> /tmp/.tmpc7aTcH/main.rs:1:2987
  |
1 | ... . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , du...
  |                                                     ^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_file;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpc7aTcH/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpc7aTcH/main.rs:1:198
  |
1 | ...Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: o...
  |                                      ^^                                                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { let content = read_bytes (path) ; return sha256 (content) } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpc7aTcH/main.rs:1:431
  |
1 | ... { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpc7aTcH/main.rs:1:484
  |
1 | ... { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpc7aTcH/main.rs:1:549
  |
1 | ...h = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size ...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { scan_directory (path) } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpc7aTcH/main.rs:1:604
  |
1 | ... { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash as usize] = path } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpc7aTcH/main.rs:1:660
  |
1 | ... { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash as usize] = path } } } } } ...
  |       ^^                                                                                                                                                                                                                                         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpc7aTcH/main.rs:1:728
  |
1 | ...(hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { ...
  |             ^^                                                                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpc7aTcH/main.rs:1:853
  |
1 | ...ath , size : size , hash : hash , }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { printl...
  |                                                    ^^                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { file_hashes [hash as usize] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpc7aTcH/main.rs:1:1957
  |
1 | ...earch_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , format ! ("{}{}...
  |                                               ^^                                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { println ! ("\n✅ No duplicate files found!") } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

error[E0425]: cannot find function `read_bytes` in this scope
 --> /tmp/.tmpc7aTcH/main.rs:1:216
  |
1 | ...bug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `sha256` in this scope
 --> /tmp/.tmpc7aTcH/main.rs:1:243
  |
1 | ...-> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + ...
  |                                                        ^^^^^^ not found in this scope

error[E0425]: cannot find function `list_dir` in this scope
 --> /tmp/.tmpc7aTcH/main.rs:1:447
  |
1 | ...: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpc7aTcH/main.rs:1:499
  |
1 | ...st_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else {...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_directory` in this scope
 --> /tmp/.tmpc7aTcH/main.rs:1:527
  |
1 | ...ems { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let ...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0277]: cannot add `()` to `()`
 --> /tmp/.tmpc7aTcH/main.rs:1:567
  |
1 | ... , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >...
  |                                          --------------  ^^^^ no implementation for `() + ()`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `()`
note: required by a bound in `scan_directory`
 --> /tmp/.tmpc7aTcH/main.rs:1:290
  |
1 | ... } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt ...
  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `scan_directory`

error[E0277]: cannot multiply `()` by `()`
 --> /tmp/.tmpc7aTcH/main.rs:1:567
  |
1 | ... , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >...
  |                                          --------------  ^^^^ no implementation for `() * ()`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `()`
note: required by a bound in `scan_directory`
 --> /tmp/.tmpc7aTcH/main.rs:1:325
  |
1 | ... ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T {...
  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `scan_directory`

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpc7aTcH/main.rs:1:567
  |
1 | ... if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size...
  |                                --------------  ^^^^ the trait `std::fmt::Display` is not implemented for `()`
  |                                |
  |                                required by a bound introduced by this call
  |
note: required by a bound in `scan_directory`
 --> /tmp/.tmpc7aTcH/main.rs:1:360
  |
1 | ...std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (di...
  |                                       ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `scan_directory`

error[E0425]: cannot find function `is_file` in this scope
 --> /tmp/.tmpc7aTcH/main.rs:1:587
  |
1 | ...ory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let ha...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_size` in this scope
 --> /tmp/.tmpc7aTcH/main.rs:1:619
  |
1 | ...th) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_h...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpc7aTcH/main.rs:1:464
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } ...
  |       -                                                                                                                                            -                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |       |                                                                                                                                            |
  |       expected this type parameter                                                                                                                 expected `T` because of return type
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: the caller chooses a type for `T` which can be different from `()`
  = note: `for` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash as usize] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } /* `T` value */ } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  +++++++++++++++

error[E0599]: no method named `to_i` found for struct `String` in the current scope
 --> /tmp/.tmpc7aTcH/main.rs:1:1732
  |
1 | ...ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , se...
  |                                                      ^^^^ method not found in `String`

error[E0277]: cannot add `String` to `String`
 --> /tmp/.tmpc7aTcH/main.rs:1:1913
  |
1 | ...; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files foun...
  |                                      --------------  ^^^^^^^^^^ no implementation for `String + String`
  |                                      |
  |                                      required by a bound introduced by this call
  |
  = help: the trait `Add<String>` is not implemented for `String`
          but trait `Add<&str>` is implemented for it
  = help: for that trait implementation, expected `&str`, found `String`
note: required by a bound in `scan_directory`
 --> /tmp/.tmpc7aTcH/main.rs:1:290
  |
1 | ... } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt ...
  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `scan_directory`

error[E0277]: cannot multiply `String` by `String`
 --> /tmp/.tmpc7aTcH/main.rs:1:1913
  |
1 | ...; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files foun...
  |                                      --------------  ^^^^^^^^^^ no implementation for `String * String`
  |                                      |
  |                                      required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `String`
note: required by a bound in `scan_directory`
 --> /tmp/.tmpc7aTcH/main.rs:1:325
  |
1 | ... ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T {...
  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `scan_directory`

error[E0599]: no method named `to_s` found for type `usize` in the current scope
 --> /tmp/.tmpc7aTcH/main.rs:1:2118
  |
1 | ...}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplica...
  |                                                       ^^^^ method not found in `usize`

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpc7aTcH/main.rs:1:2403
  |
1 | ... println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , forma...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpc7aTcH/main.rs:1:2529
  |
1 | ... , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicate...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `lower` found for struct `String` in the current scope
 --> /tmp/.tmpc7aTcH/main.rs:1:2941
  |
1 | ...\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; printl...
  |                                                      ^^^^^ method not found in `String`

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpc7aTcH/main.rs:1:3165
  |
1 | ...at ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |                                                      ^^^^^^^^^^^ not found in this scope

error: aborting due to 25 previous errors; 10 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0425, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch06-00-file-operations example 7 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmpXtfYm4/main.rs:1:130
  |
1 | ...") ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = "/var/...
  |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===") ; let mut log_config = { SomeStruct { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } } ; let mut log_dir = "/var/log/myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |                                                                                                                                  ++++++++++++                                                                                   +

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmpXtfYm4/main.rs:1:612
  |
1 | ..., " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = for...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0425]: cannot find function `remove_file` in this scope
 --> /tmp/.tmpXtfYm4/main.rs:1:899
  |
1 | ... { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } }...
  |                                                     ^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_file;
  |

error[E0425]: cannot find function `remove_file` in this scope
 --> /tmp/.tmpXtfYm4/main.rs:1:1193
  |
1 | ...ath , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "...
  |                                                     ^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_file;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpXtfYm4/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===") ; let mut log_config = { max_si...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpXtfYm4/main.rs:1:368
  |
1 | ... { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===") ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = "/var/log/myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===") ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = "/var/log/myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXtfYm4/main.rs:1:670
  |
1 | ... { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===") ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = "/var/log/myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===") ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = "/var/log/myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXtfYm4/main.rs:1:853
  |
1 | ... { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } }...
  |       ^^                                                                                                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===") ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = "/var/log/myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===") ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = "/var/log/myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXtfYm4/main.rs:1:897
  |
1 | ...ackup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } }...
  |                                                         ^^                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===") ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = "/var/log/myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===") ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = "/var/log/myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { remove_file (old_backup) } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXtfYm4/main.rs:1:935
  |
1 | ... 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! (...
  |                                                  ^^                                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===") ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = "/var/log/myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===") ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = "/var/log/myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { rename_file (old_backup , new_backup) } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpXtfYm4/main.rs:1:292
  |
1 | ...myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `glob` in this scope
 --> /tmp/.tmpXtfYm4/main.rs:1:286
  |
1 | .../var/log/myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files {...
  |                                                         ^^^^ not found in this scope

error[E0425]: cannot find function `file_size` in this scope
 --> /tmp/.tmpXtfYm4/main.rs:1:383
  |
1 | ...())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpXtfYm4/main.rs:1:570
  |
1 | ...at ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpXtfYm4/main.rs:1:813
  |
1 | ...p = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 ...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpXtfYm4/main.rs:1:826
  |
1 | ...}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `rename_file` in this scope
 --> /tmp/.tmpXtfYm4/main.rs:1:937
  |
1 | ...- 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `rename_file` in this scope
 --> /tmp/.tmpXtfYm4/main.rs:1:1053
  |
1 | ...p_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (ba...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `compress_file` in this scope
 --> /tmp/.tmpXtfYm4/main.rs:1:1121
  |
1 | ...e , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (b...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpXtfYm4/main.rs:1:1327
  |
1 | ..."  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  ...
  |                                                      ^^^^^^^^^^ not found in this scope

error: aborting due to 14 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0425, E0599.
For more information about an error, try `rustc --explain E0425`.



=== ch06-00-file-operations example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch06-00-file-operations example 9 ===
✗ Compilation failed: Compilation failed:
error[E0423]: expected value, found macro `try`
 --> /tmp/.tmpcfR0Cm/main.rs:1:460
  |
1 | ...: No read permission for: " , path)) ; return false } } ; r#try ; { { let content = read_file (path) ; { process_content (content) ; r...
  |                                                              ^^^^^ not a value

error[E0425]: cannot find value `catch` in this scope
 --> /tmp/.tmpcfR0Cm/main.rs:1:555
  |
1 | ...; { process_content (content) ; return true } } } ; catch ; error ; { println ! ("{}" , format ! ("{}{}" , "Error processing file: " ,...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpcfR0Cm/main.rs:1:563
  |
1 | ...ess_content (content) ; return true } } } ; catch ; error ; { println ! ("{}" , format ! ("{}{}" , "Error processing file: " , error ....
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpcfR0Cm/main.rs:1:638
  |
1 | ...}" , format ! ("{}{}" , "Error processing file: " , error . to_s ())) ; { let error_log = "errors.log" . to_string () ; { let mut time...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpcfR0Cm/main.rs:1:878
  |
1 | ...{}" , timestamp . to_s () , ": ") + path , " - ") + error . to_s () , "\n")) ; return false } } } } } fn main () { }
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpcfR0Cm/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn safe_file_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + st...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpcfR0Cm/main.rs:1:215
  |
1 | ... fmt :: Debug + Clone > (path : T) -> T { { if ! file_exists (path) { { println ! ("{}" , format ! ("{}{}" , "Error: File not found: "...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpcfR0Cm/main.rs:1:319
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { if ! file_exists (path) { { println ! ("{}" , format ! ("{}{}" , "Error: File not found: " , path)) ; return false } ...
  |       - expected this type parameter                                                                                                                - expected `T` because of return type                                                                              ^^^^^ expected type parameter `T`, found `bool`
  |
  = note: expected type parameter `T`
                       found type `bool`
  = note: the caller chooses a type for `T` which can be different from `bool`

error[E0425]: cannot find function `is_readable` in this scope
 --> /tmp/.tmpcfR0Cm/main.rs:1:336
  |
1 | ... not found: " , path)) ; return false } } ; if ! is_readable (path) { { println ! ("{}" , format ! ("{}{}" , "Error: No read permissio...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpcfR0Cm/main.rs:1:486
  |
1 | ...)) ; return false } } ; r#try ; { { let content = read_file (path) ; { process_content (content) ; return true } } } ; catch ; error ;...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `process_content` in this scope
 --> /tmp/.tmpcfR0Cm/main.rs:1:507
  |
1 | ...r#try ; { { let content = read_file (path) ; { process_content (content) ; return true } } } ; catch ; error ; { println ! ("{}" , for...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

warning: unreachable statement
 --> /tmp/.tmpcfR0Cm/main.rs:1:555
  |
1 | ...th) ; { process_content (content) ; return true } } } ; catch ; error ; { println ! ("{}" , format ! ("{}{}" , "Error processing file:...
  |                                        -----------         ^^^^^^^ unreachable statement
  |                                        |
  |                                        any code following this expression is unreachable
  |
  = note: `#[warn(unreachable_code)]` on by default

error[E0425]: cannot find function `current_datetime` in this scope
 --> /tmp/.tmpcfR0Cm/main.rs:1:728
  |
1 | ...rs.log" . to_string () ; { let mut timestamp = current_datetime () ; append_file (error_log , format ! ("{}{}" , format ! ("{}{}" , fo...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpcfR0Cm/main.rs:1:862
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { if ! file_exists (path) { { println ! ("{}" , format ! ("{}{}" , "Error: File not found: " , path)) ; return false } } ; if ! is_readable (path) { { println ! ("{}" , format ! ("{}{}" , "Error: No read permission for: " , path)) ; return false } } ; r#try ; { { let content = read_file (path) ; { process_content (content) ; return true } } } ; catch ; error ; { println ! ("{}" , format ! ("{}{}" , "Error processing file: " , error . to_s ())) ; { let error_log = "errors.log" . to_string () ; { let mut timestamp = current_datetime () ; append_file (error_log , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , timestamp . to_s () , ": ") + path , ...
  |       - found this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^^^^ expected `&str`, found type parameter `T`
  |
  = note:   expected reference `&str`
          found type parameter `T`

error[E0425]: cannot find function `append_file` in this scope
 --> /tmp/.tmpcfR0Cm/main.rs:1:750
  |
1 | ...() ; { let mut timestamp = current_datetime () ; append_file (error_log , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , tim...
  |                                                     ^^^^^^^^^^^ not found in this scope

error: aborting due to 13 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0308, E0423, E0425.
For more information about an error, try `rustc --explain E0308`.



=== ch06-00-file-operations example 10 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpFrHREd/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files ("data" . to_string ()) ; for file in files { ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpFrHREd/main.rs:1:138
  |
1 | ... { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } }...
  |       ^^                                                                                                                           ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files ("data" . to_string ()) ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files ("data" . to_string ()) ; for file in files { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpFrHREd/main.rs:1:195
  |
1 | ...ze (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } } ; if let Some (s) = (& r...
  |                                       ^^                                                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files ("data" . to_string ()) ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files ("data" . to_string ()) ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `list_files` in this scope
 --> /tmp/.tmpFrHREd/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files ("data" . to_string ()) ; for file in files { ...
  |                                                                                 ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_size` in this scope
 --> /tmp/.tmpFrHREd/main.rs:1:153
  |
1 | ...o_string ()) ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "la...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `move_file` in this scope
 --> /tmp/.tmpFrHREd/main.rs:1:197
  |
1 | ...ize = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } } ; if let So...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch20-00-tooling example 1 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpvlYdll/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } }...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpvlYdll/main.rs:1:72
  |
1 | ... calculate_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = ...
  |                                     ^^                                                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{}" , result) } } }
1 + use std :: collections :: HashMap ; fn calculate_something (x : i64) { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{}" , result) } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpvlYdll/main.rs:1:156
  |
1 | ...eturn y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{}" , result) } } }
  |                                 ^^                                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{}" , result) } } }
1 + use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { let result = calculate_something (10i32) ; println ! ("{}" , result) } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpvlYdll/main.rs:1:119
  |
1 | ...) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ;...
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot add `i32` to `i64`
 --> /tmp/.tmpvlYdll/main.rs:1:117
  |
1 | ...) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ;...
  |                                                     ^ no implementation for `i64 + i32`
  |
  = help: the trait `Add<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Add<Rhs>`:
            `&i64` implements `Add<i64>`
            `&i64` implements `Add`
            `i64` implements `Add<&i64>`
            `i64` implements `Add`

error[E0308]: mismatched types
 --> /tmp/.tmpvlYdll/main.rs:1:133
  |
1 | ...e_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate...
  |                         - help: try adding a return type: `-> i64`                      ^ expected `()`, found `i64`

error[E0308]: mismatched types
 --> /tmp/.tmpvlYdll/main.rs:1:194
  |
1 | ... } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{}" , result) } } }
  |                                         -------------------  ^^^^^ expected `i64`, found `i32`
  |                                         |
  |                                         arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpvlYdll/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } }...
  |                                        ^^^^^^^^^^^^^^^^^^^  -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{}" , result) } } }
1 + use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i64) ; println ! ("{}" , result) } } }
  |

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpvlYdll/main.rs:1:221
  |
1 | ...te_something (10i32) ; println ! ("{}" , result) } } }
  |                                       --    ^^^^^^ `()` cannot be formatted with the default formatter
  |                                       |
  |                                       required by this formatting parameter
  |
  = help: the trait `std::fmt::Display` is not implemented for `()`
  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 5 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.



=== ch20-00-tooling example 2 ===
✗ Compilation failed: Compilation failed:
error[E0428]: the name `fibonacci` is defined multiple times
 --> /tmp/.tmpFXqduh/main.rs:1:175
  |
1 | ... ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn fibonacci (n : i64) -> i64 { ...
  |       ----------------------------- previous definition of the value `fibonacci` here                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `fibonacci` redefined here
  |
  = note: `fibonacci` must be defined only once in the value namespace of this module

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpFXqduh/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpFXqduh/main.rs:1:69
  |
1 | ... i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn fibonacci ...
  |                   ^^                                                                                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpFXqduh/main.rs:1:86
  |
1 | use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1...
  |                                                                                      ^^ ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { n } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpFXqduh/main.rs:1:101
  |
1 | ... { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn fibonacci (n : i64) -> i...
  |                                     ^^                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpFXqduh/main.rs:1:207
  |
1 | ... i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn main () { }
  |                   ^^                                                                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn fibonacci (n : i64) -> i64 { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpFXqduh/main.rs:1:224
  |
1 | ...2i32)) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (...
  |                                                                    ^^ ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { n } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpFXqduh/main.rs:1:239
  |
1 | ... { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn main () { }
  |                                     ^^                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpFXqduh/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1...
  |                                                                          -    ^^^^ expected `i64`, found `i32`
  |                                                                          |
  |                                                                          expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i64 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpFXqduh/main.rs:1:137
  |
1 | ...{ n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i3...
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmpFXqduh/main.rs:1:135
  |
1 | ...{ n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i3...
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmpFXqduh/main.rs:1:160
  |
1 | ... ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fo...
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmpFXqduh/main.rs:1:158
  |
1 | ... ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fo...
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmpFXqduh/main.rs:1:103
  |
1 | ...(n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn fibona...
  |                 ---                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `String`
  |                 |
  |                 expected `i64` because of return type
  |
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
 --> /tmp/.tmpFXqduh/main.rs:1:217
  |
1 | ...)) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - ...
  |                                                    -    ^^^^ expected `i64`, found `i32`
  |                                                    |
  |                                                    expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i64 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpFXqduh/main.rs:1:275
  |
1 | ...{ n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn main () { }
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmpFXqduh/main.rs:1:273
  |
1 | ...{ n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn main () { }
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmpFXqduh/main.rs:1:298
  |
1 | ... ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn main () { }
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmpFXqduh/main.rs:1:296
  |
1 | ... ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn main () { }
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmpFXqduh/main.rs:1:241
  |
1 | ...(n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci (n - 1i32) , fibonacci (n - 2i32)) } } } } fn main (...
  |                 ---                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `String`
  |                 |
  |                 expected `i64` because of return type
  |
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 13 previous errors; 7 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0428.
For more information about an error, try `rustc --explain E0277`.



=== ch20-00-tooling example 3 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpMzgPHW/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpMzgPHW/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                                                         ^^     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { a + b } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpMzgPHW/main.rs:1:126
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                                                                                                              ^^     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { a * b } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpMzgPHW/main.rs:1:170
  |
1 | ... { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (...
  |                                                 ^^^  ----   ---- expected `i64`, found `i32`
  |                                                      |
  |                                                      expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpMzgPHW/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                        ^^^  -------   -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i64 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i64) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpMzgPHW/main.rs:1:190
  |
1 | ...n test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) ,...
  |                                                       ^^^^ expected `i64`, found `i32`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i64) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpMzgPHW/main.rs:1:211
  |
1 | ...! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply ...
  |                                                ^^^  ------   ---- expected `i64`, found `i32`
  |                                                     |
  |                                                     expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpMzgPHW/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                        ^^^  -------   -------
help: you can convert an `i32` to an `i64`
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add ((- 1i32).into() , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                                                                                                        +      ++++++++
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i64) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpMzgPHW/main.rs:1:233
  |
1 | ...3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_e...
  |                                                       ^^^^ expected `i64`, found `i32`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i64) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpMzgPHW/main.rs:1:254
  |
1 | ... (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32)...
  |                                                 ^^^  ----   ---- expected `i64`, found `i32`
  |                                                      |
  |                                                      expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpMzgPHW/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                        ^^^  -------   -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i64 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i64) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpMzgPHW/main.rs:1:274
  |
1 | ..., 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; ass...
  |                                                       ^^^^ expected `i64`, found `i32`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i64) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpMzgPHW/main.rs:1:321
  |
1 | ... } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq...
  |                                              ^^^^^^^^  ----   ---- expected `i64`, found `i32`
  |                                                        |
  |                                                        expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpMzgPHW/main.rs:1:88
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                                                                        ^^^^^^^^  -------   -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i64 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i64) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpMzgPHW/main.rs:1:346
  |
1 | ...tiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i...
  |                                                       ^^^^ expected `i64`, found `i32`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i64) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpMzgPHW/main.rs:1:367
  |
1 | ...ply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn mai...
  |                                             ^^^^^^^^  ------   ---- expected `i64`, found `i32`
  |                                                       |
  |                                                       expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpMzgPHW/main.rs:1:88
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                                                                        ^^^^^^^^  -------   -------
help: you can convert an `i32` to an `i64`
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply ((- 1i32).into() , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                         +      ++++++++
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i64) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpMzgPHW/main.rs:1:394
  |
1 | ..., 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                      ^^^^^^ expected `i64`, found `i32`
  |
help: you can convert an `i32` to an `i64`
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , (- 5i32).into()) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                          +      ++++++++

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpMzgPHW/main.rs:1:417
  |
1 | ...(- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                             ^^^^^^^^  ----   ------ expected `i64`, found `i32`
  |                                                       |
  |                                                       expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpMzgPHW/main.rs:1:88
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                                                                        ^^^^^^^^  -------   -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i64 , 100i32) , 0i32) } } fn main () { }
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i64) , 0i32) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpMzgPHW/main.rs:1:444
  |
1 | ... - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                       ^^^^ expected `i64`, found `i32`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i64) } } fn main () { }
  |

error: aborting due to 12 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch20-00-tooling example 4 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmppNpw46/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { { ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmppNpw46/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { { ...
  |                                                                                ^^ ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq ! (reverse_string (reverse_string (s)) , s) }) } } fn main () { }
1 + use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { s } fn property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq ! (reverse_string (reverse_string (s)) , s) }) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmppNpw46/main.rs:1:136
  |
1 | ...e_twice_is_identity () { { property_test (| s | { assert_eq ! (reverse_string (reverse_string (s)) , s) }) } } fn main () { }
  |                             ^^                                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq ! (reverse_string (reverse_string (s)) , s) }) } } fn main () { }
1 + use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { property_test (| s | { assert_eq ! (reverse_string (reverse_string (s)) , s) }) } fn main () { }
  |

error[E0425]: cannot find function `property_test` in this scope
 --> /tmp/.tmppNpw46/main.rs:1:138
  |
1 | ... property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq ! (reverse_string (reverse_string (s)) , s) }) } } fn...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch20-00-tooling example 5 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpQBK6Xo/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative number...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpQBK6Xo/main.rs:1:85
  |
1 | ...al (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i3...
  |                                          ^^                                                      ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { panic ! ("Factorial not defined for negative numbers") } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpQBK6Xo/main.rs:1:176
  |
1 | ...fined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                                   ^^    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { 1i32 } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpQBK6Xo/main.rs:1:194
  |
1 | ... } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                         ^^                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { n * factorial (n - 1i32) } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpQBK6Xo/main.rs:1:78
  |
1 | use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative number...
  |                                                                          -   ^^^^ expected `i64`, found `i32`
  |                                                                          |
  |                                                                          expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i64 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpQBK6Xo/main.rs:1:156
  |
1 | ...ial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main ...
  |                                                    -    ^^^^ expected `i64`, found `i32`
  |                                                    |
  |                                                    expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i64 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpQBK6Xo/main.rs:1:169
  |
1 | ...ed for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                    -    ^^^^ expected `i64`, found `i32`
  |                                                    |
  |                                                    expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i64 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpQBK6Xo/main.rs:1:178
  |
1 | ...) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else ...
  |         --- expected `i64` because of return type                                                                          ^^^^ expected `i64`, found `i32`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i64 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpQBK6Xo/main.rs:1:215
  |
1 | ...n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmpQBK6Xo/main.rs:1:213
  |
1 | ...n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error: aborting due to 6 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.



=== ch20-00-tooling example 6 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmprge0An/main.rs:1:296
  |
1 | ... { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_rec...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmprge0An/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibona...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmprge0An/main.rs:1:79
  |
1 | ...64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } } fn ...
  |         ^^                                                                                                                       ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmprge0An/main.rs:1:96
  |
1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibona...
  |                                                                                                ^^ ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { n } else { { format ! ("{}{}" , fibonacci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmprge0An/main.rs:1:111
  |
1 | ... 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } } fn fibonacci_iter...
  |                           ^^                                                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { format ! ("{}{}" , fibonacci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmprge0An/main.rs:1:308
  |
1 | ... ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { ben...
  |                                               ^^                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { let temp = a + b ; { a = b ; b = temp } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmprge0An/main.rs:1:394
  |
1 | ...bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib...
  |                             ^^                                                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmprge0An/main.rs:1:509
  |
1 | ...bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |                             ^^                                                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmprge0An/main.rs:1:89
  |
1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibona...
  |                                                                                    -    ^^^^ expected `i64`, found `i32`
  |                                                                                    |
  |                                                                                    expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i64 { { n } } else { { format ! ("{}{}" , fibonacci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmprge0An/main.rs:1:157
  |
1 | ...se { { format ! ("{}{}" , fibonacci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } } fn fibonacci_iterative (n : i64) ->...
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmprge0An/main.rs:1:155
  |
1 | ...se { { format ! ("{}{}" , fibonacci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } } fn fibonacci_iterative (n : i64) ->...
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmprge0An/main.rs:1:190
  |
1 | ...ci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let m...
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmprge0An/main.rs:1:188
  |
1 | ...ci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let m...
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmprge0An/main.rs:1:113
  |
1 | ...) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } }...
  |         ---                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `String`
  |         |
  |         expected `i64` because of return type
  |
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
 --> /tmp/.tmprge0An/main.rs:1:360
  |
1 | ...) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn b...
  |         --- expected `i64` because of return type                                                                              ^ expected `i64`, found `i32`
  |
help: you can convert an `i32` to an `i64`
  |
1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a.into() } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                         +++++++

error[E0308]: mismatched types
 --> /tmp/.tmprge0An/main.rs:1:469
  |
1 | ...ci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . ...
  |                                         -------------------  ^^^^^ expected `i64`, found `i32`
  |                                         |
  |                                         arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmprge0An/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibona...
  |                                        ^^^^^^^^^^^^^^^^^^^  -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i64)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

error[E0423]: expected function, found attribute macro `bench`
 --> /tmp/.tmprge0An/main.rs:1:396
  |
1 | ...; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i3...
  |                                                             ^^^^^ not a function

error[E0308]: mismatched types
 --> /tmp/.tmprge0An/main.rs:1:584
  |
1 | ...ci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |                                         -------------------  ^^^^^ expected `i64`, found `i32`
  |                                         |
  |                                         arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmprge0An/main.rs:1:208
  |
1 | ... 1i32) , fibonacci_recursive (n - 2i32)) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for...
  |                                                        ^^^^^^^^^^^^^^^^^^^  -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { format ! ("{}{}" , fibonacci_recursive (n - 1i32) , fibonacci_recursive (n - 2i32)) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i64)) } } fn main () { }
  |

error[E0423]: expected function, found attribute macro `bench`
 --> /tmp/.tmprge0An/main.rs:1:511
  |
1 | ...cci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i3...
  |                                                             ^^^^^ not a function

error: aborting due to 12 previous errors; 7 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0423, E0425.
For more information about an error, try `rustc --explain E0277`.



=== ch07-00-building-applications example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch07-00-building-applications example 2 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmpIbPktA/main.rs:1:709
  |
1 | ... = { name : "MyApp" , version : "1.0.0" , config_dir : "~/.config/myapp" , data_dir : "~/.local/share/myapp" , cache_dir : "~/.cache/myapp" , } ; ...
  |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | use std :: collections :: HashMap ; fn create_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , email : T) -> T { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{}" , format ! ("{}{}" , "Member since: " , user . created)) } } fn main () { let mut APP = { SomeStruct { name : "MyApp" , version : "1.0.0" , config_dir : "~/.config/myapp" , data_dir : "~/.local/share/myapp" , cache_dir : "~/.cache/myapp" , } } ; let mut User = { id : null , name : "" , email : "" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ++++++++++++                                                                                                                                              +

error: struct literal body without path
 --> /tmp/.tmpIbPktA/main.rs:1:867
  |
1 | ..."~/.cache/myapp" , } ; let mut User = { id : null , name : "" , email : "" , created : null , } ; { init_app () ; load_config () ; run...
  |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | use std :: collections :: HashMap ; fn create_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , email : T) -> T { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{}" , format ! ("{}{}" , "Member since: " , user . created)) } } fn main () { let mut APP = { name : "MyApp" , version : "1.0.0" , config_dir : "~/.config/myapp" , data_dir : "~/.local/share/myapp" , cache_dir : "~/.cache/myapp" , } ; let mut User = { SomeStruct { id : null , name : "" , email : "" , created : null , } } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ++++++++++++                                                           +

error[E0425]: cannot find value `User` in this scope
 --> /tmp/.tmpIbPktA/main.rs:1:227
  |
1 | ...Clone > (name : T , email : T) -> T { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . ema...
  |                                                         ^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpIbPktA/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn create_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpIbPktA/main.rs:1:212
  |
1 | ... { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } ...
  |       ^^                                                                                                                                                                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn create_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , email : T) -> T { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{}" , format ! ("{}{}" , "Member since: " , user . created)) } } fn main () { let mut APP = { name : "MyApp" , version : "1.0.0" , config_dir : "~/.config/myapp" , data_dir : "~/.local/share/myapp" , cache_dir : "~/.cache/myapp" , } ; let mut User = { id : null , name : "" , email : "" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
1 + use std :: collections :: HashMap ; fn create_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , email : T) -> T { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } fn display_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{}" , format ! ("{}{}" , "Member since: " , user . created)) } } fn main () { let mut APP = { name : "MyApp" , version : "1.0.0" , config_dir : "~/.config/myapp" , data_dir : "~/.local/share/myapp" , cache_dir : "~/.cache/myapp" , } ; let mut User = { id : null , name : "" , email : "" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |

error[E0425]: cannot find function `generate_uuid` in this scope
 --> /tmp/.tmpIbPktA/main.rs:1:258
  |
1 | ...{ { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = curren...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `current_datetime` in this scope
 --> /tmp/.tmpIbPktA/main.rs:1:338
  |
1 | ...name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user < T : std :: ops :: Add < Out...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0609]: no field `name` on type `T`
 --> /tmp/.tmpIbPktA/main.rs:1:582
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! ("User: {} ({})" , user . name , ...
  |       - type parameter 'T' declared here                                                                                                                                                      ^^^^ unknown field

error[E0609]: no field `email` on type `T`
 --> /tmp/.tmpIbPktA/main.rs:1:596
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! ("User: {} ({})" , user . name , user . email) ;...
  |       - type parameter 'T' declared here                                                                                                                                                                    ^^^^^ unknown field

error[E0609]: no field `created` on type `T`
 --> /tmp/.tmpIbPktA/main.rs:1:668
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{}" , format ! ("{}{}" , "Member since: " , user . created)) ...
  |       - type parameter 'T' declared here                                                                                                                                                                                                                                            ^^^^^^^ unknown field

error[E0308]: mismatched types
 --> /tmp/.tmpIbPktA/main.rs:1:605
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{}" , format ! ("{}{}" , "Member since: " , user . created)) } ...
  |       - expected this type parameter                                                                                                                                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `init_app` in this scope
 --> /tmp/.tmpIbPktA/main.rs:1:929
  |
1 | ... , name : "" , email : "" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `load_config` in this scope
 --> /tmp/.tmpIbPktA/main.rs:1:943
  |
1 | ...mail : "" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `run_event_loop` in this scope
 --> /tmp/.tmpIbPktA/main.rs:1:960
  |
1 | ...d : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `cleanup` in this scope
 --> /tmp/.tmpIbPktA/main.rs:1:980
  |
1 | ...init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 13 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0308, E0425, E0609.
For more information about an error, try `rustc --explain E0308`.



=== ch07-00-building-applications example 3 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmpYoiSsU/main.rs:1:702
  |
1 | ... () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { SomeStruct { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ++++++++++++                                                                                           +

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpYoiSsU/main.rs:1:214
  |
1 | ...t :: Debug + Clone > (key : T , value : T) -> T { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpYoiSsU/main.rs:1:245
  |
1 | ... value : T) -> T { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty {...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpYoiSsU/main.rs:1:312
  |
1 | ... true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `APP` in this scope
 --> /tmp/.tmpYoiSsU/main.rs:1:360
  |
1 | ...{ if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_jso...
  |                                                         ^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpYoiSsU/main.rs:1:444
  |
1 | ...to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file ...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpYoiSsU/main.rs:1:454
  |
1 | ...()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_pat...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `APP` in this scope
 --> /tmp/.tmpYoiSsU/main.rs:1:539
  |
1 | ...} fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { S...
  |                                                         ^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpYoiSsU/main.rs:1:619
  |
1 | ..." . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE =...
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpYoiSsU/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fm...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpYoiSsU/main.rs:1:307
  |
1 | ... { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } ...
  |       ^^                                                                                                                                                                              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
1 + use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpYoiSsU/main.rs:1:328
  |
1 | ... { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } ...
  |       ^^                                                                                                                                                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
1 + use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpYoiSsU/main.rs:1:507
  |
1 | ... { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } ...
  |       ^^                                                                                                                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
1 + use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } fn main () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpYoiSsU/main.rs:1:617
  |
1 | ...string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { user...
  |                                               ^^                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
1 + use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { STATE = parse_json (read_file (state_file)) } } } } fn main () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
  |

error[E0425]: cannot find function `trigger_save` in this scope
 --> /tmp/.tmpYoiSsU/main.rs:1:268
  |
1 | ... [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0605]: non-primitive cast: `T` as `usize`
 --> /tmp/.tmpYoiSsU/main.rs:1:221
  |
1 | ...ATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = j...
  |         ^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpYoiSsU/main.rs:1:349
  |
1 | ...te () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_json` in this scope
 --> /tmp/.tmpYoiSsU/main.rs:1:435
  |
1 | ...json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let sta...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpYoiSsU/main.rs:1:410
  |
1 | ...ate.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let...
  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `state_file`

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpYoiSsU/main.rs:1:528
  |
1 | ...} } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_fil...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpYoiSsU/main.rs:1:590
  |
1 | ...P . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpYoiSsU/main.rs:1:639
  |
1 | ... file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { users : vec ! [] , ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `parse_json` in this scope
 --> /tmp/.tmpYoiSsU/main.rs:1:627
  |
1 | ...ing ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { users :...
  |                                                      ^^^^^^^^^^ not found in this scope

error: aborting due to 18 previous errors; 5 warnings emitted

Some errors have detailed explanations: E0425, E0605.
For more information about an error, try `rustc --explain E0425`.



=== ch07-00-building-applications example 4 ===
✗ Compilation failed: Compilation failed:
error[E0423]: expected value, found macro `try`
 --> /tmp/.tmp0vRs1p/main.rs:1:234
  |
1 | ... Clone > (operation_fn : T , fallback_value : T) -> T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; r...
  |                                                              ^^^^^ not a value

error[E0425]: cannot find value `catch` in this scope
 --> /tmp/.tmp0vRs1p/main.rs:1:271
  |
1 | ... : T) -> T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < ...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmp0vRs1p/main.rs:1:279
  |
1 | ... T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std ...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmp0vRs1p/main.rs:1:300
  |
1 | ...rn operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Outpu...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmp0vRs1p/main.rs:1:543
  |
1 | ..._fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0423]: expected value, found macro `try`
 --> /tmp/.tmp0vRs1p/main.rs:1:568
  |
1 | ...pts : T) -> T { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_att...
  |                                                              ^^^^^ not a value

error[E0425]: cannot find value `catch` in this scope
 --> /tmp/.tmp0vRs1p/main.rs:1:605
  |
1 | ..._attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , format !...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmp0vRs1p/main.rs:1:613
  |
1 | ...s) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , format ! ("{}{}"...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmp0vRs1p/main.rs:1:780
  |
1 | ...fter " , max_attempts . to_s ()) , " attempts: ") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; ...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmp0vRs1p/main.rs:1:808
  |
1 | ... ()) , " attempts: ") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Att...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `sleep` in this scope
 --> /tmp/.tmp0vRs1p/main.rs:1:958
  |
1 | ...retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::sleep;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp0vRs1p/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn safe_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp0vRs1p/main.rs:1:526
  |
1 | ... { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Failed after " , max_attempts . to_s ()) , " attempts: ") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn safe_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , fallback_value : T) -> T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Failed after " , max_attempts . to_s ()) , " attempts: ") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn safe_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , fallback_value : T) -> T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Failed after " , max_attempts . to_s ()) , " attempts: ") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } fn main () { }
  |

error[E0618]: expected function, found `T`
 --> /tmp/.tmp0vRs1p/main.rs:1:251
  |
1 | ... Clone > (operation_fn : T , fallback_value : T) -> T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; r...
  |              ------------                                                     ^^^^^^^^^^^^---
  |              |                                                                |
  |              `operation_fn` has type `T`                                      call expression requires function

warning: unreachable statement
 --> /tmp/.tmp0vRs1p/main.rs:1:271
  |
1 | ..._value : T) -> T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_re...
  |                                   ----------------------     ^^^^^^^ unreachable statement
  |                                   |
  |                                   any code following this expression is unreachable
  |
  = note: `#[warn(unreachable_code)]` on by default

error[E0425]: cannot find function `log_error` in this scope
 --> /tmp/.tmp0vRs1p/main.rs:1:289
  |
1 | ... ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Ad...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0618]: expected function, found `T`
 --> /tmp/.tmp0vRs1p/main.rs:1:585
  |
1 | ...one > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catc...
  |           ------------                                                                                           ^^^^^^^^^^^^---
  |           |                                                                                                      |
  |           `operation_fn` has type `T`                                                                            call expression requires function

warning: unreachable statement
 --> /tmp/.tmp0vRs1p/main.rs:1:605
  |
1 | ...e (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , fo...
  |                                   ----------------------     ^^^^^^^ unreachable statement
  |                                   |
  |                                   any code following this expression is unreachable

error[E0369]: cannot subtract `i32` from `T`
 --> /tmp/.tmp0vRs1p/main.rs:1:650
  |
1 | ...rn operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , ...
  |                                                           ------------ ^ ---- i32
  |                                                           |
  |                                                           T
  |
help: consider further restricting type parameter `T` with trait `Sub`
  |
1 | use std :: collections :: HashMap ; fn safe_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , fallback_value : T) -> T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Sub<i32> > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Failed after " , max_attempts . to_s ()) , " attempts: ") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ++++++++++++++++++++

error[E0599]: no method named `to_s` found for type parameter `T` in the current scope
 --> /tmp/.tmp0vRs1p/main.rs:1:752
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Failed after " , max_attempts . to_s ())...
  |       - method `to_s` not found for this type parameter                                                                                                                                                                                                                                                                                                                                                               ^^^^ method not found in `T`

error[E0308]: mismatched types
 --> /tmp/.tmp0vRs1p/main.rs:1:938
  |
1 | ...Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }
  |                                                       ^^^^ expected `u32`, found `i32`

error[E0277]: cannot add `i32` to `u32`
 --> /tmp/.tmp0vRs1p/main.rs:1:936
  |
1 | ...Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }
  |                                                     ^ no implementation for `u32 + i32`
  |
  = help: the trait `Add<i32>` is not implemented for `u32`
  = help: the following other types implement trait `Add<Rhs>`:
            `&u32` implements `Add<u32>`
            `&u32` implements `Add`
            `u32` implements `Add<&u32>`
            `u32` implements `Add`

error[E0308]: mismatched types
 --> /tmp/.tmp0vRs1p/main.rs:1:528
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Failed after " , max_attempts . to_s ()) , " attempts: ") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } }...
  |       -                                                                                                                                                                        -     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |       |                                                                                                                                                                        |
  |       expected this type parameter                                                                                                                                             expected `T` because of return type
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: the caller chooses a type for `T` which can be different from `()`
  = note: `for` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | use std :: collections :: HashMap ; fn safe_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , fallback_value : T) -> T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Failed after " , max_attempts . to_s ()) , " attempts: ") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } /* `T` value */ } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     +++++++++++++++

error: aborting due to 19 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0369, E0423, E0425, E0599, E0618.
For more information about an error, try `rustc --explain E0277`.



=== ch07-00-building-applications example 5 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmprk25bq/main.rs:1:1163
  |
1 | ...ite as usize] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_password...
  |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site as usize] = { SomeStruct { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ++++++++++++                                                                                                        +

error[E0425]: cannot find value `MASTER_KEY` in this scope
 --> /tmp/.tmprk25bq/main.rs:1:1632
  |
1 | ... { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboa...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `null` in this scope
 --> /tmp/.tmprk25bq/main.rs:1:1906
  |
1 | ..., site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::ptr::null;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmprk25bq/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmprk25bq/main.rs:1:206
  |
1 | ... { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } ...
  |       ^^                                                                                                                                                                                                                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site as usize] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site as usize] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmprk25bq/main.rs:1:290
  |
1 | ...erate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return ...
  |               ^^                                                                                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site as usize] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site as usize] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmprk25bq/main.rs:1:621
  |
1 | ... { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } ...
  |       ^^                                                                                                                                                                                                                                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site as usize] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site as usize] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmprk25bq/main.rs:1:739
  |
1 | ...te () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; ret...
  |            ^^                                                                                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site as usize] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site as usize] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmprk25bq/main.rs:1:1093
  |
1 | ... { { { let passwords = load_passwords () ; { passwords [site as usize] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } ...
  |       ^^                                                                                                                                                                                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site as usize] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { let passwords = load_passwords () ; { passwords [site as usize] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmprk25bq/main.rs:1:1467
  |
1 | ... { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site as usize] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site as usize] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmprk25bq/main.rs:1:1539
  |
1 | ... { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } e...
  |       ^^                                                                                                                                                                                                                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site as usize] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site as usize] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmprk25bq/main.rs:1:1787
  |
1 | ...clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut ...
  |                                 ^^                                                                         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site as usize] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site as usize] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
  |

error[E0599]: no method named `chars` found for type parameter `T` in the current scope
 --> /tmp/.tmprk25bq/main.rs:1:264
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars ()...
  |       - method `chars` not found for this type parameter                                                                                                                                                                    ^^^^^ method not found in `T`

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmprk25bq/main.rs:1:324
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                  ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site as usize] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
  |                                                                                                                                                                                +++++++++++++++++++

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmprk25bq/main.rs:1:313
  |
1 | ...t . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ...
  |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0425]: cannot find function `base64_encode` in this scope
 --> /tmp/.tmprk25bq/main.rs:1:413
  |
1 | ... . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + ...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `base64_decode` in this scope
 --> /tmp/.tmprk25bq/main.rs:1:637
  |
1 | ...encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes ....
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmprk25bq/main.rs:1:773
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                                                         ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site as usize] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++++++

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmprk25bq/main.rs:1:762
  |
1 | ...te) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char ....
  |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0425]: cannot find function `char_from_code` in this scope
 --> /tmp/.tmprk25bq/main.rs:1:810
  |
1 | ...[i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } }...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `load_passwords` in this scope
 --> /tmp/.tmprk25bq/main.rs:1:1113
  |
1 | ... : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site as usize] = { username : username , password : e...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `save_passwords` in this scope
 --> /tmp/.tmprk25bq/main.rs:1:1268
  |
1 | ...STER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = ...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0605]: non-primitive cast: `T` as `usize`
 --> /tmp/.tmprk25bq/main.rs:1:1146
  |
1 | ...rds [site as usize] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_pa...
  |         ^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0425]: cannot find function `load_passwords` in this scope
 --> /tmp/.tmprk25bq/main.rs:1:1487
  |
1 | ... } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site as usize] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords ()...
  |       ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- similarly named function `add_password` defined here                                                                                                                                                                                                                                                                                                                                                        ^^^^^^^^^^^^^^ help: a function with a similar name exists: `add_password`

error[E0425]: cannot find function `copy_to_clipboard` in this scope
 --> /tmp/.tmprk25bq/main.rs:1:1646
  |
1 | ...d = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_afte...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `clear_clipboard` in this scope
 --> /tmp/.tmprk25bq/main.rs:1:1752
  |
1 | ...d to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `spawn_after` in this scope
 --> /tmp/.tmprk25bq/main.rs:1:1725
  |
1 | ... println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , form...
  |                                                      ^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmprk25bq/main.rs:1:1789
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } ...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0605]: non-primitive cast: `T` as `usize`
 --> /tmp/.tmprk25bq/main.rs:1:1566
  |
1 | ...rds [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Passw...
  |         ^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error: aborting due to 20 previous errors; 9 warnings emitted

Some errors have detailed explanations: E0308, E0425, E0599, E0605, E0608.
For more information about an error, try `rustc --explain E0308`.



=== ch07-00-building-applications example 6 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmploA4BW/main.rs:1:261
  |
1 | ... let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TR...
  |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { SomeStruct { date : current_date () , amount : amount , category : category , description : description , } } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
  |                                                                                                                                                                                                                                                                     ++++++++++++                                                                                                  +

error[E0425]: cannot find value `TRANSACTIONS_FILE` in this scope
 --> /tmp/.tmploA4BW/main.rs:1:374
  |
1 | ...description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `report_data` in this scope
 --> /tmp/.tmploA4BW/main.rs:1:1817
  |
1 | ...t_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , format ! ("{}{}" , "\n📄 Report saved to " , report_fi...
  |                                                     ^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmploA4BW/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std ::...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmploA4BW/main.rs:1:239
  |
1 | ... { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
1 + use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmploA4BW/main.rs:1:988
  |
1 | ... { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
1 + use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmploA4BW/main.rs:1:1298
  |
1 | ... { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
1 + use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
  |

error[E0425]: cannot find function `append_csv` in this scope
 --> /tmp/.tmploA4BW/main.rs:1:362
  |
1 | ...ry : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_t...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `get_monthly_total` in this scope
 --> /tmp/.tmploA4BW/main.rs:1:433
  |
1 | ...FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if m...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `get_budget_limit` in this scope
 --> /tmp/.tmploA4BW/main.rs:1:487
  |
1 | ...thly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (fo...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `send_notification` in this scope
 --> /tmp/.tmploA4BW/main.rs:1:553
  |
1 | ...tegory) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmploA4BW/main.rs:1:629
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } ...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `load_transactions` in this scope
 --> /tmp/.tmploA4BW/main.rs:1:1011
  |
1 | ... ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (m...
  |       ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- similarly named function `add_transaction` defined here                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^^^^^^^^^^^^^^^^^ help: a function with a similar name exists: `add_transaction`

error[E0425]: cannot find function `group_by` in this scope
 --> /tmp/.tmploA4BW/main.rs:1:1063
  |
1 | ...oad_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{}" , format ! ("...
  |                                                       ^^^^^^^^ not found in this scope

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmploA4BW/main.rs:1:1213
  |
1 | ..." , "\n📊 Budget Report for " , month)) ; println ! ("{}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category ...
  |                                                                --- ^ ----- i32
  |                                                                |
  |                                                                &str

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmploA4BW/main.rs:1:1477
  |
1 | ...otal ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $")...
  |                                                        ^^^^ method not found in `i32`

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmploA4BW/main.rs:1:1436
  |
1 | ... sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , form...
  |                                              ^^^^^^^ doesn't have a size known at compile-time
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: all local variables must have a statically known size

error[E0308]: mismatched types
 --> /tmp/.tmploA4BW/main.rs:1:1596
  |
1 | ...tegory , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , format ! ("{}{}" ...
  |                                                       ^^^ expected `&str`, found `str`
  |
help: consider borrowing here
  |
1 | use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + &bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             +

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmploA4BW/main.rs:1:1633
  |
1 | ..._total . to_s () , " ") + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , format ! ("{}{}" , "Total:          $" , t...
  |                                                               --- ^ ----- i32
  |                                                               |
  |                                                               &str

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmploA4BW/main.rs:1:1711
  |
1 | ... , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; gene...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `generate_pdf` in this scope
 --> /tmp/.tmploA4BW/main.rs:1:1789
  |
1 | ...le = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , format ! ("{}{}" , "\n📄 R...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmploA4BW/main.rs:1:1832
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } ...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

warning: unused variable: `TRANSACTIONS_FILE`
 --> /tmp/.tmploA4BW/main.rs:1:1937
  |
1 | ...main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; let mut CATEGORIES = vec ! ["Food" , "Transport" ,...
  |                      ^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_TRANSACTIONS_FILE`
  |
  = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `CATEGORIES`
 --> /tmp/.tmploA4BW/main.rs:1:2011
  |
1 | .... to_string () ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
  |                             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_CATEGORIES`

warning: variable does not need to be mutable
 --> /tmp/.tmploA4BW/main.rs:1:1933
  |
1 | ... saved to " , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; let mut CAT...
  |                                                         ----^^^^^^^^^^^^^^^^^
  |                                                         |
  |                                                         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

warning: variable does not need to be mutable
 --> /tmp/.tmploA4BW/main.rs:1:2007
  |
1 | ... = "~/.budget/transactions.csv" . to_string () ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other...
  |                                                         ----^^^^^^^^^^
  |                                                         |
  |                                                         help: remove this `mut`

error: aborting due to 18 previous errors; 8 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0369, E0425, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch07-00-building-applications example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch07-00-building-applications example 8 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmpgNIKSo/main.rs:1:468
  |
1 | ... } } } fn test_data_persistence () { { { let test_data = { test : "value" , } ; { let mut test_file = "test_data.json" . to_string () ...
  |                                                             ^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert ! (user . name == "Alice" , "{}" , "Name should be set") ; assert ! (user . email == "alice@example.com" , "{}" , "Email should be set") ; assert ! (user . id != null , "{}" , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } fn test_data_persistence () { { { let test_data = { SomeStruct { test : "value" , } } ; { let mut test_file = "test_data.json" . to_string () ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let mut loaded = load_json (test_file) ; assert ! (loaded . test == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ++++++++++++                      +

error[E0425]: cannot find value `null` in this scope
 --> /tmp/.tmpgNIKSo/main.rs:1:326
  |
1 | ...}" , "Email should be set") ; assert ! (user . id != null , "{}" , "ID should be generated") ; println ! ("✅ test_user_creation passed"...
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::ptr::null;
  |

error[E0425]: cannot find function `remove_file` in this scope
 --> /tmp/.tmpgNIKSo/main.rs:1:764
  |
1 | ...est == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_...
  |                                                     ^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_file;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpgNIKSo/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" ....
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpgNIKSo/main.rs:1:64
  |
1 | ... { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert ! (user . name == "Alice" , "{}" , "Name should be set") ; assert ! (user . email == "alice@example.com" , "{}" , "Email should be set") ; assert ! (user . id != null , "{}" , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                            ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert ! (user . name == "Alice" , "{}" , "Name should be set") ; assert ! (user . email == "alice@example.com" , "{}" , "Email should be set") ; assert ! (user . id != null , "{}" , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } fn test_data_persistence () { { { let test_data = { test : "value" , } ; { let mut test_file = "test_data.json" . to_string () ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let mut loaded = load_json (test_file) ; assert ! (loaded . test == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_user_creation () { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert ! (user . name == "Alice" , "{}" , "Name should be set") ; assert ! (user . email == "alice@example.com" , "{}" , "Email should be set") ; assert ! (user . id != null , "{}" , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } fn test_data_persistence () { { { let test_data = { test : "value" , } ; { let mut test_file = "test_data.json" . to_string () ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let mut loaded = load_json (test_file) ; assert ! (loaded . test == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpgNIKSo/main.rs:1:448
  |
1 | ... { { { let test_data = { test : "value" , } ; { let mut test_file = "test_data.json" . to_string () ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let mut loaded = load_json (test_file) ; assert ! (loaded . test == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert ! (user . name == "Alice" , "{}" , "Name should be set") ; assert ! (user . email == "alice@example.com" , "{}" , "Email should be set") ; assert ! (user . id != null , "{}" , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } fn test_data_persistence () { { { let test_data = { test : "value" , } ; { let mut test_file = "test_data.json" . to_string () ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let mut loaded = load_json (test_file) ; assert ! (loaded . test == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert ! (user . name == "Alice" , "{}" , "Name should be set") ; assert ! (user . email == "alice@example.com" , "{}" , "Email should be set") ; assert ! (user . id != null , "{}" , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } fn test_data_persistence () { { let test_data = { test : "value" , } ; { let mut test_file = "test_data.json" . to_string () ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let mut loaded = load_json (test_file) ; assert ! (loaded . test == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
  |

error[E0425]: cannot find function `create_user` in this scope
 --> /tmp/.tmpgNIKSo/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" ....
  |                                                                               ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `save_json` in this scope
 --> /tmp/.tmpgNIKSo/main.rs:1:547
  |
1 | ...mut test_file = "test_data.json" . to_string () ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpgNIKSo/main.rs:1:593
  |
1 | ... ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let mut loaded = load_js...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `load_json` in this scope
 --> /tmp/.tmpgNIKSo/main.rs:1:671
  |
1 | ...}" , "File should be created") ; let mut loaded = load_json (test_file) ; assert ! (loaded . test == "value" , "{}" , "Data should per...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `test_error_handling` in this scope
 --> /tmp/.tmpgNIKSo/main.rs:1:965
  |
1 | ...ser_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn ...
  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `test_performance` in this scope
 --> /tmp/.tmpgNIKSo/main.rs:1:990
  |
1 | ...data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 9 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-building-applications example 9 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `VERSION` in this scope
 --> /tmp/.tmp3k9hDI/main.rs:1:174
  |
1 | ... let release_dir = format ! ("{}{}" , "release_" , VERSION) ; { create_dir_all (release_dir) ; copy_file ("main.ruchy" . to_string () ...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find function `create_dir_all` in this scope
 --> /tmp/.tmp3k9hDI/main.rs:1:187
  |
1 | ... = format ! ("{}{}" , "release_" , VERSION) ; { create_dir_all (release_dir) ; copy_file ("main.ruchy" . to_string () , join_path (rel...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::create_dir_all;
  |

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmp3k9hDI/main.rs:1:284
  |
1 | ...n.ruchy" . to_string () , join_path (release_dir , APP_NAME)) ; copy_dir ("resources" . to_string () , join_path (release_dir , "resou...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmp3k9hDI/main.rs:1:650
  |
1 | ...cho 'Installation complete! Run {} to start.'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (relea...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `VERSION` in this scope
 --> /tmp/.tmp3k9hDI/main.rs:1:661
  |
1 | ...lation complete! Run {} to start.'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , "i...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmp3k9hDI/main.rs:1:671
  |
1 | ...plete! Run {} to start.'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , "install.sh"...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmp3k9hDI/main.rs:1:682
  |
1 | ...{} to start.'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , "install.sh" . to_strin...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmp3k9hDI/main.rs:1:693
  |
1 | ....'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , "install.sh" . to_string ()) , ins...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmp3k9hDI/main.rs:1:829
  |
1 | ...ller) ; create_archive (format ! ("{}-{}.tar.gz" , APP_NAME , VERSION) , release_dir) ; println ! ("✅ Release built: {}-{}.tar.gz" , AP...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `VERSION` in this scope
 --> /tmp/.tmp3k9hDI/main.rs:1:840
  |
1 | ...ate_archive (format ! ("{}-{}.tar.gz" , APP_NAME , VERSION) , release_dir) ; println ! ("✅ Release built: {}-{}.tar.gz" , APP_NAME , VE...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmp3k9hDI/main.rs:1:911
  |
1 | ...ir) ; println ! ("✅ Release built: {}-{}.tar.gz" , APP_NAME , VERSION) } } } } fn main () { }
  |                                                        ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `VERSION` in this scope
 --> /tmp/.tmp3k9hDI/main.rs:1:922
  |
1 | ...ln ! ("✅ Release built: {}-{}.tar.gz" , APP_NAME , VERSION) } } } } fn main () { }
  |                                                        ^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp3k9hDI/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn build_release () { { println ! ("🔨 Building release version...") ; run_tests () ; { let release_dir...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `run_tests` in this scope
 --> /tmp/.tmp3k9hDI/main.rs:1:107
  |
1 | ...{ { println ! ("🔨 Building release version...") ; run_tests () ; { let release_dir = format ! ("{}{}" , "release_" , VERSION) ; { creat...
  |                                                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmp3k9hDI/main.rs:1:259
  |
1 | ...e_dir) ; copy_file ("main.ruchy" . to_string () , join_path (release_dir , APP_NAME)) ; copy_dir ("resources" . to_string () , join_pa...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `copy_file` in this scope
 --> /tmp/.tmp3k9hDI/main.rs:1:218
  |
1 | ...e_" , VERSION) ; { create_dir_all (release_dir) ; copy_file ("main.ruchy" . to_string () , join_path (release_dir , APP_NAME)) ; copy_...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmp3k9hDI/main.rs:1:336
  |
1 | ...P_NAME)) ; copy_dir ("resources" . to_string () , join_path (release_dir , "resources" . to_string ())) ; generate_docs (join_path (re...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `copy_dir` in this scope
 --> /tmp/.tmp3k9hDI/main.rs:1:297
  |
1 | ..._string () , join_path (release_dir , APP_NAME)) ; copy_dir ("resources" . to_string () , join_path (release_dir , "resources" . to_st...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmp3k9hDI/main.rs:1:407
  |
1 | ...r , "resources" . to_string ())) ; generate_docs (join_path (release_dir , "docs" . to_string ())) ; let mut installer = format ! ("#!...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `generate_docs` in this scope
 --> /tmp/.tmp3k9hDI/main.rs:1:392
  |
1 | ...h (release_dir , "resources" . to_string ())) ; generate_docs (join_path (release_dir , "docs" . to_string ())) ; let mut installer = ...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmp3k9hDI/main.rs:1:717
  |
1 | ...N , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , "install.sh" . to_string ()) , installer) ; create_archive ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmp3k9hDI/main.rs:1:705
  |
1 | ...AME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , "install.sh" . to_string ()) , installer) ; cre...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `create_archive` in this scope
 --> /tmp/.tmp3k9hDI/main.rs:1:786
  |
1 | ...r , "install.sh" . to_string ()) , installer) ; create_archive (format ! ("{}-{}.tar.gz" , APP_NAME , VERSION) , release_dir) ; printl...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 22 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch15-00-macros-metaprogramming example 1 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp8IROk5/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn create_user (name : String , age : i32) -> String { { format ! ("{}{}" , format ! ("{}{}" , "User:...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp8IROk5/main.rs:1:92
  |
1 | ...e : i32) -> String { { format ! ("{}{}" , format ! ("{}{}" , "User: " , name) , ", Age: ") + age . to_string () } } fn main () { let m...
  |                         ^^                                                                                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn create_user (name : String , age : i32) -> String { { format ! ("{}{}" , format ! ("{}{}" , "User: " , name) , ", Age: ") + age . to_string () } } fn main () { let mut user = create_user ("Alice" . to_string () , 30i32) ; println ! ("{}" , user) ; }
1 + use std :: collections :: HashMap ; fn create_user (name : String , age : i32) -> String { format ! ("{}{}" , format ! ("{}{}" , "User: " , name) , ", Age: ") + age . to_string () } fn main () { let mut user = create_user ("Alice" . to_string () , 30i32) ; println ! ("{}" , user) ; }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp8IROk5/main.rs:1:164
  |
1 | ...("{}{}" , "User: " , name) , ", Age: ") + age . to_string () } } fn main () { let mut user = create_user ("Alice" . to_string () , 30i...
  |                                              ^^^^^^^^^^^^^^^^^^ expected `&str`, found `String`
  |
help: consider borrowing here
  |
1 | use std :: collections :: HashMap ; fn create_user (name : String , age : i32) -> String { { format ! ("{}{}" , format ! ("{}{}" , "User: " , name) , ", Age: ") + &age . to_string () } } fn main () { let mut user = create_user ("Alice" . to_string () , 30i32) ; println ! ("{}" , user) ; }
  |                                                                                                                                                                    +

warning: variable does not need to be mutable
 --> /tmp/.tmp8IROk5/main.rs:1:204
  |
1 | ...", Age: ") + age . to_string () } } fn main () { let mut user = create_user ("Alice" . to_string () , 30i32) ; println ! ("{}" , user)...
  |                                                         ----^^^^
  |                                                         |
  |                                                         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

error: aborting due to 1 previous error; 3 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch15-00-macros-metaprogramming example 2 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `User` in this scope
 --> /tmp/.tmpA7jhaG/main.rs:1:59
  |
1 | use std :: collections :: HashMap ; fn debug_user (user : User) -> String { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "U...
  |                                                           ^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpA7jhaG/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn debug_user (user : User) -> String { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "U...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpA7jhaG/main.rs:1:77
  |
1 | ... { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "User { name: " , user . name) , ", age: ") + user . age . to_string () , " }") } } ...
  |       ^^                                                                                                                                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn debug_user (user : User) -> String { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "User { name: " , user . name) , ", age: ") + user . age . to_string () , " }") } } fn main () { struct User { name : String , age : i32 , } ; }
1 + use std :: collections :: HashMap ; fn debug_user (user : User) -> String { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "User { name: " , user . name) , ", age: ") + user . age . to_string () , " }") } fn main () { struct User { name : String , age : i32 , } ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpA7jhaG/main.rs:1:277
  |
1 | ...in () { struct User { name : String , age : i32 , } ; }
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error: aborting due to 1 previous error; 3 warnings emitted

For more information about this error, try `rustc --explain E0412`.



=== ch09-00-network-programming example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 2 ===

thread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:
"net::TcpListener" is not a valid Ident
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


=== ch09-00-network-programming example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 10 ===

thread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:
"net::PacketCapture" is not a valid Ident
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


=== ch07-00-error-handling-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `value` in this scope
 --> /tmp/.tmpcLtn40/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid") } } else { { println ! ("Invalid") ...
  |                                                                  ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpcLtn40/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid") } } else { { println ! ("Invalid") ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpcLtn40/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid") } } else { { println ! ("Invalid") ...
  |                                                                                 ^^                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid") } } else { { println ! ("Invalid") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { println ! ("Valid") } else { { println ! ("Invalid") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpcLtn40/main.rs:1:114
  |
1 | ... = if value > 0i32 { { println ! ("Valid") } } else { { println ! ("Invalid") } } ; if let Some (s) = (& result as & dyn std :: any ::...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid") } } else { { println ! ("Invalid") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid") } } else { println ! ("Invalid") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error: aborting due to 1 previous error; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `status` in this scope
 --> /tmp/.tmpEXuTpe/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match status { 0i32 => println ! ("Error") , 1i32 => println ! ("Warning") ...
  |                                                                     ^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpEXuTpe/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match status { 0i32 => println ! ("Error") , 1i32 => println ! ("Warning") ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `age` in this scope
 --> /tmp/.tmp5EAiVd/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match age { 0i32 => println ! ("Invalid age") , 1i32 ..= 17i32 => println !...
  |                                                                     ^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp5EAiVd/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match age { 0i32 => println ! ("Invalid age") , 1i32 ..= 17i32 => println !...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 7 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `input` in this scope
 --> /tmp/.tmp6GDAK9/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed") } } els...
  |                                                                  ^^^^^ not found in this scope

error[E0425]: cannot find value `input` in this scope
 --> /tmp/.tmp6GDAK9/main.rs:1:159
  |
1 | ...ive input not allowed") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_re...
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp6GDAK9/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed") } } els...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp6GDAK9/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed") } } els...
  |                                                                                 ^^                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { println ! ("Error: Negative input not allowed") } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp6GDAK9/main.rs:1:142
  |
1 | ...ln ! ("Error: Negative input not allowed") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any ::...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed") } } else { process_input (input) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `process_input` in this scope
 --> /tmp/.tmp6GDAK9/main.rs:1:144
  |
1 | ...rror: Negative input not allowed") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . ...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 8 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `score` in this scope
 --> /tmp/.tmpt27Oav/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match score { 0i32 ..= 59i32 => println ! ("Fail") , 60i32 ..= 79i32 => pri...
  |                                                                     ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpt27Oav/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match score { 0i32 ..= 59i32 => println ! ("Fail") , 60i32 ..= 79i32 => pri...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 9 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `system_ready` in this scope
 --> /tmp/.tmpr0kASk/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational") } } else { { println !...
  |                                                                  ^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpr0kASk/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational") } } else { { println !...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpr0kASk/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational") } } else { { println !...
  |                                                                                 ^^                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational") } } else { { println ! ("System not ready") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if system_ready { println ! ("System operational") } else { { println ! ("System not ready") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpr0kASk/main.rs:1:127
  |
1 | ...y { { println ! ("System operational") } } else { { println ! ("System not ready") } } ; if let Some (s) = (& result as & dyn std :: a...
  |                                                      ^^                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational") } } else { { println ! ("System not ready") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational") } } else { println ! ("System not ready") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error: aborting due to 1 previous error; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch08-00-systems-programming example 1 ===
✗ Compilation failed: Compilation failed:
error[E0432]: unresolved import `std::system`
 --> /tmp/.tmp8oKthg/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monit...
  |                                                                     ^^^^^^^^^^^^^ no `system` in the root

error[E0425]: cannot find function `list` in module `process`
 --> /tmp/.tmp8oKthg/main.rs:1:2194
  |
1 | ...Processes by CPU:") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes...
  |                                                         ^^^^ not found in `process`

error[E0425]: cannot find function `sleep` in this scope
 --> /tmp/.tmp8oKthg/main.rs:1:2476
  |
1 | ..., " ") + proc . cpu_percent . to_s () , "%")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::sleep;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp8oKthg/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monit...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmp8oKthg/main.rs:1:85
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monit...
  |                                                                                     ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmp8oKthg/main.rs:1:108
  |
1 | ...sult = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===") ; let mut cpu_count = system :: cpu_count (...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmp8oKthg/main.rs:1:678
  |
1 | ... { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") , format_size (memory_info . total))) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } } ; sleep (1000i32) } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===") ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! ("{}" , format ! ("{}{}" , "Host: " , hostname)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "OS: " , os_info . name) , " ") + os_info . version) ; println ! ("{}" , format ! ("{}{}" , "CPUs: " , cpu_count . to_s ())) ; println ! ("{}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") , format_size (memory_info . total))) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===") ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! ("{}" , format ! ("{}{}" , "Host: " , hostname)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "OS: " , os_info . name) , " ") + os_info . version) ; println ! ("{}" , format ! ("{}{}" , "CPUs: " , cpu_count . to_s ())) ; println ! ("{}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("") ; loop { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") , format_size (memory_info . total))) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } } ; sleep (1000i32) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp8oKthg/main.rs:1:2278
  |
1 | ... { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } } ...
  |       ^^                                                                                                                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===") ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! ("{}" , format ! ("{}{}" , "Host: " , hostname)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "OS: " , os_info . name) , " ") + os_info . version) ; println ! ("{}" , format ! ("{}{}" , "CPUs: " , cpu_count . to_s ())) ; println ! ("{}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") , format_size (memory_info . total))) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===") ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! ("{}" , format ! ("{}{}" , "Host: " , hostname)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "OS: " , os_info . name) , " ") + os_info . version) ; println ! ("{}" , format ! ("{}{}" , "CPUs: " , cpu_count . to_s ())) ; println ! ("{}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") , format_size (memory_info . total))) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmp8oKthg/main.rs:1:623
  |
1 | ...rintln ! ("{}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("") ; loop { { { let cpu_usage = system :: ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `clear_screen` in this scope
 --> /tmp/.tmp8oKthg/main.rs:1:874
  |
1 | ...mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmp8oKthg/main.rs:1:968
  |
1 | ...ystem Monitor - Press Ctrl+C to exit") ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , form...
  |                                                               --- ^ ----- i32
  |                                                               |
  |                                                               &str

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmp8oKthg/main.rs:1:1122
  |
1 | ...age . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent ...
  |                                                        ^^^^ method not found in `i32`

error[E0308]: mismatched types
 --> /tmp/.tmp8oKthg/main.rs:1:1096
  |
1 | ..." , cpu_usage . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut me...
  |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `str`
  |
help: consider borrowing here
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===") ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! ("{}" , format ! ("{}{}" , "Host: " , hostname)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "OS: " , os_info . name) , " ") + os_info . version) ; println ! ("{}" , format ! ("{}{}" , "CPUs: " , cpu_count . to_s ())) ; println ! ("{}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") + &("█" * cpu_usage * 50i32 . to_i ()) + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") , format_size (memory_info . total))) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ++                                 +

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmp8oKthg/main.rs:1:1136
  |
1 | ... . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = m...
  |                                                               --- ^ ----- i32
  |                                                               |
  |                                                               &str

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmp8oKthg/main.rs:1:1166
  |
1 | ...50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ;...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmp8oKthg/main.rs:1:1396
  |
1 | ...t . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{}" , ...
  |                                                        ^^^^ method not found in `i32`

error[E0308]: mismatched types
 --> /tmp/.tmp8oKthg/main.rs:1:1368
  |
1 | ... mem_percent . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println...
  |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `str`
  |
help: consider borrowing here
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===") ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! ("{}" , format ! ("{}{}" , "Host: " , hostname)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "OS: " , os_info . name) , " ") + os_info . version) ; println ! ("{}" , format ! ("{}{}" , "CPUs: " , cpu_count . to_s ())) ; println ! ("{}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") + &("█" * mem_percent * 50i32 . to_i ()) + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") , format_size (memory_info . total))) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ++                                   +

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmp8oKthg/main.rs:1:1410
  |
1 | ... to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{}" , for...
  |                                                               --- ^ ----- i32
  |                                                               |
  |                                                               &str

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmp8oKthg/main.rs:1:1442
  |
1 | ...i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format !...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmp8oKthg/main.rs:1:1545
  |
1 | ... format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") , format_size (memory_info . total))) ; pr...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmp8oKthg/main.rs:1:1590
  |
1 | ..." , format_size (memory_info . used)) , " / ") , format_size (memory_info . total))) ; println ! ("{}" , format ! ("{}{}" , format ! (...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmp8oKthg/main.rs:1:1701
  |
1 | ... ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , f...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmp8oKthg/main.rs:1:1821
  |
1 | ... ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmp8oKthg/main.rs:1:1940
  |
1 | ...at ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{}" , format ! (...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmp8oKthg/main.rs:1:2068
  |
1 | ...at ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by...
  |                                                     ^^^^^^^^^^^ not found in this scope

warning: unreachable expression
 --> /tmp/.tmp8oKthg/main.rs:1:2504
  |
1 | ... ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") , format_size (memory_info . total))) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |       ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression
  |       |
  |       any code following this expression is unreachable
  |
  = note: `#[warn(unreachable_code)]` on by default

error: aborting due to 20 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0308, E0369, E0425, E0432, E0599.
For more information about an error, try `rustc --explain E0308`.



=== ch08-00-systems-programming example 2 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpUrMRam/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut pid = process :: current_pid () ; let mut ppid = process :: paren...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpUrMRam/main.rs:1:351
  |
1 | ... { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "PID: " , proc . pid . to_s ()) , ", Name: ") + proc . name , ", CPU: ") + proc . cpu_percent . to_s () , "%")) } } ...
  |       ^^                                                                                                                                                                                                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { let mut pid = process :: current_pid () ; let mut ppid = process :: parent_pid () ; let mut exe_path = process :: executable_path () ; let mut args = process :: args () ; let mut env = process :: environment () ; let mut all_processes = process :: list () ; for proc in all_processes { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "PID: " , proc . pid . to_s ()) , ", Name: ") + proc . name , ", CPU: ") + proc . cpu_percent . to_s () , "%")) } } ; let mut chrome_procs = process :: find_by_name ("chrome" . to_string ()) ; let mut high_cpu_procs = process :: list () . into_iter () . filter (| p | p . cpu_percent > 50i32) . collect () ; let mut proc = process :: from_pid (1234i32) ; proc . suspend () ; proc . resume () ; proc . terminate () ; proc . kill () ; let mut child = process :: spawn ("ls" . to_string () , vec ! ["-la"]) ; let mut output = child . wait_with_output () ; println ! ("{}" , output . stdout) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { let mut pid = process :: current_pid () ; let mut ppid = process :: parent_pid () ; let mut exe_path = process :: executable_path () ; let mut args = process :: args () ; let mut env = process :: environment () ; let mut all_processes = process :: list () ; for proc in all_processes { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "PID: " , proc . pid . to_s ()) , ", Name: ") + proc . name , ", CPU: ") + proc . cpu_percent . to_s () , "%")) } ; let mut chrome_procs = process :: find_by_name ("chrome" . to_string ()) ; let mut high_cpu_procs = process :: list () . into_iter () . filter (| p | p . cpu_percent > 50i32) . collect () ; let mut proc = process :: from_pid (1234i32) ; proc . suspend () ; proc . resume () ; proc . terminate () ; proc . kill () ; let mut child = process :: spawn ("ls" . to_string () , vec ! ["-la"]) ; let mut output = child . wait_with_output () ; println ! ("{}" , output . stdout) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpUrMRam/main.rs:1:79
  |
1 | ...in () { let result = { let mut pid = process :: current_pid () ; let mut ppid = process :: parent_pid () ; let mut exe_path = process ...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpUrMRam/main.rs:1:122
  |
1 | ...s :: current_pid () ; let mut ppid = process :: parent_pid () ; let mut exe_path = process :: executable_path () ; let mut args = proc...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpUrMRam/main.rs:1:168
  |
1 | ...: parent_pid () ; let mut exe_path = process :: executable_path () ; let mut args = process :: args () ; let mut env = process :: envi...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpUrMRam/main.rs:1:215
  |
1 | ... executable_path () ; let mut args = process :: args () ; let mut env = process :: environment () ; let mut all_processes = process ::...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpUrMRam/main.rs:1:250
  |
1 | ...= process :: args () ; let mut env = process :: environment () ; let mut all_processes = process :: list () ; for proc in all_processe...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpUrMRam/main.rs:1:302
  |
1 | ...ronment () ; let mut all_processes = process :: list () ; for proc in all_processes { { println ! ("{}" , format ! ("{}{}" , format ! ...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpUrMRam/main.rs:1:588
  |
1 | ..., "%")) } } ; let mut chrome_procs = process :: find_by_name ("chrome" . to_string ()) ; let mut high_cpu_procs = process :: list () ....
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpUrMRam/main.rs:1:665
  |
1 | ...tring ()) ; let mut high_cpu_procs = process :: list () . into_iter () . filter (| p | p . cpu_percent > 50i32) . collect () ; let mut...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpUrMRam/main.rs:1:770
  |
1 | ...50i32) . collect () ; let mut proc = process :: from_pid (1234i32) ; proc . suspend () ; proc . resume () ; proc . terminate () ; proc...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpUrMRam/main.rs:1:896
  |
1 | ...) ; proc . kill () ; let mut child = process :: spawn ("ls" . to_string () , vec ! ["-la"]) ; let mut output = child . wait_with_outpu...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error: aborting due to 10 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0433`.



=== ch08-00-systems-programming example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-systems-programming example 4 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpCClevh/main.rs:1:1025
  |
1 | ... data = shared . read (0i32 , 1024i32) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0425]: cannot find value `_000_000` in this scope
 --> /tmp/.tmpCClevh/main.rs:1:558
  |
1 | ...d . to_s ())) ; if mem_info . available < 100i32 { _000_000 } ; { println ! ("WARNING: Low memory!") ; free_caches () } ; let mut mmap...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `READ_ONLY` in this scope
 --> /tmp/.tmpCClevh/main.rs:1:700
  |
1 | ... :: map_file ("huge_dataset.bin" . to_string () , READ_ONLY) ; let mut data = mmap . read_range (0i32 , 1000000i32) ; mmap . close () ...
  |                                                      ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpCClevh/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut mem_info = system :: memory_info () ; println ! ("{}" , format ! ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `system`
 --> /tmp/.tmpCClevh/main.rs:1:84
  |
1 | ...) { let result = { let mut mem_info = system :: memory_info () ; println ! ("{}" , format ! ("{}{}" , "Total: " , mem_info . total . t...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `system`
  |
  = help: you might be missing a crate named `system`

error[E0425]: cannot find function `free_caches` in this scope
 --> /tmp/.tmpCClevh/main.rs:1:610
  |
1 | ...0_000 } ; { println ! ("WARNING: Low memory!") ; free_caches () } ; let mut mmap = memory :: map_file ("huge_dataset.bin" . to_string ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `memory`
 --> /tmp/.tmpCClevh/main.rs:1:644
  |
1 | ...) ; free_caches () } ; let mut mmap = memory :: map_file ("huge_dataset.bin" . to_string () , READ_ONLY) ; let mut data = mmap . read_...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `memory`
  |
  = help: you might be missing a crate named `memory`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `memory`
 --> /tmp/.tmpCClevh/main.rs:1:803
  |
1 | ... ; mmap . close () ; let mut shared = memory :: create_shared ("my_buffer" . to_string () , 1024i32 * 1024i32) ; shared . write (0i32 ...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `memory`
  |
  = help: you might be missing a crate named `memory`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `memory`
 --> /tmp/.tmpCClevh/main.rs:1:926
  |
1 | ...rite (0i32 , data) ; let mut shared = memory :: open_shared ("my_buffer" . to_string ()) ; let mut data = shared . read (0i32 , 1024i3...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `memory`
  |
  = help: you might be missing a crate named `memory`

error: aborting due to 8 previous errors; 1 warning emitted

Some errors have detailed explanations: E0425, E0433.
For more information about an error, try `rustc --explain E0425`.



=== ch08-00-systems-programming example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-systems-programming example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-systems-programming example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-systems-programming example 8 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `RECURSIVE` in this scope
 --> /tmp/.tmpdTE6vQ/main.rs:1:130
  |
1 | ... = fs :: watch ("/path/to/watch" . to_string () , RECURSIVE) ; watcher . on ("created" , | path | { println ! ("{}" , format ! ("{}{}"...
  |                                                      ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpdTE6vQ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut watcher = fs :: watch ("/path/to/watch" . to_string () , RECURSIV...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`
 --> /tmp/.tmpdTE6vQ/main.rs:1:83
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut watcher = fs :: watch ("/path/to/watch" . to_string () , RECURSIV...
  |                                                                                   ^^ use of unresolved module or unlinked crate `fs`
  |
  = help: you might be missing a crate named `fs`

error[E0425]: cannot find function `process_change` in this scope
 --> /tmp/.tmpdTE6vQ/main.rs:1:352
  |
1 | ...format ! ("{}{}" , "File modified: " , path)) ; process_change (path) }) ; watcher . on ("deleted" , | path | { println ! ("{}" , form...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 1 warning emitted

Some errors have detailed explanations: E0425, E0433.
For more information about an error, try `rustc --explain E0425`.



=== ch08-00-systems-programming example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-advanced-functions-tdd example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-advanced-functions-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `Type` in this scope
 --> /tmp/.tmpN7lu5G/main.rs:1:60
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |                                                            ^^^^ not found in this scope

error[E0412]: cannot find type `ResultType` in this scope
 --> /tmp/.tmpN7lu5G/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |                                                                     ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `condition1` in this scope
 --> /tmp/.tmpN7lu5G/main.rs:1:87
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |                                                                                       ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `result1` in this scope
 --> /tmp/.tmpN7lu5G/main.rs:1:109
  |
1 | ...: Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn m...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `condition2` in this scope
 --> /tmp/.tmpN7lu5G/main.rs:1:126
  |
1 | ...ype { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `result2` in this scope
 --> /tmp/.tmpN7lu5G/main.rs:1:148
  |
1 | ... { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `default_result` in this scope
 --> /tmp/.tmpN7lu5G/main.rs:1:169
  |
1 | ...; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpN7lu5G/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpN7lu5G/main.rs:1:100
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |                                                                                                    ^^              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
1 + use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { return result1 } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpN7lu5G/main.rs:1:139
  |
1 | ... { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |                                                              ^^              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
1 + use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { return result2 } ; return default_result } } fn main () { }
  |

error: aborting due to 7 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch08-00-advanced-functions-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `Type` in this scope
 --> /tmp/.tmpYC2pBH/main.rs:1:60
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |                                                            ^^^^ not found in this scope

error[E0412]: cannot find type `Type` in this scope
 --> /tmp/.tmpYC2pBH/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |                                                                     ^^^^ not found in this scope

error[E0425]: cannot find value `base_condition` in this scope
 --> /tmp/.tmpYC2pBH/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |                                                                                 ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `base_value` in this scope
 --> /tmp/.tmpYC2pBH/main.rs:1:107
  |
1 | ... : Type) -> Type { { if base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
  |                                                      ^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpYC2pBH/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpYC2pBH/main.rs:1:98
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |                                                                                                  ^^                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
1 + use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { return base_value } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
  |

error[E0425]: cannot find function `reduce` in this scope
 --> /tmp/.tmpYC2pBH/main.rs:1:160
  |
1 | ...ase_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
  |                                                        ^^^^^^ not found in this scope

error[E0425]: cannot find function `combine` in this scope
 --> /tmp/.tmpYC2pBH/main.rs:1:131
  |
1 | ... base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 6 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch08-00-advanced-functions-tdd example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 12 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch03-01-testing-functions example 2 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `actual` in this scope
 --> /tmp/.tmp5Gqtiq/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn test_function_name () { { assert_eq ! (actual , expected) } } fn main () { }
  |                                                                               ^^^^^^ not found in this scope

error[E0425]: cannot find value `expected` in this scope
 --> /tmp/.tmp5Gqtiq/main.rs:1:88
  |
1 | use std :: collections :: HashMap ; fn test_function_name () { { assert_eq ! (actual , expected) } } fn main () { }
  |                                                                                        ^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp5Gqtiq/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test_function_name () { { assert_eq ! (actual , expected) } } fn main () { }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp5Gqtiq/main.rs:1:64
  |
1 | use std :: collections :: HashMap ; fn test_function_name () { { assert_eq ! (actual , expected) } } fn main () { }
  |                                                                ^^                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_function_name () { { assert_eq ! (actual , expected) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_function_name () { assert_eq ! (actual , expected) } fn main () { }
  |

error: aborting due to 2 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch03-01-testing-functions example 3 ===
✗ Compilation failed: Compilation failed:
error[E0433]: failed to resolve: there are too many leading `super` keywords
 --> /tmp/.tmppyQo2M/main.rs:1:197
  |
1 | ...0i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }
  |                                              ^^^^^ there are too many leading `super` keywords

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmppyQo2M/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test_addition () { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn test_subtraction () { { assert_...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmppyQo2M/main.rs:1:59
  |
1 | use std :: collections :: HashMap ; fn test_addition () { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn test_subtraction () { { assert_...
  |                                                           ^^                                      ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_addition () { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn test_subtraction () { { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }
1 + use std :: collections :: HashMap ; fn test_addition () { assert_eq ! (add (2i32 , 3i32) , 5i32) } fn test_subtraction () { { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmppyQo2M/main.rs:1:129
  |
1 | ...3i32) , 5i32) } } fn test_subtraction () { { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }
  |                                               ^^                                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_addition () { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn test_subtraction () { { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }
1 + use std :: collections :: HashMap ; fn test_addition () { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn test_subtraction () { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } fn main () { use super :: * ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmppyQo2M/main.rs:1:210
  |
1 | ...2 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error[E0425]: cannot find function `add` in this scope
 --> /tmp/.tmppyQo2M/main.rs:1:74
  |
1 | use std :: collections :: HashMap ; fn test_addition () { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn test_subtraction () { { assert_...
  |                                                                          ^^^ not found in this scope
  |
help: use the `.` operator to call the method `Add::add` on `i32`
  |
1 - use std :: collections :: HashMap ; fn test_addition () { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn test_subtraction () { { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }
1 + use std :: collections :: HashMap ; fn test_addition () { { assert_eq ! (2i32.add(3i32) , 5i32) } } fn test_subtraction () { { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }
  |

error[E0425]: cannot find function `subtract` in this scope
 --> /tmp/.tmppyQo2M/main.rs:1:144
  |
1 | ... 5i32) } } fn test_subtraction () { { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }
  |                                                       ^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0425, E0433.
For more information about an error, try `rustc --explain E0425`.



=== ch03-01-testing-functions example 4 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpIEWUKf/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt ::...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpIEWUKf/main.rs:1:202
  |
1 | ...isplay + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: op...
  |                                                                  ^^     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n % 2i32 == 0i32 } } fn test_multiply () { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { a * b } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n % 2i32 == 0i32 } } fn test_multiply () { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpIEWUKf/main.rs:1:377
  |
1 | ... :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even < T : std :: ops :: Add < Out...
  |                                               ^^                                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n % 2i32 == 0i32 } } fn test_multiply () { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { if b == 0i32 { { 0i32 } } else { { a / b } } } fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n % 2i32 == 0i32 } } fn test_multiply () { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpIEWUKf/main.rs:1:394
  |
1 | ...fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even < T : std :: ops :: Add < ...
  |                                                                   ^^    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n % 2i32 == 0i32 } } fn test_multiply () { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { 0i32 } else { { a / b } } } } fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n % 2i32 == 0i32 } } fn test_multiply () { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpIEWUKf/main.rs:1:412
  |
1 | ...e > (a : T , b : T) -> T { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even < T : std :: ops :: Add < Output = T > + std ...
  |                                                                  ^^     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n % 2i32 == 0i32 } } fn test_multiply () { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { 0i32 } } else { a / b } } } fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n % 2i32 == 0i32 } } fn test_multiply () { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpIEWUKf/main.rs:1:584
  |
1 | ...: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n % 2i32 == 0i32 } } fn test_multiply () { { assert_eq ! (multiply (3i32 , ...
  |                                                             ^^                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n % 2i32 == 0i32 } } fn test_multiply () { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { n % 2i32 == 0i32 } fn test_multiply () { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |

error[E0369]: binary operation `==` cannot be applied to type `T`
 --> /tmp/.tmpIEWUKf/main.rs:1:384
  |
1 | ...+ std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even < T : std :: ops ...
  |                                                                - ^^ ---- i32
  |                                                                |
  |                                                                T
  |
help: consider further restricting type parameter `T` with trait `PartialEq`
  |
1 | use std :: collections :: HashMap ; fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialEq<i32> > (a : T , b : T) -> T { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n % 2i32 == 0i32 } } fn test_multiply () { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                ++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpIEWUKf/main.rs:1:396
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { 0i32 } ...
  |       -                                                                                                                                                  -                      ^^^^ expected type parameter `T`, found `i32`
  |       |                                                                                                                                                  |
  |       expected this type parameter                                                                                                                       expected `T` because of return type
  |
  = note: expected type parameter `T`
                       found type `i32`
  = note: the caller chooses a type for `T` which can be different from `i32`

error[E0369]: cannot divide `T` by `T`
 --> /tmp/.tmpIEWUKf/main.rs:1:416
  |
1 | ... > (a : T , b : T) -> T { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even < T : std :: ops :: Add < Output = T > + std :...
  |                                                                   - ^ - T
  |                                                                   |
  |                                                                   T
  |
help: consider further restricting type parameter `T` with trait `Div`
  |
1 | use std :: collections :: HashMap ; fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Div<Output = T> > (a : T , b : T) -> T { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n % 2i32 == 0i32 } } fn test_multiply () { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                +++++++++++++++++++++++++++

error[E0369]: cannot calculate the remainder of `T` divided by `i32`
 --> /tmp/.tmpIEWUKf/main.rs:1:588
  |
1 | ... :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n % 2i32 == 0i32 } } fn test_multiply () { { assert_eq ! (multiply (3i32 ...
  |                                                                 - ^ ---- i32
  |                                                                 |
  |                                                                 T
  |
help: consider further restricting type parameter `T` with trait `Rem`
  |
1 | use std :: collections :: HashMap ; fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Rem<i32> > (n : T) -> T { { n % 2i32 == 0i32 } } fn test_multiply () { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpIEWUKf/main.rs:1:586
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n % 2i32 == 0i32 } ...
  |       -                                                                                                                                          -     ^^^^^^^^^^^^^^^^ expected type parameter `T`, found `bool`
  |       |                                                                                                                                          |
  |       expected this type parameter                                                                                                               expected `T` because of return type
  |
  = note: expected type parameter `T`
                       found type `bool`
  = note: the caller chooses a type for `T` which can be different from `bool`

error[E0308]: mismatched types
 --> /tmp/.tmpIEWUKf/main.rs:1:975
  |
1 | ...0i32) } } fn test_is_even () { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_...
  |                                               -------  ^^^^ expected `bool`, found `i32`
  |                                               |
  |                                               arguments to this function are incorrect
  |
help: the return type of this call is `i32` due to the type of the argument passed
 --> /tmp/.tmpIEWUKf/main.rs:1:966
  |
1 | ...fn test_is_even () { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i...
  |                                     ^^^^^^^^^----^
  |                                              |
  |                                              this argument influences the return type of `is_even`
note: function defined here
 --> /tmp/.tmpIEWUKf/main.rs:1:431
  |
1 | ...fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -...
  |       ^^^^^^^                                                                                                                                    -----

error[E0308]: mismatched types
 --> /tmp/.tmpIEWUKf/main.rs:1:1005
  |
1 | ... { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |                                               -------  ^^^^ expected `bool`, found `i32`
  |                                               |
  |                                               arguments to this function are incorrect
  |
help: the return type of this call is `i32` due to the type of the argument passed
 --> /tmp/.tmpIEWUKf/main.rs:1:996
  |
1 | ...! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |                                     ^^^^^^^^^----^
  |                                              |
  |                                              this argument influences the return type of `is_even`
note: function defined here
 --> /tmp/.tmpIEWUKf/main.rs:1:431
  |
1 | ...fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -...
  |       ^^^^^^^                                                                                                                                    -----

error[E0308]: mismatched types
 --> /tmp/.tmpIEWUKf/main.rs:1:1033
  |
1 | ... ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |                                               -------  ^^^^ expected `bool`, found `i32`
  |                                               |
  |                                               arguments to this function are incorrect
  |
help: the return type of this call is `i32` due to the type of the argument passed
 --> /tmp/.tmpIEWUKf/main.rs:1:1024
  |
1 | ...! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |                                     ^^^^^^^^^----^
  |                                              |
  |                                              this argument influences the return type of `is_even`
note: function defined here
 --> /tmp/.tmpIEWUKf/main.rs:1:431
  |
1 | ...fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -...
  |       ^^^^^^^                                                                                                                                    -----

error[E0308]: mismatched types
 --> /tmp/.tmpIEWUKf/main.rs:1:1063
  |
1 | ... ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |                                               -------  ^^^^^^ expected `bool`, found `i32`
  |                                               |
  |                                               arguments to this function are incorrect
  |
help: the return type of this call is `i32` due to the type of the argument passed
 --> /tmp/.tmpIEWUKf/main.rs:1:1054
  |
1 | ... (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |                                    ^^^^^^^^^------^
  |                                             |
  |                                             this argument influences the return type of `is_even`
note: function defined here
 --> /tmp/.tmpIEWUKf/main.rs:1:431
  |
1 | ...fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -...
  |       ^^^^^^^                                                                                                                                    -----

error: aborting due to 9 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0308, E0369.
For more information about an error, try `rustc --explain E0308`.



=== ch03-01-testing-functions example 5 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpGcDqxJ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt ::...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpGcDqxJ/main.rs:1:200
  |
1 | ... { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } ...
  |       ^^                                                                                                                                                                                                                                                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } fn test_find_max () { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpGcDqxJ/main.rs:1:232
  |
1 | ...one > (numbers : T) -> T { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let ...
  |                                                               ^^           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { if numbers . len () == 0i32 { - 999999i32 } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpGcDqxJ/main.rs:1:389
  |
1 | ... . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_fi...
  |                                                      ^^                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { max_val = numbers [i as usize] } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
  |

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpGcDqxJ/main.rs:1:215
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { if numbers . len ()...
  |       - method `len` not found for this type parameter                                                                                                                    ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (numbers : T) -> T { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
  |                                                                                                                                                                                 +++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpGcDqxJ/main.rs:1:234
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { if numbers . len () == 0i32 { { - 999999i32 } ...
  |       - expected this type parameter                                                                                                                   - expected `T` because of return type ^^^^^^^^^^^ expected type parameter `T`, found `i32`
  |
  = note: expected type parameter `T`
                       found type `i32`
  = note: the caller chooses a type for `T` which can be different from `i32`

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpGcDqxJ/main.rs:1:285
  |
1 | ...i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numb...
  |                                                               ^^^^^^^^^^^^^^^

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpGcDqxJ/main.rs:1:342
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                                   ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (numbers : T) -> T { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
  |                                                                                                                                                                                 +++++++++++++++++++

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpGcDqxJ/main.rs:1:364
  |
1 | ...let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1...
  |                                                                 ^^^^^^^^^^^^

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpGcDqxJ/main.rs:1:409
  |
1 | ... { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max ()...
  |                                                                 ^^^^^^^^^^^^

error[E0277]: cannot add `Vec<i32>` to `Vec<i32>`
 --> /tmp/.tmpGcDqxJ/main.rs:1:510
  |
1 | ...() { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; ass...
  |                        --------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `Vec<i32> + Vec<i32>`
  |                        |
  |                        required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `Vec<i32>`
note: required by a bound in `find_max`
 --> /tmp/.tmpGcDqxJ/main.rs:1:55
  |
1 | use std :: collections :: HashMap ; fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt ::...
  |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`

error[E0277]: cannot multiply `Vec<i32>` by `Vec<i32>`
 --> /tmp/.tmpGcDqxJ/main.rs:1:510
  |
1 | ...() { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; ass...
  |                        --------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `Vec<i32> * Vec<i32>`
  |                        |
  |                        required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `Vec<i32>`
note: required by a bound in `find_max`
 --> /tmp/.tmpGcDqxJ/main.rs:1:90
  |
1 | ... :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T)...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`

error[E0277]: `Vec<i32>` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpGcDqxJ/main.rs:1:510
  |
1 | ...ert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (...
  |              --------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::fmt::Display` is not implemented for `Vec<i32>`
  |              |
  |              required by a bound introduced by this call
  |
note: required by a bound in `find_max`
 --> /tmp/.tmpGcDqxJ/main.rs:1:125
  |
1 | ... + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { if numbers . len ()...
  |                                          ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`

error[E0277]: can't compare `Vec<i32>` with `i32`
 --> /tmp/.tmpGcDqxJ/main.rs:1:487
  |
1 | ...max () { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ;...
  |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `Vec<i32> == i32`
  |
  = help: the trait `PartialEq<i32>` is not implemented for `Vec<i32>`
  = help: the following other types implement trait `PartialEq<Rhs>`:
            `Vec<T, A1>` implements `PartialEq<Vec<U, A2>>`
            `Vec<T, A>` implements `PartialEq<&[U; N]>`
            `Vec<T, A>` implements `PartialEq<&[U]>`
            `Vec<T, A>` implements `PartialEq<&mut [U]>`
            `Vec<T, A>` implements `PartialEq<[U; N]>`
            `Vec<T, A>` implements `PartialEq<[U]>`
            `Vec<u8>` implements `PartialEq<ByteStr>`
            `Vec<u8>` implements `PartialEq<ByteString>`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: cannot add `Vec<i32>` to `Vec<i32>`
 --> /tmp/.tmpGcDqxJ/main.rs:1:585
  |
1 | ... , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (fi...
  |                                     --------  ^^^^^^^^^^^^^ no implementation for `Vec<i32> + Vec<i32>`
  |                                     |
  |                                     required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `Vec<i32>`
note: required by a bound in `find_max`
 --> /tmp/.tmpGcDqxJ/main.rs:1:55
  |
1 | use std :: collections :: HashMap ; fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt ::...
  |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`

error[E0277]: cannot multiply `Vec<i32>` by `Vec<i32>`
 --> /tmp/.tmpGcDqxJ/main.rs:1:585
  |
1 | ... , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (fi...
  |                                     --------  ^^^^^^^^^^^^^ no implementation for `Vec<i32> * Vec<i32>`
  |                                     |
  |                                     required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `Vec<i32>`
note: required by a bound in `find_max`
 --> /tmp/.tmpGcDqxJ/main.rs:1:90
  |
1 | ... :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T)...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`

error[E0277]: `Vec<i32>` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpGcDqxJ/main.rs:1:585
  |
1 | ..., 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (ve...
  |                           --------  ^^^^^^^^^^^^^ the trait `std::fmt::Display` is not implemented for `Vec<i32>`
  |                           |
  |                           required by a bound introduced by this call
  |
note: required by a bound in `find_max`
 --> /tmp/.tmpGcDqxJ/main.rs:1:125
  |
1 | ... + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { if numbers . len ()...
  |                                          ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`

error[E0277]: can't compare `Vec<i32>` with `i32`
 --> /tmp/.tmpGcDqxJ/main.rs:1:562
  |
1 | ...9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq !...
  |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `Vec<i32> == i32`
  |
  = help: the trait `PartialEq<i32>` is not implemented for `Vec<i32>`
  = help: the following other types implement trait `PartialEq<Rhs>`:
            `Vec<T, A1>` implements `PartialEq<Vec<U, A2>>`
            `Vec<T, A>` implements `PartialEq<&[U; N]>`
            `Vec<T, A>` implements `PartialEq<&[U]>`
            `Vec<T, A>` implements `PartialEq<&mut [U]>`
            `Vec<T, A>` implements `PartialEq<[U; N]>`
            `Vec<T, A>` implements `PartialEq<[U]>`
            `Vec<u8>` implements `PartialEq<ByteStr>`
            `Vec<u8>` implements `PartialEq<ByteString>`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: cannot add `Vec<_>` to `Vec<_>`
 --> /tmp/.tmpGcDqxJ/main.rs:1:634
  |
1 | ...ec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) ,...
  |                                          --------  ^^^^^^^^ no implementation for `Vec<_> + Vec<_>`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `Vec<_>`
note: required by a bound in `find_max`
 --> /tmp/.tmpGcDqxJ/main.rs:1:55
  |
1 | use std :: collections :: HashMap ; fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt ::...
  |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`

error[E0277]: cannot multiply `Vec<_>` by `Vec<_>`
 --> /tmp/.tmpGcDqxJ/main.rs:1:634
  |
1 | ...ec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) ,...
  |                                          --------  ^^^^^^^^ no implementation for `Vec<_> * Vec<_>`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `Vec<_>`
note: required by a bound in `find_max`
 --> /tmp/.tmpGcDqxJ/main.rs:1:90
  |
1 | ... :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T)...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`

error[E0277]: `Vec<_>` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpGcDqxJ/main.rs:1:634
  |
1 | ...]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; ...
  |                               --------  ^^^^^^^^ the trait `std::fmt::Display` is not implemented for `Vec<_>`
  |                               |
  |                               required by a bound introduced by this call
  |
note: required by a bound in `find_max`
 --> /tmp/.tmpGcDqxJ/main.rs:1:125
  |
1 | ... + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { if numbers . len ()...
  |                                          ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`

error[E0277]: can't compare `Vec<_>` with `i32`
 --> /tmp/.tmpGcDqxJ/main.rs:1:611
  |
1 | ...c ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , ...
  |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `Vec<_> == i32`
  |
  = help: the trait `PartialEq<i32>` is not implemented for `Vec<_>`
  = help: the following other types implement trait `PartialEq<Rhs>`:
            `Vec<T, A1>` implements `PartialEq<Vec<U, A2>>`
            `Vec<T, A>` implements `PartialEq<&[U; N]>`
            `Vec<T, A>` implements `PartialEq<&[U]>`
            `Vec<T, A>` implements `PartialEq<&mut [U]>`
            `Vec<T, A>` implements `PartialEq<[U; N]>`
            `Vec<T, A>` implements `PartialEq<[U]>`
            `Vec<u8>` implements `PartialEq<ByteStr>`
            `Vec<u8>` implements `PartialEq<ByteString>`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: cannot add `Vec<i32>` to `Vec<i32>`
 --> /tmp/.tmpGcDqxJ/main.rs:1:684
  |
1 | ...999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5...
  |                           --------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `Vec<i32> + Vec<i32>`
  |                           |
  |                           required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `Vec<i32>`
note: required by a bound in `find_max`
 --> /tmp/.tmpGcDqxJ/main.rs:1:55
  |
1 | use std :: collections :: HashMap ; fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt ::...
  |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`

error[E0277]: cannot multiply `Vec<i32>` by `Vec<i32>`
 --> /tmp/.tmpGcDqxJ/main.rs:1:684
  |
1 | ...999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5...
  |                           --------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `Vec<i32> * Vec<i32>`
  |                           |
  |                           required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `Vec<i32>`
note: required by a bound in `find_max`
 --> /tmp/.tmpGcDqxJ/main.rs:1:90
  |
1 | ... :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T)...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`

error[E0277]: `Vec<i32>` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpGcDqxJ/main.rs:1:684
  |
1 | ...assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } f...
  |                 --------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::fmt::Display` is not implemented for `Vec<i32>`
  |                 |
  |                 required by a bound introduced by this call
  |
note: required by a bound in `find_max`
 --> /tmp/.tmpGcDqxJ/main.rs:1:125
  |
1 | ... + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { if numbers . len ()...
  |                                          ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`

error[E0277]: can't compare `Vec<i32>` with `i32`
 --> /tmp/.tmpGcDqxJ/main.rs:1:661
  |
1 | ...999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) ...
  |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `Vec<i32> == i32`
  |
  = help: the trait `PartialEq<i32>` is not implemented for `Vec<i32>`
  = help: the following other types implement trait `PartialEq<Rhs>`:
            `Vec<T, A1>` implements `PartialEq<Vec<U, A2>>`
            `Vec<T, A>` implements `PartialEq<&[U; N]>`
            `Vec<T, A>` implements `PartialEq<&[U]>`
            `Vec<T, A>` implements `PartialEq<&mut [U]>`
            `Vec<T, A>` implements `PartialEq<[U; N]>`
            `Vec<T, A>` implements `PartialEq<[U]>`
            `Vec<u8>` implements `PartialEq<ByteStr>`
            `Vec<u8>` implements `PartialEq<ByteString>`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: cannot add `Vec<i32>` to `Vec<i32>`
 --> /tmp/.tmpGcDqxJ/main.rs:1:754
  |
1 | ...) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
  |                               --------  ^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `Vec<i32> + Vec<i32>`
  |                               |
  |                               required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `Vec<i32>`
note: required by a bound in `find_max`
 --> /tmp/.tmpGcDqxJ/main.rs:1:55
  |
1 | use std :: collections :: HashMap ; fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt ::...
  |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`

error[E0277]: cannot multiply `Vec<i32>` by `Vec<i32>`
 --> /tmp/.tmpGcDqxJ/main.rs:1:754
  |
1 | ...) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
  |                               --------  ^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `Vec<i32> * Vec<i32>`
  |                               |
  |                               required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `Vec<i32>`
note: required by a bound in `find_max`
 --> /tmp/.tmpGcDqxJ/main.rs:1:90
  |
1 | ... :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T)...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`

error[E0277]: `Vec<i32>` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpGcDqxJ/main.rs:1:754
  |
1 | ...) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
  |                     --------  ^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::fmt::Display` is not implemented for `Vec<i32>`
  |                     |
  |                     required by a bound introduced by this call
  |
note: required by a bound in `find_max`
 --> /tmp/.tmpGcDqxJ/main.rs:1:125
  |
1 | ... + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { if numbers . len ()...
  |                                          ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`

error[E0277]: can't compare `Vec<i32>` with `i32`
 --> /tmp/.tmpGcDqxJ/main.rs:1:731
  |
1 | ...i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `Vec<i32> == i32`
  |
  = help: the trait `PartialEq<i32>` is not implemented for `Vec<i32>`
  = help: the following other types implement trait `PartialEq<Rhs>`:
            `Vec<T, A1>` implements `PartialEq<Vec<U, A2>>`
            `Vec<T, A>` implements `PartialEq<&[U; N]>`
            `Vec<T, A>` implements `PartialEq<&[U]>`
            `Vec<T, A>` implements `PartialEq<&mut [U]>`
            `Vec<T, A>` implements `PartialEq<[U; N]>`
            `Vec<T, A>` implements `PartialEq<[U]>`
            `Vec<u8>` implements `PartialEq<ByteStr>`
            `Vec<u8>` implements `PartialEq<ByteString>`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 26 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0599, E0608.
For more information about an error, try `rustc --explain E0277`.



=== ch03-01-testing-functions example 6 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpQybreE/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn clean_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpQybreE/main.rs:1:211
  |
1 | ...mt :: Debug + Clone > (raw_username : T) -> T { { raw_username . replace (" " , "_") } } fn count_vowels < T : std :: ops :: Add < Out...
  |                                                    ^^                                  ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn clean_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (raw_username : T) -> T { { raw_username . replace (" " , "_") } } fn count_vowels < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_username () { { assert_eq ! (clean_username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () { { assert_eq ! (count_vowels ("hello" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn clean_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (raw_username : T) -> T { raw_username . replace (" " , "_") } fn count_vowels < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_username () { { assert_eq ! (clean_username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () { { assert_eq ! (count_vowels ("hello" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpQybreE/main.rs:1:416
  |
1 | ... { { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } ...
  |       ^^                                                                                                                                                                                                                         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn clean_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (raw_username : T) -> T { { raw_username . replace (" " , "_") } } fn count_vowels < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_username () { { assert_eq ! (clean_username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () { { assert_eq ! (count_vowels ("hello" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn clean_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (raw_username : T) -> T { { raw_username . replace (" " , "_") } } fn count_vowels < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } fn test_clean_username () { { assert_eq ! (clean_username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () { { assert_eq ! (count_vowels ("hello" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpQybreE/main.rs:1:578
  |
1 | ... len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_use...
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn clean_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (raw_username : T) -> T { { raw_username . replace (" " , "_") } } fn count_vowels < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_username () { { assert_eq ! (clean_username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () { { assert_eq ! (count_vowels ("hello" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn clean_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (raw_username : T) -> T { { raw_username . replace (" " , "_") } } fn count_vowels < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { count = count + 1i32 } ; i = i + 1i32 } } ; count } } } } fn test_clean_username () { { assert_eq ! (clean_username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () { { assert_eq ! (count_vowels ("hello" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
  |

error[E0599]: no method named `replace` found for type parameter `T` in the current scope
 --> /tmp/.tmpQybreE/main.rs:1:228
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (raw_username : T) -> T { { raw_username . replace ("...
  |       - method `replace` not found for this type parameter                                                                                                                       ^^^^^^^ method not found in `T`

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpQybreE/main.rs:1:524
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                                                                              ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn clean_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (raw_username : T) -> T { { raw_username . replace (" " , "_") } } fn count_vowels < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (text : T) -> T { { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_username () { { assert_eq ! (clean_username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () { { assert_eq ! (count_vowels ("hello" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                            +++++++++++++++++++

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpQybreE/main.rs:1:562
  |
1 | ...i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } }...
  |                                                                 ^^^^^^^^^^^^

error[E0308]: mismatched types
 --> /tmp/.tmpQybreE/main.rs:1:626
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } ...
  |       - expected this type parameter                                                                                                                - expected `T` because of return type                                                                                                                                                                                 ^^^^^ expected type parameter `T`, found `i32`
  |
  = note: expected type parameter `T`
                       found type `i32`
  = note: the caller chooses a type for `T` which can be different from `i32`

error[E0277]: cannot add `String` to `String`
 --> /tmp/.tmpQybreE/main.rs:1:699
  |
1 | ...ame () { { assert_eq ! (clean_username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_...
  |                            --------------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String + String`
  |                            |
  |                            required by a bound introduced by this call
  |
  = help: the trait `Add<String>` is not implemented for `String`
          but trait `Add<&str>` is implemented for it
  = help: for that trait implementation, expected `&str`, found `String`
note: required by a bound in `clean_username`
 --> /tmp/.tmpQybreE/main.rs:1:61
  |
1 | ...ap ; fn clean_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt ...
  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `clean_username`

error[E0277]: cannot multiply `String` by `String`
 --> /tmp/.tmpQybreE/main.rs:1:699
  |
1 | ...ame () { { assert_eq ! (clean_username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_...
  |                            --------------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String * String`
  |                            |
  |                            required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `String`
note: required by a bound in `clean_username`
 --> /tmp/.tmpQybreE/main.rs:1:96
  |
1 | ... ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (raw_username : ...
  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `clean_username`

error[E0277]: cannot add `String` to `String`
 --> /tmp/.tmpQybreE/main.rs:1:781
  |
1 | ...ce_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") }...
  |                                --------------  ^^^^^^^^^^^^^^^^^^^^^ no implementation for `String + String`
  |                                |
  |                                required by a bound introduced by this call
  |
  = help: the trait `Add<String>` is not implemented for `String`
          but trait `Add<&str>` is implemented for it
  = help: for that trait implementation, expected `&str`, found `String`
note: required by a bound in `clean_username`
 --> /tmp/.tmpQybreE/main.rs:1:61
  |
1 | ...ap ; fn clean_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt ...
  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `clean_username`

error[E0277]: cannot multiply `String` by `String`
 --> /tmp/.tmpQybreE/main.rs:1:781
  |
1 | ...ce_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") }...
  |                                --------------  ^^^^^^^^^^^^^^^^^^^^^ no implementation for `String * String`
  |                                |
  |                                required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `String`
note: required by a bound in `clean_username`
 --> /tmp/.tmpQybreE/main.rs:1:96
  |
1 | ... ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (raw_username : ...
  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `clean_username`

error[E0277]: cannot add `String` to `String`
 --> /tmp/.tmpQybreE/main.rs:1:845
  |
1 | ... ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () { { assert_eq ! (count_vowels ("hel...
  |                                  --------------  ^^^^^^^^^^^^^^^^^ no implementation for `String + String`
  |                                  |
  |                                  required by a bound introduced by this call
  |
  = help: the trait `Add<String>` is not implemented for `String`
          but trait `Add<&str>` is implemented for it
  = help: for that trait implementation, expected `&str`, found `String`
note: required by a bound in `clean_username`
 --> /tmp/.tmpQybreE/main.rs:1:61
  |
1 | ...ap ; fn clean_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt ...
  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `clean_username`

error[E0277]: cannot multiply `String` by `String`
 --> /tmp/.tmpQybreE/main.rs:1:845
  |
1 | ... ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () { { assert_eq ! (count_vowels ("hel...
  |                                  --------------  ^^^^^^^^^^^^^^^^^ no implementation for `String * String`
  |                                  |
  |                                  required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `String`
note: required by a bound in `clean_username`
 --> /tmp/.tmpQybreE/main.rs:1:96
  |
1 | ... ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (raw_username : ...
  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `clean_username`

error[E0277]: cannot add `String` to `String`
 --> /tmp/.tmpQybreE/main.rs:1:929
  |
1 | ...t_vowels () { { assert_eq ! (count_vowels ("hello" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32...
  |                                 ------------  ^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String + String`
  |                                 |
  |                                 required by a bound introduced by this call
  |
  = help: the trait `Add<String>` is not implemented for `String`
          but trait `Add<&str>` is implemented for it
  = help: for that trait implementation, expected `&str`, found `String`
note: required by a bound in `count_vowels`
 --> /tmp/.tmpQybreE/main.rs:1:274
  |
1 | ..._") } } fn count_vowels < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `count_vowels`

error[E0277]: cannot multiply `String` by `String`
 --> /tmp/.tmpQybreE/main.rs:1:929
  |
1 | ...t_vowels () { { assert_eq ! (count_vowels ("hello" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32...
  |                                 ------------  ^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String * String`
  |                                 |
  |                                 required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `String`
note: required by a bound in `count_vowels`
 --> /tmp/.tmpQybreE/main.rs:1:309
  |
1 | ...: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `count_vowels`

error[E0277]: can't compare `String` with `i32`
 --> /tmp/.tmpQybreE/main.rs:1:902
  |
1 | ...ount_vowels () { { assert_eq ! (count_vowels ("hello" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2...
  |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String == i32`
  |
  = help: the trait `PartialEq<i32>` is not implemented for `String`
  = help: the following other types implement trait `PartialEq<Rhs>`:
            `String` implements `PartialEq<&str>`
            `String` implements `PartialEq<ByteStr>`
            `String` implements `PartialEq<ByteString>`
            `String` implements `PartialEq<Cow<'_, str>>`
            `String` implements `PartialEq<str>`
            `String` implements `PartialEq`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: cannot add `String` to `String`
 --> /tmp/.tmpQybreE/main.rs:1:990
  |
1 | ...g ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ...
  |                                 ------------  ^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String + String`
  |                                 |
  |                                 required by a bound introduced by this call
  |
  = help: the trait `Add<String>` is not implemented for `String`
          but trait `Add<&str>` is implemented for it
  = help: for that trait implementation, expected `&str`, found `String`
note: required by a bound in `count_vowels`
 --> /tmp/.tmpQybreE/main.rs:1:274
  |
1 | ..._") } } fn count_vowels < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `count_vowels`

error[E0277]: cannot multiply `String` by `String`
 --> /tmp/.tmpQybreE/main.rs:1:990
  |
1 | ...g ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ...
  |                                 ------------  ^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String * String`
  |                                 |
  |                                 required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `String`
note: required by a bound in `count_vowels`
 --> /tmp/.tmpQybreE/main.rs:1:309
  |
1 | ...: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `count_vowels`

error[E0277]: can't compare `String` with `i32`
 --> /tmp/.tmpQybreE/main.rs:1:963
  |
1 | ...ring ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i3...
  |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String == i32`
  |
  = help: the trait `PartialEq<i32>` is not implemented for `String`
  = help: the following other types implement trait `PartialEq<Rhs>`:
            `String` implements `PartialEq<&str>`
            `String` implements `PartialEq<ByteStr>`
            `String` implements `PartialEq<ByteString>`
            `String` implements `PartialEq<Cow<'_, str>>`
            `String` implements `PartialEq<str>`
            `String` implements `PartialEq`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: cannot add `String` to `String`
 --> /tmp/.tmpQybreE/main.rs:1:1051
  |
1 | ...ng ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32)...
  |                                  ------------  ^^^^^^^^^^^^^^^^^^^^ no implementation for `String + String`
  |                                  |
  |                                  required by a bound introduced by this call
  |
  = help: the trait `Add<String>` is not implemented for `String`
          but trait `Add<&str>` is implemented for it
  = help: for that trait implementation, expected `&str`, found `String`
note: required by a bound in `count_vowels`
 --> /tmp/.tmpQybreE/main.rs:1:274
  |
1 | ..._") } } fn count_vowels < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `count_vowels`

error[E0277]: cannot multiply `String` by `String`
 --> /tmp/.tmpQybreE/main.rs:1:1051
  |
1 | ...ng ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32)...
  |                                  ------------  ^^^^^^^^^^^^^^^^^^^^ no implementation for `String * String`
  |                                  |
  |                                  required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `String`
note: required by a bound in `count_vowels`
 --> /tmp/.tmpQybreE/main.rs:1:309
  |
1 | ...: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `count_vowels`

error[E0277]: can't compare `String` with `i32`
 --> /tmp/.tmpQybreE/main.rs:1:1024
  |
1 | ...tring ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i...
  |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String == i32`
  |
  = help: the trait `PartialEq<i32>` is not implemented for `String`
  = help: the following other types implement trait `PartialEq<Rhs>`:
            `String` implements `PartialEq<&str>`
            `String` implements `PartialEq<ByteStr>`
            `String` implements `PartialEq<ByteString>`
            `String` implements `PartialEq<Cow<'_, str>>`
            `String` implements `PartialEq<str>`
            `String` implements `PartialEq`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: cannot add `String` to `String`
 --> /tmp/.tmpQybreE/main.rs:1:1110
  |
1 | ...g ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } }...
  |                                 ------------  ^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String + String`
  |                                 |
  |                                 required by a bound introduced by this call
  |
  = help: the trait `Add<String>` is not implemented for `String`
          but trait `Add<&str>` is implemented for it
  = help: for that trait implementation, expected `&str`, found `String`
note: required by a bound in `count_vowels`
 --> /tmp/.tmpQybreE/main.rs:1:274
  |
1 | ..._") } } fn count_vowels < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `count_vowels`

error[E0277]: cannot multiply `String` by `String`
 --> /tmp/.tmpQybreE/main.rs:1:1110
  |
1 | ...g ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } }...
  |                                 ------------  ^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String * String`
  |                                 |
  |                                 required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `String`
note: required by a bound in `count_vowels`
 --> /tmp/.tmpQybreE/main.rs:1:309
  |
1 | ...: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `count_vowels`

error[E0277]: can't compare `String` with `i32`
 --> /tmp/.tmpQybreE/main.rs:1:1083
  |
1 | ...ring ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) ...
  |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String == i32`
  |
  = help: the trait `PartialEq<i32>` is not implemented for `String`
  = help: the following other types implement trait `PartialEq<Rhs>`:
            `String` implements `PartialEq<&str>`
            `String` implements `PartialEq<ByteStr>`
            `String` implements `PartialEq<ByteString>`
            `String` implements `PartialEq<Cow<'_, str>>`
            `String` implements `PartialEq<str>`
            `String` implements `PartialEq`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: cannot add `String` to `String`
 --> /tmp/.tmpQybreE/main.rs:1:1171
  |
1 | ...ing ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
  |                                   ------------  ^^^^^^^^^^^^^^^^^ no implementation for `String + String`
  |                                   |
  |                                   required by a bound introduced by this call
  |
  = help: the trait `Add<String>` is not implemented for `String`
          but trait `Add<&str>` is implemented for it
  = help: for that trait implementation, expected `&str`, found `String`
note: required by a bound in `count_vowels`
 --> /tmp/.tmpQybreE/main.rs:1:274
  |
1 | ..._") } } fn count_vowels < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `count_vowels`

error[E0277]: cannot multiply `String` by `String`
 --> /tmp/.tmpQybreE/main.rs:1:1171
  |
1 | ...ing ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
  |                                   ------------  ^^^^^^^^^^^^^^^^^ no implementation for `String * String`
  |                                   |
  |                                   required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `String`
note: required by a bound in `count_vowels`
 --> /tmp/.tmpQybreE/main.rs:1:309
  |
1 | ...: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `count_vowels`

error[E0277]: can't compare `String` with `i32`
 --> /tmp/.tmpQybreE/main.rs:1:1144
  |
1 | ...string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
  |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String == i32`
  |
  = help: the trait `PartialEq<i32>` is not implemented for `String`
  = help: the following other types implement trait `PartialEq<Rhs>`:
            `String` implements `PartialEq<&str>`
            `String` implements `PartialEq<ByteStr>`
            `String` implements `PartialEq<ByteString>`
            `String` implements `PartialEq<Cow<'_, str>>`
            `String` implements `PartialEq<str>`
            `String` implements `PartialEq`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 25 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0599, E0608.
For more information about an error, try `rustc --explain E0277`.



=== ch03-01-testing-functions example 7 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpYau8bh/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn calculate_grade < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std ::...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpYau8bh/main.rs:1:205
  |
1 | ... { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } ...
  |       ^^                                                                                                                                                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_grade < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -> T { { age >= 18i32 && is_citizen } } fn test_calculate_grade () { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn calculate_grade < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -> T { { age >= 18i32 && is_citizen } } fn test_calculate_grade () { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpYau8bh/main.rs:1:227
  |
1 | ...mt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_grade < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -> T { { age >= 18i32 && is_citizen } } fn test_calculate_grade () { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn calculate_grade < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { "A" } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -> T { { age >= 18i32 && is_citizen } } fn test_calculate_grade () { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpYau8bh/main.rs:1:264
  |
1 | ...T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_grade < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -> T { { age >= 18i32 && is_citizen } } fn test_calculate_grade () { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn calculate_grade < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { "B" } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -> T { { age >= 18i32 && is_citizen } } fn test_calculate_grade () { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpYau8bh/main.rs:1:301
  |
1 | ...lse { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } }...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_grade < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -> T { { age >= 18i32 && is_citizen } } fn test_calculate_grade () { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn calculate_grade < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { "C" } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -> T { { age >= 18i32 && is_citizen } } fn test_calculate_grade () { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpYau8bh/main.rs:1:338
  |
1 | ...lse { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote < T : std :: ops :: Ad...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_grade < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -> T { { age >= 18i32 && is_citizen } } fn test_calculate_grade () { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn calculate_grade < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { "D" } else { { "F" } } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -> T { { age >= 18i32 && is_citizen } } fn test_calculate_grade () { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpYau8bh/main.rs:1:355
  |
1 | ... 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > ...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_grade < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -> T { { age >= 18i32 && is_citizen } } fn test_calculate_grade () { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn calculate_grade < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { "F" } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -> T { { age >= 18i32 && is_citizen } } fn test_calculate_grade () { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpYau8bh/main.rs:1:551
  |
1 | ...: Debug + Clone > (age : T , is_citizen : T) -> T { { age >= 18i32 && is_citizen } } fn test_calculate_grade () { { assert_eq ! (calcu...
  |                                                        ^^                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_grade < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -> T { { age >= 18i32 && is_citizen } } fn test_calculate_grade () { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn calculate_grade < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -> T { age >= 18i32 && is_citizen } fn test_calculate_grade () { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |

error[E0369]: binary operation `>=` cannot be applied to type `T`
 --> /tmp/.tmpYau8bh/main.rs:1:216
  |
1 | ...y + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if sc...
  |                                                              ----- ^^ ----- i32
  |                                                              |
  |                                                              T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn calculate_grade < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -> T { { age >= 18i32 && is_citizen } } fn test_calculate_grade () { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                                                                                                                                                        +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpYau8bh/main.rs:1:229
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } ...
  |       -                                                                                                                                              -                           ^^^ expected type parameter `T`, found `&str`
  |       |                                                                                                                                              |
  |       expected this type parameter                                                                                                                   expected `T` because of return type
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0369]: binary operation `>=` cannot be applied to type `T`
 --> /tmp/.tmpYau8bh/main.rs:1:253
  |
1 | ...ore : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if sc...
  |                                                              ----- ^^ ----- i32
  |                                                              |
  |                                                              T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn calculate_grade < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -> T { { age >= 18i32 && is_citizen } } fn test_calculate_grade () { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                                                                                                                                                        +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpYau8bh/main.rs:1:266
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } ...
  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                            ^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0369]: binary operation `>=` cannot be applied to type `T`
 --> /tmp/.tmpYau8bh/main.rs:1:290
  |
1 | ... { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F"...
  |                                                              ----- ^^ ----- i32
  |                                                              |
  |                                                              T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn calculate_grade < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -> T { { age >= 18i32 && is_citizen } } fn test_calculate_grade () { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                                                                                                                                                        +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpYau8bh/main.rs:1:303
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } ...
  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                                                                 ^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0369]: binary operation `>=` cannot be applied to type `T`
 --> /tmp/.tmpYau8bh/main.rs:1:327
  |
1 | ... { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote < T : std ...
  |                                                              ----- ^^ ----- i32
  |                                                              |
  |                                                              T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn calculate_grade < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -> T { { age >= 18i32 && is_citizen } } fn test_calculate_grade () { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                                                                                                                                                        +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpYau8bh/main.rs:1:340
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } ...
  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                                                                                                      ^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0308]: mismatched types
 --> /tmp/.tmpYau8bh/main.rs:1:357
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } ...
  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                                                                                                                       ^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0369]: binary operation `>=` cannot be applied to type `T`
 --> /tmp/.tmpYau8bh/main.rs:1:557
  |
1 | ...fmt :: Debug + Clone > (age : T , is_citizen : T) -> T { { age >= 18i32 && is_citizen } } fn test_calculate_grade () { { assert_eq ! (...
  |                                                               --- ^^ ----- i32
  |                                                               |
  |                                                               T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn calculate_grade < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (age : T , is_citizen : T) -> T { { age >= 18i32 && is_citizen } } fn test_calculate_grade () { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpYau8bh/main.rs:1:569
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -> T { { age >= 18i32 && is_citizen } ...
  |       - found this type parameter                                                                                                                                                         ^^^^^^^^^^ expected `bool`, found type parameter `T`
  |
  = note:        expected type `bool`
          found type parameter `T`

error[E0308]: mismatched types
 --> /tmp/.tmpYau8bh/main.rs:1:553
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -> T { { age >= 18i32 && is_citizen } ...
  |       -                                                                                                                                                             -     ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `bool`
  |       |                                                                                                                                                             |
  |       expected this type parameter                                                                                                                                  expected `T` because of return type
  |
  = note: expected type parameter `T`
                       found type `bool`
  = note: the caller chooses a type for `T` which can be different from `bool`

error[E0308]: mismatched types
 --> /tmp/.tmpYau8bh/main.rs:1:654
  |
1 | ...rade () { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (...
  |                                                       ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpYau8bh/main.rs:1:700
  |
1 | ...2) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (...
  |                                                       ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpYau8bh/main.rs:1:746
  |
1 | ...2) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (...
  |                                                       ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpYau8bh/main.rs:1:792
  |
1 | ...2) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (...
  |                                                       ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpYau8bh/main.rs:1:838
  |
1 | ...2) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (...
  |                                                       ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpYau8bh/main.rs:1:884
  |
1 | ...2) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () { { asser...
  |                                                       ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpYau8bh/main.rs:1:929
  |
1 | ...32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () { { assert ! (can_vote (18i32 , true)) ; assert ! (can...
  |                                                       ^^^ expected `i32`, found `&str`

error[E0277]: cannot add `bool` to `bool`
 --> /tmp/.tmpYau8bh/main.rs:1:972
  |
1 | ..., "F") } } fn test_can_vote () { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i...
  |                                                 ^^^^^^^^ no implementation for `bool + bool`
  |
  = help: the trait `Add` is not implemented for `bool`
note: required by a bound in `can_vote`
 --> /tmp/.tmpYau8bh/main.rs:1:393
  |
1 | ...} } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: f...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `can_vote`

error[E0277]: cannot multiply `bool` by `bool`
 --> /tmp/.tmpYau8bh/main.rs:1:972
  |
1 | ..., "F") } } fn test_can_vote () { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i...
  |                                                 ^^^^^^^^ no implementation for `bool * bool`
  |
  = help: the trait `Mul` is not implemented for `bool`
note: required by a bound in `can_vote`
 --> /tmp/.tmpYau8bh/main.rs:1:428
  |
1 | ... :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `can_vote`

error[E0308]: mismatched types
 --> /tmp/.tmpYau8bh/main.rs:1:982
  |
1 | ...rt ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i...
  |          --------  ^^^^^   ---- expected all arguments to be this `bool` type because they need to match the type of this parameter
  |          |         |
  |          |         expected `bool`, found `i32`
  |          arguments to this function are incorrect
  |
help: the return type of this call is `i32` due to the type of the argument passed
 --> /tmp/.tmpYau8bh/main.rs:1:972
  |
1 | ... test_can_vote () { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ;...
  |                                    ^^^^^^^^^^-----^^^^^^^^
  |                                              |
  |                                              this argument influences the return type of `can_vote`
note: function defined here
 --> /tmp/.tmpYau8bh/main.rs:1:378
  |
1 | ...fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -...
  |       ^^^^^^^^   -                                                                                                                                -------   -------------- `age` needs to match the `bool` type of this parameter
  |                  |                                                                                                                                |
  |                  `age` and `is_citizen` both reference this parameter `T`                                                                         this parameter needs to match the `bool` type of `is_citizen`

error[E0277]: cannot add `bool` to `bool`
 --> /tmp/.tmpYau8bh/main.rs:1:1009
  |
1 | ...sert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (2...
  |                                                 ^^^^^^^^ no implementation for `bool + bool`
  |
  = help: the trait `Add` is not implemented for `bool`
note: required by a bound in `can_vote`
 --> /tmp/.tmpYau8bh/main.rs:1:393
  |
1 | ...} } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: f...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `can_vote`

error[E0277]: cannot multiply `bool` by `bool`
 --> /tmp/.tmpYau8bh/main.rs:1:1009
  |
1 | ...sert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (2...
  |                                                 ^^^^^^^^ no implementation for `bool * bool`
  |
  = help: the trait `Mul` is not implemented for `bool`
note: required by a bound in `can_vote`
 --> /tmp/.tmpYau8bh/main.rs:1:428
  |
1 | ... :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `can_vote`

error[E0308]: mismatched types
 --> /tmp/.tmpYau8bh/main.rs:1:1019
  |
1 | ...rt ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (...
  |          --------  ^^^^^   ---- expected all arguments to be this `bool` type because they need to match the type of this parameter
  |          |         |
  |          |         expected `bool`, found `i32`
  |          arguments to this function are incorrect
  |
help: the return type of this call is `i32` due to the type of the argument passed
 --> /tmp/.tmpYau8bh/main.rs:1:1009
  |
1 | ...ote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)...
  |                                    ^^^^^^^^^^-----^^^^^^^^
  |                                              |
  |                                              this argument influences the return type of `can_vote`
note: function defined here
 --> /tmp/.tmpYau8bh/main.rs:1:378
  |
1 | ...fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -...
  |       ^^^^^^^^   -                                                                                                                                -------   -------------- `age` needs to match the `bool` type of this parameter
  |                  |                                                                                                                                |
  |                  `age` and `is_citizen` both reference this parameter `T`                                                                         this parameter needs to match the `bool` type of `is_citizen`

error[E0277]: cannot add `bool` to `bool`
 --> /tmp/.tmpYau8bh/main.rs:1:1048
  |
1 | ...rt ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (...
  |                                                 ^^^^^^^^ no implementation for `bool + bool`
  |
  = help: the trait `Add` is not implemented for `bool`
note: required by a bound in `can_vote`
 --> /tmp/.tmpYau8bh/main.rs:1:393
  |
1 | ...} } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: f...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `can_vote`

error[E0277]: cannot multiply `bool` by `bool`
 --> /tmp/.tmpYau8bh/main.rs:1:1048
  |
1 | ...rt ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (...
  |                                                 ^^^^^^^^ no implementation for `bool * bool`
  |
  = help: the trait `Mul` is not implemented for `bool`
note: required by a bound in `can_vote`
 --> /tmp/.tmpYau8bh/main.rs:1:428
  |
1 | ... :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `can_vote`

error[E0308]: mismatched types
 --> /tmp/.tmpYau8bh/main.rs:1:1058
  |
1 | ... ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |          --------  ^^^^^   ---- expected all arguments to be this `bool` type because they need to match the type of this parameter
  |          |         |
  |          |         expected `bool`, found `i32`
  |          arguments to this function are incorrect
  |
help: the return type of this call is `i32` due to the type of the argument passed
 --> /tmp/.tmpYau8bh/main.rs:1:1048
  |
1 | ...e (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false...
  |                                    ^^^^^^^^^^-----^^^^^^^^
  |                                              |
  |                                              this argument influences the return type of `can_vote`
note: function defined here
 --> /tmp/.tmpYau8bh/main.rs:1:378
  |
1 | ...fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -...
  |       ^^^^^^^^   -                                                                                                                                -------   -------------- `age` needs to match the `bool` type of this parameter
  |                  |                                                                                                                                |
  |                  `age` and `is_citizen` both reference this parameter `T`                                                                         this parameter needs to match the `bool` type of `is_citizen`

error[E0277]: cannot add `bool` to `bool`
 --> /tmp/.tmpYau8bh/main.rs:1:1087
  |
1 | ... ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                 ^^^^^^^^ no implementation for `bool + bool`
  |
  = help: the trait `Add` is not implemented for `bool`
note: required by a bound in `can_vote`
 --> /tmp/.tmpYau8bh/main.rs:1:393
  |
1 | ...} } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: f...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `can_vote`

error[E0277]: cannot multiply `bool` by `bool`
 --> /tmp/.tmpYau8bh/main.rs:1:1087
  |
1 | ... ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                 ^^^^^^^^ no implementation for `bool * bool`
  |
  = help: the trait `Mul` is not implemented for `bool`
note: required by a bound in `can_vote`
 --> /tmp/.tmpYau8bh/main.rs:1:428
  |
1 | ... :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `can_vote`

error[E0308]: mismatched types
 --> /tmp/.tmpYau8bh/main.rs:1:1097
  |
1 | ...! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |         --------  ^^^^^   ----- expected all arguments to be this `bool` type because they need to match the type of this parameter
  |         |         |
  |         |         expected `bool`, found `i32`
  |         arguments to this function are incorrect
  |
help: the return type of this call is `i32` due to the type of the argument passed
 --> /tmp/.tmpYau8bh/main.rs:1:1087
  |
1 | ...e (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                    ^^^^^^^^^^-----^^^^^^^^^
  |                                              |
  |                                              this argument influences the return type of `can_vote`
note: function defined here
 --> /tmp/.tmpYau8bh/main.rs:1:378
  |
1 | ...fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -...
  |       ^^^^^^^^   -                                                                                                                                -------   -------------- `age` needs to match the `bool` type of this parameter
  |                  |                                                                                                                                |
  |                  `age` and `is_citizen` both reference this parameter `T`                                                                         this parameter needs to match the `bool` type of `is_citizen`

error[E0277]: cannot add `bool` to `bool`
 --> /tmp/.tmpYau8bh/main.rs:1:1127
  |
1 | ...! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                 ^^^^^^^^ no implementation for `bool + bool`
  |
  = help: the trait `Add` is not implemented for `bool`
note: required by a bound in `can_vote`
 --> /tmp/.tmpYau8bh/main.rs:1:393
  |
1 | ...} } } } } } } fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: f...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `can_vote`

error[E0277]: cannot multiply `bool` by `bool`
 --> /tmp/.tmpYau8bh/main.rs:1:1127
  |
1 | ...! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                 ^^^^^^^^ no implementation for `bool * bool`
  |
  = help: the trait `Mul` is not implemented for `bool`
note: required by a bound in `can_vote`
 --> /tmp/.tmpYau8bh/main.rs:1:428
  |
1 | ... :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `can_vote`

error[E0308]: mismatched types
 --> /tmp/.tmpYau8bh/main.rs:1:1137
  |
1 | ...! (! can_vote (17i32 , false)) } } fn main () { }
  |         --------  ^^^^^   ----- expected all arguments to be this `bool` type because they need to match the type of this parameter
  |         |         |
  |         |         expected `bool`, found `i32`
  |         arguments to this function are incorrect
  |
help: the return type of this call is `i32` due to the type of the argument passed
 --> /tmp/.tmpYau8bh/main.rs:1:1127
  |
1 | ... (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                    ^^^^^^^^^^-----^^^^^^^^^
  |                                              |
  |                                              this argument influences the return type of `can_vote`
note: function defined here
 --> /tmp/.tmpYau8bh/main.rs:1:378
  |
1 | ...fn can_vote < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (age : T , is_citizen : T) -...
  |       ^^^^^^^^   -                                                                                                                                -------   -------------- `age` needs to match the `bool` type of this parameter
  |                  |                                                                                                                                |
  |                  `age` and `is_citizen` both reference this parameter `T`                                                                         this parameter needs to match the `bool` type of `is_citizen`

error: aborting due to 34 previous errors; 8 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0369.
For more information about an error, try `rustc --explain E0277`.



=== ch03-01-testing-functions example 8 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpAmxqMz/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test_fahrenheit_to_celsius () { { assert_eq ! (fahrenheit_to_celsius (32i32) , 0i32) ; assert_eq !...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpAmxqMz/main.rs:1:420
  |
1 | ...t :: Debug + Clone > (fahrenheit : T) -> T { { return fahrenheit - 32i32 * 5i32 / 9i32 } } fn main () { }
  |                                                 ^^                                       ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_fahrenheit_to_celsius () { { assert_eq ! (fahrenheit_to_celsius (32i32) , 0i32) ; assert_eq ! (fahrenheit_to_celsius (212i32) , 100i32) ; assert_eq ! (fahrenheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (fahrenheit : T) -> T { { return fahrenheit - 32i32 * 5i32 / 9i32 } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_fahrenheit_to_celsius () { { assert_eq ! (fahrenheit_to_celsius (32i32) , 0i32) ; assert_eq ! (fahrenheit_to_celsius (212i32) , 100i32) ; assert_eq ! (fahrenheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (fahrenheit : T) -> T { return fahrenheit - 32i32 * 5i32 / 9i32 } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpAmxqMz/main.rs:1:230
  |
1 | ... ; assert_eq ! (fahrenheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius < T : std :: ops :: Add < Output = T > + std :: ...
  |                                                      ^^^^^ expected `f64`, found `i32`
  |
help: you can convert an `i32` to an `f64`, producing the floating point representation of the integer
  |
1 | use std :: collections :: HashMap ; fn test_fahrenheit_to_celsius () { { assert_eq ! (fahrenheit_to_celsius (32i32) , 0i32) ; assert_eq ! (fahrenheit_to_celsius (212i32) , 100i32) ; assert_eq ! (fahrenheit_to_celsius (98.6f64) , 37i32.into()) } } fn fahrenheit_to_celsius < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (fahrenheit : T) -> T { { return fahrenheit - 32i32 * 5i32 / 9i32 } } fn main () { }
  |                                                                                                                                                                                                                                           +++++++

error[E0369]: cannot subtract `i32` from `T`
 --> /tmp/.tmpAmxqMz/main.rs:1:440
  |
1 | ...Debug + Clone > (fahrenheit : T) -> T { { return fahrenheit - 32i32 * 5i32 / 9i32 } } fn main () { }
  |                                                     ---------- ^ ------------------- i32
  |                                                     |
  |                                                     T
  |
help: consider further restricting type parameter `T` with trait `Sub`
  |
1 | use std :: collections :: HashMap ; fn test_fahrenheit_to_celsius () { { assert_eq ! (fahrenheit_to_celsius (32i32) , 0i32) ; assert_eq ! (fahrenheit_to_celsius (212i32) , 100i32) ; assert_eq ! (fahrenheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Sub<i32, Output = T> > (fahrenheit : T) -> T { { return fahrenheit - 32i32 * 5i32 / 9i32 } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                          ++++++++++++++++++++++++++++++++

error: aborting due to 2 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0308, E0369.
For more information about an error, try `rustc --explain E0308`.



=== ch03-01-testing-functions example 9 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpWS0fiu/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test_divide_bad () { { assert_eq ! (divide (10i32 , 2i32) , 5i32) } } fn test_divide_good () { { a...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpWS0fiu/main.rs:1:61
  |
1 | use std :: collections :: HashMap ; fn test_divide_bad () { { assert_eq ! (divide (10i32 , 2i32) , 5i32) } } fn test_divide_good () { { a...
  |                                                             ^^                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_divide_bad () { { assert_eq ! (divide (10i32 , 2i32) , 5i32) } } fn test_divide_good () { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (0i32 , 5i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_divide_bad () { assert_eq ! (divide (10i32 , 2i32) , 5i32) } fn test_divide_good () { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (0i32 , 5i32) , 0i32) } } fn main () { }
  |

error[E0425]: cannot find function `divide` in this scope
 --> /tmp/.tmpWS0fiu/main.rs:1:76
  |
1 | use std :: collections :: HashMap ; fn test_divide_bad () { { assert_eq ! (divide (10i32 , 2i32) , 5i32) } } fn test_divide_good () { { a...
  |                                                                            ^^^^^^ not found in this scope

error[E0425]: cannot find function `divide` in this scope
 --> /tmp/.tmpWS0fiu/main.rs:1:150
  |
1 | ..., 5i32) } } fn test_divide_good () { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (0i32 , 5i32) , 0i32) } } fn m...
  |                                                        ^^^^^^ not found in this scope

error[E0425]: cannot find function `divide` in this scope
 --> /tmp/.tmpWS0fiu/main.rs:1:195
  |
1 | ..._eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (0i32 , 5i32) , 0i32) } } fn main () { }
  |                                                        ^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch03-01-testing-functions example 10 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpIXnq8D/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test_useless () { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_usef...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpIXnq8D/main.rs:1:58
  |
1 | use std :: collections :: HashMap ; fn test_useless () { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_usef...
  |                                                          ^^                                                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_useless () { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_useless () { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } fn test_useful () { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpIXnq8D/main.rs:1:146
  |
1 | ...t ! (result > 0i32) } } } fn test_useful () { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
  |                                                  ^^                                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_useless () { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_useless () { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () { assert_eq ! (add (2i32 , 3i32) , 5i32) } fn main () { }
  |

error[E0425]: cannot find function `add` in this scope
 --> /tmp/.tmpIXnq8D/main.rs:1:75
  |
1 | use std :: collections :: HashMap ; fn test_useless () { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_usef...
  |                                                                           ^^^ not found in this scope
  |
help: use the `.` operator to call the method `Add::add` on `i32`
  |
1 - use std :: collections :: HashMap ; fn test_useless () { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_useless () { { { let result = 2i32.add(3i32) ; assert ! (result > 0i32) } } } fn test_useful () { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
  |

error[E0425]: cannot find function `add` in this scope
 --> /tmp/.tmpIXnq8D/main.rs:1:161
  |
1 | ...ult > 0i32) } } } fn test_useful () { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
  |                                                         ^^^ not found in this scope
  |
help: use the `.` operator to call the method `Add::add` on `i32`
  |
1 - use std :: collections :: HashMap ; fn test_useless () { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_useless () { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () { { assert_eq ! (2i32.add(3i32) , 5i32) } } fn main () { }
  |

error: aborting due to 2 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch03-01-testing-functions example 11 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpMpsshZ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test1 () { { assert_eq ! (is_valid ("abc" . to_string ()) , false) } } fn test_password_too_short ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpMpsshZ/main.rs:1:51
  |
1 | use std :: collections :: HashMap ; fn test1 () { { assert_eq ! (is_valid ("abc" . to_string ()) , false) } } fn test_password_too_short ...
  |                                                   ^^                                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test1 () { { assert_eq ! (is_valid ("abc" . to_string ()) , false) } } fn test_password_too_short () { { assert_eq ! (is_valid_password ("abc" . to_string ()) , false) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test1 () { assert_eq ! (is_valid ("abc" . to_string ()) , false) } fn test_password_too_short () { { assert_eq ! (is_valid_password ("abc" . to_string ()) , false) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpMpsshZ/main.rs:1:143
  |
1 | ...} fn test_password_too_short () { { assert_eq ! (is_valid_password ("abc" . to_string ()) , false) } } fn main () { }
  |                                      ^^                                                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test1 () { { assert_eq ! (is_valid ("abc" . to_string ()) , false) } } fn test_password_too_short () { { assert_eq ! (is_valid_password ("abc" . to_string ()) , false) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test1 () { { assert_eq ! (is_valid ("abc" . to_string ()) , false) } } fn test_password_too_short () { assert_eq ! (is_valid_password ("abc" . to_string ()) , false) } fn main () { }
  |

error[E0425]: cannot find function `is_valid` in this scope
 --> /tmp/.tmpMpsshZ/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn test1 () { { assert_eq ! (is_valid ("abc" . to_string ()) , false) } } fn test_password_too_short ...
  |                                                                  ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_valid_password` in this scope
 --> /tmp/.tmpMpsshZ/main.rs:1:158
  |
1 | ...n test_password_too_short () { { assert_eq ! (is_valid_password ("abc" . to_string ()) , false) } } fn main () { }
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 2 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch03-01-testing-functions example 12 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmplGekHr/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test_is_strong_password () { { assert ! (is_strong_password ("MyPass123!" . to_string ())) ; asser...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmplGekHr/main.rs:1:529
  |
1 | ...ne > (password : T) -> T { { if password . len () < 8i32 { { return false } } ; { let has_digit = password . chars () . any (| c | c ....
  |                                                               ^^            ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_is_strong_password () { { assert ! (is_strong_password ("MyPass123!" . to_string ())) ; assert ! (! is_strong_password ("weak" . to_string ())) ; assert ! (! is_strong_password ("NoNumbers!" . to_string ())) ; assert ! (! is_strong_password ("nonumbers123" . to_string ())) } } fn is_strong_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (password : T) -> T { { if password . len () < 8i32 { { return false } } ; { let has_digit = password . chars () . any (| c | c . is_digit ()) ; { let mut has_special = password . chars () . any (| c | "!@#$%^&*" . contains (c)) ; return has_digit && has_special } } } } fn test_password_edge_cases () { { assert ! (! is_strong_password ("" . to_string ())) ; assert ! (! is_strong_password ("12345678" . to_string ())) ; assert ! (! is_strong_password ("!!!!!!!!" . to_string ())) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_is_strong_password () { { assert ! (is_strong_password ("MyPass123!" . to_string ())) ; assert ! (! is_strong_password ("weak" . to_string ())) ; assert ! (! is_strong_password ("NoNumbers!" . to_string ())) ; assert ! (! is_strong_password ("nonumbers123" . to_string ())) } } fn is_strong_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (password : T) -> T { { if password . len () < 8i32 { return false } ; { let has_digit = password . chars () . any (| c | c . is_digit ()) ; { let mut has_special = password . chars () . any (| c | "!@#$%^&*" . contains (c)) ; return has_digit && has_special } } } } fn test_password_edge_cases () { { assert ! (! is_strong_password ("" . to_string ())) ; assert ! (! is_strong_password ("12345678" . to_string ())) ; assert ! (! is_strong_password ("!!!!!!!!" . to_string ())) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmplGekHr/main.rs:1:101
  |
1 | ..._password () { { assert ! (is_strong_password ("MyPass123!" . to_string ())) ; assert ! (! is_strong_password ("weak" . to_string ()))...
  |                               ------------------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `String`
  |                               |
  |                               arguments to this function are incorrect
  |
help: the return type of this call is `String` due to the type of the argument passed
 --> /tmp/.tmplGekHr/main.rs:1:81
  |
1 | ... assert ! (is_strong_password ("MyPass123!" . to_string ())) ; assert ! (! is_strong_password ("weak" . to_string ())) ; assert ! (! i...
  |               ^^^^^^^^^^^^^^^^^^^^---------------------------^
  |                                   |
  |                                   this argument influences the return type of `is_strong_password`
note: function defined here
 --> /tmp/.tmplGekHr/main.rs:1:326
  |
1 | ...fn is_strong_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (password : T) -...
  |       ^^^^^^^^^^^^^^^^^^                                                                                                                                    ------------

error[E0308]: mismatched types
 --> /tmp/.tmplGekHr/main.rs:1:165
  |
1 | ... to_string ())) ; assert ! (! is_strong_password ("weak" . to_string ())) ; assert ! (! is_strong_password ("NoNumbers!" . to_string (...
  |                                  ------------------  ^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `String`
  |                                  |
  |                                  arguments to this function are incorrect
  |
help: the return type of this call is `String` due to the type of the argument passed
 --> /tmp/.tmplGekHr/main.rs:1:145
  |
1 | ...; assert ! (! is_strong_password ("weak" . to_string ())) ; assert ! (! is_strong_password ("NoNumbers!" . to_string ())) ; assert ! (...
  |                  ^^^^^^^^^^^^^^^^^^^^---------------------^
  |                                      |
  |                                      this argument influences the return type of `is_strong_password`
note: function defined here
 --> /tmp/.tmplGekHr/main.rs:1:326
  |
1 | ...fn is_strong_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (password : T) -...
  |       ^^^^^^^^^^^^^^^^^^                                                                                                                                    ------------

error[E0308]: mismatched types
 --> /tmp/.tmplGekHr/main.rs:1:223
  |
1 | ..._string ())) ; assert ! (! is_strong_password ("NoNumbers!" . to_string ())) ; assert ! (! is_strong_password ("nonumbers123" . to_str...
  |                               ------------------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `String`
  |                               |
  |                               arguments to this function are incorrect
  |
help: the return type of this call is `String` due to the type of the argument passed
 --> /tmp/.tmplGekHr/main.rs:1:203
  |
1 | ...ssert ! (! is_strong_password ("NoNumbers!" . to_string ())) ; assert ! (! is_strong_password ("nonumbers123" . to_string ())) } } fn ...
  |               ^^^^^^^^^^^^^^^^^^^^---------------------------^
  |                                   |
  |                                   this argument influences the return type of `is_strong_password`
note: function defined here
 --> /tmp/.tmplGekHr/main.rs:1:326
  |
1 | ...fn is_strong_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (password : T) -...
  |       ^^^^^^^^^^^^^^^^^^                                                                                                                                    ------------

error[E0308]: mismatched types
 --> /tmp/.tmplGekHr/main.rs:1:287
  |
1 | ...string ())) ; assert ! (! is_strong_password ("nonumbers123" . to_string ())) } } fn is_strong_password < T : std :: ops :: Add < Outp...
  |                              ------------------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `String`
  |                              |
  |                              arguments to this function are incorrect
  |
help: the return type of this call is `String` due to the type of the argument passed
 --> /tmp/.tmplGekHr/main.rs:1:267
  |
1 | ...sert ! (! is_strong_password ("nonumbers123" . to_string ())) } } fn is_strong_password < T : std :: ops :: Add < Output = T > + std :...
  |              ^^^^^^^^^^^^^^^^^^^^-----------------------------^
  |                                  |
  |                                  this argument influences the return type of `is_strong_password`
note: function defined here
 --> /tmp/.tmplGekHr/main.rs:1:326
  |
1 | ...fn is_strong_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (password : T) -...
  |       ^^^^^^^^^^^^^^^^^^                                                                                                                                    ------------

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmplGekHr/main.rs:1:513
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (password : T) -> T { { if password . len ()...
  |       - method `len` not found for this type parameter                                                                                                                      ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn test_is_strong_password () { { assert ! (is_strong_password ("MyPass123!" . to_string ())) ; assert ! (! is_strong_password ("weak" . to_string ())) ; assert ! (! is_strong_password ("NoNumbers!" . to_string ())) ; assert ! (! is_strong_password ("nonumbers123" . to_string ())) } } fn is_strong_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (password : T) -> T { { if password . len () < 8i32 { { return false } } ; { let has_digit = password . chars () . any (| c | c . is_digit ()) ; { let mut has_special = password . chars () . any (| c | "!@#$%^&*" . contains (c)) ; return has_digit && has_special } } } } fn test_password_edge_cases () { { assert ! (! is_strong_password ("" . to_string ())) ; assert ! (! is_strong_password ("12345678" . to_string ())) ; assert ! (! is_strong_password ("!!!!!!!!" . to_string ())) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         +++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmplGekHr/main.rs:1:538
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (password : T) -> T { { if password . len () < 8i32 { { return false } ...
  |       - expected this type parameter                                                                                                                    - expected `T` because of return type        ^^^^^ expected type parameter `T`, found `bool`
  |
  = note: expected type parameter `T`
                       found type `bool`
  = note: the caller chooses a type for `T` which can be different from `bool`

error[E0599]: no method named `chars` found for type parameter `T` in the current scope
 --> /tmp/.tmplGekHr/main.rs:1:579
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (password : T) -> T { { if password . len () < 8i32 { { return false } } ; { let has_digit = password . chars ()...
  |       - method `chars` not found for this type parameter                                                                                                                                                                                      ^^^^^ method not found in `T`

error[E0599]: no method named `chars` found for type parameter `T` in the current scope
 --> /tmp/.tmplGekHr/main.rs:1:655
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (password : T) -> T { { if password . len () < 8i32 { { return false } } ; { let has_digit = password . chars () . any (| c | c . is_digit ()) ; { let mut has_special = password . chars ()...
  |       - method `chars` not found for this type parameter                                                                                                                                                                                                                                                                  ^^^^^ method not found in `T`

error[E0308]: mismatched types
 --> /tmp/.tmplGekHr/main.rs:1:813
  |
1 | ...d_edge_cases () { { assert ! (! is_strong_password ("" . to_string ())) ; assert ! (! is_strong_password ("12345678" . to_string ())) ...
  |                                    ------------------  ^^^^^^^^^^^^^^^^^ expected `bool`, found `String`
  |                                    |
  |                                    arguments to this function are incorrect
  |
help: the return type of this call is `String` due to the type of the argument passed
 --> /tmp/.tmplGekHr/main.rs:1:793
  |
1 | ...{ { assert ! (! is_strong_password ("" . to_string ())) ; assert ! (! is_strong_password ("12345678" . to_string ())) ; assert ! (! is...
  |                    ^^^^^^^^^^^^^^^^^^^^-----------------^
  |                                        |
  |                                        this argument influences the return type of `is_strong_password`
note: function defined here
 --> /tmp/.tmplGekHr/main.rs:1:326
  |
1 | ...fn is_strong_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (password : T) -...
  |       ^^^^^^^^^^^^^^^^^^                                                                                                                                    ------------

error[E0308]: mismatched types
 --> /tmp/.tmplGekHr/main.rs:1:867
  |
1 | ...o_string ())) ; assert ! (! is_strong_password ("12345678" . to_string ())) ; assert ! (! is_strong_password ("!!!!!!!!" . to_string (...
  |                                ------------------  ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `String`
  |                                |
  |                                arguments to this function are incorrect
  |
help: the return type of this call is `String` due to the type of the argument passed
 --> /tmp/.tmplGekHr/main.rs:1:847
  |
1 | ...assert ! (! is_strong_password ("12345678" . to_string ())) ; assert ! (! is_strong_password ("!!!!!!!!" . to_string ())) } } fn main ...
  |                ^^^^^^^^^^^^^^^^^^^^-------------------------^
  |                                    |
  |                                    this argument influences the return type of `is_strong_password`
note: function defined here
 --> /tmp/.tmplGekHr/main.rs:1:326
  |
1 | ...fn is_strong_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (password : T) -...
  |       ^^^^^^^^^^^^^^^^^^                                                                                                                                    ------------

error[E0308]: mismatched types
 --> /tmp/.tmplGekHr/main.rs:1:929
  |
1 | ...o_string ())) ; assert ! (! is_strong_password ("!!!!!!!!" . to_string ())) } } fn main () { }
  |                                ------------------  ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `String`
  |                                |
  |                                arguments to this function are incorrect
  |
help: the return type of this call is `String` due to the type of the argument passed
 --> /tmp/.tmplGekHr/main.rs:1:909
  |
1 | ...assert ! (! is_strong_password ("!!!!!!!!" . to_string ())) } } fn main () { }
  |                ^^^^^^^^^^^^^^^^^^^^-------------------------^
  |                                    |
  |                                    this argument influences the return type of `is_strong_password`
note: function defined here
 --> /tmp/.tmplGekHr/main.rs:1:326
  |
1 | ...fn is_strong_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (password : T) -...
  |       ^^^^^^^^^^^^^^^^^^                                                                                                                                    ------------

error: aborting due to 11 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0308, E0599.
For more information about an error, try `rustc --explain E0308`.



=== ch16-00-testing-quality example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 2 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmp5Wc7Kn/main.rs:1:498
  |
1 | ... . spawn (|| { heavy_computation () }) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0425]: cannot find value `spawn` in this scope
 --> /tmp/.tmp5Wc7Kn/main.rs:1:82
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut handle = spawn ; { println ! ("Running in parallel!") ; compute_r...
  |                                                                                  ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::spawn;
  |

error[E0425]: cannot find value `spawn` in this scope
 --> /tmp/.tmp5Wc7Kn/main.rs:1:248
  |
1 | ...ata = vec ! [1i32 , 2i32 , 3i32] ; let mut handle = spawn ; r#move ; { { let sum = data . sum () ; println ! ("{}" , format ! ("{}{}" ...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::spawn;
  |

error[E0425]: cannot find value `r#move` in this scope
 --> /tmp/.tmp5Wc7Kn/main.rs:1:256
  |
1 | ...c ! [1i32 , 2i32 , 3i32] ; let mut handle = spawn ; r#move ; { { let sum = data . sum () ; println ! ("{}" , format ! ("{}{}" , "Sum: ...
  |                                                        ^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp5Wc7Kn/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut handle = spawn ; { println ! ("Running in parallel!") ; compute_r...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `compute_result` in this scope
 --> /tmp/.tmp5Wc7Kn/main.rs:1:129
  |
1 | ... spawn ; { println ! ("Running in parallel!") ; compute_result () } ; let mut result = handle . join () ; let mut data = vec ! [1i32 ,...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `sum` found for struct `Vec<i32>` in the current scope
 --> /tmp/.tmp5Wc7Kn/main.rs:1:286
  |
1 | ...ut handle = spawn ; r#move ; { { let sum = data . sum () ; println ! ("{}" , format ! ("{}{}" , "Sum: " , sum . to_s ())) } } ; let mu...
  |                                                      ^^^ `Vec<i32>` is not an iterator
  |
help: call `.into_iter()` first
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut handle = spawn ; { println ! ("Running in parallel!") ; compute_result () } ; let mut result = handle . join () ; let mut data = vec ! [1i32 , 2i32 , 3i32] ; let mut handle = spawn ; r#move ; { { let sum = data . into_iter().sum () ; println ! ("{}" , format ! ("{}{}" , "Sum: " , sum . to_s ())) } } ; let mut handle = Thread :: builder () . name ("worker") . stack_size (4i32 * 1024i32 * 1024i32) . spawn (|| { heavy_computation () }) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |                                                                                                                                                                                                                                                                                              ++++++++++++

error: aborting due to 6 previous errors; 1 warning emitted

Some errors have detailed explanations: E0425, E0599.
For more information about an error, try `rustc --explain E0425`.



=== ch14-00-concurrency example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 12 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 13 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch04-00-command-line-tools example 1 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpd2ljFI/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("Word Counter Tool") ; print ! ("Enter filename: ") ; let mut ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpd2ljFI/main.rs:1:396
  |
1 | ... input . pop () ; } } input } ; let mut content = read_file (filename) ; let mut words = content . split_whitespace () ; let mut word_...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 2 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpSb7Qt8/main.rs:1:1162
  |
1 | ... { input . pop () ; } } input } == "y" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpSb7Qt8/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut name = { print ! ("{}" , "What's your name? ") ; std :: io :: Wri...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0599]: no method named `to_i` found for struct `String` in the current scope
 --> /tmp/.tmpSb7Qt8/main.rs:1:777
  |
1 | ...ends_with ('\r') { input . pop () ; } } input } . to_i () ; let mut is_student = { print ! ("{}" , "Are you a student? (y/n) ") ; std ...
  |                                                      ^^^^ method not found in `String`

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0599`.



=== ch04-00-command-line-tools example 3 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmp7FY526/main.rs:1:462
  |
1 | ... file_size ("data.txt" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp7FY526/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut content = read_file ("data.txt" . to_string ()) ; let mut lines =...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmp7FY526/main.rs:1:83
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut content = read_file ("data.txt" . to_string ()) ; let mut lines =...
  |                                                                                   ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_lines` in this scope
 --> /tmp/.tmp7FY526/main.rs:1:139
  |
1 | ...ile ("data.txt" . to_string ()) ; let mut lines = read_lines ("data.txt" . to_string ()) ; write_file ("output.txt" . to_string () , "...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmp7FY526/main.rs:1:180
  |
1 | ... lines = read_lines ("data.txt" . to_string ()) ; write_file ("output.txt" . to_string () , "Hello, World!" . to_string ()) ; append_f...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `timestamp` in this scope
 --> /tmp/.tmp7FY526/main.rs:1:331
  |
1 | ...to_string () , format ! ("{}{}" , "New entry: " , timestamp ())) ; let mut exists = file_exists ("config.txt" . to_string ()) ; let mu...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `append_file` in this scope
 --> /tmp/.tmp7FY526/main.rs:1:256
  |
1 | ...to_string () , "Hello, World!" . to_string ()) ; append_file ("log.txt" . to_string () , format ! ("{}{}" , "New entry: " , timestamp ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmp7FY526/main.rs:1:365
  |
1 | ...New entry: " , timestamp ())) ; let mut exists = file_exists ("config.txt" . to_string ()) ; let mut size = file_size ("data.txt" . to...
  |                                                     ^^^^^^^^^^^ not found in this scope

error: aborting due to 7 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 4 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpkehQuJ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut args = command_args () ; let mut program_name = args [0i32 as usi...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `command_args` in this scope
 --> /tmp/.tmpkehQuJ/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut args = command_args () ; let mut program_name = args [0i32 as usi...
  |                                                                                ^^^^^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `exit` in this scope
 --> /tmp/.tmpGqreeY/main.rs:1:600
  |
1 | ..." , "Error: File '" , filename) , "' not found!")) ; exit (1i32) } } ; let mut content = read_file (filename) ; let mut lines = conten...
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::process::exit;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpGqreeY/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Text Processor ===") ; let mut filename = { print ! ("{}"...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpGqreeY/main.rs:1:468
  |
1 | ...ith ('\r') { input . pop () ; } } input } ; if ! file_exists (filename) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "E...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpGqreeY/main.rs:1:636
  |
1 | ...t found!")) ; exit (1i32) } } ; let mut content = read_file (filename) ; let mut lines = content . lines () ; println ! ("\nChoose ope...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0599]: no method named `to_i` found for struct `String` in the current scope
 --> /tmp/.tmpGqreeY/main.rs:1:1238
  |
1 | ...ends_with ('\r') { input . pop () ; } } input } . to_i () ; match choice { 1i32 => { println ! ("{}" , format ! ("{}{}" , "Total lines...
  |                                                      ^^^^ method not found in `String`

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpGqreeY/main.rs:1:2199
  |
1 | ...= filename . replace (".txt" , "_modified.txt") ; write_file (output_file , new_content) ; println ! ("{}" , format ! ("{}{}" , "Saved...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpGqreeY/main.rs:1:2443
  |
1 | ...le = filename . replace (".txt" , "_upper.txt") ; write_file (output_file , upper_content) ; println ! ("{}" , format ! ("{}{}" , "Sav...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpGqreeY/main.rs:1:2798
  |
1 | ...le = filename . replace (".txt" , "_clean.txt") ; write_file (output_file , clean_content) ; println ! ("{}" , format ! ("{}{}" , "Sav...
  |                                                      ^^^^^^^^^^ not found in this scope

error: aborting due to 7 previous errors; 1 warning emitted

Some errors have detailed explanations: E0425, E0599.
For more information about an error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 6 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpAPTaq9/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===") ; let mut log_file = { print ! ("{}" ,...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpAPTaq9/main.rs:1:661
  |
1 | ... { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ...
  |       ^^                                                                                                                                                                                                  ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===") ; let mut log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===") ; let mut log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpAPTaq9/main.rs:1:694
  |
1 | ... for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_co...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===") ; let mut log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===") ; let mut log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { success_count += 1i32 } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpAPTaq9/main.rs:1:760
  |
1 | ...nt += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count...
  |                                                         ^^                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===") ; let mut log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===") ; let mut log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { not_found_count += 1i32 } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpAPTaq9/main.rs:1:828
  |
1 | ...ount += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 1...
  |                                                           ^^                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===") ; let mut log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===") ; let mut log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { error_count += 1i32 } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpAPTaq9/main.rs:1:1753
  |
1 | ... { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ...
  |       ^^                                                                                                                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===") ; let mut log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===") ; let mut log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `read_lines` in this scope
 --> /tmp/.tmpAPTaq9/main.rs:1:482
  |
1 | ... { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_co...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpAPTaq9/main.rs:1:1309
  |
1 | ...mat ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{}" , format !...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpAPTaq9/main.rs:1:1346
  |
1 | ...uccess_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpAPTaq9/main.rs:1:1480
  |
1 | ...! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{}" , format...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpAPTaq9/main.rs:1:1519
  |
1 | ...ound_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpAPTaq9/main.rs:1:1652
  |
1 | ... ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; f...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpAPTaq9/main.rs:1:1687
  |
1 | ... , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestam...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `extract_hour` in this scope
 --> /tmp/.tmpAPTaq9/main.rs:1:1773
  |
1 | ...s = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `get` found for unit type `()` in the current scope
    --> /tmp/.tmpAPTaq9/main.rs:1:1844
     |
1    | ...t_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hou...
     |                                                                     ^^^
     |
help: there is a method `ge` with a similar name, but with different arguments
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1438:5
     |
1438 |     fn ge(&self, other: &Rhs) -> bool {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `max_by_value` found for unit type `()` in the current scope
 --> /tmp/.tmpAPTaq9/main.rs:1:1931
  |
1 | ...32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Busie...
  |                                                    ^^^^^^^^^^^^ method not found in `()`

error: aborting due to 10 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0425, E0599.
For more information about an error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 7 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpE4TPyN/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Batch File Renamer ===") ; let mut directory = { print ! ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpE4TPyN/main.rs:1:1296
  |
1 | ... { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") + new_name) ; renamed_count += 1i32 } } else { { println ! ("{}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Batch File Renamer ===") ; let mut directory = { print ! ("{}" , "Enter directory path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") + new_name) ; renamed_count += 1i32 } } else { { println ! ("{}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Batch File Renamer ===") ; let mut directory = { print ! ("{}" , "Enter directory path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") + new_name) ; renamed_count += 1i32 } } else { { println ! ("{}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpE4TPyN/main.rs:1:1329
  |
1 | ... { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") + new_name) ; renamed_count += 1i32 } } else { { println ! ("{}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Batch File Renamer ===") ; let mut directory = { print ! ("{}" , "Enter directory path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") + new_name) ; renamed_count += 1i32 } } else { { println ! ("{}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Batch File Renamer ===") ; let mut directory = { print ! ("{}" , "Enter directory path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") + new_name) ; renamed_count += 1i32 } } else { { println ! ("{}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpE4TPyN/main.rs:1:1669
  |
1 | ...enamed_count += 1i32 } } else { { println ! ("{}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ; println ! ("{}"...
  |                                    ^^                                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Batch File Renamer ===") ; let mut directory = { print ! ("{}" , "Enter directory path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") + new_name) ; renamed_count += 1i32 } } else { { println ! ("{}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Batch File Renamer ===") ; let mut directory = { print ! ("{}" , "Enter directory path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") + new_name) ; renamed_count += 1i32 } } else { println ! ("{}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `list_files` in this scope
 --> /tmp/.tmpE4TPyN/main.rs:1:1220
  |
1 | ... { input . pop () ; } } input } ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if fil...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpE4TPyN/main.rs:1:1410
  |
1 | ...ce (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ;...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpE4TPyN/main.rs:1:1460
  |
1 | ...y , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , format ! ...
  |                                   ^^^^^^^^^ help: a local variable with a similar name exists: `old_path`

error[E0425]: cannot find function `rename_file` in this scope
 --> /tmp/.tmpE4TPyN/main.rs:1:1498
  |
1 | ...new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , format ! ("{}{}" , format ! (...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpE4TPyN/main.rs:1:1843
  |
1 | ..., format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) ...
  |                                                        ^^^^ method not found in `i32`

error: aborting due to 5 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0425, E0599.
For more information about an error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 8 ===
✗ Compilation failed: Compilation failed:
error[E0423]: expected value, found macro `try`
 --> /tmp/.tmpGah20b/main.rs:1:567
  |
1 | ...rmission denied?)")) ; return false } } ; { let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! ("{}" , for...
  |                                                              ^^^^^ not a value

error[E0425]: cannot find value `catch` in this scope
 --> /tmp/.tmpGah20b/main.rs:1:604
  |
1 | ... let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! ("{}" , format ! ("{}{}" , "❌ Error reading file: " , e...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpGah20b/main.rs:1:612
  |
1 | ...tent = r#try ; { { read_file (filename) } ; catch ; error ; { println ! ("{}" , format ! ("{}{}" , "❌ Error reading file: " , error . t...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpGah20b/main.rs:1:686
  |
1 | ...{}" , format ! ("{}{}" , "❌ Error reading file: " , error . to_s ())) ; return false } ; let mut word_count = content . split_whitespac...
  |                                                         ^^^^^ not found in this scope

error[E0425]: cannot find function `exit` in this scope
 --> /tmp/.tmpGah20b/main.rs:1:1421
  |
1 | ...y!") } } else { { println ! ("Processing failed!") ; exit (1i32) } } ; }
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::process::exit;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpGah20b/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn process_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fm...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpGah20b/main.rs:1:1322
  |
1 | ...} input } ; if process_file (filename) { { println ! ("Processing completed successfully!") } } else { { println ! ("Processing failed...
  |                                             ^^                                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (filename : T) -> T { { if ! file_exists (filename) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Error: File '" , filename) , "' does not exist")) ; return false } } ; if ! file_readable (filename) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Error: Cannot read file '" , filename) , "' (permission denied?)")) ; return false } } ; { let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! ("{}" , format ! ("{}{}" , "❌ Error reading file: " , error . to_s ())) ; return false } ; let mut word_count = content . split_whitespace () . len () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "✅ File processed: " , word_count . to_s ()) , " words")) ; return true } } } } fn main () { let mut filename = { print ! ("{}" , "Enter filename: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if process_file (filename) { { println ! ("Processing completed successfully!") } } else { { println ! ("Processing failed!") ; exit (1i32) } } ; }
1 + use std :: collections :: HashMap ; fn process_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (filename : T) -> T { { if ! file_exists (filename) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Error: File '" , filename) , "' does not exist")) ; return false } } ; if ! file_readable (filename) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Error: Cannot read file '" , filename) , "' (permission denied?)")) ; return false } } ; { let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! ("{}" , format ! ("{}{}" , "❌ Error reading file: " , error . to_s ())) ; return false } ; let mut word_count = content . split_whitespace () . len () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "✅ File processed: " , word_count . to_s ()) , " words")) ; return true } } } } fn main () { let mut filename = { print ! ("{}" , "Enter filename: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if process_file (filename) { println ! ("Processing completed successfully!") } else { { println ! ("Processing failed!") ; exit (1i32) } } ; }
  |

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpGah20b/main.rs:1:212
  |
1 | ... :: Debug + Clone > (filename : T) -> T { { if ! file_exists (filename) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpGah20b/main.rs:1:357
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (filename : T) -> T { { if ! file_exists (filename) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Error: File '" , filename) , "' does not exist")) ; return false } }...
  |       - expected this type parameter                                                                                                                    - expected `T` because of return type                                                                                                                        ^^^^^ expected type parameter `T`, found `bool`
  |
  = note: expected type parameter `T`
                       found type `bool`
  = note: the caller chooses a type for `T` which can be different from `bool`

error[E0425]: cannot find function `file_readable` in this scope
 --> /tmp/.tmpGah20b/main.rs:1:374
  |
1 | ... "' does not exist")) ; return false } } ; if ! file_readable (filename) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpGah20b/main.rs:1:579
  |
1 | ... ; return false } } ; { let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! ("{}" , format ! ("{}{}" , "❌ Er...
  |                                                      ^^^^^^^^^ not found in this scope

warning: unreachable statement
 --> /tmp/.tmpGah20b/main.rs:1:723
  |
1 | ...or . to_s ())) ; return false } ; let mut word_count = content . split_whitespace () . len () ; println ! ("{}" , format ! ("{}{}" , f...
  |                     ------------     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable statement
  |                     |
  |                     any code following this expression is unreachable
  |
  = note: `#[warn(unreachable_code)]` on by default

error[E0308]: mismatched types
 --> /tmp/.tmpGah20b/main.rs:1:1310
  |
1 | ...r') { input . pop () ; } } input } ; if process_file (filename) { { println ! ("Processing completed successfully!") } } else { { prin...
  |                                            ------------  ^^^^^^^^ expected `bool`, found `String`
  |                                            |
  |                                            arguments to this function are incorrect
  |
help: the return type of this call is `String` due to the type of the argument passed
 --> /tmp/.tmpGah20b/main.rs:1:1296
  |
1 | ...pop () ; } } input } ; if process_file (filename) { { println ! ("Processing completed successfully!") } } else { { println ! ("Proces...
  |                              ^^^^^^^^^^^^^^--------^
  |                                            |
  |                                            this argument influences the return type of `process_file`
note: function defined here
 --> /tmp/.tmpGah20b/main.rs:1:40
  |
1 | ...fn process_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (filename : T) -...
  |       ^^^^^^^^^^^^                                                                                                                                    ------------

error[E0277]: cannot add `bool` to `bool`
 --> /tmp/.tmpGah20b/main.rs:1:1310
  |
1 | ...) { input . pop () ; } } input } ; if process_file (filename) { { println ! ("Processing completed successfully!") } } else { { printl...
  |                                          ------------  ^^^^^^^^ no implementation for `bool + bool`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `bool`
note: required by a bound in `process_file`
 --> /tmp/.tmpGah20b/main.rs:1:59
  |
1 | use std :: collections :: HashMap ; fn process_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fm...
  |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `process_file`

error[E0277]: cannot multiply `bool` by `bool`
 --> /tmp/.tmpGah20b/main.rs:1:1310
  |
1 | ...) { input . pop () ; } } input } ; if process_file (filename) { { println ! ("Processing completed successfully!") } } else { { printl...
  |                                          ------------  ^^^^^^^^ no implementation for `bool * bool`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `bool`
note: required by a bound in `process_file`
 --> /tmp/.tmpGah20b/main.rs:1:94
  |
1 | ...: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (filename : T) ...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `process_file`

error: aborting due to 12 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0423, E0425.
For more information about an error, try `rustc --explain E0277`.



=== ch04-00-command-line-tools example 9 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `sleep` in this scope
 --> /tmp/.tmpHNHOgn/main.rs:1:966
  |
1 | .... to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } ...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::sleep;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpHNHOgn/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ;...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpHNHOgn/main.rs:1:672
  |
1 | ... { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                       ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpHNHOgn/main.rs:1:744
  |
1 | ... { { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ...
  |       ^^                                                                                                                                                                                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } ; println ! ("\n✅ All files processed!") } } } } fn main () { }
  |

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpHNHOgn/main.rs:1:696
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len ()...
  |       - method `len` not found for this type parameter                                                                                                                           ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           +++++++++++++++++++

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpHNHOgn/main.rs:1:765
  |
1 | ... { let mut i = 0i32 ; while i < total { { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! (...
  |                                                                 ^^^^^^^^^^^^

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpHNHOgn/main.rs:1:916
  |
1 | ...format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } ...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `process_file` in this scope
 --> /tmp/.tmpHNHOgn/main.rs:1:944
  |
1 | ...g... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All file...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpHNHOgn/main.rs:1:1006
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } }...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 6 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0308, E0425, E0599, E0608.
For more information about an error, try `rustc --explain E0308`.



=== ch04-00-command-line-tools example 10 ===
✗ Compilation failed: Compilation failed:
error: multiple unused formatting arguments
 --> /tmp/.tmpxrh5q2/main.rs:1:291
  |
1 | ... 1i32 } } ; i = i + 1i32 } } ; println ! ("File has" , lines , "lines") } } } }
  |                                              ----------   ^^^^^   ^^^^^^^ argument never used
  |                                              |            |
  |                                              |            argument never used
  |                                              multiple missing formatting specifiers

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpxrh5q2/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; let...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpxrh5q2/main.rs:1:50
  |
1 | ... { { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("File has" , lines , "lines") } } } }
  |       ^^                                                                                                                                                                                                                                                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("File has" , lines , "lines") } } } }
1 + use std :: collections :: HashMap ; fn main () { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("File has" , lines , "lines") } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpxrh5q2/main.rs:1:219
  |
1 | ...content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("File has" , lines ,...
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("File has" , lines , "lines") } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i as usize] == '\n' { lines = lines + 1i32 } ; i = i + 1i32 } } ; println ! ("File has" , lines , "lines") } } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpxrh5q2/main.rs:1:164
  |
1 | ...t lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = ...
  |                                              -   ^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                              |
  |                                              expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len ().try_into().unwrap() { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("File has" , lines , "lines") } } } }
  |                                                                                                                                                                                    ++++++++++++++++++++

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpxrh5q2/main.rs:1:197
  |
1 | ...while i < content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("File has"...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error: aborting due to 3 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.



=== ch04-00-command-line-tools example 11 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `TASK_FILE` in this scope
 --> /tmp/.tmp7ZtFMq/main.rs:1:281
  |
1 | .... Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `TASK_FILE` in this scope
 --> /tmp/.tmp7ZtFMq/main.rs:1:315
  |
1 | ...if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `TASK_FILE` in this scope
 --> /tmp/.tmp7ZtFMq/main.rs:1:567
  |
1 | ...{ let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + st...
  |                                                      ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp7ZtFMq/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp7ZtFMq/main.rs:1:294
  |
1 | ...fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std ::...
  |                                                      ^^                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { return read_lines (TASK_FILE) } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7ZtFMq/main.rs:1:515
  |
1 | ...+ Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std ::...
  |                                 ^^                                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7ZtFMq/main.rs:1:999
  |
1 | ... { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } }...
  |       ^^                                                                                                                                                                                                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7ZtFMq/main.rs:1:1084
  |
1 | ... as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" ...
  |                                                                   ^^      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { "DONE" } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7ZtFMq/main.rs:1:1104
  |
1 | ... status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () ,...
  |                                                                 ^^         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { "PENDING" } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7ZtFMq/main.rs:1:1382
  |
1 | ... { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7ZtFMq/main.rs:1:2627
  |
1 | ...) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.t...
  |                                                    ^^                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { println ! ("❌ Invalid task number") } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmp7ZtFMq/main.rs:1:268
  |
1 | ...rintln ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } f...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_lines` in this scope
 --> /tmp/.tmp7ZtFMq/main.rs:1:303
  |
1 | ...asks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: A...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0599]: no method named `join` found for type parameter `T` in the current scope
 --> /tmp/.tmp7ZtFMq/main.rs:1:541
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("...
  |       - method `join` not found for this type parameter                                                                                                                            ^^^^ method not found in `T`

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmp7ZtFMq/main.rs:1:555
  |
1 | ...T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Outpu...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0599]: no method named `is_empty` found for type parameter `T` in the current scope
 --> /tmp/.tmp7ZtFMq/main.rs:1:770
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty ()...
  |       - method `is_empty` not found for this type parameter                                                                                                           ^^^^^^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following traits define an item `is_empty`, perhaps you need to restrict type parameter `T` with one of them:
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                +++++++++++++++++++
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + RangeBounds</* T */> > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ++++++++++++++++++++++

error[E0069]: `return;` in a function whose return type is not `()`
 --> /tmp/.tmp7ZtFMq/main.rs:1:820
  |
1 | ... > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , format ! ("{}{}" , ...
  |                      - expected `T` because of this return type                          ^^^^^^ return type is not `()`
  |
help: give the `return` a value of the expected type
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return /* value */ } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            +++++++++++

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmp7ZtFMq/main.rs:1:918
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () ....
  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                                                      ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                +++++++++++++++++++

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmp7ZtFMq/main.rs:1:990
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () {...
  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                                                                                                                              ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                +++++++++++++++++++

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmp7ZtFMq/main.rs:1:1020
  |
1 | ...t i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" }...
  |                                                                 ^^^^^^^^^^^^

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmp7ZtFMq/main.rs:1:1170
  |
1 | ...} ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops ::...
  |                                                        ^^^^ method not found in `i32`

error[E0308]: mismatched types
 --> /tmp/.tmp7ZtFMq/main.rs:1:972
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } f...
  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                                                                                                                                                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: the caller chooses a type for `T` which can be different from `()`
  = note: `while` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } /* `T` value */ } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    +++++++++++++++

error[E0599]: no method named `push` found for type parameter `T` in the current scope
 --> /tmp/.tmp7ZtFMq/main.rs:1:1762
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (f...
  |       - method `push` not found for this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^^^^ method not found in `T`

error[E0308]: mismatched types
 --> /tmp/.tmp7ZtFMq/main.rs:1:1828
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } ...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `to_i` found for struct `String` in the current scope
 --> /tmp/.tmp7ZtFMq/main.rs:1:2427
  |
1 | ...ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usiz...
  |                                                      ^^^^ method not found in `String`

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmp7ZtFMq/main.rs:1:2480
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (tasks : T) -> T { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              +++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmp7ZtFMq/main.rs:1:2584
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } e...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
 --> /tmp/.tmp7ZtFMq/main.rs:1:2629
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } ...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
 --> /tmp/.tmp7ZtFMq/main.rs:1:3164
  |
1 | ...'\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (task...
  |                                                 ------   ^^^ expected `String`, found `&str`
  |                                                 |
  |                                                 this expression has type `String`

error[E0308]: mismatched types
 --> /tmp/.tmp7ZtFMq/main.rs:1:3192
  |
1 | .... pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { ...
  |                                   ------                               ^^^ expected `String`, found `&str`
  |                                   |
  |                                   this expression has type `String`

error[E0308]: mismatched types
 --> /tmp/.tmp7ZtFMq/main.rs:1:3218
  |
1 | ...} input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (t...
  |                      ------ this expression has type `String`                       ^^^ expected `String`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmp7ZtFMq/main.rs:1:3249
  |
1 | ...nput } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (task...
  |                   ------ this expression has type `String`                                                      ^^^ expected `String`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmp7ZtFMq/main.rs:1:3808
  |
1 | ...ch choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" =>...
  |       ------ this expression has type `String`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^^^ expected `String`, found `&str`

error[E0277]: cannot add `()` to `()`
 --> /tmp/.tmp7ZtFMq/main.rs:1:3183
  |
1 | ...) ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_ta...
  |                                            ----------  ^^^^^ no implementation for `() + ()`
  |                                            |
  |                                            required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `()`
note: required by a bound in `list_tasks`
 --> /tmp/.tmp7ZtFMq/main.rs:1:614
  |
1 | ...ent) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fm...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`

error[E0277]: cannot multiply `()` by `()`
 --> /tmp/.tmp7ZtFMq/main.rs:1:3183
  |
1 | ...) ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_ta...
  |                                            ----------  ^^^^^ no implementation for `() * ()`
  |                                            |
  |                                            required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `()`
note: required by a bound in `list_tasks`
 --> /tmp/.tmp7ZtFMq/main.rs:1:649
  |
1 | ...:: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) ->...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmp7ZtFMq/main.rs:1:3183
  |
1 | ...ut } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks)...
  |                                 ----------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`
  |                                 |
  |                                 required by a bound introduced by this call
  |
note: required by a bound in `list_tasks`
 --> /tmp/.tmp7ZtFMq/main.rs:1:684
  |
1 | ...+ std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty ()...
  |                                         ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`

error[E0277]: cannot add `()` to `()`
 --> /tmp/.tmp7ZtFMq/main.rs:1:3209
  |
1 | ...ice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index =...
  |                                             --------  ^^^^^ no implementation for `() + ()`
  |                                             |
  |                                             required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `()`
note: required by a bound in `add_task`
 --> /tmp/.tmp7ZtFMq/main.rs:1:1239
  |
1 | ...2 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: f...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `add_task`

error[E0277]: cannot multiply `()` by `()`
 --> /tmp/.tmp7ZtFMq/main.rs:1:3209
  |
1 | ...ice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index =...
  |                                             --------  ^^^^^ no implementation for `() * ()`
  |                                             |
  |                                             required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `()`
note: required by a bound in `add_task`
 --> /tmp/.tmp7ZtFMq/main.rs:1:1274
  |
1 | ... :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `add_task`

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmp7ZtFMq/main.rs:1:3209
  |
1 | ...> list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ...
  |                                  --------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`
  |                                  |
  |                                  required by a bound introduced by this call
  |
note: required by a bound in `add_task`
 --> /tmp/.tmp7ZtFMq/main.rs:1:1309
  |
1 | ... + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = { pr...
  |                                          ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `add_task`

error[E0277]: cannot add `()` to `()`
 --> /tmp/.tmp7ZtFMq/main.rs:1:3240
  |
1 | ...s) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which tas...
  |                                          -------------  ^^^^^ no implementation for `() + ()`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `()`
note: required by a bound in `complete_task`
 --> /tmp/.tmp7ZtFMq/main.rs:1:1887
  |
1 | ... } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `complete_task`

error[E0277]: cannot multiply `()` by `()`
 --> /tmp/.tmp7ZtFMq/main.rs:1:3240
  |
1 | ...s) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which tas...
  |                                          -------------  ^^^^^ no implementation for `() * ()`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `()`
note: required by a bound in `complete_task`
 --> /tmp/.tmp7ZtFMq/main.rs:1:1922
  |
1 | ...: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> ...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `complete_task`

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmp7ZtFMq/main.rs:1:3240
  |
1 | ...> add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delet...
  |                                -------------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`
  |                                |
  |                                required by a bound introduced by this call
  |
note: required by a bound in `complete_task`
 --> /tmp/.tmp7ZtFMq/main.rs:1:1957
  |
1 | ...std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { l...
  |                                       ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `complete_task`

error[E0277]: cannot add `()` to `()`
 --> /tmp/.tmp7ZtFMq/main.rs:1:3270
  |
1 | ..."3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std...
  |                                            ----------  ^^^^^ no implementation for `() + ()`
  |                                            |
  |                                            required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `()`
note: required by a bound in `list_tasks`
 --> /tmp/.tmp7ZtFMq/main.rs:1:614
  |
1 | ...ent) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fm...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`

error[E0277]: cannot multiply `()` by `()`
 --> /tmp/.tmp7ZtFMq/main.rs:1:3270
  |
1 | ..."3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std...
  |                                            ----------  ^^^^^ no implementation for `() * ()`
  |                                            |
  |                                            required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `()`
note: required by a bound in `list_tasks`
 --> /tmp/.tmp7ZtFMq/main.rs:1:649
  |
1 | ...:: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) ->...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmp7ZtFMq/main.rs:1:3270
  |
1 | ...lete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: W...
  |                                 ----------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`
  |                                 |
  |                                 required by a bound introduced by this call
  |
note: required by a bound in `list_tasks`
 --> /tmp/.tmp7ZtFMq/main.rs:1:684
  |
1 | ...+ std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty ()...
  |                                         ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`

error[E0599]: no method named `to_i` found for struct `String` in the current scope
 --> /tmp/.tmp7ZtFMq/main.rs:1:3649
  |
1 | ...ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (inde...
  |                                                      ^^^^ method not found in `String`

error[E0599]: no method named `len` found for unit type `()` in the current scope
    --> /tmp/.tmp7ZtFMq/main.rs:1:3702
     |
1    | ...} input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("...
     |                                                                     ^^^
     |
help: there is a method `le` with a similar name, but with different arguments
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1402:5
     |
1402 |     fn le(&self, other: &Rhs) -> bool {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `remove` found for unit type `()` in the current scope
 --> /tmp/.tmp7ZtFMq/main.rs:1:3721
  |
1 | ...ndex >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } ...
  |                                                       ^^^^^^ method not found in `()`

error[E0277]: cannot add `()` to `()`
 --> /tmp/.tmp7ZtFMq/main.rs:1:3750
  |
1 | ...s . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Go...
  |                                            ----------  ^^^^^ no implementation for `() + ()`
  |                                            |
  |                                            required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `()`
note: required by a bound in `save_tasks`
 --> /tmp/.tmp7ZtFMq/main.rs:1:372
  |
1 | ...c ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fm...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `save_tasks`

error[E0277]: cannot multiply `()` by `()`
 --> /tmp/.tmp7ZtFMq/main.rs:1:3750
  |
1 | ...s . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Go...
  |                                            ----------  ^^^^^ no implementation for `() * ()`
  |                                            |
  |                                            required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `()`
note: required by a bound in `save_tasks`
 --> /tmp/.tmp7ZtFMq/main.rs:1:407
  |
1 | ...:: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) ->...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `save_tasks`

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmp7ZtFMq/main.rs:1:3750
  |
1 | ...{ { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; ...
  |                                 ----------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`
  |                                 |
  |                                 required by a bound introduced by this call
  |
note: required by a bound in `save_tasks`
 --> /tmp/.tmp7ZtFMq/main.rs:1:442
  |
1 | ...+ std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks ...
  |                                         ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `save_tasks`

error: aborting due to 43 previous errors; 8 warnings emitted

Some errors have detailed explanations: E0069, E0277, E0308, E0425, E0599, E0608.
For more information about an error, try `rustc --explain E0069`.



=== ch04-00-command-line-tools example 13 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpRG8H60/main.rs:1:337
  |
1 | ... ('\r') { input . pop () ; } } input } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpRG8H60/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("Enter thing:") ; let mut thing = { let mut input = String :: ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch04-00-command-line-tools example 14 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found `let` statement
 --> /tmp/.tmpwzEFTs/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let mut data = read_file ("/Users/noah/Desktop/data.txt" . to_string ()) ; ...
  |                                                               ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpwzEFTs/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let mut data = read_file ("/Users/noah/Desktop/data.txt" . to_string ()) ; ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpwzEFTs/main.rs:1:78
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let mut data = read_file ("/Users/noah/Desktop/data.txt" . to_string ()) ; ...
  |                                                                              ^^^^^^^^^ not found in this scope

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch12-00-traits-generics example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch03-00-functions-tdd example 4 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp3TLKvg/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn square (n : i32) -> i32 { { n * n } } fn sum_of_squares (a : i32 , b : i32) -> i32 { { format ! ("...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp3TLKvg/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn square (n : i32) -> i32 { { n * n } } fn sum_of_squares (a : i32 , b : i32) -> i32 { { format ! ("...
  |                                                                  ^^     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square (n : i32) -> i32 { { n * n } } fn sum_of_squares (a : i32 , b : i32) -> i32 { { format ! ("{}{}" , square (a) , square (b)) } } fn main () { { { let result = sum_of_squares (3i32 , 4i32) ; println ! ("{}" , result) } } }
1 + use std :: collections :: HashMap ; fn square (n : i32) -> i32 { n * n } fn sum_of_squares (a : i32 , b : i32) -> i32 { { format ! ("{}{}" , square (a) , square (b)) } } fn main () { { { let result = sum_of_squares (3i32 , 4i32) ; println ! ("{}" , result) } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp3TLKvg/main.rs:1:125
  |
1 | ...um_of_squares (a : i32 , b : i32) -> i32 { { format ! ("{}{}" , square (a) , square (b)) } } fn main () { { { let result = sum_of_squa...
  |                                               ^^                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square (n : i32) -> i32 { { n * n } } fn sum_of_squares (a : i32 , b : i32) -> i32 { { format ! ("{}{}" , square (a) , square (b)) } } fn main () { { { let result = sum_of_squares (3i32 , 4i32) ; println ! ("{}" , result) } } }
1 + use std :: collections :: HashMap ; fn square (n : i32) -> i32 { { n * n } } fn sum_of_squares (a : i32 , b : i32) -> i32 { format ! ("{}{}" , square (a) , square (b)) } fn main () { { { let result = sum_of_squares (3i32 , 4i32) ; println ! ("{}" , result) } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp3TLKvg/main.rs:1:188
  |
1 | ...quare (b)) } } fn main () { { { let result = sum_of_squares (3i32 , 4i32) ; println ! ("{}" , result) } } }
  |                                ^^                                                                         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square (n : i32) -> i32 { { n * n } } fn sum_of_squares (a : i32 , b : i32) -> i32 { { format ! ("{}{}" , square (a) , square (b)) } } fn main () { { { let result = sum_of_squares (3i32 , 4i32) ; println ! ("{}" , result) } } }
1 + use std :: collections :: HashMap ; fn square (n : i32) -> i32 { { n * n } } fn sum_of_squares (a : i32 , b : i32) -> i32 { { format ! ("{}{}" , square (a) , square (b)) } } fn main () { { let result = sum_of_squares (3i32 , 4i32) ; println ! ("{}" , result) } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp3TLKvg/main.rs:1:127
  |
1 | ...es (a : i32 , b : i32) -> i32 { { format ! ("{}{}" , square (a) , square (b)) } } fn main () { { { let result = sum_of_squares (3i32 ,...
  |                              ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`
  |                              |
  |                              expected `i32` because of return type
  |
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 1 previous error; 4 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `return_type` in this scope
 --> /tmp/.tmpfhKdm2/main.rs:1:204
  |
1 | ...td :: fmt :: Debug + Clone > (parameters : T) -> return_type { { return_expression } } fn main () { }
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `return_expression` in this scope
 --> /tmp/.tmpfhKdm2/main.rs:1:220
  |
1 | ...+ Clone > (parameters : T) -> return_type { { return_expression } } fn main () { }
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpfhKdm2/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn function_name < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: f...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpfhKdm2/main.rs:1:218
  |
1 | ...mt :: Debug + Clone > (parameters : T) -> return_type { { return_expression } } fn main () { }
  |                                                            ^^                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn function_name < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (parameters : T) -> return_type { { return_expression } } fn main () { }
1 + use std :: collections :: HashMap ; fn function_name < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (parameters : T) -> return_type { return_expression } fn main () { }
  |

error: aborting due to 2 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch03-00-functions-tdd example 9 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpJtp1pP/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn helper (x : i32) -> i32 { { x * x } } fn main_calculation (n : i32) -> i32 { { format ! ("{}{}" , ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpJtp1pP/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn helper (x : i32) -> i32 { { x * x } } fn main_calculation (n : i32) -> i32 { { format ! ("{}{}" , ...
  |                                                                  ^^     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn helper (x : i32) -> i32 { { x * x } } fn main_calculation (n : i32) -> i32 { { format ! ("{}{}" , helper (n) , helper (n + 1i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn helper (x : i32) -> i32 { x * x } fn main_calculation (n : i32) -> i32 { { format ! ("{}{}" , helper (n) , helper (n + 1i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpJtp1pP/main.rs:1:117
  |
1 | ... fn main_calculation (n : i32) -> i32 { { format ! ("{}{}" , helper (n) , helper (n + 1i32)) } } fn main () { }
  |                                            ^^                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn helper (x : i32) -> i32 { { x * x } } fn main_calculation (n : i32) -> i32 { { format ! ("{}{}" , helper (n) , helper (n + 1i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn helper (x : i32) -> i32 { { x * x } } fn main_calculation (n : i32) -> i32 { format ! ("{}{}" , helper (n) , helper (n + 1i32)) } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpJtp1pP/main.rs:1:119
  |
1 | ...culation (n : i32) -> i32 { { format ! ("{}{}" , helper (n) , helper (n + 1i32)) } } fn main () { }
  |                          ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`
  |                          |
  |                          expected `i32` because of return type
  |
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 1 previous error; 3 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch11-00-file-operations-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `DataType` in this scope
 --> /tmp/.tmpYpyU6P/main.rs:1:56
  |
1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
  |                                                        ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `default_value` in this scope
 --> /tmp/.tmpYpyU6P/main.rs:1:76
  |
1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
  |                                                                            ^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpYpyU6P/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpYpyU6P/main.rs:1:67
  |
1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
  |                                                                   ^^                    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
1 + use std :: collections :: HashMap ; fn read_data () -> DataType { return default_value } fn main () { }
  |

error: aborting due to 2 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch11-00-file-operations-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `DataType` in this scope
 --> /tmp/.tmpQOiBbH/main.rs:1:60
  |
1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...
  |                                                            ^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpQOiBbH/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpQOiBbH/main.rs:1:101
  |
1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...
  |                                                                                                     ^^           ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } fn main () { }
1 + use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { return true } ; return false } } fn main () { }
  |

error[E0425]: cannot find function `valid` in this scope
 --> /tmp/.tmpQOiBbH/main.rs:1:85
  |
1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...
  |                                                                                     ^^^^^ not found in this scope

error: aborting due to 2 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch11-00-file-operations-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `ConfigType` in this scope
 --> /tmp/.tmpLP9WHL/main.rs:1:58
  |
1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...
  |                                                          ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `default_config` in this scope
 --> /tmp/.tmpLP9WHL/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...
  |                                                                                ^^^^^^^^^^^^^^ not found in this scope

error[E0412]: cannot find type `ConfigType` in this scope
 --> /tmp/.tmpLP9WHL/main.rs:1:124
  |
1 | ...eturn default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
  |                                                      ^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpLP9WHL/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpLP9WHL/main.rs:1:71
  |
1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...
  |                                                                       ^^                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
1 + use std :: collections :: HashMap ; fn load_config () -> ConfigType { return default_config } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpLP9WHL/main.rs:1:146
  |
1 | ...g } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
  |                                                         ^^                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
1 + use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { return validate (config) } fn main () { }
  |

error[E0425]: cannot find function `validate` in this scope
 --> /tmp/.tmpLP9WHL/main.rs:1:155
  |
1 | ...ve_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
  |                                                       ^^^^^^^^ not found in this scope

error: aborting due to 4 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch11-00-file-operations-tdd example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-control-flow-tdd example 8 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `condition` in this scope
 --> /tmp/.tmpEGuuHU/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if condition { () } else { if other_condition { () } else { () } } ; if let...
  |                                                                  ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `other_condition` in this scope
 --> /tmp/.tmpEGuuHU/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if condition { () } else { if other_condition { () } else { () } } ; if let...
  |                                                                                             ^^^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpEGuuHU/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if condition { () } else { if other_condition { () } else { () } } ; if let...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 9 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `condition` in this scope
 --> /tmp/.tmp9LSPYh/main.rs:1:71
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start .. end { () } } ; if let S...
  |                                                                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `start` in this scope
 --> /tmp/.tmp9LSPYh/main.rs:1:106
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start .. end { () } } ; if let S...
  |                                                                                                          ^^^^^ not found in this scope

error[E0425]: cannot find value `end` in this scope
 --> /tmp/.tmp9LSPYh/main.rs:1:115
  |
1 | ... { while condition { () } ; for variable in start .. end { () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast...
  |                                                         ^^^ not found in this scope
  |
help: you might have meant to write `.` instead of `..`
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start .. end { () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start.end { () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp9LSPYh/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start .. end { () } } ; if let S...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 3 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 10 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `value` in this scope
 --> /tmp/.tmp1V4iNc/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match value { pattern1 => action1 , pattern2 => action2 , _ => default_acti...
  |                                                                     ^^^^^ not found in this scope

error[E0425]: cannot find value `action1` in this scope
 --> /tmp/.tmp1V4iNc/main.rs:1:89
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match value { pattern1 => action1 , pattern2 => action2 , _ => default_acti...
  |                                                                                         ^^^^^^^ not found in this scope

error[E0425]: cannot find value `action2` in this scope
 --> /tmp/.tmp1V4iNc/main.rs:1:111
  |
1 | ... = match value { pattern1 => action1 , pattern2 => action2 , _ => default_action , } ; if let Some (s) = (& result as & dyn std :: any...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `default_action` in this scope
 --> /tmp/.tmp1V4iNc/main.rs:1:126
  |
1 | ...attern1 => action1 , pattern2 => action2 , _ => default_action , } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcas...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp1V4iNc/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match value { pattern1 => action1 , pattern2 => action2 , _ => default_acti...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 4 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 11 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `user_input` in this scope
 --> /tmp/.tmpP6w2BI/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...
  |                                                                  ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `threshold` in this scope
 --> /tmp/.tmpP6w2BI/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...
  |                                                                               ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpP6w2BI/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpP6w2BI/main.rs:1:91
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...
  |                                                                                           ^^                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { process_high_value () } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpP6w2BI/main.rs:1:126
  |
1 | ...put > threshold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :...
  |                                                         ^^                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { process_normal_value () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `process_high_value` in this scope
 --> /tmp/.tmpP6w2BI/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...
  |                                                                                             ^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `process_normal_value` in this scope
 --> /tmp/.tmpP6w2BI/main.rs:1:128
  |
1 | ...shold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . d...
  |                                                 ^^^^^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 4 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 12 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp69iDM2/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; while count < 10i32 { { do_something () ; count = ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `do_something` in this scope
 --> /tmp/.tmp69iDM2/main.rs:1:112
  |
1 | ...{ let mut count = 0i32 ; while count < 10i32 { { do_something () ; count = count + 1i32 } } } ; if let Some (s) = (& result as & dyn s...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 14 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `status_code` in this scope
 --> /tmp/.tmp61KLpT/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match status_code { 200i32 => println ! ("Success") , 404i32 => println ! (...
  |                                                                     ^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp61KLpT/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match status_code { 200i32 => println ! ("Success") , 404i32 => println ! (...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== appendix-c-troubleshooting example 1 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpuNTrn8/main.rs:1:143
  |
1 | ... let mut x = 42i32 ; let mut y = 24i32 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpuNTrn8/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut x = 42i32 ; let mut y = 24i32 ; let mut x = 42i32 ; let mut y = 2...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== appendix-c-troubleshooting example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 4 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpqlxWQn/main.rs:1:159
  |
1 | ... ; let mut x = "string" . to_string () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpqlxWQn/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut x = "string" . to_string () ; let mut x = 42i32 ; let mut x = "st...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== appendix-c-troubleshooting example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 6 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpJEKYT9/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut s = String :: from ("hello" . to_string ()) ; takes_ownership (s)...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `takes_ownership` in this scope
 --> /tmp/.tmpJEKYT9/main.rs:1:119
  |
1 | ... s = String :: from ("hello" . to_string ()) ; takes_ownership (s) ; println ! ("{}" , s) ; let mut s = String :: from ("hello" . to_s...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `takes_ownership` in this scope
 --> /tmp/.tmpJEKYT9/main.rs:1:218
  |
1 | ... s = String :: from ("hello" . to_string ()) ; takes_ownership (s . clone ()) ; println ! ("{}" , s) ; let mut s = String :: from ("he...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `borrows_value` in this scope
 --> /tmp/.tmpJEKYT9/main.rs:1:328
  |
1 | ...t s = String :: from ("hello" . to_string ()) ; borrows_value (& s) ; println ! ("{}" , s) } ; if let Some (s) = (& result as & dyn st...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== appendix-c-troubleshooting example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 9 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpDXugjJ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut v = vec ! [1i32 , 2i32 , 3i32] ; let mut item = v [5i32 as usize]...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpDXugjJ/main.rs:1:362
  |
1 | ...if let Some (item) = v . get (5i32) . cloned () { { println ! ("Item: {}" , item) } } } ; if let Some (s) = (& result as & dyn std :: ...
  |                                                      ^^                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { let mut v = vec ! [1i32 , 2i32 , 3i32] ; let mut item = v [5i32 as usize] ; let mut v = vec ! [1i32 , 2i32 , 3i32] ; match v . get (5i32) . cloned () { Some (item) => println ! ("Item: {}" , item) , None => println ! ("Index out of bounds") , } ; if let Some (item) = v . get (5i32) . cloned () { { println ! ("Item: {}" , item) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { let mut v = vec ! [1i32 , 2i32 , 3i32] ; let mut item = v [5i32 as usize] ; let mut v = vec ! [1i32 , 2i32 , 3i32] ; match v . get (5i32) . cloned () { Some (item) => println ! ("Item: {}" , item) , None => println ! ("Index out of bounds") , } ; if let Some (item) = v . get (5i32) . cloned () { println ! ("Item: {}" , item) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0277]: the type `[i32]` cannot be indexed by `i32`
   --> /tmp/.tmpDXugjJ/main.rs:1:197
    |
1   | ...! [1i32 , 2i32 , 3i32] ; match v . get (5i32) . cloned () { Some (item) => println ! ("Item: {}" , item) , None => println ! ("Index o...
    |                                       ---  ^^^^ slice indices are of type `usize` or ranges of `usize`
    |                                       |
    |                                       required by a bound introduced by this call
    |
    = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
    = help: the following other types implement trait `SliceIndex<T>`:
              `usize` implements `SliceIndex<ByteStr>`
              `usize` implements `SliceIndex<[T]>`
note: required by a bound in `core::slice::<impl [T]>::get`
   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:573:12
    |
571 |     pub fn get<I>(&self, index: I) -> Option<&I::Output>
    |            --- required by a bound in this associated function
572 |     where
573 |         I: SliceIndex<Self>,
    |            ^^^^^^^^^^^^^^^^ required by this bound in `core::slice::<impl [T]>::get`

error[E0277]: the type `[i32]` cannot be indexed by `i32`
   --> /tmp/.tmpDXugjJ/main.rs:1:342
    |
1   | ...s") , } ; if let Some (item) = v . get (5i32) . cloned () { { println ! ("Item: {}" , item) } } } ; if let Some (s) = (& result as & d...
    |                                       ---  ^^^^ slice indices are of type `usize` or ranges of `usize`
    |                                       |
    |                                       required by a bound introduced by this call
    |
    = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
    = help: the following other types implement trait `SliceIndex<T>`:
              `usize` implements `SliceIndex<ByteStr>`
              `usize` implements `SliceIndex<[T]>`
note: required by a bound in `core::slice::<impl [T]>::get`
   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:573:12
    |
571 |     pub fn get<I>(&self, index: I) -> Option<&I::Output>
    |            --- required by a bound in this associated function
572 |     where
573 |         I: SliceIndex<Self>,
    |            ^^^^^^^^^^^^^^^^ required by this bound in `core::slice::<impl [T]>::get`

error: aborting due to 2 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0277`.



=== appendix-c-troubleshooting example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 13 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 14 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 15 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 16 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp9uz8h8/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmp9uz8h8/main.rs:1:102
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for...
  |                                                                                                      ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp9uz8h8/main.rs:1:162
  |
1 | ...ut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i...
  |                                                         ^^                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { list . insert (0i32 , i) } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp9uz8h8/main.rs:1:259
  |
1 | ...que = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any...
  |                                                          ^^                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { deque . push_front (i) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0308]: mismatched types
    --> /tmp/.tmp9uz8h8/main.rs:1:179
     |
1    | ...ew () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { ...
     |                                                ------  ^^^^ expected `usize`, found `i32`
     |                                                |
     |                                                arguments to this method are incorrect
     |
note: method defined here
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2034:12
     |
2034 |     pub fn insert(&mut self, index: usize, element: T) {
     |            ^^^^^^
help: change the type of the numeric literal from `i32` to `usize`
     |
1    - use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1    + use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0usize , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
     |

error: aborting due to 1 previous error; 4 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== appendix-c-troubleshooting example 17 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpe9LIpq/main.rs:1:161
  |
1 | ...ut data = response . json () . await ? } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0425]: cannot find value `url` in this scope
 --> /tmp/.tmpe9LIpq/main.rs:1:100
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut response = reqwest :: get (url) . await ? ; let mut data = respon...
  |                                                                                                    ^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpe9LIpq/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut response = reqwest :: get (url) . await ? ; let mut data = respon...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
 --> /tmp/.tmpe9LIpq/main.rs:1:84
  |
1 | ... { let result = { let mut response = reqwest :: get (url) . await ? ; let mut data = response . json () . await ? } ; if let Some (s) ...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
  |
  = help: you might be missing a crate named `reqwest`

error: aborting due to 3 previous errors; 1 warning emitted

Some errors have detailed explanations: E0425, E0433.
For more information about an error, try `rustc --explain E0425`.



=== appendix-c-troubleshooting example 18 ===
✗ Compilation failed: Failed to transpile to Rust


=== appendix-c-troubleshooting example 19 ===
✗ Compilation failed: Failed to transpile to Rust


=== appendix-c-troubleshooting example 20 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 2 ===

thread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:
"alice@email.com" is not a valid Ident
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


=== ch05-00-data-processing example 3 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpPVawDQ/main.rs:1:478
  |
1 | ...return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut ...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpPVawDQ/main.rs:1:515
  |
1 | ...t mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut ...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpPVawDQ/main.rs:1:534
  |
1 | ...rs . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers ....
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpPVawDQ/main.rs:1:571
  |
1 | ...rs . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transa...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpPVawDQ/main.rs:1:608
  |
1 | ...mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t |...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `transactions` in this scope
 --> /tmp/.tmpPVawDQ/main.rs:1:648
  |
1 | ...inimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let m...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `transactions` in this scope
 --> /tmp/.tmpPVawDQ/main.rs:1:751
  |
1 | ... > 100i32) . collect () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let ...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `transactions` in this scope
 --> /tmp/.tmpPVawDQ/main.rs:1:855
  |
1 | ...lect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }
  |                                                     ^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpPVawDQ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpPVawDQ/main.rs:1:218
  |
1 | ... { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } ...
  |       ^^                                                                                                                                                                                                                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }
1 + use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpPVawDQ/main.rs:1:266
  |
1 | ... { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ...
  |       ^^                                                                                                                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }
1 + use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpPVawDQ/main.rs:1:338
  |
1 | ...ield as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } ...
  |                                                     ^^                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }
1 + use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { groups [key as usize] = vec ! [] } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }
  |

error[E0277]: `T` is not an iterator
 --> /tmp/.tmpPVawDQ/main.rs:1:256
  |
1 | ...d : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { ...
  |                                                        ^^^^^^^ `T` is not an iterator
  |
  = note: required for `T` to implement `IntoIterator`
help: consider further restricting type parameter `T` with trait `Iterator`
  |
1 | use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }
  |                                                                                                                                                                                       +++++++++++++++++++++

error[E0599]: no method named `has_key` found for unit type `()` in the current scope
 --> /tmp/.tmpPVawDQ/main.rs:1:322
  |
1 | ...et key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . pu...
  |                                                       ^^^^^^^ method not found in `()`

error[E0308]: mismatched types
 --> /tmp/.tmpPVawDQ/main.rs:1:434
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } ...
  |       - expected this type parameter                                                                                                                               - expected `T` because of return type                                                                                                                                                                                       ^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: the caller chooses a type for `T` which can be different from `()`

error[E0605]: non-primitive cast: `T` as `usize`
 --> /tmp/.tmpPVawDQ/main.rs:1:288
  |
1 | ...rd [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) }...
  |        ^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error: aborting due to 12 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0425, E0599, E0605.
For more information about an error, try `rustc --explain E0277`.



=== ch05-00-data-processing example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 8 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmpbwPb3a/main.rs:1:685
  |
1 | ...monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart...
  |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") + bar , " ") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = { SomeStruct { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } } ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ++++++++++++                                                                                                       +

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpbwPb3a/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpbwPb3a/main.rs:1:432
  |
1 | ... { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") + bar , " ") + value . to_s ()) } } } } ...
  |       ^^                                                                                                                                                                                                         ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") + bar , " ") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
1 + use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . items () { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") + bar , " ") + value . to_s ()) } } } } } } } fn main () { let mut monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
  |

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpbwPb3a/main.rs:1:303
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{}" , "=" * title . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                                                                      ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (data : T , title : T) -> T { { println ! ("{}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") + bar , " ") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
  |                                                                                                                                                                                       +++++++++++++++++++

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpbwPb3a/main.rs:1:289
  |
1 | ..." , "\n" , title)) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width =...
  |                                     --    ^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                                     |
  |                                     required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `values` found for type parameter `T` in the current scope
 --> /tmp/.tmpbwPb3a/main.rs:1:338
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values ()...
  |       - method `values` not found for this type parameter                                                                                                                                                                                                                                      ^^^^^^ method not found in `T`

error[E0599]: no method named `items` found for type parameter `T` in the current scope
 --> /tmp/.tmpbwPb3a/main.rs:1:421
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . items ()...
  |       - method `items` not found for this type parameter                                                                                                                                                                                                                                                                                                                          ^^^^^ method not found in `T`

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpbwPb3a/main.rs:1:494
  |
1 | ...value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" ...
  |                                              ^^^^^^^ doesn't have a size known at compile-time
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: all local variables must have a statically known size

error[E0308]: mismatched types
 --> /tmp/.tmpbwPb3a/main.rs:1:602
  |
1 | ...ormat ! ("{}{}" , format ! ("{}{}" , key , " │") + bar , " ") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = ...
  |                                                       ^^^ expected `&str`, found `str`
  |
help: consider borrowing here
  |
1 | use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") + &bar , " ") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +

error[E0308]: mismatched types
 --> /tmp/.tmpbwPb3a/main.rs:1:393
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") + bar , " ") + value . to_s ()) } } } } } ...
  |       - expected this type parameter                                                                                                                            - expected `T` because of return type                                                                                                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: the caller chooses a type for `T` which can be different from `()`
  = note: `for` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") + bar , " ") + value . to_s ()) } } } } /* `T` value */ } } } } fn main () { let mut monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                +++++++++++++++

error: aborting due to 8 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch05-00-data-processing example 9 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmptyK2K1/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut sales_data = load_csv ("sales.csv" . to_string ()) ; let mut tota...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `load_csv` in this scope
 --> /tmp/.tmptyK2K1/main.rs:1:86
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut sales_data = load_csv ("sales.csv" . to_string ()) ; let mut tota...
  |                                                                                      ^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-data-processing example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch01-02-hello-world example 2 ===
✗ Compilation failed: Compilation failed:
error: multiple unused formatting arguments
 --> /tmp/.tmpYmDCAO/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello" , "World" , "from" , "Ruchy") } }
  |                                                               -------   ^^^^^^^   ^^^^^^   ^^^^^^^ argument never used
  |                                                               |         |         |
  |                                                               |         |         argument never used
  |                                                               |         argument never used
  |                                                               multiple missing formatting specifiers

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpYmDCAO/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello" , "World" , "from" , "Ruchy") } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpYmDCAO/main.rs:1:50
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello" , "World" , "from" , "Ruchy") } }
  |                                                  ^^                                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { println ! ("Hello" , "World" , "from" , "Ruchy") } }
1 + use std :: collections :: HashMap ; fn main () { println ! ("Hello" , "World" , "from" , "Ruchy") }
  |

error: aborting due to 1 previous error; 2 warnings emitted




=== ch01-02-hello-world example 3 ===
✗ Compilation failed: Compilation failed:
error: argument never used
 --> /tmp/.tmpvQh2Fm/main.rs:1:114
  |
1 | ...et name = "Alice" . to_string () ; { println ! ("Hello," , name) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Hello, " ,...
  |                                                    --------   ^^^^ argument never used
  |                                                    |
  |                                                    formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpvQh2Fm/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let name = "Alice" . to_string () ; { println ! ("Hello," , name) ; println ! ("{}" ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpvQh2Fm/main.rs:1:50
  |
1 | ... { { { let name = "Alice" . to_string () ; { println ! ("Hello," , name) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Hello, " , name) , "!")) } } } }
  |       ^^                                                                                                                                                           ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let name = "Alice" . to_string () ; { println ! ("Hello," , name) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Hello, " , name) , "!")) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let name = "Alice" . to_string () ; { println ! ("Hello," , name) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Hello, " , name) , "!")) } } }
  |

error: aborting due to 1 previous error; 2 warnings emitted




=== ch01-02-hello-world example 4 ===
✗ Compilation failed: Compilation failed:
error: argument never used
 --> /tmp/.tmpfydJCC/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("The answer is" , 42i32) ; println ! ("Pi is approximately" , 3.14159f64) ;...
  |                                                               ---------------   ^^^^^ argument never used
  |                                                               |
  |                                                               formatting specifier missing

error: argument never used
 --> /tmp/.tmpfydJCC/main.rs:1:125
  |
1 | ... ("The answer is" , 42i32) ; println ! ("Pi is approximately" , 3.14159f64) ; println ! ("Is Ruchy awesome?" , true) } }
  |                                            ---------------------   ^^^^^^^^^^ argument never used
  |                                            |
  |                                            formatting specifier missing

error: argument never used
 --> /tmp/.tmpfydJCC/main.rs:1:172
  |
1 | ... approximately" , 3.14159f64) ; println ! ("Is Ruchy awesome?" , true) } }
  |                                               -------------------   ^^^^ argument never used
  |                                               |
  |                                               formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpfydJCC/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("The answer is" , 42i32) ; println ! ("Pi is approximately" , 3.14159f64) ;...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 3 previous errors; 1 warning emitted




=== ch02-00-variables-types example 1 ===
✗ Compilation failed: Compilation failed:
error: multiple unused formatting arguments
 --> /tmp/.tmpRmfp1G/main.rs:1:161
  |
1 | ...t is_learning = true ; println ! ("Hi" , name , ", you're" , age , "years old!") ; println ! ("Currently learning Ruchy:" , is_learnin...
  |                                      ----   ^^^^   ^^^^^^^^^^   ^^^   ^^^^^^^^^^^^ argument never used
  |                                      |      |      |            |
  |                                      |      |      |            argument never used
  |                                      |      |      argument never used
  |                                      |      argument never used
  |                                      multiple missing formatting specifiers

error: argument never used
 --> /tmp/.tmpRmfp1G/main.rs:1:244
  |
1 | ... , age , "years old!") ; println ! ("Currently learning Ruchy:" , is_learning) } } } }
  |                                        ---------------------------   ^^^^^^^^^^^ argument never used
  |                                        |
  |                                        formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpRmfp1G/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let name = "Alice" . to_string () ; { let mut age = 25i32 ; let mut is_learning = tr...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpRmfp1G/main.rs:1:50
  |
1 | ... { { { let name = "Alice" . to_string () ; { let mut age = 25i32 ; let mut is_learning = true ; println ! ("Hi" , name , ", you're" , age , "years old!") ; println ! ("Currently learning Ruchy:" , is_learning) } } } }
  |       ^^                                                                                                                                                                                                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let name = "Alice" . to_string () ; { let mut age = 25i32 ; let mut is_learning = true ; println ! ("Hi" , name , ", you're" , age , "years old!") ; println ! ("Currently learning Ruchy:" , is_learning) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let name = "Alice" . to_string () ; { let mut age = 25i32 ; let mut is_learning = true ; println ! ("Hi" , name , ", you're" , age , "years old!") ; println ! ("Currently learning Ruchy:" , is_learning) } } }
  |

warning: variable does not need to be mutable
 --> /tmp/.tmpRmfp1G/main.rs:1:96
  |
1 | use std :: collections :: HashMap ; fn main () { { { let name = "Alice" . to_string () ; { let mut age = 25i32 ; let mut is_learning = tr...
  |                                                                                                ----^^^
  |                                                                                                |
  |                                                                                                help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

warning: variable does not need to be mutable
 --> /tmp/.tmpRmfp1G/main.rs:1:118
  |
1 | ..."Alice" . to_string () ; { let mut age = 25i32 ; let mut is_learning = true ; println ! ("Hi" , name , ", you're" , age , "years old!"...
  |                                                         ----^^^^^^^^^^^
  |                                                         |
  |                                                         help: remove this `mut`

error: aborting due to 2 previous errors; 4 warnings emitted




=== ch02-00-variables-types example 2 ===
✗ Compilation failed: Compilation failed:
error: argument never used
 --> /tmp/.tmpdNQAzl/main.rs:1:422
  |
1 | ...ut is_enrolled = ! has_graduated ; println ! ("Student:" , full_name) ; println ! ("Score:" , score , "(" , percentage , "%)") ; print...
  |                                                  ----------   ^^^^^^^^^ argument never used
  |                                                  |
  |                                                  formatting specifier missing

error: multiple unused formatting arguments
 --> /tmp/.tmpdNQAzl/main.rs:1:457
  |
1 | ...Student:" , full_name) ; println ! ("Score:" , score , "(" , percentage , "%)") ; println ! ("Temperature:" , temperature , "°C") ; pr...
  |                                        --------   ^^^^^   ^^^   ^^^^^^^^^^   ^^^^ argument never used
  |                                        |          |       |     |
  |                                        |          |       |     argument never used
  |                                        |          |       argument never used
  |                                        |          argument never used
  |                                        multiple missing formatting specifiers

error: multiple unused formatting arguments
 --> /tmp/.tmpdNQAzl/main.rs:1:520
  |
1 | ... "(" , percentage , "%)") ; println ! ("Temperature:" , temperature , "°C") ; println ! ("Status: student=" , is_student , ", graduate...
  |                                           --------------   ^^^^^^^^^^^   ^^^^ argument never used
  |                                           |                |
  |                                           |                argument never used
  |                                           multiple missing formatting specifiers

error: multiple unused formatting arguments
 --> /tmp/.tmpdNQAzl/main.rs:1:574
  |
1 | ...ure , "°C") ; println ! ("Status: student=" , is_student , ", graduated=" , has_graduated) } } } }
  |                             ------------------   ^^^^^^^^^^   ^^^^^^^^^^^^^^   ^^^^^^^^^^^^^ argument never used
  |                             |                    |            |
  |                             |                    |            argument never used
  |                             |                    argument never used
  |                             multiple missing formatting specifiers

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpdNQAzl/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let first_name = "John" . to_string () ; { let mut last_name = "Doe" . to_string () ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpdNQAzl/main.rs:1:50
  |
1 | ... { { { let first_name = "John" . to_string () ; { let mut last_name = "Doe" . to_string () ; let mut full_name = format ! ("{}{}" , first_name , " ") + last_name ; let mut score = 95i32 ; let mut percentage = 95.5f64 ; let mut temperature = - 10i32 ; let mut is_student = true ; let mut has_graduated = false ; let mut is_enrolled = ! has_graduated ; println ! ("Student:" , full_name) ; println ! ("Score:" , score , "(" , percentage , "%)") ; println ! ("Temperature:" , temperature , "°C") ; println ! ("Status: student=" , is_student , ", graduated=" , has_graduated) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let first_name = "John" . to_string () ; { let mut last_name = "Doe" . to_string () ; let mut full_name = format ! ("{}{}" , first_name , " ") + last_name ; let mut score = 95i32 ; let mut percentage = 95.5f64 ; let mut temperature = - 10i32 ; let mut is_student = true ; let mut has_graduated = false ; let mut is_enrolled = ! has_graduated ; println ! ("Student:" , full_name) ; println ! ("Score:" , score , "(" , percentage , "%)") ; println ! ("Temperature:" , temperature , "°C") ; println ! ("Status: student=" , is_student , ", graduated=" , has_graduated) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let first_name = "John" . to_string () ; { let mut last_name = "Doe" . to_string () ; let mut full_name = format ! ("{}{}" , first_name , " ") + last_name ; let mut score = 95i32 ; let mut percentage = 95.5f64 ; let mut temperature = - 10i32 ; let mut is_student = true ; let mut has_graduated = false ; let mut is_enrolled = ! has_graduated ; println ! ("Student:" , full_name) ; println ! ("Score:" , score , "(" , percentage , "%)") ; println ! ("Temperature:" , temperature , "°C") ; println ! ("Status: student=" , is_student , ", graduated=" , has_graduated) } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpdNQAzl/main.rs:1:199
  |
1 | ...name = format ! ("{}{}" , first_name , " ") + last_name ; let mut score = 95i32 ; let mut percentage = 95.5f64 ; let mut temperature =...
  |                                                  ^^^^^^^^^ expected `&str`, found `String`
  |
help: consider borrowing here
  |
1 | use std :: collections :: HashMap ; fn main () { { { let first_name = "John" . to_string () ; { let mut last_name = "Doe" . to_string () ; let mut full_name = format ! ("{}{}" , first_name , " ") + &last_name ; let mut score = 95i32 ; let mut percentage = 95.5f64 ; let mut temperature = - 10i32 ; let mut is_student = true ; let mut has_graduated = false ; let mut is_enrolled = ! has_graduated ; println ! ("Student:" , full_name) ; println ! ("Score:" , score , "(" , percentage , "%)") ; println ! ("Temperature:" , temperature , "°C") ; println ! ("Status: student=" , is_student , ", graduated=" , has_graduated) } } } }
  |                                                                                                                                                                                                       +

error: aborting due to 5 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch02-00-variables-types example 3 ===
✗ Compilation failed: Compilation failed:
error: multiple unused formatting arguments
 --> /tmp/.tmpntT4Hr/main.rs:1:358
  |
1 | ...um = total_points > 150i32 ; println ! ("Welcome back," , username , "!") ; println ! ("Logins:" , login_count , ", Points:" , total_p...
  |                                            ---------------   ^^^^^^^^   ^^^ argument never used
  |                                            |                 |
  |                                            |                 argument never used
  |                                            multiple missing formatting specifiers

error: multiple unused formatting arguments
 --> /tmp/.tmpntT4Hr/main.rs:1:399
  |
1 | ..., username , "!") ; println ! ("Logins:" , login_count , ", Points:" , total_points) ; println ! ("Premium status:" , is_premium) } } } }
  |                                   ---------   ^^^^^^^^^^^   ^^^^^^^^^^^   ^^^^^^^^^^^^ argument never used
  |                                   |           |             |
  |                                   |           |             argument never used
  |                                   |           argument never used
  |                                   multiple missing formatting specifiers

error: argument never used
 --> /tmp/.tmpntT4Hr/main.rs:1:474
  |
1 | ... ", Points:" , total_points) ; println ! ("Premium status:" , is_premium) } } } }
  |                                              -----------------   ^^^^^^^^^^ argument never used
  |                                              |
  |                                              formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpntT4Hr/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let username = "programmer2024" . to_string () ; { let mut login_count = 1i32 ; let ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpntT4Hr/main.rs:1:50
  |
1 | ... { { { let username = "programmer2024" . to_string () ; { let mut login_count = 1i32 ; let mut is_premium = false ; let mut welcome_bonus = 100i32 ; let mut total_points = welcome_bonus + login_count * 10i32 ; login_count = login_count + 1i32 ; is_premium = total_points > 150i32 ; println ! ("Welcome back," , username , "!") ; println ! ("Logins:" , login_count , ", Points:" , total_points) ; println ! ("Premium status:" , is_premium) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let username = "programmer2024" . to_string () ; { let mut login_count = 1i32 ; let mut is_premium = false ; let mut welcome_bonus = 100i32 ; let mut total_points = welcome_bonus + login_count * 10i32 ; login_count = login_count + 1i32 ; is_premium = total_points > 150i32 ; println ! ("Welcome back," , username , "!") ; println ! ("Logins:" , login_count , ", Points:" , total_points) ; println ! ("Premium status:" , is_premium) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let username = "programmer2024" . to_string () ; { let mut login_count = 1i32 ; let mut is_premium = false ; let mut welcome_bonus = 100i32 ; let mut total_points = welcome_bonus + login_count * 10i32 ; login_count = login_count + 1i32 ; is_premium = total_points > 150i32 ; println ! ("Welcome back," , username , "!") ; println ! ("Logins:" , login_count , ", Points:" , total_points) ; println ! ("Premium status:" , is_premium) } } }
  |

warning: value assigned to `is_premium` is never read
 --> /tmp/.tmpntT4Hr/main.rs:1:142
  |
1 | ...2024" . to_string () ; { let mut login_count = 1i32 ; let mut is_premium = false ; let mut welcome_bonus = 100i32 ; let mut total_poin...
  |                                                                  ^^^^^^^^^^
  |
  = help: maybe it is overwritten before being read?
  = note: `#[warn(unused_assignments)]` on by default

warning: variable does not need to be mutable
 --> /tmp/.tmpntT4Hr/main.rs:1:167
  |
1 | ...ogin_count = 1i32 ; let mut is_premium = false ; let mut welcome_bonus = 100i32 ; let mut total_points = welcome_bonus + login_count *...
  |                                                         ----^^^^^^^^^^^^^
  |                                                         |
  |                                                         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

warning: variable does not need to be mutable
 --> /tmp/.tmpntT4Hr/main.rs:1:200
  |
1 | ...emium = false ; let mut welcome_bonus = 100i32 ; let mut total_points = welcome_bonus + login_count * 10i32 ; login_count = login_coun...
  |                                                         ----^^^^^^^^^^^^
  |                                                         |
  |                                                         help: remove this `mut`

error: aborting due to 3 previous errors; 5 warnings emitted




=== ch02-00-variables-types example 4 ===
✗ Compilation failed: Compilation failed:
error: argument never used
 --> /tmp/.tmpt3DzRm/main.rs:1:287
  |
1 | ...e , true , true] ; println ! ("First language:" , favorite_languages [0i32 as usize]) ; println ! ("Today's temp:" , daily_temperature...
  |                                  -----------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
  |                                  |
  |                                  formatting specifier missing

error: multiple unused formatting arguments
 --> /tmp/.tmpt3DzRm/main.rs:1:354
  |
1 | ...32 as usize]) ; println ! ("Today's temp:" , daily_temperatures [0i32 as usize] , "°C") ; println ! ("I know" , favorite_languages . l...
  |                               ---------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^ argument never used
  |                               |                 |
  |                               |                 argument never used
  |                               multiple missing formatting specifiers

error: multiple unused formatting arguments
 --> /tmp/.tmpt3DzRm/main.rs:1:421
  |
1 | ...as usize] , "°C") ; println ! ("I know" , favorite_languages . len () , "languages") } } } }
  |                                   --------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^ argument never used
  |                                   |          |
  |                                   |          argument never used
  |                                   multiple missing formatting specifiers

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpt3DzRm/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let favorite_languages = vec ! ["Python" , "Rust" , "Ruchy"] ; { let mut daily_tempe...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpt3DzRm/main.rs:1:50
  |
1 | ... { { { let favorite_languages = vec ! ["Python" , "Rust" , "Ruchy"] ; { let mut daily_temperatures = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let mut task_completed = vec ! [true , false , true , true] ; println ! ("First language:" , favorite_languages [0i32 as usize]) ; println ! ("Today's temp:" , daily_temperatures [0i32 as usize] , "°C") ; println ! ("I know" , favorite_languages . len () , "languages") } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let favorite_languages = vec ! ["Python" , "Rust" , "Ruchy"] ; { let mut daily_temperatures = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let mut task_completed = vec ! [true , false , true , true] ; println ! ("First language:" , favorite_languages [0i32 as usize]) ; println ! ("Today's temp:" , daily_temperatures [0i32 as usize] , "°C") ; println ! ("I know" , favorite_languages . len () , "languages") } } } }
1 + use std :: collections :: HashMap ; fn main () { { let favorite_languages = vec ! ["Python" , "Rust" , "Ruchy"] ; { let mut daily_temperatures = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let mut task_completed = vec ! [true , false , true , true] ; println ! ("First language:" , favorite_languages [0i32 as usize]) ; println ! ("Today's temp:" , daily_temperatures [0i32 as usize] , "°C") ; println ! ("I know" , favorite_languages . len () , "languages") } } }
  |

warning: unused variable: `task_completed`
 --> /tmp/.tmpt3DzRm/main.rs:1:202
  |
1 | ..., 26.2f64] ; let mut task_completed = vec ! [true , false , true , true] ; println ! ("First language:" , favorite_languages [0i32 as ...
  |                         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_task_completed`
  |
  = note: `#[warn(unused_variables)]` on by default

warning: variable does not need to be mutable
 --> /tmp/.tmpt3DzRm/main.rs:1:123
  |
1 | ...guages = vec ! ["Python" , "Rust" , "Ruchy"] ; { let mut daily_temperatures = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let mut ta...
  |                                                         ----^^^^^^^^^^^^^^^^^^
  |                                                         |
  |                                                         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

warning: variable does not need to be mutable
 --> /tmp/.tmpt3DzRm/main.rs:1:198
  |
1 | ... = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let mut task_completed = vec ! [true , false , true , true] ; println ! ("First langu...
  |                                                         ----^^^^^^^^^^^^^^
  |                                                         |
  |                                                         help: remove this `mut`

error: aborting due to 3 previous errors; 5 warnings emitted




=== ch02-00-variables-types example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `user_name` in this scope
 --> /tmp/.tmpxXSGPU/main.rs:1:52
  |
1 | use std :: collections :: HashMap ; fn main () { { user_name = "Alice" } }
  |                                                    ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpxXSGPU/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { user_name = "Alice" } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpxXSGPU/main.rs:1:50
  |
1 | use std :: collections :: HashMap ; fn main () { { user_name = "Alice" } }
  |                                                  ^^                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { user_name = "Alice" } }
1 + use std :: collections :: HashMap ; fn main () { user_name = "Alice" }
  |

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch02-00-variables-types example 6 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmplpd8jO/main.rs:1:117
  |
1 | use std :: collections :: HashMap ; fn main () { { { let age = "25" . to_string () ; let mut next_year = age + 1i32 } } }
  |                                                                                                                     ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmplpd8jO/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let age = "25" . to_string () ; let mut next_year = age + 1i32 } } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmplpd8jO/main.rs:1:50
  |
1 | use std :: collections :: HashMap ; fn main () { { { let age = "25" . to_string () ; let mut next_year = age + 1i32 } } }
  |                                                  ^^                                                                  ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let age = "25" . to_string () ; let mut next_year = age + 1i32 } } }
1 + use std :: collections :: HashMap ; fn main () { { let age = "25" . to_string () ; let mut next_year = age + 1i32 } }
  |

error: aborting due to 1 previous error; 2 warnings emitted




=== ch02-00-variables-types example 8 ===
✗ Compilation failed: Compilation failed:
error: multiple unused formatting arguments
 --> /tmp/.tmpC3CHCD/main.rs:1:132
  |
1 | ...ng () ; { let mut age = 25i32 ; println ! ("Hi" , name , ", age" , age) } } } }
  |                                               ----   ^^^^   ^^^^^^^   ^^^ argument never used
  |                                               |      |      |
  |                                               |      |      argument never used
  |                                               |      argument never used
  |                                               multiple missing formatting specifiers

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpC3CHCD/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let name = "Alice" . to_string () ; { let mut age = 25i32 ; println ! ("Hi" , name ,...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpC3CHCD/main.rs:1:50
  |
1 | ...n main () { { { let name = "Alice" . to_string () ; { let mut age = 25i32 ; println ! ("Hi" , name , ", age" , age) } } } }
  |                ^^                                                                                                         ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let name = "Alice" . to_string () ; { let mut age = 25i32 ; println ! ("Hi" , name , ", age" , age) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let name = "Alice" . to_string () ; { let mut age = 25i32 ; println ! ("Hi" , name , ", age" , age) } } }
  |

warning: variable does not need to be mutable
 --> /tmp/.tmpC3CHCD/main.rs:1:96
  |
1 | use std :: collections :: HashMap ; fn main () { { { let name = "Alice" . to_string () ; { let mut age = 25i32 ; println ! ("Hi" , name ,...
  |                                                                                                ----^^^
  |                                                                                                |
  |                                                                                                help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

error: aborting due to 1 previous error; 3 warnings emitted




=== ch02-00-variables-types example 9 ===
✗ Compilation failed: Compilation failed:
error: multiple unused formatting arguments
 --> /tmp/.tmpGrkOPP/main.rs:1:812
  |
1 | ..._adult && lives_in_tech_city ; println ! ("Profile:" , name , age , city) ; println ! ("Math:" , sum , difference , average) ; println...
  |                                              ----------   ^^^^   ^^^   ^^^^ argument never used
  |                                              |            |      |
  |                                              |            |      argument never used
  |                                              |            argument never used
  |                                              multiple missing formatting specifiers

error: multiple unused formatting arguments
 --> /tmp/.tmpGrkOPP/main.rs:1:854
  |
1 | ...le:" , name , age , city) ; println ! ("Math:" , sum , difference , average) ; println ! ("Contact:" , username , email) ; println ! (...
  |                                           -------   ^^^   ^^^^^^^^^^   ^^^^^^^ argument never used
  |                                           |         |     |
  |                                           |         |     argument never used
  |                                           |         argument never used
  |                                           multiple missing formatting specifiers

error: multiple unused formatting arguments
 --> /tmp/.tmpGrkOPP/main.rs:1:908
  |
1 | ... sum , difference , average) ; println ! ("Contact:" , username , email) ; println ! ("Status:" , is_adult , lives_in_tech_city , read...
  |                                              ----------   ^^^^^^^^   ^^^^^ argument never used
  |                                              |            |
  |                                              |            argument never used
  |                                              multiple missing formatting specifiers

error: multiple unused formatting arguments
 --> /tmp/.tmpGrkOPP/main.rs:1:951
  |
1 | ...rname , email) ; println ! ("Status:" , is_adult , lives_in_tech_city , ready_for_job) } } } }
  |                                ---------   ^^^^^^^^   ^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^ argument never used
  |                                |           |          |
  |                                |           |          argument never used
  |                                |           argument never used
  |                                multiple missing formatting specifiers

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpGrkOPP/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let name = "Alex" . to_string () ; { let mut age = 28i32 ; let mut city = "San Franc...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpGrkOPP/main.rs:1:50
  |
1 | ... { { { let name = "Alex" . to_string () ; { let mut age = 28i32 ; let mut city = "San Francisco" . to_string () ; let mut hobby = "rock climbing" . to_string () ; let mut goal = "master Ruchy in 30 days" . to_string () ; let mut num1 = 15i32 ; let mut num2 = 25i32 ; let mut sum = num1 + num2 ; let mut difference = num1 - num2 ; let mut average = num1 + num2 / 2i32 ; let mut first_name = "Alex" . to_string () ; let mut last_name = "Johnson" . to_string () ; let mut username = format ! ("{}{}" , first_name , "_") + last_name ; let mut email = format ! ("{}{}" , username , "@example.com") ; let mut is_adult = age >= 18i32 ; let mut lives_in_tech_city = city == "San Francisco" ; let mut ready_for_job = is_adult && lives_in_tech_city ; println ! ("Profile:" , name , age , city) ; println ! ("Math:" , sum , difference , average) ; println ! ("Contact:" , username , email) ; println ! ("Status:" , is_adult , lives_in_tech_city , ready_for_job) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let name = "Alex" . to_string () ; { let mut age = 28i32 ; let mut city = "San Francisco" . to_string () ; let mut hobby = "rock climbing" . to_string () ; let mut goal = "master Ruchy in 30 days" . to_string () ; let mut num1 = 15i32 ; let mut num2 = 25i32 ; let mut sum = num1 + num2 ; let mut difference = num1 - num2 ; let mut average = num1 + num2 / 2i32 ; let mut first_name = "Alex" . to_string () ; let mut last_name = "Johnson" . to_string () ; let mut username = format ! ("{}{}" , first_name , "_") + last_name ; let mut email = format ! ("{}{}" , username , "@example.com") ; let mut is_adult = age >= 18i32 ; let mut lives_in_tech_city = city == "San Francisco" ; let mut ready_for_job = is_adult && lives_in_tech_city ; println ! ("Profile:" , name , age , city) ; println ! ("Math:" , sum , difference , average) ; println ! ("Contact:" , username , email) ; println ! ("Status:" , is_adult , lives_in_tech_city , ready_for_job) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let name = "Alex" . to_string () ; { let mut age = 28i32 ; let mut city = "San Francisco" . to_string () ; let mut hobby = "rock climbing" . to_string () ; let mut goal = "master Ruchy in 30 days" . to_string () ; let mut num1 = 15i32 ; let mut num2 = 25i32 ; let mut sum = num1 + num2 ; let mut difference = num1 - num2 ; let mut average = num1 + num2 / 2i32 ; let mut first_name = "Alex" . to_string () ; let mut last_name = "Johnson" . to_string () ; let mut username = format ! ("{}{}" , first_name , "_") + last_name ; let mut email = format ! ("{}{}" , username , "@example.com") ; let mut is_adult = age >= 18i32 ; let mut lives_in_tech_city = city == "San Francisco" ; let mut ready_for_job = is_adult && lives_in_tech_city ; println ! ("Profile:" , name , age , city) ; println ! ("Math:" , sum , difference , average) ; println ! ("Contact:" , username , email) ; println ! ("Status:" , is_adult , lives_in_tech_city , ready_for_job) } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpGrkOPP/main.rs:1:566
  |
1 | ...name = format ! ("{}{}" , first_name , "_") + last_name ; let mut email = format ! ("{}{}" , username , "@example.com") ; let mut is_a...
  |                                                  ^^^^^^^^^ expected `&str`, found `String`
  |
help: consider borrowing here
  |
1 | use std :: collections :: HashMap ; fn main () { { { let name = "Alex" . to_string () ; { let mut age = 28i32 ; let mut city = "San Francisco" . to_string () ; let mut hobby = "rock climbing" . to_string () ; let mut goal = "master Ruchy in 30 days" . to_string () ; let mut num1 = 15i32 ; let mut num2 = 25i32 ; let mut sum = num1 + num2 ; let mut difference = num1 - num2 ; let mut average = num1 + num2 / 2i32 ; let mut first_name = "Alex" . to_string () ; let mut last_name = "Johnson" . to_string () ; let mut username = format ! ("{}{}" , first_name , "_") + &last_name ; let mut email = format ! ("{}{}" , username , "@example.com") ; let mut is_adult = age >= 18i32 ; let mut lives_in_tech_city = city == "San Francisco" ; let mut ready_for_job = is_adult && lives_in_tech_city ; println ! ("Profile:" , name , age , city) ; println ! ("Math:" , sum , difference , average) ; println ! ("Contact:" , username , email) ; println ! ("Status:" , is_adult , lives_in_tech_city , ready_for_job) } } } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      +

error: aborting due to 5 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch06-00-data-structures-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpaws99t/main.rs:1:198
  |
1 | ...ut greeting = "Welcome" . to_string () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpaws99t/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut message = "Hello World" . to_string () ; let mut name = "Alice" ....
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch06-00-data-structures-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmp2mVNhh/main.rs:1:151
  |
1 | ... number = 100i32 ; let mut flag = true } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp2mVNhh/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut text = "Count" . to_string () ; let mut number = 100i32 ; let mut...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch06-00-data-structures-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpB93o6y/main.rs:1:190
  |
1 | ...; let mut title = "Mr." . to_string () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpB93o6y/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut first_name = "John" . to_string () ; let mut last_name = "Doe" . ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch06-00-data-structures-tdd example 7 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpbv9zwn/main.rs:1:179
  |
1 | ...mut unit = "Fahrenheit" . to_string () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpbv9zwn/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut label = "Temperature" . to_string () ; let mut value = 72i32 ; le...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch06-00-data-structures-tdd example 8 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpAzezwV/main.rs:1:171
  |
1 | ... . to_string () ; let mut debug = true } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpAzezwV/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut app_name = "MyApp" . to_string () ; let mut version = "1.0" . to_...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch03-00-functions example 1 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp6lOEaA/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let name = "Alice" . to_string () ; { let mut a = 15i32 ; let mut b = 27i32 ; let mu...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp6lOEaA/main.rs:1:50
  |
1 | ... { { { let name = "Alice" . to_string () ; { let mut a = 15i32 ; let mut b = 27i32 ; let mut greeting = format ! ("{}{}" , format ! ("{}{}" , "Hello, " , name) , "! Welcome to Ruchy!") ; let mut sum = a + b ; let mut result_message = format ! ("{}{}" , format ! ("{}{}" , a , " + ") + b , " = ") + sum ; println ! ("{}" , greeting) ; println ! ("{}" , result_message) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let name = "Alice" . to_string () ; { let mut a = 15i32 ; let mut b = 27i32 ; let mut greeting = format ! ("{}{}" , format ! ("{}{}" , "Hello, " , name) , "! Welcome to Ruchy!") ; let mut sum = a + b ; let mut result_message = format ! ("{}{}" , format ! ("{}{}" , a , " + ") + b , " = ") + sum ; println ! ("{}" , greeting) ; println ! ("{}" , result_message) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let name = "Alice" . to_string () ; { let mut a = 15i32 ; let mut b = 27i32 ; let mut greeting = format ! ("{}{}" , format ! ("{}{}" , "Hello, " , name) , "! Welcome to Ruchy!") ; let mut sum = a + b ; let mut result_message = format ! ("{}{}" , format ! ("{}{}" , a , " + ") + b , " = ") + sum ; println ! ("{}" , greeting) ; println ! ("{}" , result_message) } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp6lOEaA/main.rs:1:332
  |
1 | ... format ! ("{}{}" , format ! ("{}{}" , a , " + ") + b , " = ") + sum ; println ! ("{}" , greeting) ; println ! ("{}" , result_message)...
  |                                                        ^ expected `&str`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmp6lOEaA/main.rs:1:345
  |
1 | ...{}" , format ! ("{}{}" , a , " + ") + b , " = ") + sum ; println ! ("{}" , greeting) ; println ! ("{}" , result_message) } } } }
  |                                                       ^^^ expected `&str`, found `i32`

error: aborting due to 2 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 2 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpq45D6l/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let input1 = 10i32 ; { let mut input2 = 20i32 ; let mut sum = input1 + input2 ; let ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpq45D6l/main.rs:1:50
  |
1 | ... { { { let input1 = 10i32 ; { let mut input2 = 20i32 ; let mut sum = input1 + input2 ; let mut product = input1 * input2 ; let mut average = sum / 2i32 ; let mut result = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Sum: " , sum) , ", Product: ") + product , ", Average: ") + average ; println ! ("{}" , result) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let input1 = 10i32 ; { let mut input2 = 20i32 ; let mut sum = input1 + input2 ; let mut product = input1 * input2 ; let mut average = sum / 2i32 ; let mut result = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Sum: " , sum) , ", Product: ") + product , ", Average: ") + average ; println ! ("{}" , result) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let input1 = 10i32 ; { let mut input2 = 20i32 ; let mut sum = input1 + input2 ; let mut product = input1 * input2 ; let mut average = sum / 2i32 ; let mut result = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Sum: " , sum) , ", Product: ") + product , ", Average: ") + average ; println ! ("{}" , result) } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpq45D6l/main.rs:1:309
  |
1 | ...at ! ("{}{}" , "Sum: " , sum) , ", Product: ") + product , ", Average: ") + average ; println ! ("{}" , result) } } } }
  |                                                     ^^^^^^^ expected `&str`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpq45D6l/main.rs:1:336
  |
1 | ...m) , ", Product: ") + product , ", Average: ") + average ; println ! ("{}" , result) } } } }
  |                                                     ^^^^^^^ expected `&str`, found `i32`

error: aborting due to 2 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 3 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpWL5gW0/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let user_name = "Alice" . to_string () ; { let mut greeting_template = format ! ("{}...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpWL5gW0/main.rs:1:50
  |
1 | ... { { { let user_name = "Alice" . to_string () ; { let mut greeting_template = format ! ("{}{}" , format ! ("{}{}" , "Hello, " , user_name) , "! Welcome!") ; let mut num1 = 15i32 ; let mut num2 = 27i32 ; let mut operation = "addition" . to_string () ; let mut calc_result = num1 + num2 ; let mut calc_display = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , operation , ": ") + num1 , " + ") + num2 , " = ") + calc_result ; println ! ("{}" , greeting_template) ; println ! ("{}" , calc_display) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let user_name = "Alice" . to_string () ; { let mut greeting_template = format ! ("{}{}" , format ! ("{}{}" , "Hello, " , user_name) , "! Welcome!") ; let mut num1 = 15i32 ; let mut num2 = 27i32 ; let mut operation = "addition" . to_string () ; let mut calc_result = num1 + num2 ; let mut calc_display = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , operation , ": ") + num1 , " + ") + num2 , " = ") + calc_result ; println ! ("{}" , greeting_template) ; println ! ("{}" , calc_display) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let user_name = "Alice" . to_string () ; { let mut greeting_template = format ! ("{}{}" , format ! ("{}{}" , "Hello, " , user_name) , "! Welcome!") ; let mut num1 = 15i32 ; let mut num2 = 27i32 ; let mut operation = "addition" . to_string () ; let mut calc_result = num1 + num2 ; let mut calc_display = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , operation , ": ") + num1 , " + ") + num2 , " = ") + calc_result ; println ! ("{}" , greeting_template) ; println ! ("{}" , calc_display) } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpWL5gW0/main.rs:1:434
  |
1 | ... ("{}{}" , format ! ("{}{}" , operation , ": ") + num1 , " + ") + num2 , " = ") + calc_result ; println ! ("{}" , greeting_template) ;...
  |                                                      ^^^^ expected `&str`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpWL5gW0/main.rs:1:450
  |
1 | ...t ! ("{}{}" , operation , ": ") + num1 , " + ") + num2 , " = ") + calc_result ; println ! ("{}" , greeting_template) ; println ! ("{}"...
  |                                                      ^^^^ expected `&str`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpWL5gW0/main.rs:1:466
  |
1 | ...tion , ": ") + num1 , " + ") + num2 , " = ") + calc_result ; println ! ("{}" , greeting_template) ; println ! ("{}" , calc_display) } ...
  |                                                   ^^^^^^^^^^^ expected `&str`, found `i32`

error: aborting due to 3 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 4 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpJS3uYu/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = "San Francisco" . to_string ()...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpJS3uYu/main.rs:1:50
  |
1 | ... { { { let temperature_f = 68i32 ; { let mut user_location = "San Francisco" . to_string () ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Weather in " , user_location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{}" , weather_report) ; println ! ("{}" , comfort_message) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = "San Francisco" . to_string () ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Weather in " , user_location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{}" , weather_report) ; println ! ("{}" , comfort_message) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let temperature_f = 68i32 ; { let mut user_location = "San Francisco" . to_string () ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Weather in " , user_location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{}" , weather_report) ; println ! ("{}" , comfort_message) } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpJS3uYu/main.rs:1:516
  |
1 | ... "°C)") ; let mut comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{}" , ...
  |                                                            ^^                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = "San Francisco" . to_string () ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Weather in " , user_location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{}" , weather_report) ; println ! ("{}" , comfort_message) } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = "San Francisco" . to_string () ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Weather in " , user_location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfortable { "Perfect weather!" } else { { "Dress accordingly" } } ; println ! ("{}" , weather_report) ; println ! ("{}" , comfort_message) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpJS3uYu/main.rs:1:548
  |
1 | ... = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{}" , weather_report) ; println ! ("{}"...
  |                                                           ^^                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = "San Francisco" . to_string () ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Weather in " , user_location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{}" , weather_report) ; println ! ("{}" , comfort_message) } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = "San Francisco" . to_string () ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Weather in " , user_location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfortable { { "Perfect weather!" } } else { "Dress accordingly" } ; println ! ("{}" , weather_report) ; println ! ("{}" , comfort_message) } } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpJS3uYu/main.rs:1:419
  |
1 | ...}" , "Weather in " , user_location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfo...
  |                                                  ^^^^^^^^^^^^^ expected `&str`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpJS3uYu/main.rs:1:445
  |
1 | ...location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfortable { { "Perfect weathe...
  |                                                  ^^^^^^^^^^^^^ expected `&str`, found `i32`

error: aborting due to 2 previous errors; 4 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 5 ===
✗ Compilation failed: Compilation failed:
error: argument never used
 --> /tmp/.tmpzkm4CI/main.rs:1:1094
  |
1 | ...love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{}" , excited) ...
  |                                                 --------------   ^^^^ argument never used
  |                                                 |
  |                                                 formatting specifier missing

error: argument never used
 --> /tmp/.tmpzkm4CI/main.rs:1:1127
  |
1 | ...rintln ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{}" , excited) } } } }
  |                                                  -----------   ^^^^^^^^ argument never used
  |                                                  |
  |                                                  formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpzkm4CI/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: D...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpzkm4CI/main.rs:1:192
  |
1 | ...fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std ...
  |                                                                  ^^     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { x * x } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{}" , excited) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpzkm4CI/main.rs:1:369
  |
1 | ...mt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Ad...
  |                                              ^^                                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { let pi = 3.14159f64 ; pi * square (radius) } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{}" , excited) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpzkm4CI/main.rs:1:609
  |
1 | ... (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Out...
  |                                             ^^                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { format ! ("{}{}" , first_name , "_") + last_name } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{}" , excited) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpzkm4CI/main.rs:1:824
  |
1 | ...:: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32...
  |                                                   ^^                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { format ! ("{}{}" , message , "!!!") } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{}" , excited) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpzkm4CI/main.rs:1:879
  |
1 | ... { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{}" , excited) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{}" , excited) } } }
  |

error[E0277]: cannot multiply `f64` by `T`
 --> /tmp/.tmpzkm4CI/main.rs:1:398
  |
1 | ... (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + st...
  |                                                      ^ no implementation for `f64 * T`
  |
  = help: the trait `Mul<T>` is not implemented for `f64`
help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement
  |
1 | use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T where f64: Mul<T> { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{}" , excited) } } } }
  |                                                                                                                                                                                                                                                                                                                                                                               +++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpzkm4CI/main.rs:1:650
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } ...
  |       - found this type parameter                                                                                                                                                                                      ^^^^^^^^^ expected `&str`, found type parameter `T`
  |
  = note:   expected reference `&str`
          found type parameter `T`

error[E0308]: mismatched types
 --> /tmp/.tmpzkm4CI/main.rs:1:611
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } ...
  |       -                                                                                                                                                                   -     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `String`
  |       |                                                                                                                                                                   |
  |       expected this type parameter                                                                                                                                        expected `T` because of return type
  |
  = note: expected type parameter `T`
                     found struct `String`
  = note: the caller chooses a type for `T` which can be different from `String`

error[E0308]: mismatched types
 --> /tmp/.tmpzkm4CI/main.rs:1:826
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } ...
  |       -                                                                                                                                                -     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `String`
  |       |                                                                                                                                                |
  |       expected this type parameter                                                                                                                     expected `T` because of return type
  |
  = note: expected type parameter `T`
                     found struct `String`
  = note: the caller chooses a type for `T` which can be different from `String`
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: cannot add `String` to `String`
 --> /tmp/.tmpzkm4CI/main.rs:1:936
  |
1 | ...rcle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("...
  |                                            ^^^^^^^^^^^^^ no implementation for `String + String`
  |
  = help: the trait `Add<String>` is not implemented for `String`
          but trait `Add<&str>` is implemented for it
  = help: for that trait implementation, expected `&str`, found `String`
note: required by a bound in `make_username`
 --> /tmp/.tmpzkm4CI/main.rs:1:445
  |
1 | ... } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `make_username`

error[E0277]: cannot multiply `String` by `String`
 --> /tmp/.tmpzkm4CI/main.rs:1:936
  |
1 | ...rcle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("...
  |                                            ^^^^^^^^^^^^^ no implementation for `String * String`
  |
  = help: the trait `Mul` is not implemented for `String`
note: required by a bound in `make_username`
 --> /tmp/.tmpzkm4CI/main.rs:1:480
  |
1 | ...: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `make_username`

error[E0277]: cannot add `String` to `String`
 --> /tmp/.tmpzkm4CI/main.rs:1:1029
  |
1 | ...ng ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , us...
  |                               -----  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String + String`
  |                               |
  |                               required by a bound introduced by this call
  |
  = help: the trait `Add<String>` is not implemented for `String`
          but trait `Add<&str>` is implemented for it
  = help: for that trait implementation, expected `&str`, found `String`
note: required by a bound in `shout`
 --> /tmp/.tmpzkm4CI/main.rs:1:679
  |
1 | ...") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std ::...
  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `shout`

error[E0277]: cannot multiply `String` by `String`
 --> /tmp/.tmpzkm4CI/main.rs:1:1029
  |
1 | ...ng ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , us...
  |                               -----  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String * String`
  |                               |
  |                               required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `String`
note: required by a bound in `shout`
 --> /tmp/.tmpzkm4CI/main.rs:1:714
  |
1 | ...td :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : ...
  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `shout`

error[E0382]: use of moved value: `x`
   --> /tmp/.tmpzkm4CI/main.rs:1:198
    |
1   | ...: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output...
    |                              -               ----^
    |                              |               |   |
    |                              |               |   value used here after move
    |                              |               `x` moved due to usage in operator
    |                              move occurs because `x` has type `T`, which does not implement the `Copy` trait
    |
note: calling this operator moves the left-hand side
   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/arith.rs:333:12
    |
333 |     fn mul(self, rhs: Rhs) -> Self::Output;
    |            ^^^^
help: consider cloning the value if the performance cost is acceptable
    |
1   | use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x.clone() * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{}" , excited) } } } }
    |                                                                                                                                                                                                   ++++++++
help: consider further restricting type parameter `T` with trait `Copy`
    |
1   | use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + Copy > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{}" , excited) } } } }
    |                                                                                                                                                                               ++++++

error: aborting due to 11 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0382.
For more information about an error, try `rustc --explain E0277`.



=== ch03-00-functions example 6 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpcW3ty1/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpcW3ty1/main.rs:1:198
  |
1 | ...y + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T...
  |                                                          ^^                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { number % 2i32 == 0i32 } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpcW3ty1/main.rs:1:391
  |
1 | ... { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } ...
  |       ^^                                                                                                                                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpcW3ty1/main.rs:1:413
  |
1 | ...mt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { "A" } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpcW3ty1/main.rs:1:450
  |
1 | ...T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { "B" } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpcW3ty1/main.rs:1:487
  |
1 | ...lse { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } }...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { "C" } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpcW3ty1/main.rs:1:524
  |
1 | ...lse { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: op...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { "D" } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpcW3ty1/main.rs:1:541
  |
1 | ... 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { "F" } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpcW3ty1/main.rs:1:725
  |
1 | ... { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } ...
  |       ^^                                                                                                                                                                                                                                                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpcW3ty1/main.rs:1:761
  |
1 | ... + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "la...
  |                                                                  ^^      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { "even" } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpcW3ty1/main.rs:1:781
  |
1 | ...> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "s...
  |                                                                  ^^     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { "odd" } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpcW3ty1/main.rs:1:828
  |
1 | ...n" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" ...
  |                                                                 ^^       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { "large" } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpcW3ty1/main.rs:1:849
  |
1 | ... } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , ...
  |                                                                 ^^       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { "small" } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

error[E0369]: cannot calculate the remainder of `T` divided by `i32`
 --> /tmp/.tmpcW3ty1/main.rs:1:207
  |
1 | ...lay + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output =...
  |                                                              ------ ^ ---- i32
  |                                                              |
  |                                                              T
  |
help: consider further restricting type parameter `T` with trait `Rem`
  |
1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Rem<i32> > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |                                                                                                                                                                                ++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpcW3ty1/main.rs:1:200
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } ...
  |       -                                                                                                                                               -     ^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `bool`
  |       |                                                                                                                                               |
  |       expected this type parameter                                                                                                                    expected `T` because of return type
  |
  = note: expected type parameter `T`
                       found type `bool`
  = note: the caller chooses a type for `T` which can be different from `bool`

error[E0369]: binary operation `>=` cannot be applied to type `T`
 --> /tmp/.tmpcW3ty1/main.rs:1:402
  |
1 | ...y + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if sc...
  |                                                              ----- ^^ ----- i32
  |                                                              |
  |                                                              T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                  +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpcW3ty1/main.rs:1:415
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } ...
  |       -                                                                                                                                              -                           ^^^ expected type parameter `T`, found `&str`
  |       |                                                                                                                                              |
  |       expected this type parameter                                                                                                                   expected `T` because of return type
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0369]: binary operation `>=` cannot be applied to type `T`
 --> /tmp/.tmpcW3ty1/main.rs:1:439
  |
1 | ...ore : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if sc...
  |                                                              ----- ^^ ----- i32
  |                                                              |
  |                                                              T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                  +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpcW3ty1/main.rs:1:452
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } ...
  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                            ^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0369]: binary operation `>=` cannot be applied to type `T`
 --> /tmp/.tmpcW3ty1/main.rs:1:476
  |
1 | ... { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F"...
  |                                                              ----- ^^ ----- i32
  |                                                              |
  |                                                              T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                  +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpcW3ty1/main.rs:1:489
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } ...
  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                                                                 ^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0369]: binary operation `>=` cannot be applied to type `T`
 --> /tmp/.tmpcW3ty1/main.rs:1:513
  |
1 | ... { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T...
  |                                                              ----- ^^ ----- i32
  |                                                              |
  |                                                              T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                  +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpcW3ty1/main.rs:1:526
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } ...
  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                                                                                                      ^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0308]: mismatched types
 --> /tmp/.tmpcW3ty1/main.rs:1:543
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } ...
  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                                                                                                                       ^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0308]: mismatched types
 --> /tmp/.tmpcW3ty1/main.rs:1:756
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) {...
  |       -                                                                                                                                                                    -------  ^ expected `bool`, found type parameter `T`
  |       |                                                                                                                                                                    |
  |       found this type parameter                                                                                                                                            arguments to this function are incorrect
  |
  = note:        expected type `bool`
          found type parameter `T`
help: the return type of this call is `T` due to the type of the argument passed
 --> /tmp/.tmpcW3ty1/main.rs:1:747
  |
1 | ... : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else...
  |                                       ^^^^^^^^^-^
  |                                                |
  |                                                this argument influences the return type of `is_even`
note: function defined here
 --> /tmp/.tmpcW3ty1/main.rs:1:40
  |
1 | ...fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -...
  |       ^^^^^^^                                                                                                                                    ----------

error[E0277]: cannot add `bool` to `bool`
 --> /tmp/.tmpcW3ty1/main.rs:1:756
  |
1 | ...e > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } ...
  |                                             -------  ^ no implementation for `bool + bool`
  |                                             |
  |                                             required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `bool`
note: required by a bound in `is_even`
 --> /tmp/.tmpcW3ty1/main.rs:1:54
  |
1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: ...
  |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_even`

error[E0277]: cannot multiply `bool` by `bool`
 --> /tmp/.tmpcW3ty1/main.rs:1:756
  |
1 | ...e > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } ...
  |                                             -------  ^ no implementation for `bool * bool`
  |                                             |
  |                                             required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `bool`
note: required by a bound in `is_even`
 --> /tmp/.tmpcW3ty1/main.rs:1:89
  |
1 | ...d :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T)...
  |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_even`

error[E0369]: binary operation `>` cannot be applied to type `T`
 --> /tmp/.tmpcW3ty1/main.rs:1:817
  |
1 | ...(n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , forma...
  |                                                                - ^ ------ i32
  |                                                                |
  |                                                                T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpcW3ty1/main.rs:1:865
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } ...
  |       - expected this type parameter                                                                                                             - expected `T` because of return type                                                                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `String`
  |
  = note: expected type parameter `T`
                     found struct `String`
  = note: the caller chooses a type for `T` which can be different from `String`
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 16 previous errors; 13 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0369.
For more information about an error, try `rustc --explain E0277`.



=== ch03-00-functions example 7 ===
✗ Compilation failed: Compilation failed:
error: argument never used
 --> /tmp/.tmp4wLEIG/main.rs:1:1194
  |
1 | ...le" . to_string () ; println ! ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scor...
  |                                    ---------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
  |                                    |
  |                                    formatting specifier missing

error: argument never used
 --> /tmp/.tmp4wLEIG/main.rs:1:1259
  |
1 | ...total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
  |                                        ----------------   ^^^^^^^^^^^^^^^^^^^^^^ argument never used
  |                                        |
  |                                        formatting specifier missing

error: argument never used
 --> /tmp/.tmp4wLEIG/main.rs:1:1312
  |
1 | ..., find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
  |                                           -------------   ^^^^^^^^^^^^^^^^^^^ argument never used
  |                                           |
  |                                           formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp4wLEIG/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std ::...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp4wLEIG/main.rs:1:642
  |
1 | ... . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words...
  |                                                      ^^                              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" . to_string () ; println ! ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
1 + use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { max_val = numbers [i as usize] } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" . to_string () ; println ! ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp4wLEIG/main.rs:1:875
  |
1 | ...t :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = ...
  |                                           ^^                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" . to_string () ; println ! ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
1 + use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { let words = text . split (" ") ; words . len () } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" . to_string () ; println ! ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp4wLEIG/main.rs:1:946
  |
1 | ... { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" . to_string () ; println ! ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" . to_string () ; println ! ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
1 + use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" . to_string () ; println ! ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } }
  |

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmp4wLEIG/main.rs:1:269
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                                   ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" . to_string () ; println ! ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
  |                                                                                                                                                                                        +++++++++++++++++++

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmp4wLEIG/main.rs:1:303
  |
1 | ... 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops ...
  |                                                                 ^^^^^^^^^^^^

error[E0308]: mismatched types
 --> /tmp/.tmp4wLEIG/main.rs:1:337
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } ...
  |       - expected this type parameter                                                                                                                  - expected `T` because of return type                                                                                                  ^^^^^ expected type parameter `T`, found `f64`
  |
  = note: expected type parameter `T`
                       found type `f64`
  = note: the caller chooses a type for `T` which can be different from `f64`

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmp4wLEIG/main.rs:1:538
  |
1 | ...+ Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numb...
  |                                                               ^^^^^^^^^^^^^^^

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmp4wLEIG/main.rs:1:595
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                                                          ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (numbers : T) -> T { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" . to_string () ; println ! ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       +++++++++++++++++++

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmp4wLEIG/main.rs:1:617
  |
1 | ...let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1...
  |                                                                 ^^^^^^^^^^^^

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmp4wLEIG/main.rs:1:662
  |
1 | ... { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : st...
  |                                                                 ^^^^^^^^^^^^

error[E0599]: no method named `split` found for type parameter `T` in the current scope
 --> /tmp/.tmp4wLEIG/main.rs:1:898
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split ("...
  |       - method `split` not found for this type parameter                                                                                                                       ^^^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `split`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + BufRead > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" . to_string () ; println ! ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       +++++++++

error[E0277]: cannot add `Vec<f64>` to `Vec<f64>`
 --> /tmp/.tmp4wLEIG/main.rs:1:1211
  |
1 | ... println ! ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("W...
  |                                  ---------------  ^^^^^^^^^^^^^ no implementation for `Vec<f64> + Vec<f64>`
  |                                  |
  |                                  required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `Vec<f64>`
note: required by a bound in `calculate_total`
 --> /tmp/.tmp4wLEIG/main.rs:1:62
  |
1 | ...p ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt ...
  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `calculate_total`

error[E0277]: cannot multiply `Vec<f64>` by `Vec<f64>`
 --> /tmp/.tmp4wLEIG/main.rs:1:1211
  |
1 | ... println ! ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("W...
  |                                  ---------------  ^^^^^^^^^^^^^ no implementation for `Vec<f64> * Vec<f64>`
  |                                  |
  |                                  required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `Vec<f64>`
note: required by a bound in `calculate_total`
 --> /tmp/.tmp4wLEIG/main.rs:1:97
  |
1 | ... ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> ...
  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `calculate_total`

error[E0277]: `Vec<f64>` doesn't implement `std::fmt::Display`
 --> /tmp/.tmp4wLEIG/main.rs:1:1211
  |
1 | ... ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:...
  |                        ---------------  ^^^^^^^^^^^^^ the trait `std::fmt::Display` is not implemented for `Vec<f64>`
  |                        |
  |                        required by a bound introduced by this call
  |
note: required by a bound in `calculate_total`
 --> /tmp/.tmp4wLEIG/main.rs:1:132
  |
1 | ...td :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; l...
  |                                      ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `calculate_total`

error[E0277]: cannot add `Vec<i32>` to `Vec<i32>`
 --> /tmp/.tmp4wLEIG/main.rs:1:1269
  |
1 | ...) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
  |                                      --------  ^^^^^^^^^^^ no implementation for `Vec<i32> + Vec<i32>`
  |                                      |
  |                                      required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `Vec<i32>`
note: required by a bound in `find_max`
 --> /tmp/.tmp4wLEIG/main.rs:1:365
  |
1 | ...} ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: f...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`

error[E0277]: cannot multiply `Vec<i32>` by `Vec<i32>`
 --> /tmp/.tmp4wLEIG/main.rs:1:1269
  |
1 | ...) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
  |                                      --------  ^^^^^^^^^^^ no implementation for `Vec<i32> * Vec<i32>`
  |                                      |
  |                                      required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `Vec<i32>`
note: required by a bound in `find_max`
 --> /tmp/.tmp4wLEIG/main.rs:1:400
  |
1 | ... :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T)...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`

error[E0277]: `Vec<i32>` doesn't implement `std::fmt::Display`
 --> /tmp/.tmp4wLEIG/main.rs:1:1269
  |
1 | ...n ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
  |                            --------  ^^^^^^^^^^^ the trait `std::fmt::Display` is not implemented for `Vec<i32>`
  |                            |
  |                            required by a bound introduced by this call
  |
note: required by a bound in `find_max`
 --> /tmp/.tmp4wLEIG/main.rs:1:435
  |
1 | ... + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = n...
  |                                          ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`

error[E0277]: cannot add `String` to `String`
 --> /tmp/.tmp4wLEIG/main.rs:1:1325
  |
1 | ...scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
  |                                          -----------  ^^^^^ no implementation for `String + String`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Add<String>` is not implemented for `String`
          but trait `Add<&str>` is implemented for it
  = help: for that trait implementation, expected `&str`, found `String`
note: required by a bound in `count_words`
 --> /tmp/.tmp4wLEIG/main.rs:1:733
  |
1 | ...x_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fm...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `count_words`

error[E0277]: cannot multiply `String` by `String`
 --> /tmp/.tmp4wLEIG/main.rs:1:1325
  |
1 | ...scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
  |                                          -----------  ^^^^^ no implementation for `String * String`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `String`
note: required by a bound in `count_words`
 --> /tmp/.tmp4wLEIG/main.rs:1:768
  |
1 | ...:: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> ...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `count_words`

error: aborting due to 19 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0599, E0608.
For more information about an error, try `rustc --explain E0277`.



=== ch03-00-functions example 9 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpY4rrih/main.rs:1:374
  |
1 | ...t msg = greet ("Alice" . to_string ()) } }
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpY4rrih/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn greet < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Di...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpY4rrih/main.rs:1:204
  |
1 | ... T) -> T { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") + age , " years old") } } fn main (...
  |               ^^                                                                                                           ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn greet < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , age : T) -> T { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") + age , " years old") } } fn main () { { let msg = greet ("Alice" . to_string ()) } }
1 + use std :: collections :: HashMap ; fn greet < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , age : T) -> T { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") + age , " years old") } fn main () { { let msg = greet ("Alice" . to_string ()) } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpY4rrih/main.rs:1:294
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , age : T) -> T { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") + age , ...
  |       - found this type parameter                                                                                                                                                                                                                           ^^^ expected `&str`, found type parameter `T`
  |
  = note:   expected reference `&str`
          found type parameter `T`

error[E0308]: mismatched types
 --> /tmp/.tmpY4rrih/main.rs:1:206
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , age : T) -> T { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") + age , " years old") } ...
  |       -                                                                                                                                                       -     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `String`
  |       |                                                                                                                                                       |
  |       expected this type parameter                                                                                                                            expected `T` because of return type
  |
  = note: expected type parameter `T`
                     found struct `String`
  = note: the caller chooses a type for `T` which can be different from `String`
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 3 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 10 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpqKA1Oz/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn bad_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fm...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpqKA1Oz/main.rs:1:383
  |
1 | ... + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; result } } } fn main () { { println ! ("{}" , good_functio...
  |                                                    ^^                                  ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn bad_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; x } } fn good_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; result } } } fn main () { { println ! ("{}" , good_function (5i32)) } }
1 + use std :: collections :: HashMap ; fn bad_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; x } } fn good_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { let result = x + 1i32 ; result } } fn main () { { println ! ("{}" , good_function (5i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpqKA1Oz/main.rs:1:437
  |
1 | ...esult = x + 1i32 ; result } } } fn main () { { println ! ("{}" , good_function (5i32)) } }
  |                                                 ^^                                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn bad_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; x } } fn good_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; result } } } fn main () { { println ! ("{}" , good_function (5i32)) } }
1 + use std :: collections :: HashMap ; fn bad_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; x } } fn good_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; result } } } fn main () { println ! ("{}" , good_function (5i32)) }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpqKA1Oz/main.rs:1:208
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; ...
  |       -                                                                                                                                                    -   ^^^^ expected type parameter `T`, found `i32`
  |       |                                                                                                                                                    |
  |       expected this type parameter                                                                                                                         expected because this is `T`
  |
  = note: expected type parameter `T`
                       found type `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpqKA1Oz/main.rs:1:404
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; ...
  |       -                                                                                                                                                               -   ^^^^ expected type parameter `T`, found `i32`
  |       |                                                                                                                                                               |
  |       expected this type parameter                                                                                                                                    expected because this is `T`
  |
  = note: expected type parameter `T`
                       found type `i32`

error: aborting due to 2 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 12 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp7CDZwT/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp7CDZwT/main.rs:1:213
  |
1 | ...td :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Outpu...
  |                                                      ^^                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { celsius * 9i32 / 5i32 + 32i32 } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7CDZwT/main.rs:1:434
  |
1 | ... + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Out...
  |                                                     ^^                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { weight_kg / height_m * height_m } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7CDZwT/main.rs:1:662
  |
1 | ...discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ...
  |                                 ^^                                                                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { let discount = price * discount_percent / 100i32 ; price - discount } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7CDZwT/main.rs:1:902
  |
1 | ...t :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: A...
  |                                           ^^                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { let words = text . split (" ") ; words . len () } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7CDZwT/main.rs:1:1129
  |
1 | ... { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } ...
  |       ^^                                                                                                                                                                                                                                                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7CDZwT/main.rs:1:1258
  |
1 | ...ords . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } }...
  |                    ^^                                                                                                 ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7CDZwT/main.rs:1:1580
  |
1 | ... { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } ...
  |       ^^                                                                                                                                                                                                                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7CDZwT/main.rs:1:1633
  |
1 | ...f energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time...
  |                                                      ^^                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { "Go for a run or hit the gym!" } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7CDZwT/main.rs:1:1728
  |
1 | ... if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn ...
  |                                                        ^^                         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { "Perfect time for a walk" } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7CDZwT/main.rs:1:1767
  |
1 | ...e > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to...
  |                                                       ^^                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { "Maybe just relax and read" } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp7CDZwT/main.rs:1:225
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / ...
  |       -                                                                                                                                                      -------   ^^^^ expected type parameter `T`, found `i32`
  |       |                                                                                                                                                      |
  |       expected this type parameter                                                                                                                           expected because this is `T`
  |
  = note: expected type parameter `T`
                       found type `i32`

error[E0369]: cannot divide `T` by `i32`
 --> /tmp/.tmp7CDZwT/main.rs:1:230
  |
1 | ... std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Out...
  |                                                          -------------- ^ ---- i32
  |                                                          |
  |                                                          T
  |
help: consider further restricting type parameter `T` with trait `Div`
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Div<i32> > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                              ++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmp7CDZwT/main.rs:1:239
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } ...
  |       - expected this type parameter                                                                                                                                                 ^^^^^ expected type parameter `T`, found `i32`
  |
  = note: expected type parameter `T`
                       found type `i32`

error[E0369]: cannot divide `T` by `T`
 --> /tmp/.tmp7CDZwT/main.rs:1:446
  |
1 | ...Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add ...
  |                                                            --------- ^ -------- T
  |                                                            |
  |                                                            T
  |
help: consider further restricting type parameter `T` with trait `Div`
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Div > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++

error[E0369]: cannot divide `T` by `i32`
 --> /tmp/.tmp7CDZwT/main.rs:1:706
  |
1 | ...discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ...
  |                                                    ------------------------ ^ ------ i32
  |                                                    |
  |                                                    T
  |
help: consider further restricting type parameter `T` with trait `Div`
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Div<i32> > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ++++++++++++++++++++

error[E0599]: no method named `split` found for type parameter `T` in the current scope
 --> /tmp/.tmp7CDZwT/main.rs:1:925
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split ("...
  |       - method `split` not found for this type parameter                                                                                                                       ^^^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `split`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + BufRead > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  +++++++++

error[E0599]: no method named `split` found for type parameter `T` in the current scope
 --> /tmp/.tmp7CDZwT/main.rs:1:1157
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split ("...
  |       - method `split` not found for this type parameter                                                                                                                                 ^^^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `split`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + BufRead > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                +++++++++

error[E0308]: mismatched types
 --> /tmp/.tmp7CDZwT/main.rs:1:1364
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } ...
  |       - expected this type parameter                                                                                                                     - expected `T` because of return type                                                                                                                                                                                                          ^^^^^^^^ expected type parameter `T`, found `String`
  |
  = note: expected type parameter `T`
                     found struct `String`
  = note: the caller chooses a type for `T` which can be different from `String`

error[E0369]: binary operation `>` cannot be applied to type `T`
 --> /tmp/.tmp7CDZwT/main.rs:1:1598
  |
1 | ... > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!...
  |                                                           ------------ ^ ---- i32
  |                                                           |
  |                                                           T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           +++++++++++++++++++++++++++

error[E0369]: binary operation `>` cannot be applied to type `T`
 --> /tmp/.tmp7CDZwT/main.rs:1:1623
  |
1 | ...vailable_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_l...
  |                                                          -------------- ^ ----- i32
  |                                                          |
  |                                                          T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmp7CDZwT/main.rs:1:1635
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } ...
  |       - expected this type parameter                                                                                                                                             - expected `T` because of return type                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0369]: binary operation `>` cannot be applied to type `T`
 --> /tmp/.tmp7CDZwT/main.rs:1:1693
  |
1 | ...60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } }...
  |                                                           ------------ ^ ---- i32
  |                                                           |
  |                                                           T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           +++++++++++++++++++++++++++

error[E0369]: binary operation `>` cannot be applied to type `T`
 --> /tmp/.tmp7CDZwT/main.rs:1:1718
  |
1 | ...or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just re...
  |                                                          -------------- ^ ----- i32
  |                                                          |
  |                                                          T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmp7CDZwT/main.rs:1:1730
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } ...
  |       - expected this type parameter                                                                                                                                             - expected `T` because of return type                                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0308]: mismatched types
 --> /tmp/.tmp7CDZwT/main.rs:1:1769
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } ...
  |       - expected this type parameter                                                                                                                                             - expected `T` because of return type                                                                                                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0308]: mismatched types
 --> /tmp/.tmp7CDZwT/main.rs:1:1914
  |
1 | ..."{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recomme...
  |           -------------  -----   ^^^^^^^ expected `i32`, found `f64`
  |           |              |
  |           |              expected all arguments to be this `i32` type because they need to match the type of this parameter
  |           arguments to this function are incorrect
  |
help: the return type of this call is `f64` due to the type of the argument passed
 --> /tmp/.tmp7CDZwT/main.rs:1:1891
  |
1 | ...) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ...
  |                          ^^^^^^^^^^^^^^^^^^^^^^^-------^
  |                                                 |
  |                                                 this argument influences the return type of `calculate_bmi`
note: function defined here
 --> /tmp/.tmp7CDZwT/main.rs:1:252
  |
1 | ...fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -...
  |       ^^^^^^^^^^^^^   -                                                                                                                                -------------   ------------ this parameter needs to match the `i32` type of `weight_kg`
  |                       |                                                                                                                                |
  |                       `weight_kg` and `height_m` both reference this parameter `T`                                                                     `height_m` needs to match the `i32` type of this parameter
help: change the type of the numeric literal from `f64` to `i32`
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1i32)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

error[E0277]: cannot add `String` to `String`
 --> /tmp/.tmp7CDZwT/main.rs:1:1958
  |
1 | ...64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                             ------------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String + String`
  |                             |
  |                             required by a bound introduced by this call
  |
  = help: the trait `Add<String>` is not implemented for `String`
          but trait `Add<&str>` is implemented for it
  = help: for that trait implementation, expected `&str`, found `String`
note: required by a bound in `get_initials`
 --> /tmp/.tmp7CDZwT/main.rs:1:982
  |
1 | ...) } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `get_initials`

error[E0277]: cannot multiply `String` by `String`
 --> /tmp/.tmp7CDZwT/main.rs:1:1958
  |
1 | ...64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                             ------------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String * String`
  |                             |
  |                             required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `String`
note: required by a bound in `get_initials`
 --> /tmp/.tmp7CDZwT/main.rs:1:1017
  |
1 | ...: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T)...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `get_initials`

error: aborting due to 18 previous errors; 11 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0369, E0599.
For more information about an error, try `rustc --explain E0277`.


