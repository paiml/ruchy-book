=== ch02-00-variables-types-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found `let` statement
 --> /tmp/.tmp9zI1aI/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let mut result = value1 + value2 ; if let Some (s) = (& result as & dyn std...
  |                                                               ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

error[E0425]: cannot find value `value1` in this scope
 --> /tmp/.tmp9zI1aI/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let mut result = value1 + value2 ; if let Some (s) = (& result as & dyn std...
  |                                                                                ^^^^^^ not found in this scope

error[E0425]: cannot find value `value2` in this scope
 --> /tmp/.tmp9zI1aI/main.rs:1:89
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let mut result = value1 + value2 ; if let Some (s) = (& result as & dyn std...
  |                                                                                         ^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp9zI1aI/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let mut result = value1 + value2 ; if let Some (s) = (& result as & dyn std...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 3 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch02-00-variables-types-tdd example 7 ===
✗ Compilation failed: Compilation failed:
error: expected one of `!`, `.`, `::`, `;`, `?`, `else`, `{`, or an operator, found `}`
 --> /tmp/.tmpDK3oTN/main.rs:1:182
  |
1 | ...ustment ; let mut final_result = step2 / divisor } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < Strin...
  |                                                     ^ expected one of 8 possible tokens

error[E0425]: cannot find value `initial_value` in this scope
 --> /tmp/.tmpDK3oTN/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut step1 = initial_value * factor ; let mut step2 = step1 + adjustme...
  |                                                                                 ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `factor` in this scope
 --> /tmp/.tmpDK3oTN/main.rs:1:97
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut step1 = initial_value * factor ; let mut step2 = step1 + adjustme...
  |                                                                                                 ^^^^^^ not found in this scope

error[E0425]: cannot find value `adjustment` in this scope
 --> /tmp/.tmpDK3oTN/main.rs:1:130
  |
1 | ... initial_value * factor ; let mut step2 = step1 + adjustment ; let mut final_result = step2 / divisor } ; if let Some (s) = (& result ...
  |                                                      ^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpDK3oTN/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut step1 = initial_value * factor ; let mut step2 = step1 + adjustme...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 4 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch02-00-variables-types-tdd example 8 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpchxw0d/main.rs:1:117
  |
1 | ...3.14159f64 ; let mut GRAVITY = 9.81f64 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpchxw0d/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut PI = 3.14159f64 ; let mut GRAVITY = 9.81f64 } ; if let Some (s) =...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch10-00-performance-optimization example 1 ===
✗ Compilation failed: Compilation failed:
error[E0432]: unresolved import `std::perf`
 --> /tmp/.tmpTzRM96/main.rs:1:739
  |
1 | ...eturn lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32)...
  |                                                      ^^^^^^^^^^^ no `perf` in the root

error[E0432]: unresolved import `std::parallel`
 --> /tmp/.tmpTzRM96/main.rs:1:759
  |
1 | ... } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = ...
  |                                                  ^^^^^^^^^^^^^^^ no `parallel` in the root

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpTzRM96/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpTzRM96/main.rs:1:84
  |
1 | ... { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } ...
  |       ^^                                                                                                                                                                                                                                                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTzRM96/main.rs:1:134
  |
1 | ... { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ...
  |       ^^                                                                                                                                                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTzRM96/main.rs:1:211
  |
1 | ...; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed...
  |                                  ^^                                                                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { if similar (processed , existing) { { processed . merge (existing) } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTzRM96/main.rs:1:249
  |
1 | ...in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; retur...
  |                                                       ^^                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { processed . merge (existing) } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTzRM96/main.rs:1:401
  |
1 | ... { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTzRM96/main.rs:1:532
  |
1 | ... { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ...
  |       ^^                                                                                                                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTzRM96/main.rs:1:595
  |
1 | ...em . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } ...
  |                                                   ^^                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { lookup [key as usize] . merge (item) } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTzRM96/main.rs:1:645
  |
1 | ... { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn mai...
  |                                                       ^^                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { lookup [key as usize] = item } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpTzRM96/main.rs:1:753
  |
1 | ... . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut n...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpTzRM96/main.rs:1:777
  |
1 | ...main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: meas...
  |                                                        ^ help: remove this semicolon

error[E0277]: `String` is not an iterator
 --> /tmp/.tmpTzRM96/main.rs:1:127
  |
1 | ...ults = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (proc...
  |                                    ^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`
  |
  = help: the trait `Iterator` is not implemented for `String`
  = note: required for `String` to implement `IntoIterator`

error[E0425]: cannot find function `expensive_transform` in this scope
 --> /tmp/.tmpTzRM96/main.rs:1:154
  |
1 | ...] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existi...
  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `similar` in this scope
 --> /tmp/.tmpTzRM96/main.rs:1:216
  |
1 | ...ransform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results ....
  |                                                       ^^^^^^^ not found in this scope

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `parallel`
 --> /tmp/.tmpTzRM96/main.rs:1:419
  |
1 | ... String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for ite...
  |                                        ^^^^^^^^ use of unresolved module or unlinked crate `parallel`
  |
  = help: you might be missing a crate named `parallel`

error[E0425]: cannot find function `expensive_transform` in this scope
 --> /tmp/.tmpTzRM96/main.rs:1:454
  |
1 | ...results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key...
  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `has_key` found for unit type `()` in the current scope
 --> /tmp/.tmpTzRM96/main.rs:1:579
  |
1 | ...s { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as ...
  |                                                       ^^^^^^^ method not found in `()`

error[E0599]: no method named `values` found for unit type `()` in the current scope
 --> /tmp/.tmpTzRM96/main.rs:1:704
  |
1 | ... [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut ...
  |                                                       ^^^^^^ method not found in `()`

error[E0425]: cannot find function `generate_test_data` in this scope
 --> /tmp/.tmpTzRM96/main.rs:1:794
  |
1 | ...rf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_na...
  |                                                  ^^^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 10 previous errors; 11 warnings emitted

Some errors have detailed explanations: E0277, E0425, E0432, E0433, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch10-00-performance-optimization example 2 ===

thread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:
"perf::CpuProfiler" is not a valid Ident
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


=== ch10-00-performance-optimization example 3 ===
✗ Compilation failed: Compilation failed:
error[E0432]: unresolved import `std::bench`
 --> /tmp/.tmp5pUKmn/main.rs:1:446
  |
1 | ...ms" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite ("String Operations" . to_string () , { let mut map :...
  |                                                     ^^^^^^^^^^^^ no `bench` in the root

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmp5pUKmn/main.rs:1:155
  |
1 | ...ing) -> i32 { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmp5pUKmn/main.rs:1:199
  |
1 | ...or i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmp5pUKmn/main.rs:1:718
  |
1 | ...g () , (|| { { let s = "" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ("str...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmp5pUKmn/main.rs:1:889
  |
1 | ... let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } ...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmp5pUKmn/main.rs:1:1038
  |
1 | ...g ()) ; map . insert ("join" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () ....
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp5pUKmn/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) -> i32 { { { let times = vec !...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp5pUKmn/main.rs:1:117
  |
1 | ... { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let mut avg = times . mean () ; let mut std = times . std_dev () ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg , std) } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) -> i32 { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let mut avg = times . mean () ; let mut std = times . std_dev () ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite ("String Operations" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("concatenation" . to_string () , (|| { { let s = "" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ("string builder" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert ("join" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join ("") }) . to_string ()) ; map }) ; }
1 + use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) -> i32 { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let mut avg = times . mean () ; let mut std = times . std_dev () ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg , std) } } } fn main () { use std :: bench ; ; bench :: suite ("String Operations" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("concatenation" . to_string () , (|| { { let s = "" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ("string builder" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert ("join" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join ("") }) . to_string ()) ; map }) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp5pUKmn/main.rs:1:170
  |
1 | ...i32 { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measur...
  |                                                               ^^           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) -> i32 { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let mut avg = times . mean () ; let mut std = times . std_dev () ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite ("String Operations" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("concatenation" . to_string () , (|| { { let s = "" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ("string builder" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert ("join" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join ("") }) . to_string ()) ; map }) ; }
1 + use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) -> i32 { { { let times = vec ! [] ; { for i in range (5i32) { func (data) } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let mut avg = times . mean () ; let mut std = times . std_dev () ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite ("String Operations" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("concatenation" . to_string () , (|| { { let s = "" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ("string builder" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert ("join" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join ("") }) . to_string ()) ; map }) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp5pUKmn/main.rs:1:216
  |
1 | ...; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let mut avg = times . m...
  |                                ^^                                                                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) -> i32 { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let mut avg = times . mean () ; let mut std = times . std_dev () ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite ("String Operations" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("concatenation" . to_string () , (|| { { let s = "" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ("string builder" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert ("join" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join ("") }) . to_string ()) ; map }) ; }
1 + use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) -> i32 { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } ; let mut avg = times . mean () ; let mut std = times . std_dev () ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite ("String Operations" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("concatenation" . to_string () , (|| { { let s = "" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ("string builder" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert ("join" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join ("") }) . to_string ()) ; map }) ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmp5pUKmn/main.rs:1:461
  |
1 | ... avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite ("String Operations" . to_string () , { let mut map : std :: coll...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp5pUKmn/main.rs:1:736
  |
1 | ...{ let s = "" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ("string builder" ...
  |                                                             ^^                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) -> i32 { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let mut avg = times . mean () ; let mut std = times . std_dev () ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite ("String Operations" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("concatenation" . to_string () , (|| { { let s = "" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ("string builder" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert ("join" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join ("") }) . to_string ()) ; map }) ; }
1 + use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) -> i32 { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let mut avg = times . mean () ; let mut std = times . std_dev () ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite ("String Operations" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("concatenation" . to_string () , (|| { { let s = "" . to_string () ; for i in range (1000i32) { s += i . to_s () } } }) . to_string ()) ; map . insert ("string builder" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert ("join" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join ("") }) . to_string ()) ; map }) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp5pUKmn/main.rs:1:907
  |
1 | ...gBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ())...
  |                                                      ^^                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) -> i32 { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let mut avg = times . mean () ; let mut std = times . std_dev () ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite ("String Operations" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("concatenation" . to_string () , (|| { { let s = "" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ("string builder" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert ("join" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join ("") }) . to_string ()) ; map }) ; }
1 + use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) -> i32 { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let mut avg = times . mean () ; let mut std = times . std_dev () ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite ("String Operations" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("concatenation" . to_string () , (|| { { let s = "" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ("string builder" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { builder . append (i . to_s ()) } ; builder . to_string () } } }) . to_string ()) ; map . insert ("join" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join ("") }) . to_string ()) ; map }) ; }
  |

error[E0618]: expected function, found `String`
 --> /tmp/.tmp5pUKmn/main.rs:1:172
  |
1 | ...: String , func : String , data : String) -> i32 { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in r...
  |               ----                                                                                           ^^^^-------
  |               |                                                                                              |
  |               `func` has type `String`                                                                       call expression requires function

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `perf`
 --> /tmp/.tmp5pUKmn/main.rs:1:231
  |
1 | ...or i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let mut avg = times . mean...
  |                                            ^^^^ use of unresolved module or unlinked crate `perf`
  |
  = help: you might be missing a crate named `perf`

error[E0618]: expected function, found `String`
 --> /tmp/.tmp5pUKmn/main.rs:1:253
  |
1 | ... , func : String , data : String) -> i32 { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ...
  |       ----                                                                                                                                                                            ^^^^-------
  |       |                                                                                                                                                                               |
  |       `func` has type `String`                                                                                                                                                        call expression requires function

error[E0308]: mismatched types
 --> /tmp/.tmp5pUKmn/main.rs:1:366
  |
1 | ...td = times . std_dev () ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: su...
  |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: `{closure@/tmp/.tmp5pUKmn/main.rs:1:674: 1:676}` doesn't implement `std::fmt::Display`
 --> /tmp/.tmp5pUKmn/main.rs:1:766
  |
1 | ...string () , (|| { { let s = "" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ...
  |                 -- doesn't satisfy `_: Display` or `_: ToString`                                            ^^^^^^^^^ method cannot be called on `{closure@/tmp/.tmp5pUKmn/main.rs:1:674: 1:676}` due to unsatisfied trait bounds
  |
  = note: the following trait bounds were not satisfied:
          `{closure@/tmp/.tmp5pUKmn/main.rs:1:674: 1:676}: std::fmt::Display`
          which is required by `{closure@/tmp/.tmp5pUKmn/main.rs:1:674: 1:676}: ToString`

error[E0433]: failed to resolve: use of undeclared type `StringBuilder`
 --> /tmp/.tmp5pUKmn/main.rs:1:852
  |
1 | ..." . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ;...
  |                                             ^^^^^^^^^^^^^ use of undeclared type `StringBuilder`

error: aborting due to 12 previous errors; 7 warnings emitted

Some errors have detailed explanations: E0308, E0425, E0432, E0433, E0599, E0618.
For more information about an error, try `rustc --explain E0308`.



=== ch10-00-performance-optimization example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `fibonacci_cache` in this scope
 --> /tmp/.tmp5ISTsA/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n...
  |                                                                               ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `fibonacci_cache` in this scope
 --> /tmp/.tmp5ISTsA/main.rs:1:120
  |
1 | ... { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibon...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `fibonacci_cache` in this scope
 --> /tmp/.tmp5ISTsA/main.rs:1:264
  |
1 | ...(n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive ...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmp5ISTsA/main.rs:1:420
  |
1 | ...-> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmp5ISTsA/main.rs:1:456
  |
1 | ...[] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] ...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmp5ISTsA/main.rs:1:970
  |
1 | ...rds : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> ...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmp5ISTsA/main.rs:1:1061
  |
1 | ...ve_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predica...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `null` in this scope
 --> /tmp/.tmp5ISTsA/main.rs:1:1243
  |
1 | ...if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::ptr::null;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp5ISTsA/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp5ISTsA/main.rs:1:111
  |
1 | ... -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else ...
  |                                                   ^^                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { return fibonacci_cache [n as usize] } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp5ISTsA/main.rs:1:185
  |
1 | ...ibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32)...
  |                                                                    ^^ ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { n } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp5ISTsA/main.rs:1:200
  |
1 | ...esult = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = r...
  |                                          ^^                                                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp5ISTsA/main.rs:1:377
  |
1 | ... { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } ...
  |       ^^                                                                                                                                                                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp5ISTsA/main.rs:1:445
  |
1 | ... { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ...
  |       ^^                                                                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp5ISTsA/main.rs:1:492
  |
1 | ..., items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return dupl...
  |                        ^^                                                                                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp5ISTsA/main.rs:1:540
  |
1 | ...if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find...
  |                                                  ^^                                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { duplicates . push (items [i as usize]) } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp5ISTsA/main.rs:1:676
  |
1 | ... { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } ...
  |       ^^                                                                                                                                                                                                                 ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp5ISTsA/main.rs:1:796
  |
1 | ... ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_ar...
  |                                                         ^^                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { duplicates . add (item) } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp5ISTsA/main.rs:1:942
  |
1 | ...ds_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records...
  |                                         ^^                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { for record in records { { database . insert (record) } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp5ISTsA/main.rs:1:968
  |
1 | ...ecords : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) ...
  |                                                        ^^                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { database . insert (record) } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp5ISTsA/main.rs:1:1059
  |
1 | ...e_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicat...
  |                                                    ^^                                 ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { database . insert_batch (records) } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp5ISTsA/main.rs:1:1188
  |
1 | ...ate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibo...
  |                                                 ^^                                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { if predicate (item) { { return item } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp5ISTsA/main.rs:1:1212
  |
1 | ...ng) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cach...
  |                                                               ^^           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { return item } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmp5ISTsA/main.rs:1:504
  |
1 | ... (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; ...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmp5ISTsA/main.rs:1:526
  |
1 | ...en ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } ...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmp5ISTsA/main.rs:1:568
  |
1 | ...[j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : ...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0308]: mismatched types
 --> /tmp/.tmp5ISTsA/main.rs:1:602
  |
1 | ...-> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } ...
  |       --- expected `i32` because of return type                                                                                                                                                                                              ^^^^^^^^^^ expected `i32`, found `Vec<_>`
  |
  = note: expected type `i32`
           found struct `Vec<_>`

error[E0433]: failed to resolve: use of undeclared type `Set`
 --> /tmp/.tmp5ISTsA/main.rs:1:691
  |
1 | ...optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if see...
  |                                                       ^^^ use of undeclared type `Set`

error[E0433]: failed to resolve: use of undeclared type `Set`
 --> /tmp/.tmp5ISTsA/main.rs:1:730
  |
1 | ... let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . ad...
  |                                                       ^^^ use of undeclared type `Set`

error[E0277]: `String` is not an iterator
 --> /tmp/.tmp5ISTsA/main.rs:1:758
  |
1 | ... = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return du...
  |                                   ^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`
  |
  = help: the trait `Iterator` is not implemented for `String`
  = note: required for `String` to implement `IntoIterator`

error[E0277]: `String` is not an iterator
 --> /tmp/.tmp5ISTsA/main.rs:1:958
  |
1 | ...ing) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { d...
  |                                  ^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`
  |
  = help: the trait `Iterator` is not implemented for `String`
  = note: required for `String` to implement `IntoIterator`

error[E0308]: mismatched types
 --> /tmp/.tmp5ISTsA/main.rs:1:944
  |
1 | ...records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String)...
  |                         ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |                         |
  |                         expected `i32` because of return type
  |
  = note: `for` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } /* `i32` value */ } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         +++++++++++++++++

error[E0277]: `String` is not an iterator
 --> /tmp/.tmp5ISTsA/main.rs:1:1180
  |
1 | ...String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_...
  |                                   ^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`
  |
  = help: the trait `Iterator` is not implemented for `String`
  = note: required for `String` to implement `IntoIterator`

error[E0618]: expected function, found `String`
 --> /tmp/.tmp5ISTsA/main.rs:1:1193
  |
1 | ...ms : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn ma...
  |                  ---------                                               ^^^^^^^^^-------
  |                  |                                                       |
  |                  `predicate` has type `String`                           call expression requires function

warning: unused variable: `fibonacci_cache`
 --> /tmp/.tmp5ISTsA/main.rs:1:1273
  |
1 | ...n main () { let mut fibonacci_cache = () ; }
  |                        ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_fibonacci_cache`
  |
  = note: `#[warn(unused_variables)]` on by default

warning: variable does not need to be mutable
 --> /tmp/.tmp5ISTsA/main.rs:1:1269
  |
1 | ...turn item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                         ----^^^^^^^^^^^^^^^
  |                                                         |
  |                                                         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

error: aborting due to 19 previous errors; 17 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0425, E0433, E0618.
For more information about an error, try `rustc --explain E0277`.



=== ch10-00-performance-optimization example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 8 ===
✗ Compilation failed: Compilation failed:
error[E0432]: unresolved import `std::db`
 --> /tmp/.tmpglQW3e/main.rs:1:1403
  |
1 | ... []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp"...
  |                                          ^^^^^^^--
  |                                          |      |
  |                                          |      help: a similar name exists in the module: `dbg`
  |                                          no `db` in the root

error[E0432]: unresolved import `std::perf`
 --> /tmp/.tmpglQW3e/main.rs:1:1421
  |
1 | ... unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_...
  |                                                      ^^^^^^^^^^^ no `perf` in the root

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpglQW3e/main.rs:1:90
  |
1 | use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { { let plan = database . explain (sql) ; { println ! ("{:?}" ,...
  |                                                                                          ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpglQW3e/main.rs:1:553
  |
1 | ...ere_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_lo...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpglQW3e/main.rs:1:951
  |
1 | ...users_with_posts_naive () -> i32 { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = d...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpglQW3e/main.rs:1:1033
  |
1 | ...M users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpglQW3e/main.rs:1:1194
  |
1 | ...et_users_with_posts_optimized () -> i32 { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JO...
  |                                                       ^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpglQW3e/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { { let plan = database . explain (sql) ; { println ! ("{:?}" ,...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpglQW3e/main.rs:1:75
  |
1 | ... { { { let plan = database . explain (sql) ; { println ! ("{:?}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{:?}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { { let plan = database . explain (sql) ; { println ! ("{:?}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{:?}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {:.1}x faster" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { let plan = database . explain (sql) ; { println ! ("{:?}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{:?}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {:.1}x faster" , naive_time / optimized_time) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpglQW3e/main.rs:1:667
  |
1 | ... { { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } ...
  |       ^^                                                                                                                                                                                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { { let plan = database . explain (sql) ; { println ! ("{:?}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{:?}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {:.1}x faster" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { { let plan = database . explain (sql) ; { println ! ("{:?}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{:?}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {:.1}x faster" , naive_time / optimized_time) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpglQW3e/main.rs:1:935
  |
1 | ... { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } ...
  |       ^^                                                                                                                                                                                                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { { let plan = database . explain (sql) ; { println ! ("{:?}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{:?}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {:.1}x faster" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { { let plan = database . explain (sql) ; { println ! ("{:?}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{:?}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () -> i32 { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } fn get_users_with_posts_optimized () -> i32 { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {:.1}x faster" , naive_time / optimized_time) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpglQW3e/main.rs:1:1016
  |
1 | ...r user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users }...
  |                      ^^                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { { let plan = database . explain (sql) ; { println ! ("{:?}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{:?}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {:.1}x faster" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { { let plan = database . explain (sql) ; { println ! ("{:?}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{:?}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query ("SELECT * FROM users") ; { for user in users { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {:.1}x faster" , naive_time / optimized_time) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpglQW3e/main.rs:1:1185
  |
1 | ... { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } ...
  |       ^^                                                                                                                                                                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { { let plan = database . explain (sql) ; { println ! ("{:?}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{:?}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {:.1}x faster" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { { let plan = database . explain (sql) ; { println ! ("{:?}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{:?}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {:.1}x faster" , naive_time / optimized_time) ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpglQW3e/main.rs:1:1415
  |
1 | ...(& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myap...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpglQW3e/main.rs:1:1435
  |
1 | ... } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ;...
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `extract_table` in this scope
 --> /tmp/.tmpglQW3e/main.rs:1:373
  |
1 | ...ected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Sugge...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `extract_where` in this scope
 --> /tmp/.tmpglQW3e/main.rs:1:420
  |
1 | ... extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `find_patterns` in this scope
 --> /tmp/.tmpglQW3e/main.rs:1:613
  |
1 | ...et_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && ...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpglQW3e/main.rs:1:641
  |
1 | ...-> i32 { { { let plan = database . explain (sql) ; { println ! ("{:?}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{:?}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } ...
  |       --- expected `i32` because of return type                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `for` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { { let plan = database . explain (sql) ; { println ! ("{:?}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{:?}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } /* `i32` value */ } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {:.1}x faster" , naive_time / optimized_time) ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     +++++++++++++++++

error: aborting due to 11 previous errors; 8 warnings emitted

Some errors have detailed explanations: E0308, E0425, E0432.
For more information about an error, try `rustc --explain E0308`.



=== ch10-00-performance-optimization example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch04-00-modules-tdd example 3 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found keyword `mod`
 --> /tmp/.tmpV0gckT/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod module_name { { pub fn public_function () { () } ; fn private_function ...
  |                                                               ^^^ expected expression

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpV0gckT/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod module_name { { pub fn public_function () { () } ; fn private_function ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch04-00-modules-tdd example 4 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpIlyDWq/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpIlyDWq/main.rs:1:50
  |
1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }
  |                                                  ^^                                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }
1 + use std :: collections :: HashMap ; fn main () { module_name :: public_function () }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `module_name`
 --> /tmp/.tmpIlyDWq/main.rs:1:52
  |
1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }
  |                                                    ^^^^^^^^^^^ use of unresolved module or unlinked crate `module_name`
  |
  = help: you might be missing a crate named `module_name`

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0433`.



=== ch04-00-modules-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found keyword `mod`
 --> /tmp/.tmp8I8HkZ/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod math { { pub fn add (a : i32 , b : i32) -> i32 { { a + b } } ; pub fn s...
  |                                                               ^^^ expected expression

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp8I8HkZ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod math { { pub fn add (a : i32 , b : i32) -> i32 { { a + b } } ; pub fn s...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch04-00-modules-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found keyword `mod`
 --> /tmp/.tmpfg7ql9/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod strings { { pub fn greet () { { println ! ("Hello!") } } ; pub fn farew...
  |                                                               ^^^ expected expression

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpfg7ql9/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod strings { { pub fn greet () { { println ! ("Hello!") } } ; pub fn farew...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch09-00-collections-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `start` in this scope
 --> /tmp/.tmpRuy6Hb/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{:?}" , variable) } } ; if let...
  |                                                                               ^^^^^ not found in this scope

error[E0425]: cannot find value `end` in this scope
 --> /tmp/.tmpRuy6Hb/main.rs:1:88
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{:?}" , variable) } } ; if let...
  |                                                                                        ^^^ not found in this scope
  |
help: you might have meant to write `.` instead of `..`
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{:?}" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for variable in start.end { { println ! ("{:?}" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpRuy6Hb/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{:?}" , variable) } } ; if let...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpRuy6Hb/main.rs:1:94
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{:?}" , variable) } } ; if let...
  |                                                                                              ^^                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{:?}" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { println ! ("{:?}" , variable) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error: aborting due to 2 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `initial_value` in this scope
 --> /tmp/.tmpT71xzC/main.rs:1:87
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut accumulator = initial_value ; let mut counter = start ; while cou...
  |                                                                                       ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `start` in this scope
 --> /tmp/.tmpT71xzC/main.rs:1:121
  |
1 | ...mut accumulator = initial_value ; let mut counter = start ; while counter <= end { { accumulator = update (accumulator , counter) ; co...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `end` in this scope
 --> /tmp/.tmpT71xzC/main.rs:1:146
  |
1 | ...l_value ; let mut counter = start ; while counter <= end { { accumulator = update (accumulator , counter) ; counter = counter + 1i32 }...
  |                                                         ^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpT71xzC/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut accumulator = initial_value ; let mut counter = start ; while cou...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `update` in this scope
 --> /tmp/.tmpT71xzC/main.rs:1:168
  |
1 | ...er = start ; while counter <= end { { accumulator = update (accumulator , counter) ; counter = counter + 1i32 } } } ; if let Some (s) ...
  |                                                        ^^^^^^ not found in this scope

error: aborting due to 4 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `height` in this scope
 --> /tmp/.tmp7yGr36/main.rs:1:84
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (out...
  |                                                                                    ^^^^^^ not found in this scope

error[E0425]: cannot find value `width` in this scope
 --> /tmp/.tmp7yGr36/main.rs:1:116
  |
1 | ...or outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn s...
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp7yGr36/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (out...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp7yGr36/main.rs:1:93
  |
1 | ...ult = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as ...
  |                                        ^^                                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { for inner in 0i32 .. width { { process (outer , inner) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7yGr36/main.rs:1:124
  |
1 | ...r in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: a...
  |                                                         ^^                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { process (outer , inner) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `process` in this scope
 --> /tmp/.tmp7yGr36/main.rs:1:126
  |
1 | ... 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :...
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 7 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpdRP94O/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! ("{:?}" ,...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpdRP94O/main.rs:1:88
  |
1 | ...t result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! ("{:?}" , result) } } } ; if let Some (s) = (& result as ...
  |                                        ^^                                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! ("{:?}" , result) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { let result = process (i) ; println ! ("{:?}" , result) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `process` in this scope
 --> /tmp/.tmpdRP94O/main.rs:1:105
  |
1 | ...result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! ("{:?}" , result) } } } ; if let Some (s) = (& result as & ...
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 9 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `height` in this scope
 --> /tmp/.tmpLotV2r/main.rs:1:82
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = ca...
  |                                                                                  ^^^^^^ not found in this scope

error[E0425]: cannot find value `width` in this scope
 --> /tmp/.tmpLotV2r/main.rs:1:112
  |
1 | ... = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let...
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpLotV2r/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = ca...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpLotV2r/main.rs:1:91
  |
1 | ... in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) ...
  |                         ^^                                                                                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpLotV2r/main.rs:1:120
  |
1 | ...eight { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result a...
  |                                         ^^                                                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { let value = calculate (row , col) ; display (value) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `calculate` in this scope
 --> /tmp/.tmpLotV2r/main.rs:1:136
  |
1 | ...ht { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as &...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `display` in this scope
 --> /tmp/.tmpLotV2r/main.rs:1:160
  |
1 | ..... width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any)...
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 4 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 10 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmprdvMLI/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { c...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmprdvMLI/main.rs:1:114
  |
1 | ... count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & dyn...
  |                                              ^^                                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { if condition (i) { { count = count + 1i32 } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmprdvMLI/main.rs:1:135
  |
1 | ... 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & dyn std :: ...
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { count = count + 1i32 } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `condition` in this scope
 --> /tmp/.tmprdvMLI/main.rs:1:119
  |
1 | ...mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & ...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch19-00-real-world-projects example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch19-00-real-world-projects example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch19-00-real-world-projects example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch19-00-real-world-projects example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== conclusion example 2 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmplphaDr/main.rs:1:562
  |
1 | ...()) ; let mut add_one = | x | x + 1i32 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`
 --> /tmp/.tmplphaDr/main.rs:1:478
  |
1 | ...pop () ; } } input } ; let mut contents = fs :: read_to_string ("file.txt" . to_string ()) ; let mut add_one = | x | x + 1i32 } ; if l...
  |                                              ^^ use of unresolved module or unlinked crate `fs`
  |
  = help: you might be missing a crate named `fs`
help: consider importing this module
  |
1 + use std::fs;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmplphaDr/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut arr = vec ! [1i32 , 2i32 , 3i32] ; let mut name = { print ! ("{}"...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0433`.



=== ch11-00-advanced-patterns example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 12 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 3 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `xFF` in this scope
 --> /tmp/.tmpW6t13c/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...
  |                                                                                ^^^ not found in this scope

error[E0425]: cannot find value `o77` in this scope
 --> /tmp/.tmpW6t13c/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...
  |                                                                                             ^^^ not found in this scope

error[E0425]: cannot find value `b1010` in this scope
 --> /tmp/.tmpW6t13c/main.rs:1:106
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...
  |                                                                                                          ^^^^^ not found in this scope

error[E0425]: cannot find value `_000_000` in this scope
 --> /tmp/.tmpW6t13c/main.rs:1:121
  |
1 | ... ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f64 ; 2f64 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; 3.14f64 ; f64 ; ...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `e6` in this scope
 --> /tmp/.tmpW6t13c/main.rs:1:156
  |
1 | ...2 ; b1010 ; 1i32 ; _000_000 ; 3.14f64 ; 2f64 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; 3.14f64 ; f64 ; 100i32 } ; if let Some (s) = (& ...
  |                                                          ^^ not found in this scope

error[E0423]: expected value, found builtin type `f64`
 --> /tmp/.tmpW6t13c/main.rs:1:198
  |
1 | ... ; 2f64 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; 3.14f64 ; f64 ; 100i32 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . ...
  |                                                               ^^^ not a value

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpW6t13c/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 6 previous errors; 1 warning emitted

Some errors have detailed explanations: E0423, E0425.
For more information about an error, try `rustc --explain E0423`.



=== appendix-b-syntax-reference example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 6 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found `let` statement
 --> /tmp/.tmpohst8j/main.rs:1:275
  |
1 | ...147483648i64 ; let mut uint = 4294967295i64 ; let mut long = - ! let mut ulong = ! let mut size = - 1i32 ; let mut usize = 1i32 ; let ...
  |                                                                     ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

error: expected expression, found `let` statement
 --> /tmp/.tmpohst8j/main.rs:1:293
  |
1 | ... mut uint = 4294967295i64 ; let mut long = - ! let mut ulong = ! let mut size = - 1i32 ; let mut usize = 1i32 ; let mut single = 3.14f...
  |                                                                     ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpohst8j/main.rs:1:499
  |
1 | ...let mut owned = "world" . to_string () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpohst8j/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut flag = true ; let mut small = - 128i32 ; let mut byte = 255i32 ; ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 3 previous errors; 1 warning emitted




=== appendix-b-syntax-reference example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 8 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmp5YgUaK/main.rs:1:384
  |
1 | ... mut x = "now a string" . to_string () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp5YgUaK/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut x = 42i32 ; let mut name = "Alice" . to_string () ; let mut count...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0529]: expected an array or slice, found `Vec<i32>`
 --> /tmp/.tmp5YgUaK/main.rs:1:255
  |
1 | ...(x , y) = (10i32 , 20i32) ; let [first , second , ..] = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32] ; let mut x = 42i32 ; let mut x = "no...
  |                                    ^^^^^^^^^^^^^^^^^^^^^ pattern cannot match with input type `Vec<i32>`
  |
help: consider slicing here
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut x = 42i32 ; let mut name = "Alice" . to_string () ; let mut count = 100i32 ; let mut score = 95.5f64 ; let mut counter = 0i32 ; counter += 1i32 ; let (x , y) = (10i32 , 20i32) ; let [first , second , ..] = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32][..] ; let mut x = 42i32 ; let mut x = "now a string" . to_string () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |                                                                                                                                                                                                                                                                                                                               ++++

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0529`.



=== appendix-b-syntax-reference example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 11 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `value` in this scope
 --> /tmp/.tmpYlsrF9/main.rs:1:71
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { match value { 0i32 => "zero" , 1i32 | 2i32 => "one or two" , 3i32 ..= 10i...
  |                                                                       ^^^^^ not found in this scope

error[E0425]: cannot find value `point` in this scope
 --> /tmp/.tmpYlsrF9/main.rs:1:234
  |
1 | ...=> "big number" , _ => "something else" , } ; match point { Point { x : 0i32 , y : 0i32 } => "origin" , Point { x , y : 0i32 } => form...
  |                                                        ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmpYlsrF9/main.rs:1:242
  |
1 | ...number" , _ => "something else" , } ; match point { Point { x : 0i32 , y : 0i32 } => "origin" , Point { x , y : 0i32 } => format ! ("{...
  |                                                        ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmpYlsrF9/main.rs:1:286
  |
1 | ...point { Point { x : 0i32 , y : 0i32 } => "origin" , Point { x , y : 0i32 } => format ! ("{}{}" , format ! ("{}{}" , "on x-axis at " , ...
  |                                                        ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmpYlsrF9/main.rs:1:390
  |
1 | ...! ("{}{}" , "on x-axis at " , x . to_s ()) , ",") , Point { x : 0i32 , y } => format ! ("{}{}" , format ! ("{}{}" , "on y-axis at " , ...
  |                                                        ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmpYlsrF9/main.rs:1:494
  |
1 | ...! ("{}{}" , "on y-axis at " , y . to_s ()) , ",") , Point { x , y } => format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "point...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `number` in this scope
 --> /tmp/.tmpYlsrF9/main.rs:1:639
  |
1 | .... to_s ()) , ", ") + y . to_s () , ")") , } ; match number { n if n < 0i32 => "negative" , n if n > 0i32 => "positive" , _ => "zero" ,...
  |                                                        ^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpYlsrF9/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { match value { 0i32 => "zero" , 1i32 | 2i32 => "one or two" , 3i32 ..= 10i...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0308]: `match` arms have incompatible types
 --> /tmp/.tmpYlsrF9/main.rs:1:312
  |
1 | ... ; match point { Point { x : 0i32 , y : 0i32 } => "origin" , Point { x , y : 0i32 } => format ! ("{}{}" , format ! ("{}{}" , "on x-axis at " , x . to_s ()) , ",") , ...
  |       -----------                                    --------                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `String`
  |       |                                              |
  |       |                                              this is found to be of type `&str`
  |       `match` arms have incompatible types
  |
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 8 previous errors; 1 warning emitted

Some errors have detailed explanations: E0308, E0422, E0425.
For more information about an error, try `rustc --explain E0308`.



=== appendix-b-syntax-reference example 12 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 14 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 15 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 16 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 17 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 18 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 19 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 20 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 21 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 22 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 23 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 24 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 25 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 26 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 27 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 28 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 29 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 30 ===
✗ Compilation failed: Failed to transpile to Rust


=== appendix-b-syntax-reference example 31 ===
✗ Compilation failed: Failed to transpile to Rust


=== appendix-b-syntax-reference example 32 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 33 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 34 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 35 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-input-output-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `variable` in this scope
 --> /tmp/.tmpQS6ei8/main.rs:1:114
  |
1 | ...{ println ! ("text message") ; println ! ("{:?}" , variable) ; println ! ("{:?}" , 42i32) ; println ! ("{:?}" , true) } ; if let Some ...
  |                                                       ^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpQS6ei8/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("text message") ; println ! ("{:?}" , variable) ; println ! ("...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch10-00-input-output-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `value` in this scope
 --> /tmp/.tmpj7IFuv/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut data = value ; println ! ("Label:") ; println ! ("{:?}" , data) }...
  |                                                                                ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpj7IFuv/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut data = value ; println ! ("Label:") ; println ! ("{:?}" , data) }...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch10-00-input-output-tdd example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch18-00-deployment-devops example 1 ===
✗ Compilation failed: Compilation failed:
error[E0432]: unresolved import `std::deploy`
 --> /tmp/.tmp1R5RI4/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: deploy ; ; let mut config = DeployConfig { app : "my-app" . to...
  |                                                                     ^^^^^^^^^^^^^ no `deploy` in the root

error[E0422]: cannot find struct, variant or union type `DeployConfig` in this scope
 --> /tmp/.tmp1R5RI4/main.rs:1:104
  |
1 | ...esult = { use std :: deploy ; ; let mut config = DeployConfig { app : "my-app" . to_string () , environment : env :: var ("DEPLOY_ENV"...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `env`
 --> /tmp/.tmp1R5RI4/main.rs:1:165
  |
1 | ... "my-app" . to_string () , environment : env :: var ("DEPLOY_ENV" . to_string ()) , strategy : BlueGreen , health_check : "/health" . ...
  |                                             ^^^ use of unresolved module or unlinked crate `env`
  |
  = help: you might be missing a crate named `env`
help: consider importing this module
  |
1 + use std::env;
  |

error[E0425]: cannot find value `BlueGreen` in this scope
 --> /tmp/.tmp1R5RI4/main.rs:1:219
  |
1 | ...:: var ("DEPLOY_ENV" . to_string ()) , strategy : BlueGreen , health_check : "/health" . to_string () , rollback_on_failure : true , }...
  |                                                      ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp1R5RI4/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: deploy ; ; let mut config = DeployConfig { app : "my-app" . to...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmp1R5RI4/main.rs:1:85
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: deploy ; ; let mut config = DeployConfig { app : "my-app" . to...
  |                                                                                     ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error: aborting due to 4 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0422, E0425, E0432, E0433.
For more information about an error, try `rustc --explain E0422`.



=== ch18-00-deployment-devops example 2 ===
✗ Compilation failed: Compilation failed:
error: argument never used
 --> /tmp/.tmpOQxrdr/main.rs:1:653
  |
1 | ... ; blue . destroy () ; println ! ("✅ Deployed version {}" , "{:?}" , new_version) } } } } fn main () { }
  |                                      ------------------------            ^^^^^^^^^^^ argument never used
  |                                      |
  |                                      formatting specifier missing

error[E0425]: cannot find function `sleep` in this scope
 --> /tmp/.tmpOQxrdr/main.rs:1:406
  |
1 | ...healthy") } } ; LoadBalancer :: switch_to (green) ; sleep (Duration :: from_mins (5i32)) ; if green . error_rate () > 0.01f64 { { Load...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::sleep;
  |

error[E0433]: failed to resolve: use of undeclared type `Duration`
 --> /tmp/.tmpOQxrdr/main.rs:1:413
  |
1 | ... ; LoadBalancer :: switch_to (green) ; sleep (Duration :: from_mins (5i32)) ; if green . error_rate () > 0.01f64 { { LoadBalancer :: s...
  |                                                  ^^^^^^^^ use of undeclared type `Duration`
  |
help: consider importing this struct
  |
1 + use std::time::Duration;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpOQxrdr/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn deploy_blue_green (new_version : String) -> i32 { { { let blue = Environment :: current () ; { let...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpOQxrdr/main.rs:1:90
  |
1 | ... { { { let blue = Environment :: current () ; { let mut green = Environment :: provision (new_version) ; green . deploy () ; green . run_health_checks () ; green . run_smoke_tests () ; if ! green . is_healthy () { { green . destroy () ; panic ! ("Green environment unhealthy") } } ; LoadBalancer :: switch_to (green) ; sleep (Duration :: from_mins (5i32)) ; if green . error_rate () > 0.01f64 { { LoadBalancer :: switch_to (blue) ; green . destroy () ; panic ! ("High error rate, rolled back") } } ; blue . destroy () ; println ! ("✅ Deployed version {}" , "{:?}" , new_version) } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn deploy_blue_green (new_version : String) -> i32 { { { let blue = Environment :: current () ; { let mut green = Environment :: provision (new_version) ; green . deploy () ; green . run_health_checks () ; green . run_smoke_tests () ; if ! green . is_healthy () { { green . destroy () ; panic ! ("Green environment unhealthy") } } ; LoadBalancer :: switch_to (green) ; sleep (Duration :: from_mins (5i32)) ; if green . error_rate () > 0.01f64 { { LoadBalancer :: switch_to (blue) ; green . destroy () ; panic ! ("High error rate, rolled back") } } ; blue . destroy () ; println ! ("✅ Deployed version {}" , "{:?}" , new_version) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn deploy_blue_green (new_version : String) -> i32 { { let blue = Environment :: current () ; { let mut green = Environment :: provision (new_version) ; green . deploy () ; green . run_health_checks () ; green . run_smoke_tests () ; if ! green . is_healthy () { { green . destroy () ; panic ! ("Green environment unhealthy") } } ; LoadBalancer :: switch_to (green) ; sleep (Duration :: from_mins (5i32)) ; if green . error_rate () > 0.01f64 { { LoadBalancer :: switch_to (blue) ; green . destroy () ; panic ! ("High error rate, rolled back") } } ; blue . destroy () ; println ! ("✅ Deployed version {}" , "{:?}" , new_version) } } } fn main () { }
  |

error[E0433]: failed to resolve: use of undeclared type `Environment`
 --> /tmp/.tmpOQxrdr/main.rs:1:105
  |
1 | ..._version : String) -> i32 { { { let blue = Environment :: current () ; { let mut green = Environment :: provision (new_version) ; gree...
  |                                               ^^^^^^^^^^^ use of undeclared type `Environment`

error[E0433]: failed to resolve: use of undeclared type `Environment`
 --> /tmp/.tmpOQxrdr/main.rs:1:151
  |
1 | ...ironment :: current () ; { let mut green = Environment :: provision (new_version) ; green . deploy () ; green . run_health_checks () ;...
  |                                               ^^^^^^^^^^^ use of undeclared type `Environment`

error[E0433]: failed to resolve: use of undeclared type `LoadBalancer`
 --> /tmp/.tmpOQxrdr/main.rs:1:370
  |
1 | ...c ! ("Green environment unhealthy") } } ; LoadBalancer :: switch_to (green) ; sleep (Duration :: from_mins (5i32)) ; if green . error_...
  |                                              ^^^^^^^^^^^^ use of undeclared type `LoadBalancer`

error[E0433]: failed to resolve: use of undeclared type `LoadBalancer`
 --> /tmp/.tmpOQxrdr/main.rs:1:484
  |
1 | ... ; if green . error_rate () > 0.01f64 { { LoadBalancer :: switch_to (blue) ; green . destroy () ; panic ! ("High error rate, rolled ba...
  |                                              ^^^^^^^^^^^^ use of undeclared type `LoadBalancer`

error[E0308]: mismatched types
 --> /tmp/.tmpOQxrdr/main.rs:1:607
  |
1 | ...} ; blue . destroy () ; println ! ("✅ Deployed version {}" , "{:?}" , new_version) } } } } fn main () { }
  |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 8 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0308, E0425, E0433.
For more information about an error, try `rustc --explain E0308`.



=== ch18-00-deployment-devops example 3 ===
✗ Compilation failed: Compilation failed:
error: argument never used
 --> /tmp/.tmp1PyeHs/main.rs:1:791
  |
1 | ... by >20%") } } ; println ! ("✅ Canary at {}% - metrics healthy" , "{:?}" , percentage) } } } } ; deployment . finalize () } } } } fn ma...
  |                                ------------------------------------            ^^^^^^^^^^ argument never used
  |                                |
  |                                formatting specifier missing

error[E0425]: cannot find function `sleep` in this scope
 --> /tmp/.tmp1PyeHs/main.rs:1:382
  |
1 | ... deployment . set_traffic_percentage (percentage) ; sleep (Duration :: from_mins (10i32)) ; { let current = Metrics :: current () ; { ...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::sleep;
  |

error[E0433]: failed to resolve: use of undeclared type `Duration`
 --> /tmp/.tmp1PyeHs/main.rs:1:389
  |
1 | ... set_traffic_percentage (percentage) ; sleep (Duration :: from_mins (10i32)) ; { let current = Metrics :: current () ; { if current . ...
  |                                                  ^^^^^^^^ use of undeclared type `Duration`
  |
help: consider importing this struct
  |
1 + use std::time::Duration;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp1PyeHs/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn deploy_canary (new_version : String) -> i32 { { { let deployment = CanaryDeployment :: new (new_ve...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp1PyeHs/main.rs:1:86
  |
1 | ... { { { let deployment = CanaryDeployment :: new (new_version) ; { deployment . set_traffic_percentage (5i32) ; deployment . deploy () ; let mut baseline = Metrics :: baseline () ; for percentage in vec ! [5i32 , 10i32 , 25i32 , 50i32 , 100i32] { { deployment . set_traffic_percentage (percentage) ; sleep (Duration :: from_mins (10i32)) ; { let current = Metrics :: current () ; { if current . error_rate > baseline . error_rate * 1.1f64 { { deployment . rollback () ; panic ! ("Error rate increased by >10%") } } ; if current . p99_latency > baseline . p99_latency * 1.2f64 { { deployment . rollback () ; panic ! ("Latency increased by >20%") } } ; println ! ("✅ Canary at {}% - metrics healthy" , "{:?}" , percentage) } } } } ; deployment . finalize () } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn deploy_canary (new_version : String) -> i32 { { { let deployment = CanaryDeployment :: new (new_version) ; { deployment . set_traffic_percentage (5i32) ; deployment . deploy () ; let mut baseline = Metrics :: baseline () ; for percentage in vec ! [5i32 , 10i32 , 25i32 , 50i32 , 100i32] { { deployment . set_traffic_percentage (percentage) ; sleep (Duration :: from_mins (10i32)) ; { let current = Metrics :: current () ; { if current . error_rate > baseline . error_rate * 1.1f64 { { deployment . rollback () ; panic ! ("Error rate increased by >10%") } } ; if current . p99_latency > baseline . p99_latency * 1.2f64 { { deployment . rollback () ; panic ! ("Latency increased by >20%") } } ; println ! ("✅ Canary at {}% - metrics healthy" , "{:?}" , percentage) } } } } ; deployment . finalize () } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn deploy_canary (new_version : String) -> i32 { { let deployment = CanaryDeployment :: new (new_version) ; { deployment . set_traffic_percentage (5i32) ; deployment . deploy () ; let mut baseline = Metrics :: baseline () ; for percentage in vec ! [5i32 , 10i32 , 25i32 , 50i32 , 100i32] { { deployment . set_traffic_percentage (percentage) ; sleep (Duration :: from_mins (10i32)) ; { let current = Metrics :: current () ; { if current . error_rate > baseline . error_rate * 1.1f64 { { deployment . rollback () ; panic ! ("Error rate increased by >10%") } } ; if current . p99_latency > baseline . p99_latency * 1.2f64 { { deployment . rollback () ; panic ! ("Latency increased by >20%") } } ; println ! ("✅ Canary at {}% - metrics healthy" , "{:?}" , percentage) } } } } ; deployment . finalize () } } } fn main () { }
  |

error[E0433]: failed to resolve: use of undeclared type `CanaryDeployment`
 --> /tmp/.tmp1PyeHs/main.rs:1:107
  |
1 | ...String) -> i32 { { { let deployment = CanaryDeployment :: new (new_version) ; { deployment . set_traffic_percentage (5i32) ; deploymen...
  |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `CanaryDeployment`

error[E0433]: failed to resolve: use of undeclared type `Metrics`
 --> /tmp/.tmp1PyeHs/main.rs:1:238
  |
1 | ... ; deployment . deploy () ; let mut baseline = Metrics :: baseline () ; for percentage in vec ! [5i32 , 10i32 , 25i32 , 50i32 , 100i32...
  |                                                   ^^^^^^^ use of undeclared type `Metrics`

error[E0433]: failed to resolve: use of undeclared type `Metrics`
 --> /tmp/.tmp1PyeHs/main.rs:1:438
  |
1 | ...ration :: from_mins (10i32)) ; { let current = Metrics :: current () ; { if current . error_rate > baseline . error_rate * 1.1f64 { { ...
  |                                                   ^^^^^^^ use of undeclared type `Metrics`

error: aborting due to 6 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0425, E0433.
For more information about an error, try `rustc --explain E0425`.



=== ch18-00-deployment-devops example 4 ===
✗ Compilation failed: Compilation failed:
error[E0432]: unresolved import `feature_flags`
 --> /tmp/.tmpqte5Ad/main.rs:1:69
  |
1 | ...n main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ("api_key" . to_string ()) ; let m...
  |                                   ^^^^^^^^^^^^^ use of unresolved module or unlinked crate `feature_flags`
  |
help: you might be missing a crate named `feature_flags`, add it to your project and import it in your code
  |
1 + extern crate feature_flags;
  |

error[E0425]: cannot find value `user` in this scope
 --> /tmp/.tmpqte5Ad/main.rs:1:456
  |
1 | ...) , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percen...
  |                                                         ^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpqte5Ad/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpqte5Ad/main.rs:1:106
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ...
  |                                                                                                          ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpqte5Ad/main.rs:1:464
  |
1 | ...ue)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage i...
  |                                                           ^^                    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ("api_key" . to_string ()) ; let mut new_algorithm = Flag :: new ("new-algorithm" . to_string ()) . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new ("beta_users" . to_string () , true) , Rule :: new ("internal_users" . to_string () , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ("api_key" . to_string ()) ; let mut new_algorithm = Flag :: new ("new-algorithm" . to_string ()) . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new ("beta_users" . to_string () , true) , Rule :: new ("internal_users" . to_string () , true)]) ; if flags . is_enabled (new_algorithm , user) { use_new_algorithm () } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpqte5Ad/main.rs:1:498
  |
1 | ..._algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 7...
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ("api_key" . to_string ()) ; let mut new_algorithm = Flag :: new ("new-algorithm" . to_string ()) . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new ("beta_users" . to_string () , true) , Rule :: new ("internal_users" . to_string () , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ("api_key" . to_string ()) ; let mut new_algorithm = Flag :: new ("new-algorithm" . to_string ()) . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new ("beta_users" . to_string () , true) , Rule :: new ("internal_users" . to_string () , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { use_old_algorithm () } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0433]: failed to resolve: use of undeclared type `Rule`
 --> /tmp/.tmpqte5Ad/main.rs:1:309
  |
1 | ...lout_percentage (10i32) . targeting_rules (vec ! [Rule :: new ("beta_users" . to_string () , true) , Rule :: new ("internal_users" . t...
  |                                                      ^^^^ use of undeclared type `Rule`

error[E0433]: failed to resolve: use of undeclared type `Rule`
 --> /tmp/.tmpqte5Ad/main.rs:1:360
  |
1 | ...ule :: new ("beta_users" . to_string () , true) , Rule :: new ("internal_users" . to_string () , true)]) ; if flags . is_enabled (new_...
  |                                                      ^^^^ use of undeclared type `Rule`

error[E0425]: cannot find function `use_new_algorithm` in this scope
 --> /tmp/.tmpqte5Ad/main.rs:1:466
  |
1 | ...ew_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 ,...
  |                             ^^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists: `new_algorithm`

error[E0425]: cannot find function `use_old_algorithm` in this scope
 --> /tmp/.tmpqte5Ad/main.rs:1:500
  |
1 | ..., user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `monitor_metrics` in this scope
 --> /tmp/.tmpqte5Ad/main.rs:1:647
  |
1 | ...s . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `metrics_degraded` in this scope
 --> /tmp/.tmpqte5Ad/main.rs:1:671
  |
1 | ...orithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 8 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0425, E0432, E0433.
For more information about an error, try `rustc --explain E0425`.



=== ch18-00-deployment-devops example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch18-00-deployment-devops example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch18-00-deployment-devops example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch18-00-deployment-devops example 8 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch01-03-interpreter-scripting example 1 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `ruchy` in this scope
 --> /tmp/.tmp4n8GO5/main.rs:1:65
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "2 + 2" } ; if let Some (s) = (& result as & dyn std :: any :...
  |                                                                 ^^^^^ not found in this scope

error[E0425]: cannot find value `e` in this scope
 --> /tmp/.tmp4n8GO5/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "2 + 2" } ; if let Some (s) = (& result as & dyn std :: any :...
  |                                                                         ^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp4n8GO5/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "2 + 2" } ; if let Some (s) = (& result as & dyn std :: any :...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 2 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `ruchy` in this scope
 --> /tmp/.tmpzLx3IG/main.rs:1:65
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let name = \"World\"; \"Hello \" + name + \"!\"" } ; if let ...
  |                                                                 ^^^^^ not found in this scope

error[E0425]: cannot find value `e` in this scope
 --> /tmp/.tmpzLx3IG/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let name = \"World\"; \"Hello \" + name + \"!\"" } ; if let ...
  |                                                                         ^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpzLx3IG/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let name = \"World\"; \"Hello \" + name + \"!\"" } ; if let ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 3 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `ruchy` in this scope
 --> /tmp/.tmpOMgayF/main.rs:1:65
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let nums = [1, 2, 3]; nums[1]" } ; if let Some (s) = (& resu...
  |                                                                 ^^^^^ not found in this scope

error[E0425]: cannot find value `e` in this scope
 --> /tmp/.tmpOMgayF/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let nums = [1, 2, 3]; nums[1]" } ; if let Some (s) = (& resu...
  |                                                                         ^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpOMgayF/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let nums = [1, 2, 3]; nums[1]" } ; if let Some (s) = (& resu...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 7 ===
✗ Compilation failed: Compilation failed:
error[E0434]: can't capture dynamic environment in a fn item
 --> /tmp/.tmpWHsHDe/main.rs:1:266
  |
1 | ...i32 { { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ...
  |                                                                  ^^^^^^^^^
  |
  = help: use the `|| { ... }` closure form instead

error[E0425]: cannot find value `global_var` in this scope
 --> /tmp/.tmpWHsHDe/main.rs:1:141
  |
1 | ...ng () ; { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; fn nested () -> i32 { { println ! ("{:?}" , global_var) ;...
  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `local_var`

error[E0425]: cannot find value `global_var` in this scope
 --> /tmp/.tmpWHsHDe/main.rs:1:232
  |
1 | ...> i32 { { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ...
  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `local_var`

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpWHsHDe/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { { let local_var = "I'm local" . to_string () ; { println ! ("{:?}"...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpWHsHDe/main.rs:1:70
  |
1 | ... { { { let local_var = "I'm local" . to_string () ; { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; fn nested () -> i32 { { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ("{:?}" , nested_var) } } } ; nested () } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { { let local_var = "I'm local" . to_string () ; { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; fn nested () -> i32 { { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ("{:?}" , nested_var) } } } ; nested () } } } } fn main () { let mut global_var = "I'm global" . to_string () ; { demonstrate_scope () } }
1 + use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { let local_var = "I'm local" . to_string () ; { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; fn nested () -> i32 { { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ("{:?}" , nested_var) } } } ; nested () } } } fn main () { let mut global_var = "I'm global" . to_string () ; { demonstrate_scope () } }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpWHsHDe/main.rs:1:366
  |
1 | ...o_string () ; println ! ("{:?}" , nested_var) } } } ; nested () } } } } fn main () { let mut global_var = "I'm global" . to_string () ...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpWHsHDe/main.rs:1:450
  |
1 | ...) { let mut global_var = "I'm global" . to_string () ; { demonstrate_scope () } }
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { { let local_var = "I'm local" . to_string () ; { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; fn nested () -> i32 { { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ("{:?}" , nested_var) } } } ; nested () } } } } fn main () { let mut global_var = "I'm global" . to_string () ; { demonstrate_scope () } }
1 + use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { { let local_var = "I'm local" . to_string () ; { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; fn nested () -> i32 { { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ("{:?}" , nested_var) } } } ; nested () } } } } fn main () { let mut global_var = "I'm global" . to_string () ; demonstrate_scope () }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpWHsHDe/main.rs:1:328
  |
1 | ...d_var = "I'm nested" . to_string () ; println ! ("{:?}" , nested_var) } } } ; nested () } } } } fn main () { let mut global_var = "I'm...
  |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
 --> /tmp/.tmpWHsHDe/main.rs:1:452
  |
1 | ...main () { let mut global_var = "I'm global" . to_string () ; { demonstrate_scope () } }
  |           -                                                       ^^^^^^^^^^^^^^^^^^^^- help: consider using a semicolon here: `;`
  |           |                                                       |
  |           expected `()` because of default return type            expected `()`, found `i32`

error: aborting due to 5 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0308, E0425, E0434.
For more information about an error, try `rustc --explain E0308`.



=== ch01-03-interpreter-scripting example 8 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpa4lckL/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpa4lckL/main.rs:1:50
  |
1 | ... { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } } }
  |       ^^                                                                                                                                                                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } } }
1 + use std :: collections :: HashMap ; fn main () { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpa4lckL/main.rs:1:118
  |
1 | ...32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds")...
  |                                                 ^^                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { println ! ("{:?}" , arr [5i32 as usize]) } else { { println ! ("Index out of bounds") } } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpa4lckL/main.rs:1:172
  |
1 | ...tln ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } } }
  |                                                    ^^                                 ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" , arr [5i32 as usize]) } } else { println ! ("Index out of bounds") } } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpa4lckL/main.rs:1:103
  |
1 | ...let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("In...
  |                                              ----   ^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                              |
  |                                              expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len ().try_into().unwrap() { { println ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } } }
  |                                                                                                                   ++++++++++++++++++++

error: aborting due to 1 previous error; 4 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch01-03-interpreter-scripting example 10 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpAOz7Jy/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn get_double (x : i32) -> i32 { { x * 2i32 } } fn process_and_print (x : i32) -> i32 { { { let doubl...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpAOz7Jy/main.rs:1:70
  |
1 | use std :: collections :: HashMap ; fn get_double (x : i32) -> i32 { { x * 2i32 } } fn process_and_print (x : i32) -> i32 { { { let doubl...
  |                                                                      ^^        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn get_double (x : i32) -> i32 { { x * 2i32 } } fn process_and_print (x : i32) -> i32 { { { let doubled = x * 2i32 ; { println ! ("Doubled:") ; println ! ("{:?}" , doubled) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn get_double (x : i32) -> i32 { x * 2i32 } fn process_and_print (x : i32) -> i32 { { { let doubled = x * 2i32 ; { println ! ("Doubled:") ; println ! ("{:?}" , doubled) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpAOz7Jy/main.rs:1:125
  |
1 | ...nt (x : i32) -> i32 { { { let doubled = x * 2i32 ; { println ! ("Doubled:") ; println ! ("{:?}" , doubled) } } } } fn main () { }
  |                          ^^                                                                                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn get_double (x : i32) -> i32 { { x * 2i32 } } fn process_and_print (x : i32) -> i32 { { { let doubled = x * 2i32 ; { println ! ("Doubled:") ; println ! ("{:?}" , doubled) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn get_double (x : i32) -> i32 { { x * 2i32 } } fn process_and_print (x : i32) -> i32 { { let doubled = x * 2i32 ; { println ! ("Doubled:") ; println ! ("{:?}" , doubled) } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpAOz7Jy/main.rs:1:181
  |
1 | ... x * 2i32 ; { println ! ("Doubled:") ; println ! ("{:?}" , doubled) } } } } fn main () { }
  |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 1 previous error; 3 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch01-03-interpreter-scripting example 12 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmp07NDeE/main.rs:1:183
  |
1 | ...t mut x = 42i32 ; let mut y = calc (z) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0425]: cannot find value `items` in this scope
 --> /tmp/.tmp07NDeE/main.rs:1:133
  |
1 | ...nt = 42i32 ; let mut total_price = calculate_price (items) ; let mut x = 42i32 ; let mut y = calc (z) } ; if let Some (s) = (& result ...
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp07NDeE/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut user_count = 42i32 ; let mut total_price = calculate_price (items...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `calculate_price` in this scope
 --> /tmp/.tmp07NDeE/main.rs:1:116
  |
1 | ...mut user_count = 42i32 ; let mut total_price = calculate_price (items) ; let mut x = 42i32 ; let mut y = calc (z) } ; if let Some (s) ...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 13 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpqGbsMh/main.rs:1:208
  |
1 | ...ut last_grade = grades [4i32 as usize] } } } }
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpqGbsMh/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let mut first_grade =...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpqGbsMh/main.rs:1:50
  |
1 | ... { { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let mut first_grade = grades [0i32 as usize] ; let mut last_grade = grades [4i32 as usize] } } } }
  |       ^^                                                                                                                                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let mut first_grade = grades [0i32 as usize] ; let mut last_grade = grades [4i32 as usize] } } } }
1 + use std :: collections :: HashMap ; fn main () { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let mut first_grade = grades [0i32 as usize] ; let mut last_grade = grades [4i32 as usize] } } }
  |

error: aborting due to 1 previous error; 2 warnings emitted




=== ch17-00-documentation example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 5 ===
✗ Compilation failed: Compilation failed:
error: expected item, found `{`
 --> /tmp/.tmp7RsVGb/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { mod handlers { { } } ; mod services { { } } } ; if let Some (s) = (& resu...
  |                                                                                ^ expected item
  |
  = note: for a full list of items that can appear in modules, see <https://doc.rust-lang.org/reference/items.html>

error: expected item, found `{`
 --> /tmp/.tmp7RsVGb/main.rs:1:103
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { mod handlers { { } } ; mod services { { } } } ; if let Some (s) = (& resu...
  |                                                                                                       ^ expected item
  |
  = note: for a full list of items that can appear in modules, see <https://doc.rust-lang.org/reference/items.html>

error: expected item, found `}`
 --> /tmp/.tmp7RsVGb/main.rs:1:109
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { mod handlers { { } } ; mod services { { } } } ; if let Some (s) = (& resu...
  |                                                                                                             ^ expected item
  |
  = note: for a full list of items that can appear in modules, see <https://doc.rust-lang.org/reference/items.html>

error: aborting due to 3 previous errors




=== ch17-00-documentation example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 9 ===
✗ Compilation failed: Compilation failed:
error[E0670]: `async fn` is not permitted in Rust 2015
 --> /tmp/.tmpRSaA9a/main.rs:1:37
  |
1 | use std :: collections :: HashMap ; async fn request_flow () -> i32 { { client . send_request () ; server . validate () ; server . proces...
  |                                     ^^^^^ to use `async fn`, switch to Rust 2018 or later
  |
  = help: pass `--edition 2024` to `rustc`
  = note: for more on editions, read https://doc.rust-lang.org/edition-guide

error[E0425]: cannot find value `client` in this scope
 --> /tmp/.tmpRSaA9a/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; async fn request_flow () -> i32 { { client . send_request () ; server . validate () ; server . proces...
  |                                                                         ^^^^^^ not found in this scope

error[E0425]: cannot find value `server` in this scope
 --> /tmp/.tmpRSaA9a/main.rs:1:100
  |
1 | use std :: collections :: HashMap ; async fn request_flow () -> i32 { { client . send_request () ; server . validate () ; server . proces...
  |                                                                                                    ^^^^^^ not found in this scope

error[E0425]: cannot find value `server` in this scope
 --> /tmp/.tmpRSaA9a/main.rs:1:123
  |
1 | ...{ client . send_request () ; server . validate () ; server . process () ; server . respond () } } fn main () { impl ConfigBuilder { } ; }
  |                                                        ^^^^^^ not found in this scope

error[E0425]: cannot find value `server` in this scope
 --> /tmp/.tmpRSaA9a/main.rs:1:145
  |
1 | ...t () ; server . validate () ; server . process () ; server . respond () } } fn main () { impl ConfigBuilder { } ; }
  |                                                        ^^^^^^ not found in this scope

error[E0412]: cannot find type `ConfigBuilder` in this scope
 --> /tmp/.tmpRSaA9a/main.rs:1:187
  |
1 | ... () ; server . respond () } } fn main () { impl ConfigBuilder { } ; }
  |                                                    ^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpRSaA9a/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; async fn request_flow () -> i32 { { client . send_request () ; server . validate () ; server . proces...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpRSaA9a/main.rs:1:205
  |
1 | ... respond () } } fn main () { impl ConfigBuilder { } ; }
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error: aborting due to 6 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0412, E0425, E0670.
For more information about an error, try `rustc --explain E0412`.



=== ch17-00-documentation example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch06-00-file-operations example 1 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `create_dir` in this scope
 --> /tmp/.tmpfT6S3k/main.rs:1:1261
  |
1 | ... , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{:?}" , format ! ("{}{}" , "Created folder: " ...
  |                                                      ^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::create_dir;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpfT6S3k/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Desktop Organizer ===") ; let mut file_categories = { let...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpfT6S3k/main.rs:1:1015
  |
1 | ... { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . iter () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{:?}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Desktop Organizer ===") ; let mut file_categories = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("Documents" . to_string () , (vec ! [".pdf" , ".doc" , ".docx" , ".txt"]) . to_string ()) ; map . insert ("Images" . to_string () , (vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"]) . to_string ()) ; map . insert ("Videos" . to_string () , (vec ! [".mp4" , ".avi" , ".mov" , ".mkv"]) . to_string ()) ; map . insert ("Code" . to_string () , (vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"]) . to_string ()) ; map . insert ("Data" . to_string () , (vec ! [".csv" , ".json" , ".xml" , ".xlsx"]) . to_string ()) ; map } ; let mut source_dir = "~/Desktop" . to_string () ; let mut files = list_files (source_dir) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . iter () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{:?}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } } } } ; println ! ("✅ Desktop organized!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Desktop Organizer ===") ; let mut file_categories = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("Documents" . to_string () , (vec ! [".pdf" , ".doc" , ".docx" , ".txt"]) . to_string ()) ; map . insert ("Images" . to_string () , (vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"]) . to_string ()) ; map . insert ("Videos" . to_string () , (vec ! [".mp4" , ".avi" , ".mov" , ".mkv"]) . to_string ()) ; map . insert ("Code" . to_string () , (vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"]) . to_string ()) ; map . insert ("Data" . to_string () , (vec ! [".csv" , ".json" , ".xml" , ".xlsx"]) . to_string ()) ; map } ; let mut source_dir = "~/Desktop" . to_string () ; let mut files = list_files (source_dir) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . iter () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{:?}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } } } ; println ! ("✅ Desktop organized!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpfT6S3k/main.rs:1:1128
  |
1 | ... { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{:?}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Desktop Organizer ===") ; let mut file_categories = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("Documents" . to_string () , (vec ! [".pdf" , ".doc" , ".docx" , ".txt"]) . to_string ()) ; map . insert ("Images" . to_string () , (vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"]) . to_string ()) ; map . insert ("Videos" . to_string () , (vec ! [".mp4" , ".avi" , ".mov" , ".mkv"]) . to_string ()) ; map . insert ("Code" . to_string () , (vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"]) . to_string ()) ; map . insert ("Data" . to_string () , (vec ! [".csv" , ".json" , ".xml" , ".xlsx"]) . to_string ()) ; map } ; let mut source_dir = "~/Desktop" . to_string () ; let mut files = list_files (source_dir) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . iter () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{:?}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } } } } ; println ! ("✅ Desktop organized!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Desktop Organizer ===") ; let mut file_categories = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("Documents" . to_string () , (vec ! [".pdf" , ".doc" , ".docx" , ".txt"]) . to_string ()) ; map . insert ("Images" . to_string () , (vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"]) . to_string ()) ; map . insert ("Videos" . to_string () , (vec ! [".mp4" , ".avi" , ".mov" , ".mkv"]) . to_string ()) ; map . insert ("Code" . to_string () , (vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"]) . to_string ()) ; map . insert ("Data" . to_string () , (vec ! [".csv" , ".json" , ".xml" , ".xlsx"]) . to_string ()) ; map } ; let mut source_dir = "~/Desktop" . to_string () ; let mut files = list_files (source_dir) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . iter () { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{:?}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } } } ; println ! ("✅ Desktop organized!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpfT6S3k/main.rs:1:1169
  |
1 | ... { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{:?}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Desktop Organizer ===") ; let mut file_categories = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("Documents" . to_string () , (vec ! [".pdf" , ".doc" , ".docx" , ".txt"]) . to_string ()) ; map . insert ("Images" . to_string () , (vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"]) . to_string ()) ; map . insert ("Videos" . to_string () , (vec ! [".mp4" , ".avi" , ".mov" , ".mkv"]) . to_string ()) ; map . insert ("Code" . to_string () , (vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"]) . to_string ()) ; map . insert ("Data" . to_string () , (vec ! [".csv" , ".json" , ".xml" , ".xlsx"]) . to_string ()) ; map } ; let mut source_dir = "~/Desktop" . to_string () ; let mut files = list_files (source_dir) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . iter () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{:?}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } } } } ; println ! ("✅ Desktop organized!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Desktop Organizer ===") ; let mut file_categories = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("Documents" . to_string () , (vec ! [".pdf" , ".doc" , ".docx" , ".txt"]) . to_string ()) ; map . insert ("Images" . to_string () , (vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"]) . to_string ()) ; map . insert ("Videos" . to_string () , (vec ! [".mp4" , ".avi" , ".mov" , ".mkv"]) . to_string ()) ; map . insert ("Code" . to_string () , (vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"]) . to_string ()) ; map . insert ("Data" . to_string () , (vec ! [".csv" , ".json" , ".xml" , ".xlsx"]) . to_string ()) ; map } ; let mut source_dir = "~/Desktop" . to_string () ; let mut files = list_files (source_dir) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . iter () { { if extensions . contains (extension) { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{:?}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } } } ; println ! ("✅ Desktop organized!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0599]: the method `to_string` exists for struct `Vec<&str>`, but its trait bounds were not satisfied
   --> /tmp/.tmpfT6S3k/main.rs:1:333
    |
1   | ...oc" , ".docx" , ".txt"]) . to_string ()) ; map . insert ("Images" . to_string () , (vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"...
    |                               ^^^^^^^^^ method cannot be called on `Vec<&str>` due to unsatisfied trait bounds
    |
   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1
    |
414 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<&str>: ToString` or `Vec<&str>: std::fmt::Display`
    |
    = note: the following trait bounds were not satisfied:
            `Vec<&str>: std::fmt::Display`
            which is required by `Vec<&str>: ToString`
            `[&str]: std::fmt::Display`
            which is required by `[&str]: ToString`

error[E0599]: the method `to_string` exists for struct `Vec<&str>`, but its trait bounds were not satisfied
   --> /tmp/.tmpfT6S3k/main.rs:1:445
    |
1   | ...png" , ".gif" , ".svg"]) . to_string ()) ; map . insert ("Videos" . to_string () , (vec ! [".mp4" , ".avi" , ".mov" , ".mkv"]) . to_st...
    |                               ^^^^^^^^^ method cannot be called on `Vec<&str>` due to unsatisfied trait bounds
    |
   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1
    |
414 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<&str>: ToString` or `Vec<&str>: std::fmt::Display`
    |
    = note: the following trait bounds were not satisfied:
            `Vec<&str>: std::fmt::Display`
            which is required by `Vec<&str>: ToString`
            `[&str]: std::fmt::Display`
            which is required by `[&str]: ToString`

error[E0599]: the method `to_string` exists for struct `Vec<&str>`, but its trait bounds were not satisfied
   --> /tmp/.tmpfT6S3k/main.rs:1:547
    |
1   | ...avi" , ".mov" , ".mkv"]) . to_string ()) ; map . insert ("Code" . to_string () , (vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"]) ....
    |                               ^^^^^^^^^ method cannot be called on `Vec<&str>` due to unsatisfied trait bounds
    |
   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1
    |
414 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<&str>: ToString` or `Vec<&str>: std::fmt::Display`
    |
    = note: the following trait bounds were not satisfied:
            `Vec<&str>: std::fmt::Display`
            which is required by `Vec<&str>: ToString`
            `[&str]: std::fmt::Display`
            which is required by `[&str]: ToString`

error[E0599]: the method `to_string` exists for struct `Vec<&str>`, but its trait bounds were not satisfied
   --> /tmp/.tmpfT6S3k/main.rs:1:655
    |
1   | ...s" , ".ruchy" , ".cpp"]) . to_string ()) ; map . insert ("Data" . to_string () , (vec ! [".csv" , ".json" , ".xml" , ".xlsx"]) . to_st...
    |                               ^^^^^^^^^ method cannot be called on `Vec<&str>` due to unsatisfied trait bounds
    |
   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1
    |
414 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<&str>: ToString` or `Vec<&str>: std::fmt::Display`
    |
    = note: the following trait bounds were not satisfied:
            `Vec<&str>: std::fmt::Display`
            which is required by `Vec<&str>: ToString`
            `[&str]: std::fmt::Display`
            which is required by `[&str]: ToString`

error[E0599]: the method `to_string` exists for struct `Vec<&str>`, but its trait bounds were not satisfied
   --> /tmp/.tmpfT6S3k/main.rs:1:757
    |
1   | ...on" , ".xml" , ".xlsx"]) . to_string ()) ; map } ; let mut source_dir = "~/Desktop" . to_string () ; let mut files = list_files (sourc...
    |                               ^^^^^^^^^ method cannot be called on `Vec<&str>` due to unsatisfied trait bounds
    |
   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1
    |
414 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<&str>: ToString` or `Vec<&str>: std::fmt::Display`
    |
    = note: the following trait bounds were not satisfied:
            `Vec<&str>: std::fmt::Display`
            which is required by `Vec<&str>: ToString`
            `[&str]: std::fmt::Display`
            which is required by `[&str]: ToString`

error[E0425]: cannot find function `list_files` in this scope
 --> /tmp/.tmpfT6S3k/main.rs:1:847
  |
1 | ...ir = "~/Desktop" . to_string () ; let mut files = list_files (source_dir) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , ...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `get_extension` in this scope
 --> /tmp/.tmpfT6S3k/main.rs:1:1035
  |
1 | ...ze")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . ite...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpfT6S3k/main.rs:1:1190
  |
1 | ...ons . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (t...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `dir_exists` in this scope
 --> /tmp/.tmpfT6S3k/main.rs:1:1233
  |
1 | ..._dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{:?}" , format ! (...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpfT6S3k/main.rs:1:1381
  |
1 | ...ted folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpfT6S3k/main.rs:1:1435
  |
1 | ..._path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{:?}"...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `move_file` in this scope
 --> /tmp/.tmpfT6S3k/main.rs:1:1467
  |
1 | ...mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{:?}" , format ! ("{}{}" , format ! (...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 13 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0425, E0599.
For more information about an error, try `rustc --explain E0425`.



=== ch06-00-file-operations example 2 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpsuQej5/main.rs:1:541
  |
1 | ...(".././data//file.txt" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0425]: cannot find function `set_current_dir` in this scope
 --> /tmp/.tmpsuQej5/main.rs:1:108
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; set_current_dir ("/home/user/p...
  |                                                                                                            ^^^^^^^^^^^^^^^
  |
help: a local variable with a similar name exists
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; set_current_dir ("/home/user/projects" . to_string ()) ; let mut full_path = absolute_path ("data.txt" . to_string ()) ; let mut parent = parent_dir (full_path) ; let mut filename = file_name (full_path) ; let mut extension = file_extension (full_path) ; let mut project_path = join_path (home_dir () , "projects" . to_string () , "my_app" . to_string ()) ; let mut clean_path = normalize_path (".././data//file.txt" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; current_dir ("/home/user/projects" . to_string ()) ; let mut full_path = absolute_path ("data.txt" . to_string ()) ; let mut parent = parent_dir (full_path) ; let mut filename = file_name (full_path) ; let mut extension = file_extension (full_path) ; let mut project_path = join_path (home_dir () , "projects" . to_string () , "my_app" . to_string ()) ; let mut clean_path = normalize_path (".././data//file.txt" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |
help: consider importing this function
  |
1 + use std::env::set_current_dir;
  |

error[E0425]: cannot find function `home_dir` in this scope
 --> /tmp/.tmpsuQej5/main.rs:1:397
  |
1 | ...on (full_path) ; let mut project_path = join_path (home_dir () , "projects" . to_string () , "my_app" . to_string ()) ; let mut clean_...
  |                                                       ^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::env::home_dir;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpsuQej5/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; set_current_dir ("/home/user/p...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `get_current_dir` in this scope
 --> /tmp/.tmpsuQej5/main.rs:1:87
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; set_current_dir ("/home/user/p...
  |                                                                                       ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `absolute_path` in this scope
 --> /tmp/.tmpsuQej5/main.rs:1:185
  |
1 | ...projects" . to_string ()) ; let mut full_path = absolute_path ("data.txt" . to_string ()) ; let mut parent = parent_dir (full_path) ; ...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `parent_dir` in this scope
 --> /tmp/.tmpsuQej5/main.rs:1:246
  |
1 | ...tring ()) ; let mut parent = parent_dir (full_path) ; let mut filename = file_name (full_path) ; let mut extension = file_extension (f...
  |                                 ^^^^^^^^^^ help: a local variable with a similar name exists: `current_dir`

error[E0425]: cannot find function `file_name` in this scope
 --> /tmp/.tmpsuQej5/main.rs:1:290
  |
1 | ...ent = parent_dir (full_path) ; let mut filename = file_name (full_path) ; let mut extension = file_extension (full_path) ; let mut pro...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_extension` in this scope
 --> /tmp/.tmpsuQej5/main.rs:1:334
  |
1 | ...e = file_name (full_path) ; let mut extension = file_extension (full_path) ; let mut project_path = join_path (home_dir () , "projects...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpsuQej5/main.rs:1:386
  |
1 | ...le_extension (full_path) ; let mut project_path = join_path (home_dir () , "projects" . to_string () , "my_app" . to_string ()) ; let ...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 9 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch06-00-file-operations example 3 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpnuqLMy/main.rs:1:562
  |
1 | ...mut can_execute = is_executable (path) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpnuqLMy/main.rs:1:344
  |
1 | ..."system.conf" . to_string ()) ; let mut is_file = is_file (path) ; let mut is_dir = is_directory (path) ; let mut is_symlink = is_symb...
  |                                                               ^^^^ not a value

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpnuqLMy/main.rs:1:383
  |
1 | ... is_file = is_file (path) ; let mut is_dir = is_directory (path) ; let mut is_symlink = is_symbolic_link (path) ; let mut can_read = i...
  |                                                               ^^^^ not a value

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpnuqLMy/main.rs:1:430
  |
1 | ..._directory (path) ; let mut is_symlink = is_symbolic_link (path) ; let mut can_read = is_readable (path) ; let mut can_write = is_writ...
  |                                                               ^^^^ not a value

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpnuqLMy/main.rs:1:470
  |
1 | ... is_symbolic_link (path) ; let mut can_read = is_readable (path) ; let mut can_write = is_writable (path) ; let mut can_execute = is_e...
  |                                                               ^^^^ not a value

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpnuqLMy/main.rs:1:511
  |
1 | ...ad = is_readable (path) ; let mut can_write = is_writable (path) ; let mut can_execute = is_executable (path) } ; if let Some (s) = (&...
  |                                                               ^^^^ not a value

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpnuqLMy/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut exists = file_exists ("config.json" . to_string ()) ; let mut siz...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpnuqLMy/main.rs:1:82
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut exists = file_exists ("config.json" . to_string ()) ; let mut siz...
  |                                                                                  ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_size` in this scope
 --> /tmp/.tmpnuqLMy/main.rs:1:142
  |
1 | ...s ("config.json" . to_string ()) ; let mut size = file_size ("data.csv" . to_string ()) ; let mut modified = file_modified_time ("log....
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_modified_time` in this scope
 --> /tmp/.tmpnuqLMy/main.rs:1:201
  |
1 | ...ata.csv" . to_string ()) ; let mut modified = file_modified_time ("log.txt" . to_string ()) ; let mut is_read_only = is_readonly ("sys...
  |                                                  ^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_readonly` in this scope
 --> /tmp/.tmpnuqLMy/main.rs:1:272
  |
1 | ...og.txt" . to_string ()) ; let mut is_read_only = is_readonly ("system.conf" . to_string ()) ; let mut is_file = is_file (path) ; let m...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_file` in this scope
 --> /tmp/.tmpnuqLMy/main.rs:1:335
  |
1 | ...("system.conf" . to_string ()) ; let mut is_file = is_file (path) ; let mut is_dir = is_directory (path) ; let mut is_symlink = is_sym...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_directory` in this scope
 --> /tmp/.tmpnuqLMy/main.rs:1:369
  |
1 | ... mut is_file = is_file (path) ; let mut is_dir = is_directory (path) ; let mut is_symlink = is_symbolic_link (path) ; let mut can_read...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_symbolic_link` in this scope
 --> /tmp/.tmpnuqLMy/main.rs:1:412
  |
1 | ...r = is_directory (path) ; let mut is_symlink = is_symbolic_link (path) ; let mut can_read = is_readable (path) ; let mut can_write = i...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_readable` in this scope
 --> /tmp/.tmpnuqLMy/main.rs:1:457
  |
1 | ...k = is_symbolic_link (path) ; let mut can_read = is_readable (path) ; let mut can_write = is_writable (path) ; let mut can_execute = i...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_writable` in this scope
 --> /tmp/.tmpnuqLMy/main.rs:1:498
  |
1 | ..._read = is_readable (path) ; let mut can_write = is_writable (path) ; let mut can_execute = is_executable (path) } ; if let Some (s) =...
  |                                                     ^^^^^^^^^^^ not found in this scope

error: aborting due to 15 previous errors; 1 warning emitted

Some errors have detailed explanations: E0423, E0425.
For more information about an error, try `rustc --explain E0423`.



=== ch06-00-file-operations example 4 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `create_dir` in this scope
 --> /tmp/.tmpq7G7Cx/main.rs:1:280
  |
1 | ... process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" ....
  |                                                      ^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::create_dir;
  |

error[E0425]: cannot find function `create_dir_all` in this scope
 --> /tmp/.tmpq7G7Cx/main.rs:1:323
  |
1 | ...() { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" ....
  |                                                    ^^^^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::create_dir_all;
  |

error[E0425]: cannot find function `remove_dir` in this scope
 --> /tmp/.tmpq7G7Cx/main.rs:1:381
  |
1 | ...ir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" ...
  |                                                      ^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_dir;
  |

error[E0425]: cannot find function `remove_dir_all` in this scope
 --> /tmp/.tmpq7G7Cx/main.rs:1:426
  |
1 | ... ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_dir_all;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpq7G7Cx/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let p...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpq7G7Cx/main.rs:1:76
  |
1 | ... { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } ...
  |       ^^                                                                                                                                                                                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
1 + use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpq7G7Cx/main.rs:1:129
  |
1 | ... { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } ...
  |       ^^                                                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
1 + use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpq7G7Cx/main.rs:1:194
  |
1 | ...h = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
1 + use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { walk_directory (path) } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpq7G7Cx/main.rs:1:229
  |
1 | ..._directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . t...
  |                                                           ^^                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
1 + use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { process_file (path) } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
  |

error[E0425]: cannot find function `list_dir` in this scope
 --> /tmp/.tmpq7G7Cx/main.rs:1:92
  |
1 | use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let p...
  |                                                                                            ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpq7G7Cx/main.rs:1:144
  |
1 | ...st_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else {...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_directory` in this scope
 --> /tmp/.tmpq7G7Cx/main.rs:1:172
  |
1 | ...ems { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } ...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpq7G7Cx/main.rs:1:196
  |
1 | ...r , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ...
  |                ---------------------------^^^^^^^^^^^^^^^^^^^^^-------------------------------------
  |                |                          |
  |                |                          expected `()`, found `i32`
  |                expected this to be `()`
  |
help: consider using a semicolon here
  |
1 | use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path); } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
  |                                                                                                                                                                                                                         +
help: consider using a semicolon here
  |
1 | use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } }; } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
  |                                                                                                                                                                                                                                                              +
help: you might have meant to return this value
  |
1 | use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { return walk_directory (path); } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
  |                                                                                                                                                                                                    ++++++                      +

error[E0425]: cannot find function `process_file` in this scope
 --> /tmp/.tmpq7G7Cx/main.rs:1:231
  |
1 | ...ry (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpq7G7Cx/main.rs:1:109
  |
1 | ...-> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } ...
  |       ---                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |       |
  |       expected `i32` because of return type
  |
  = note: `for` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } /* `i32` value */ } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
  |                                                                                                                                                                                                                                                                     +++++++++++++++++

error[E0425]: cannot find function `list_dir` in this scope
 --> /tmp/.tmpq7G7Cx/main.rs:1:503
  |
1 | ...th_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `list_files` in this scope
 --> /tmp/.tmpq7G7Cx/main.rs:1:556
  |
1 | ...t_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_str...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `list_directories` in this scope
 --> /tmp/.tmpq7G7Cx/main.rs:1:610
  |
1 | ...les ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 13 previous errors; 5 warnings emitted

Some errors have detailed explanations: E0308, E0425.
For more information about an error, try `rustc --explain E0308`.



=== ch06-00-file-operations example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch06-00-file-operations example 6 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `min_size` in this scope
 --> /tmp/.tmp3am531/main.rs:1:397
  |
1 | ...th) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { du...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `file_hashes` in this scope
 --> /tmp/.tmp3am531/main.rs:1:445
  |
1 | ... min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collection...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `duplicates` in this scope
 --> /tmp/.tmp3am531/main.rs:1:478
  |
1 | ...file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String >...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `file_hashes` in this scope
 --> /tmp/.tmp3am531/main.rs:1:650
  |
1 | ... () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `file_hashes` in this scope
 --> /tmp/.tmp3am531/main.rs:1:911
  |
1 | ...) , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `remove_file` in this scope
 --> /tmp/.tmp3am531/main.rs:1:3055
  |
1 | ... . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , ...
  |                                                     ^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_file;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp3am531/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp3am531/main.rs:1:72
  |
1 | ...n hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) ->...
  |                                      ^^                                                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { let content = read_bytes (path) ; return sha256 (content) } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp3am531/main.rs:1:179
  |
1 | ... { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp3am531/main.rs:1:232
  |
1 | ... { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp3am531/main.rs:1:297
  |
1 | ...h = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size ...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { scan_directory (path) } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp3am531/main.rs:1:352
  |
1 | ... { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp3am531/main.rs:1:408
  |
1 | ... { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp3am531/main.rs:1:476
  |
1 | ... { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp3am531/main.rs:1:909
  |
1 | ...() , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { printl...
  |                                                    ^^                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { file_hashes [hash as usize] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp3am531/main.rs:1:2015
  |
1 | ...earch_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}...
  |                                               ^^                                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { println ! ("\n✅ No duplicate files found!") } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

error[E0425]: cannot find function `read_bytes` in this scope
 --> /tmp/.tmp3am531/main.rs:1:90
  |
1 | use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } ...
  |                                                                                          ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `sha256` in this scope
 --> /tmp/.tmp3am531/main.rs:1:117
  |
1 | ... i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list...
  |                                                        ^^^^^^ not found in this scope

error[E0425]: cannot find function `list_dir` in this scope
 --> /tmp/.tmp3am531/main.rs:1:195
  |
1 | ...can_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmp3am531/main.rs:1:247
  |
1 | ...st_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else {...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_directory` in this scope
 --> /tmp/.tmp3am531/main.rs:1:275
  |
1 | ...ems { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let ...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmp3am531/main.rs:1:299
  |
1 | ... ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } ...
  |       ---------------------------^^^^^^^^^^^^^^^^^^^^^-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  |       |                          |
  |       |                          expected `()`, found `i32`
  |       expected this to be `()`
  |
help: consider using a semicolon here
  |
1 | use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path); } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                +
help: consider using a semicolon here
  |
1 | use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } }; } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   +
help: you might have meant to return this value
  |
1 | use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { return scan_directory (path); } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |                                                                                                                                                                                                                                                                                                           ++++++                      +

error[E0425]: cannot find function `is_file` in this scope
 --> /tmp/.tmp3am531/main.rs:1:335
  |
1 | ...ory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let ha...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_size` in this scope
 --> /tmp/.tmp3am531/main.rs:1:367
  |
1 | ...th) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_h...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmp3am531/main.rs:1:212
  |
1 | ...-> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } ...
  |       ---                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |       |
  |       expected `i32` because of return type
  |
  = note: `for` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } /* `i32` value */ } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let mut search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++++

error[E0599]: no method named `to_i` found for struct `String` in the current scope
 --> /tmp/.tmp3am531/main.rs:1:1788
  |
1 | ...ends_with ('\r') { input . pop () ; } } input } . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , ...
  |                                                      ^^^^ method not found in `String`

error[E0308]: mismatched types
 --> /tmp/.tmp3am531/main.rs:1:1971
  |
1 | ... () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files ...
  |                                          --------------  ^^^^^^^^^^ expected `i32`, found `String`
  |                                          |
  |                                          arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmp3am531/main.rs:1:143
  |
1 | ... read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in...
  |                                                          ^^^^^^^^^^^^^^  ---------

error[E0599]: no method named `to_s` found for type `usize` in the current scope
 --> /tmp/.tmp3am531/main.rs:1:2178
  |
1 | ...}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplica...
  |                                                       ^^^^ method not found in `usize`

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmp3am531/main.rs:1:2469
  |
1 | ...rintln ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , for...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmp3am531/main.rs:1:2597
  |
1 | ... , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = { print ! ("{}" , "\nDelete duplicate...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `lower` found for struct `String` in the current scope
 --> /tmp/.tmp3am531/main.rs:1:3009
  |
1 | ...\r') { input . pop () ; } } input } ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; printl...
  |                                                      ^^^^^ method not found in `String`

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmp3am531/main.rs:1:3237
  |
1 | ...at ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |                                                      ^^^^^^^^^^^ not found in this scope

error: aborting due to 22 previous errors; 10 warnings emitted

Some errors have detailed explanations: E0308, E0425, E0599.
For more information about an error, try `rustc --explain E0308`.



=== ch06-00-file-operations example 7 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmpXxEF6Q/main.rs:1:853
  |
1 | ... , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = for...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0425]: cannot find function `remove_file` in this scope
 --> /tmp/.tmpXxEF6Q/main.rs:1:1140
  |
1 | ... { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } }...
  |                                                     ^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_file;
  |

error[E0425]: cannot find function `remove_file` in this scope
 --> /tmp/.tmpXxEF6Q/main.rs:1:1434
  |
1 | ...ath , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" ,...
  |                                                     ^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_file;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpXxEF6Q/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===") ; let mut log_config = { let mu...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpXxEF6Q/main.rs:1:627
  |
1 | ... { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===") ; let mut log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("max_size" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert ("max_backups" . to_string () , (5i32) . to_string ()) ; map . insert ("compress" . to_string () , (true) . to_string ()) ; map } ; let mut log_dir = "/var/log/myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===") ; let mut log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("max_size" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert ("max_backups" . to_string () , (5i32) . to_string ()) ; map . insert ("compress" . to_string () , (true) . to_string ()) ; map } ; let mut log_dir = "/var/log/myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXxEF6Q/main.rs:1:911
  |
1 | ... { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===") ; let mut log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("max_size" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert ("max_backups" . to_string () , (5i32) . to_string ()) ; map . insert ("compress" . to_string () , (true) . to_string ()) ; map } ; let mut log_dir = "/var/log/myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===") ; let mut log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("max_size" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert ("max_backups" . to_string () , (5i32) . to_string ()) ; map . insert ("compress" . to_string () , (true) . to_string ()) ; map } ; let mut log_dir = "/var/log/myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXxEF6Q/main.rs:1:1094
  |
1 | ... { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } }...
  |       ^^                                                                                                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===") ; let mut log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("max_size" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert ("max_backups" . to_string () , (5i32) . to_string ()) ; map . insert ("compress" . to_string () , (true) . to_string ()) ; map } ; let mut log_dir = "/var/log/myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===") ; let mut log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("max_size" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert ("max_backups" . to_string () , (5i32) . to_string ()) ; map . insert ("compress" . to_string () , (true) . to_string ()) ; map } ; let mut log_dir = "/var/log/myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXxEF6Q/main.rs:1:1138
  |
1 | ...ackup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } }...
  |                                                         ^^                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===") ; let mut log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("max_size" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert ("max_backups" . to_string () , (5i32) . to_string ()) ; map . insert ("compress" . to_string () , (true) . to_string ()) ; map } ; let mut log_dir = "/var/log/myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===") ; let mut log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("max_size" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert ("max_backups" . to_string () , (5i32) . to_string ()) ; map . insert ("compress" . to_string () , (true) . to_string ()) ; map } ; let mut log_dir = "/var/log/myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { remove_file (old_backup) } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXxEF6Q/main.rs:1:1176
  |
1 | ... 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! (...
  |                                                  ^^                                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===") ; let mut log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("max_size" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert ("max_backups" . to_string () , (5i32) . to_string ()) ; map . insert ("compress" . to_string () , (true) . to_string ()) ; map } ; let mut log_dir = "/var/log/myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===") ; let mut log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("max_size" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert ("max_backups" . to_string () , (5i32) . to_string ()) ; map . insert ("compress" . to_string () , (true) . to_string ()) ; map } ; let mut log_dir = "/var/log/myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { rename_file (old_backup , new_backup) } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpXxEF6Q/main.rs:1:551
  |
1 | ...myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `glob` in this scope
 --> /tmp/.tmpXxEF6Q/main.rs:1:545
  |
1 | .../var/log/myapp" . to_string () ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files {...
  |                                                         ^^^^ not found in this scope

error[E0425]: cannot find function `file_size` in this scope
 --> /tmp/.tmpXxEF6Q/main.rs:1:642
  |
1 | ...())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , forma...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0609]: no field `max_size` on type `HashMap<String, String>`
 --> /tmp/.tmpXxEF6Q/main.rs:1:688
  |
1 | ...et size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ...
  |                                                            ^^^^^^^^ unknown field

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpXxEF6Q/main.rs:1:812
  |
1 | ...at ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i3...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0609]: no field `max_backups` on type `HashMap<String, String>`
 --> /tmp/.tmpXxEF6Q/main.rs:1:873
  |
1 | ...size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , lo...
  |                                                          ^^^^^^^^^^^ unknown field

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpXxEF6Q/main.rs:1:1054
  |
1 | ...p = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 ...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpXxEF6Q/main.rs:1:1067
  |
1 | ...}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0609]: no field `max_backups` on type `HashMap<String, String>`
 --> /tmp/.tmpXxEF6Q/main.rs:1:1117
  |
1 | ... if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_ba...
  |                                                          ^^^^^^^^^^^ unknown field

error[E0425]: cannot find function `rename_file` in this scope
 --> /tmp/.tmpXxEF6Q/main.rs:1:1178
  |
1 | ...- 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `rename_file` in this scope
 --> /tmp/.tmpXxEF6Q/main.rs:1:1294
  |
1 | ...p_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (ba...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0609]: no field `compress` on type `HashMap<String, String>`
 --> /tmp/.tmpXxEF6Q/main.rs:1:1349
  |
1 | ... rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".g...
  |                                                            ^^^^^^^^ unknown field

error[E0425]: cannot find function `compress_file` in this scope
 --> /tmp/.tmpXxEF6Q/main.rs:1:1362
  |
1 | ...e , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (b...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpXxEF6Q/main.rs:1:1570
  |
1 | ..."  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "...
  |                                                      ^^^^^^^^^^ not found in this scope

error: aborting due to 17 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0425, E0599, E0609.
For more information about an error, try `rustc --explain E0425`.



=== ch06-00-file-operations example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch06-00-file-operations example 9 ===
✗ Compilation failed: Compilation failed:
error[E0423]: expected value, found macro `try`
 --> /tmp/.tmpQN5Efe/main.rs:1:338
  |
1 | ...: No read permission for: " , path)) ; return false } } ; r#try ; { { let content = read_file (path) ; { process_content (content) ; r...
  |                                                              ^^^^^ not a value

error[E0425]: cannot find value `catch` in this scope
 --> /tmp/.tmpQN5Efe/main.rs:1:433
  |
1 | ...; { process_content (content) ; return true } } } ; catch ; error ; { println ! ("{:?}" , format ! ("{}{}" , "Error processing file: "...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpQN5Efe/main.rs:1:441
  |
1 | ...ess_content (content) ; return true } } } ; catch ; error ; { println ! ("{:?}" , format ! ("{}{}" , "Error processing file: " , error...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpQN5Efe/main.rs:1:518
  |
1 | ...}" , format ! ("{}{}" , "Error processing file: " , error . to_s ())) ; { let error_log = "errors.log" . to_string () ; { let mut time...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpQN5Efe/main.rs:1:758
  |
1 | ...{}" , timestamp . to_s () , ": ") + path , " - ") + error . to_s () , "\n")) ; return false } } } } } fn main () { }
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpQN5Efe/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn safe_file_operation (path : i32) -> i32 { { if ! file_exists (path) { { println ! ("{:?}" , format...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpQN5Efe/main.rs:1:89
  |
1 | use std :: collections :: HashMap ; fn safe_file_operation (path : i32) -> i32 { { if ! file_exists (path) { { println ! ("{:?}" , format...
  |                                                                                         ^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpQN5Efe/main.rs:1:195
  |
1 | ...-> i32 { { if ! file_exists (path) { { println ! ("{:?}" , format ! ("{}{}" , "Error: File not found: " , path)) ; return false } } ; ...
  |       --- expected `i32` because of return type                                                                              ^^^^^ expected `i32`, found `bool`

error[E0425]: cannot find function `is_readable` in this scope
 --> /tmp/.tmpQN5Efe/main.rs:1:212
  |
1 | ... not found: " , path)) ; return false } } ; if ! is_readable (path) { { println ! ("{:?}" , format ! ("{}{}" , "Error: No read permiss...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpQN5Efe/main.rs:1:364
  |
1 | ...)) ; return false } } ; r#try ; { { let content = read_file (path) ; { process_content (content) ; return true } } } ; catch ; error ;...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `process_content` in this scope
 --> /tmp/.tmpQN5Efe/main.rs:1:385
  |
1 | ...r#try ; { { let content = read_file (path) ; { process_content (content) ; return true } } } ; catch ; error ; { println ! ("{:?}" , f...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

warning: unreachable statement
 --> /tmp/.tmpQN5Efe/main.rs:1:433
  |
1 | ...th) ; { process_content (content) ; return true } } } ; catch ; error ; { println ! ("{:?}" , format ! ("{}{}" , "Error processing fil...
  |                                        -----------         ^^^^^^^ unreachable statement
  |                                        |
  |                                        any code following this expression is unreachable
  |
  = note: `#[warn(unreachable_code)]` on by default

error[E0425]: cannot find function `current_datetime` in this scope
 --> /tmp/.tmpQN5Efe/main.rs:1:608
  |
1 | ...rs.log" . to_string () ; { let mut timestamp = current_datetime () ; append_file (error_log , format ! ("{}{}" , format ! ("{}{}" , fo...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpQN5Efe/main.rs:1:742
  |
1 | ... format ! ("{}{}" , timestamp . to_s () , ": ") + path , " - ") + error . to_s () , "\n")) ; return false } } } } } fn main () { }
  |                                                      ^^^^ expected `&str`, found `i32`

error[E0425]: cannot find function `append_file` in this scope
 --> /tmp/.tmpQN5Efe/main.rs:1:630
  |
1 | ...() ; { let mut timestamp = current_datetime () ; append_file (error_log , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , tim...
  |                                                     ^^^^^^^^^^^ not found in this scope

error: aborting due to 13 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0308, E0423, E0425.
For more information about an error, try `rustc --explain E0308`.



=== ch06-00-file-operations example 10 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpudkiAW/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files ("data" . to_string ()) ; for file in files { ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpudkiAW/main.rs:1:138
  |
1 | ... { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } }...
  |       ^^                                                                                                                           ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files ("data" . to_string ()) ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files ("data" . to_string ()) ; for file in files { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpudkiAW/main.rs:1:195
  |
1 | ...ze (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } } ; if let Some (s) = (& r...
  |                                       ^^                                                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files ("data" . to_string ()) ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files ("data" . to_string ()) ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `list_files` in this scope
 --> /tmp/.tmpudkiAW/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files ("data" . to_string ()) ; for file in files { ...
  |                                                                                 ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_size` in this scope
 --> /tmp/.tmpudkiAW/main.rs:1:153
  |
1 | ...o_string ()) ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "la...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `move_file` in this scope
 --> /tmp/.tmpudkiAW/main.rs:1:197
  |
1 | ...ize = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } } ; if let So...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch20-00-tooling example 1 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp6BMxru/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; retur...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp6BMxru/main.rs:1:79
  |
1 | ...ate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = ...
  |                                     ^^                                                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{:?}" , result) } } }
1 + use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{:?}" , result) } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp6BMxru/main.rs:1:163
  |
1 | ...turn y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{:?}" , result) } } }
  |                                ^^                                                                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{:?}" , result) } } }
1 + use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { let result = calculate_something (10i32) ; println ! ("{:?}" , result) } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp6BMxru/main.rs:1:126
  |
1 | ...2 { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ;...
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot add `i32` to `i64`
 --> /tmp/.tmp6BMxru/main.rs:1:124
  |
1 | ...2 { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ;...
  |                                                     ^ no implementation for `i64 + i32`
  |
  = help: the trait `Add<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Add<Rhs>`:
            `&i64` implements `Add<i64>`
            `&i64` implements `Add`
            `i64` implements `Add<&i64>`
            `i64` implements `Add`

error[E0308]: mismatched types
 --> /tmp/.tmp6BMxru/main.rs:1:140
  |
1 | ...thing (x : i64) -> i32 { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculat...
  |                       --- expected `i32` because of return type                          ^ expected `i32`, found `i64`
  |
help: you can convert an `i64` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y.try_into().unwrap() } } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{:?}" , result) } } }
  |                                                                                                                                             ++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmp6BMxru/main.rs:1:201
  |
1 | ... } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{:?}" , result) } } }
  |                                         -------------------  ^^^^^ expected `i64`, found `i32`
  |                                         |
  |                                         arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmp6BMxru/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; retur...
  |                                        ^^^^^^^^^^^^^^^^^^^  -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{:?}" , result) } } }
1 + use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i64) ; println ! ("{:?}" , result) } } }
  |

error: aborting due to 4 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.



=== ch20-00-tooling example 2 ===
✗ Compilation failed: Compilation failed:
error[E0428]: the name `fibonacci` is defined multiple times
 --> /tmp/.tmpuFC7fX/main.rs:1:155
  |
1 | ... ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { ...
  |       ----------------------------- previous definition of the value `fibonacci` here                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `fibonacci` redefined here
  |
  = note: `fibonacci` must be defined only once in the value namespace of this module

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpuFC7fX/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpuFC7fX/main.rs:1:69
  |
1 | ...nacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) ...
  |                             ^^                                                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpuFC7fX/main.rs:1:86
  |
1 | use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n...
  |                                                                                      ^^ ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { n } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpuFC7fX/main.rs:1:101
  |
1 | ...) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if ...
  |                                               ^^                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpuFC7fX/main.rs:1:187
  |
1 | ...nacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |                             ^^                                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpuFC7fX/main.rs:1:204
  |
1 | ... 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } f...
  |                                                                    ^^ ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { n } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpuFC7fX/main.rs:1:219
  |
1 | ...) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |                                               ^^                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpuFC7fX/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n...
  |                                                                          -    ^^^^ expected `i64`, found `i32`
  |                                                                          |
  |                                                                          expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i64 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpuFC7fX/main.rs:1:118
  |
1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32...
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmpuFC7fX/main.rs:1:116
  |
1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32...
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmpuFC7fX/main.rs:1:141
  |
1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fib...
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmpuFC7fX/main.rs:1:139
  |
1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fib...
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmpuFC7fX/main.rs:1:197
  |
1 | ...2) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn ma...
  |                                                    -    ^^^^ expected `i64`, found `i32`
  |                                                    |
  |                                                    expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i64 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpuFC7fX/main.rs:1:236
  |
1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmpuFC7fX/main.rs:1:234
  |
1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmpuFC7fX/main.rs:1:259
  |
1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmpuFC7fX/main.rs:1:257
  |
1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error: aborting due to 11 previous errors; 7 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0428.
For more information about an error, try `rustc --explain E0277`.



=== ch20-00-tooling example 3 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpxm9qOS/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpxm9qOS/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                                                         ^^     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { a + b } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpxm9qOS/main.rs:1:126
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                                                                                                              ^^     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { a * b } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpxm9qOS/main.rs:1:177
  |
1 | ...b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (...
  |                                                 ^^^  ----   ---- expected `i64`, found `i32`
  |                                                      |
  |                                                      expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpxm9qOS/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                        ^^^  -------   -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i64 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i64) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpxm9qOS/main.rs:1:197
  |
1 | ...add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) ,...
  |                                                       ^^^^ expected `i64`, found `i32`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i64) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpxm9qOS/main.rs:1:218
  |
1 | ...! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply ...
  |                                                ^^^  ------   ---- expected `i64`, found `i32`
  |                                                     |
  |                                                     expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpxm9qOS/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                        ^^^  -------   -------
help: you can convert an `i32` to an `i64`
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add ((- 1i32).into() , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                                                                                                               +      ++++++++
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i64) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpxm9qOS/main.rs:1:240
  |
1 | ...3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { a...
  |                                                       ^^^^ expected `i64`, found `i32`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i64) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpxm9qOS/main.rs:1:261
  |
1 | ... (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 ...
  |                                                 ^^^  ----   ---- expected `i64`, found `i32`
  |                                                      |
  |                                                      expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpxm9qOS/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                        ^^^  -------   -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i64 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i64) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpxm9qOS/main.rs:1:281
  |
1 | ..., 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32...
  |                                                       ^^^^ expected `i64`, found `i32`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i64) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpxm9qOS/main.rs:1:248
  |
1 | ... ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i3...
  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpxm9qOS/main.rs:1:335
  |
1 | ... test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq...
  |                                              ^^^^^^^^  ----   ---- expected `i64`, found `i32`
  |                                                        |
  |                                                        expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpxm9qOS/main.rs:1:88
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                                                                        ^^^^^^^^  -------   -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i64 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i64) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpxm9qOS/main.rs:1:360
  |
1 | ...) -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i...
  |                                                       ^^^^ expected `i64`, found `i32`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i64) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpxm9qOS/main.rs:1:381
  |
1 | ...ply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn mai...
  |                                             ^^^^^^^^  ------   ---- expected `i64`, found `i32`
  |                                                       |
  |                                                       expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpxm9qOS/main.rs:1:88
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                                                                        ^^^^^^^^  -------   -------
help: you can convert an `i32` to an `i64`
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply ((- 1i32).into() , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                       +      ++++++++
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i64) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpxm9qOS/main.rs:1:408
  |
1 | ..., 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                      ^^^^^^ expected `i64`, found `i32`
  |
help: you can convert an `i32` to an `i64`
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , (- 5i32).into()) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                        +      ++++++++

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpxm9qOS/main.rs:1:431
  |
1 | ...(- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                             ^^^^^^^^  ----   ------ expected `i64`, found `i32`
  |                                                       |
  |                                                       expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpxm9qOS/main.rs:1:88
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                                                                        ^^^^^^^^  -------   -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i64 , 100i32) , 0i32) } } fn main () { }
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i64) , 0i32) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpxm9qOS/main.rs:1:458
  |
1 | ... - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                       ^^^^ expected `i64`, found `i32`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i64) } } fn main () { }
  |

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpxm9qOS/main.rs:1:418
  |
1 | ...ly (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 14 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0308, E0317.
For more information about an error, try `rustc --explain E0308`.



=== ch20-00-tooling example 4 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpjQMW5e/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () -> i...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpjQMW5e/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () -> i...
  |                                                                                ^^ ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () -> i32 { { property_test (| s | { assert_eq ! (reverse_string (reverse_string (s)) , s) }) } } fn main () { }
1 + use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { s } fn property_test_reverse_twice_is_identity () -> i32 { { property_test (| s | { assert_eq ! (reverse_string (reverse_string (s)) , s) }) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpjQMW5e/main.rs:1:143
  |
1 | ..._is_identity () -> i32 { { property_test (| s | { assert_eq ! (reverse_string (reverse_string (s)) , s) }) } } fn main () { }
  |                             ^^                                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () -> i32 { { property_test (| s | { assert_eq ! (reverse_string (reverse_string (s)) , s) }) } } fn main () { }
1 + use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () -> i32 { property_test (| s | { assert_eq ! (reverse_string (reverse_string (s)) , s) }) } fn main () { }
  |

error[E0425]: cannot find function `property_test` in this scope
 --> /tmp/.tmpjQMW5e/main.rs:1:145
  |
1 | ...ty_test_reverse_twice_is_identity () -> i32 { { property_test (| s | { assert_eq ! (reverse_string (reverse_string (s)) , s) }) } } fn...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch20-00-tooling example 5 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpVPnyhw/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative number...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpVPnyhw/main.rs:1:85
  |
1 | ...al (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i3...
  |                                          ^^                                                      ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { panic ! ("Factorial not defined for negative numbers") } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpVPnyhw/main.rs:1:176
  |
1 | ...fined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                                   ^^    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { 1i32 } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpVPnyhw/main.rs:1:194
  |
1 | ... } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                         ^^                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { n * factorial (n - 1i32) } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpVPnyhw/main.rs:1:78
  |
1 | use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative number...
  |                                                                          -   ^^^^ expected `i64`, found `i32`
  |                                                                          |
  |                                                                          expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i64 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpVPnyhw/main.rs:1:156
  |
1 | ...ial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main ...
  |                                                    -    ^^^^ expected `i64`, found `i32`
  |                                                    |
  |                                                    expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i64 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpVPnyhw/main.rs:1:169
  |
1 | ...ed for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                    -    ^^^^ expected `i64`, found `i32`
  |                                                    |
  |                                                    expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i64 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpVPnyhw/main.rs:1:178
  |
1 | ...) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else ...
  |         --- expected `i64` because of return type                                                                          ^^^^ expected `i64`, found `i32`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i64 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpVPnyhw/main.rs:1:215
  |
1 | ...n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmpVPnyhw/main.rs:1:213
  |
1 | ...n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error: aborting due to 6 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.



=== ch20-00-tooling example 6 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmp2dCTmB/main.rs:1:276
  |
1 | ... { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_rec...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp2dCTmB/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp2dCTmB/main.rs:1:79
  |
1 | ... i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_...
  |                   ^^                                                                                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp2dCTmB/main.rs:1:96
  |
1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - ...
  |                                                                                                ^^ ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { n } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp2dCTmB/main.rs:1:111
  |
1 | ... { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n :...
  |                                     ^^                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp2dCTmB/main.rs:1:288
  |
1 | ... ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 ...
  |                                               ^^                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { let temp = a + b ; { a = b ; b = temp } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp2dCTmB/main.rs:1:381
  |
1 | ...ecursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib...
  |                             ^^                                                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp2dCTmB/main.rs:1:503
  |
1 | ...terative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |                             ^^                                                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp2dCTmB/main.rs:1:89
  |
1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - ...
  |                                                                                    -    ^^^^ expected `i64`, found `i32`
  |                                                                                    |
  |                                                                                    expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i64 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp2dCTmB/main.rs:1:138
  |
1 | ...= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> ...
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmp2dCTmB/main.rs:1:136
  |
1 | ...= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> ...
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmp2dCTmB/main.rs:1:171
  |
1 | ...ci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mu...
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmp2dCTmB/main.rs:1:169
  |
1 | ...ci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mu...
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmp2dCTmB/main.rs:1:340
  |
1 | ...) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn b...
  |         --- expected `i64` because of return type                                                                              ^ expected `i64`, found `i32`
  |
help: you can convert an `i32` to an `i64`
  |
1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a.into() } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                     +++++++

error[E0308]: mismatched types
 --> /tmp/.tmp2dCTmB/main.rs:1:456
  |
1 | ...ci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative...
  |                                         -------------------  ^^^^^ expected `i64`, found `i32`
  |                                         |
  |                                         arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmp2dCTmB/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - ...
  |                                        ^^^^^^^^^^^^^^^^^^^  -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i64)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

error[E0423]: expected function, found attribute macro `bench`
 --> /tmp/.tmp2dCTmB/main.rs:1:383
  |
1 | ...emp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i3...
  |                                                             ^^^^^ not a function

error[E0308]: mismatched types
 --> /tmp/.tmp2dCTmB/main.rs:1:578
  |
1 | ...ci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |                                         -------------------  ^^^^^ expected `i64`, found `i32`
  |                                         |
  |                                         arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmp2dCTmB/main.rs:1:188
  |
1 | ...- 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for...
  |                                                        ^^^^^^^^^^^^^^^^^^^  -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i64)) } } fn main () { }
  |

error[E0423]: expected function, found attribute macro `bench`
 --> /tmp/.tmp2dCTmB/main.rs:1:505
  |
1 | ...ursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i3...
  |                                                             ^^^^^ not a function

error: aborting due to 11 previous errors; 7 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0423, E0425.
For more information about an error, try `rustc --explain E0277`.



=== ch07-00-building-applications example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch07-00-building-applications example 2 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `User` in this scope
 --> /tmp/.tmpisYQoV/main.rs:1:109
  |
1 | ...e : String , email : String) -> i32 { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . ema...
  |                                                         ^^^^ not found in this scope

error[E0425]: cannot find value `null` in this scope
 --> /tmp/.tmpisYQoV/main.rs:1:1125
  |
1 | ...Map :: new () ; map . insert ("id" . to_string () , (null) . to_string ()) ; map . insert ("name" . to_string () , ("") . to_string ()...
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::ptr::null;
  |

error[E0425]: cannot find value `null` in this scope
 --> /tmp/.tmpisYQoV/main.rs:1:1314
  |
1 | ...ring ()) ; map . insert ("created" . to_string () , (null) . to_string ()) ; map } ; { init_app () ; load_config () ; run_event_loop (...
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::ptr::null;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpisYQoV/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn create_user (name : String , email : String) -> i32 { { { let user = User . copy () ; { user . id ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpisYQoV/main.rs:1:94
  |
1 | ... { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } ...
  |       ^^                                                                                                                                                                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn create_user (name : String , email : String) -> i32 { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user (user : String) { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{:?}" , format ! ("{}{}" , "Member since: " , user . created)) } } fn main () { let mut APP = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("name" . to_string () , ("MyApp") . to_string ()) ; map . insert ("version" . to_string () , ("1.0.0") . to_string ()) ; map . insert ("config_dir" . to_string () , ("~/.config/myapp") . to_string ()) ; map . insert ("data_dir" . to_string () , ("~/.local/share/myapp") . to_string ()) ; map . insert ("cache_dir" . to_string () , ("~/.cache/myapp") . to_string ()) ; map } ; let mut User = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("id" . to_string () , (null) . to_string ()) ; map . insert ("name" . to_string () , ("") . to_string ()) ; map . insert ("email" . to_string () , ("") . to_string ()) ; map . insert ("created" . to_string () , (null) . to_string ()) ; map } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
1 + use std :: collections :: HashMap ; fn create_user (name : String , email : String) -> i32 { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } fn display_user (user : String) { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{:?}" , format ! ("{}{}" , "Member since: " , user . created)) } } fn main () { let mut APP = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("name" . to_string () , ("MyApp") . to_string ()) ; map . insert ("version" . to_string () , ("1.0.0") . to_string ()) ; map . insert ("config_dir" . to_string () , ("~/.config/myapp") . to_string ()) ; map . insert ("data_dir" . to_string () , ("~/.local/share/myapp") . to_string ()) ; map . insert ("cache_dir" . to_string () , ("~/.cache/myapp") . to_string ()) ; map } ; let mut User = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("id" . to_string () , (null) . to_string ()) ; map . insert ("name" . to_string () , ("") . to_string ()) ; map . insert ("email" . to_string () , ("") . to_string ()) ; map . insert ("created" . to_string () , (null) . to_string ()) ; map } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |

error[E0425]: cannot find function `generate_uuid` in this scope
 --> /tmp/.tmpisYQoV/main.rs:1:140
  |
1 | ...{ { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = curren...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `current_datetime` in this scope
 --> /tmp/.tmpisYQoV/main.rs:1:220
  |
1 | ...name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user (user : String) { { println !...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0609]: no field `name` on type `String`
 --> /tmp/.tmpisYQoV/main.rs:1:334
  |
1 | ...r (user : String) { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{:?}" , format ! ("{}{}" , "Member since:...
  |                                                              ^^^^ unknown field

error[E0609]: no field `email` on type `String`
 --> /tmp/.tmpisYQoV/main.rs:1:348
  |
1 | ...g) { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{:?}" , format ! ("{}{}" , "Member since: " , user . cre...
  |                                                             ^^^^^ unknown field

error[E0609]: no field `created` on type `String`
 --> /tmp/.tmpisYQoV/main.rs:1:422
  |
1 | ... ("{:?}" , format ! ("{}{}" , "Member since: " , user . created)) } } fn main () { let mut APP = { let mut map : std :: collections ::...
  |                                                            ^^^^^^^ unknown field

error[E0425]: cannot find function `init_app` in this scope
 --> /tmp/.tmpisYQoV/main.rs:1:1348
  |
1 | ... to_string () , (null) . to_string ()) ; map } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `load_config` in this scope
 --> /tmp/.tmpisYQoV/main.rs:1:1362
  |
1 | ...(null) . to_string ()) ; map } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `run_event_loop` in this scope
 --> /tmp/.tmpisYQoV/main.rs:1:1379
  |
1 | ... ()) ; map } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `cleanup` in this scope
 --> /tmp/.tmpisYQoV/main.rs:1:1399
  |
1 | ...init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 12 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0425, E0609.
For more information about an error, try `rustc --explain E0425`.



=== ch07-00-building-applications example 3 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpNUsUm2/main.rs:1:96
  |
1 | use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dir...
  |                                                                                                ^^^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpNUsUm2/main.rs:1:127
  |
1 | ...: String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () -> i32 { { if STATE . ...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpNUsUm2/main.rs:1:201
  |
1 | ... trigger_save () } } fn save_state () -> i32 { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `APP` in this scope
 --> /tmp/.tmpNUsUm2/main.rs:1:249
  |
1 | ...{ if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_jso...
  |                                                         ^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpNUsUm2/main.rs:1:333
  |
1 | ...to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () -> i32 { { { let stat...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpNUsUm2/main.rs:1:343
  |
1 | ...()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () -> i32 { { { let state_file = j...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `APP` in this scope
 --> /tmp/.tmpNUsUm2/main.rs:1:435
  |
1 | ...ad_state () -> i32 { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { S...
  |                                                         ^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpNUsUm2/main.rs:1:515
  |
1 | ..." . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE =...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `null` in this scope
 --> /tmp/.tmpNUsUm2/main.rs:1:823
  |
1 | ...()) ; map . insert ("current_user" . to_string () , (null) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_strin...
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::ptr::null;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpNUsUm2/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dir...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpNUsUm2/main.rs:1:196
  |
1 | ... { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } ...
  |       ^^                                                                                                                                                                              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () -> i32 { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () -> i32 { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("users" . to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (null) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; }
1 + use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () -> i32 { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } fn load_state () -> i32 { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("users" . to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (null) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpNUsUm2/main.rs:1:217
  |
1 | ... { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } ...
  |       ^^                                                                                                                                                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () -> i32 { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () -> i32 { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("users" . to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (null) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; }
1 + use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () -> i32 { { if STATE . dirty { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } fn load_state () -> i32 { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("users" . to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (null) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpNUsUm2/main.rs:1:403
  |
1 | ... { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } ...
  |       ^^                                                                                                                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () -> i32 { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () -> i32 { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("users" . to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (null) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; }
1 + use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () -> i32 { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () -> i32 { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } fn main () { let mut STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("users" . to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (null) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpNUsUm2/main.rs:1:513
  |
1 | ...string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { let ...
  |                                               ^^                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () -> i32 { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () -> i32 { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("users" . to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (null) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; }
1 + use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () -> i32 { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () -> i32 { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { STATE = parse_json (read_file (state_file)) } } } } fn main () { let mut STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("users" . to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (null) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; }
  |

error[E0425]: cannot find function `trigger_save` in this scope
 --> /tmp/.tmpNUsUm2/main.rs:1:150
  |
1 | ... [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () -> i32 { { if STATE . dirty { { { let state_file...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0605]: non-primitive cast: `String` as `usize`
 --> /tmp/.tmpNUsUm2/main.rs:1:103
  |
1 | ...ATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () -> i32 { { if STATE . dirty { { { let state_f...
  |         ^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpNUsUm2/main.rs:1:238
  |
1 | ...> i32 { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_json` in this scope
 --> /tmp/.tmpNUsUm2/main.rs:1:324
  |
1 | ...json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () -> i32 { { { ...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpNUsUm2/main.rs:1:299
  |
1 | ...ate.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () -> i32 { ...
  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `state_file`

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpNUsUm2/main.rs:1:424
  |
1 | ... } fn load_state () -> i32 { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_fil...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpNUsUm2/main.rs:1:486
  |
1 | ...P . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpNUsUm2/main.rs:1:535
  |
1 | ... file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { let mut map : std :...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `parse_json` in this scope
 --> /tmp/.tmpNUsUm2/main.rs:1:523
  |
1 | ...ing ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { let mut...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0599]: the method `to_string` exists for struct `Vec<_>`, but its trait bounds were not satisfied
   --> /tmp/.tmpNUsUm2/main.rs:1:760
    |
1   | ...to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (null) . to_string ()) ; map . insert ("sett...
    |                                ^^^^^^^^^ method cannot be called on `Vec<_>` due to unsatisfied trait bounds
    |
   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1
    |
414 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<_>: ToString` or `Vec<_>: std::fmt::Display`
    |
    = note: the following trait bounds were not satisfied:
            `Vec<_>: std::fmt::Display`
            which is required by `Vec<_>: ToString`
            `[_]: std::fmt::Display`
            which is required by `[_]: ToString`

error[E0599]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpNUsUm2/main.rs:1:896
  |
1 | ...ings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to...
  |                                  ^^^^^^^^^ method cannot be called on `()` due to unsatisfied trait bounds
  |
  = note: the following trait bounds were not satisfied:
          `(): std::fmt::Display`
          which is required by `(): ToString`

error[E0599]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpNUsUm2/main.rs:1:958
  |
1 | ...ache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; }
  |                                  ^^^^^^^^^ method cannot be called on `()` due to unsatisfied trait bounds
  |
  = note: the following trait bounds were not satisfied:
          `(): std::fmt::Display`
          which is required by `(): ToString`

error: aborting due to 21 previous errors; 5 warnings emitted

Some errors have detailed explanations: E0425, E0599, E0605.
For more information about an error, try `rustc --explain E0425`.



=== ch07-00-building-applications example 4 ===
✗ Compilation failed: Compilation failed:
error[E0423]: expected value, found macro `try`
 --> /tmp/.tmpbFSOMB/main.rs:1:116
  |
1 | use std :: collections :: HashMap ; fn safe_operation (operation_fn : String , fallback_value : String) -> i32 { { r#try ; { return opera...
  |                                                                                                                    ^^^^^ not a value

error[E0425]: cannot find value `catch` in this scope
 --> /tmp/.tmpbFSOMB/main.rs:1:153
  |
1 | ...ng) -> i32 { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry (o...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpbFSOMB/main.rs:1:161
  |
1 | ...32 { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry (operation...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpbFSOMB/main.rs:1:182
  |
1 | ...rn operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry (operation_fn : String , max_at...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmpbFSOMB/main.rs:1:307
  |
1 | ... , max_attempts : String) -> i32 { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0423]: expected value, found macro `try`
 --> /tmp/.tmpbFSOMB/main.rs:1:332
  |
1 | ...tring) -> i32 { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_att...
  |                                                              ^^^^^ not a value

error[E0425]: cannot find value `catch` in this scope
 --> /tmp/.tmpbFSOMB/main.rs:1:369
  |
1 | ..._attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{:?}" , format...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpbFSOMB/main.rs:1:377
  |
1 | ...s) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{:?}" , format ! ("{}{...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpbFSOMB/main.rs:1:546
  |
1 | ...fter " , max_attempts . to_s ()) , " attempts: ") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; ...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpbFSOMB/main.rs:1:574
  |
1 | ... ()) , " attempts: ") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Att...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `sleep` in this scope
 --> /tmp/.tmpbFSOMB/main.rs:1:724
  |
1 | ...retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::sleep;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpbFSOMB/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn safe_operation (operation_fn : String , fallback_value : String) -> i32 { { r#try ; { return opera...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpbFSOMB/main.rs:1:290
  |
1 | ... { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Failed after " , max_attempts . to_s ()) , " attempts: ") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn safe_operation (operation_fn : String , fallback_value : String) -> i32 { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry (operation_fn : String , max_attempts : String) -> i32 { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Failed after " , max_attempts . to_s ()) , " attempts: ") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn safe_operation (operation_fn : String , fallback_value : String) -> i32 { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry (operation_fn : String , max_attempts : String) -> i32 { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Failed after " , max_attempts . to_s ()) , " attempts: ") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } fn main () { }
  |

error[E0618]: expected function, found `String`
 --> /tmp/.tmpbFSOMB/main.rs:1:133
  |
1 | ...on (operation_fn : String , fallback_value : String) -> i32 { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (erro...
  |        ------------                                                                 ^^^^^^^^^^^^---
  |        |                                                                            |
  |        `operation_fn` has type `String`                                             call expression requires function

warning: unreachable statement
 --> /tmp/.tmpbFSOMB/main.rs:1:153
  |
1 | ...: String) -> i32 { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_re...
  |                                   ----------------------     ^^^^^^^ unreachable statement
  |                                   |
  |                                   any code following this expression is unreachable
  |
  = note: `#[warn(unreachable_code)]` on by default

error[E0425]: cannot find function `log_error` in this scope
 --> /tmp/.tmpbFSOMB/main.rs:1:171
  |
1 | ... ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry (operation_fn : String...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0618]: expected function, found `String`
 --> /tmp/.tmpbFSOMB/main.rs:1:349
  |
1 | ...y (operation_fn : String , max_attempts : String) -> i32 { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ...
  |       ------------                                                                                                       ^^^^^^^^^^^^---
  |       |                                                                                                                  |
  |       `operation_fn` has type `String`                                                                                   call expression requires function

warning: unreachable statement
 --> /tmp/.tmpbFSOMB/main.rs:1:369
  |
1 | ...e (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{:?}" , ...
  |                                   ----------------------     ^^^^^^^ unreachable statement
  |                                   |
  |                                   any code following this expression is unreachable

error[E0369]: cannot subtract `i32` from `String`
   --> /tmp/.tmpbFSOMB/main.rs:1:414
    |
1   | ...rn operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}"...
    |                                                           ------------ ^ ---- i32
    |                                                           |
    |                                                           String
    |
note: the foreign item type `String` doesn't implement `Sub<i32>`
   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:360:1
    |
360 | pub struct String {
    | ^^^^^^^^^^^^^^^^^ not implement `Sub<i32>`

error[E0599]: no method named `to_s` found for struct `String` in the current scope
 --> /tmp/.tmpbFSOMB/main.rs:1:518
  |
1 | ...at ! ("{}{}" , "❌ Failed after " , max_attempts . to_s ()) , " attempts: ") + error . to_s ()) ; panic ! (error) } } ; { let wait_time ...
  |                                                       ^^^^ method not found in `String`

error[E0308]: mismatched types
 --> /tmp/.tmpbFSOMB/main.rs:1:704
  |
1 | ...Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }
  |                                                       ^^^^ expected `u32`, found `i32`

error[E0277]: cannot add `i32` to `u32`
 --> /tmp/.tmpbFSOMB/main.rs:1:702
  |
1 | ...Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }
  |                                                     ^ no implementation for `u32 + i32`
  |
  = help: the trait `Add<i32>` is not implemented for `u32`
  = help: the following other types implement trait `Add<Rhs>`:
            `&u32` implements `Add<u32>`
            `&u32` implements `Add`
            `u32` implements `Add<&u32>`
            `u32` implements `Add`

error[E0308]: mismatched types
 --> /tmp/.tmpbFSOMB/main.rs:1:292
  |
1 | ...-> i32 { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Failed after " , max_attempts . to_s ()) , " attempts: ") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } }...
  |       ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |       |
  |       expected `i32` because of return type
  |
  = note: `for` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | use std :: collections :: HashMap ; fn safe_operation (operation_fn : String , fallback_value : String) -> i32 { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry (operation_fn : String , max_attempts : String) -> i32 { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Failed after " , max_attempts . to_s ()) , " attempts: ") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } /* `i32` value */ } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           +++++++++++++++++

error: aborting due to 19 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0369, E0423, E0425, E0599, E0618.
For more information about an error, try `rustc --explain E0277`.



=== ch07-00-building-applications example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `MASTER_KEY` in this scope
 --> /tmp/.tmpStodPQ/main.rs:1:1055
  |
1 | ...("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_dat...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `MASTER_KEY` in this scope
 --> /tmp/.tmpStodPQ/main.rs:1:1416
  |
1 | ... { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboa...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `null` in this scope
 --> /tmp/.tmpStodPQ/main.rs:1:1692
  |
1 | ..., site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::ptr::null;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpStodPQ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpStodPQ/main.rs:1:88
  |
1 | ... { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } ...
  |       ^^                                                                                                                                                                                                                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpStodPQ/main.rs:1:172
  |
1 | ...erate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return ...
  |               ^^                                                                                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpStodPQ/main.rs:1:382
  |
1 | ... { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } ...
  |       ^^                                                                                                                                                                                                                                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpStodPQ/main.rs:1:500
  |
1 | ...te () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; ret...
  |            ^^                                                                                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } ; return decrypted . join ("") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpStodPQ/main.rs:1:741
  |
1 | ... { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpStodPQ/main.rs:1:1251
  |
1 | ... { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpStodPQ/main.rs:1:1323
  |
1 | ... { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } e...
  |       ^^                                                                                                                                                                                                                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpStodPQ/main.rs:1:1571
  |
1 | ...lipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut...
  |                                ^^                                                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; }
  |

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpStodPQ/main.rs:1:196
  |
1 | ...merate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return...
  |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0599]: no method named `code` found for type `char` in the current scope
 --> /tmp/.tmpStodPQ/main.rs:1:250
  |
1 | ... key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn d...
  |                                                       ^^^^ method not found in `char`

error[E0425]: cannot find function `base64_encode` in this scope
 --> /tmp/.tmpStodPQ/main.rs:1:295
  |
1 | ... . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 {...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `base64_decode` in this scope
 --> /tmp/.tmpStodPQ/main.rs:1:398
  |
1 | ... : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes ....
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `char_from_code` in this scope
 --> /tmp/.tmpStodPQ/main.rs:1:571
  |
1 | ...[i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } }...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `load_passwords` in this scope
 --> /tmp/.tmpStodPQ/main.rs:1:761
  |
1 | ...password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `current_datetime` in this scope
 --> /tmp/.tmpStodPQ/main.rs:1:1128
  |
1 | ...)) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn ge...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `save_passwords` in this scope
 --> /tmp/.tmpStodPQ/main.rs:1:1175
  |
1 | ...(current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let pa...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0605]: non-primitive cast: `String` as `usize`
 --> /tmp/.tmpStodPQ/main.rs:1:794
  |
1 | ...rds [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; ma...
  |         ^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0425]: cannot find function `load_passwords` in this scope
 --> /tmp/.tmpStodPQ/main.rs:1:1271
  |
1 | ... } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords ()...
  |       ------------------------------------------------------------------------------ similarly named function `add_password` defined here                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^^^^^^^^^^^^^ help: a function with a similar name exists: `add_password`

error[E0425]: cannot find function `copy_to_clipboard` in this scope
 --> /tmp/.tmpStodPQ/main.rs:1:1430
  |
1 | ...d = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_afte...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `clear_clipboard` in this scope
 --> /tmp/.tmpStodPQ/main.rs:1:1536
  |
1 | ...d to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No passwo...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `spawn_after` in this scope
 --> /tmp/.tmpStodPQ/main.rs:1:1509
  |
1 | ... println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , fo...
  |                                                      ^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpStodPQ/main.rs:1:1573
  |
1 | ... } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = ...
  |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0605]: non-primitive cast: `String` as `usize`
 --> /tmp/.tmpStodPQ/main.rs:1:1350
  |
1 | ...rds [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Passw...
  |         ^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error: aborting due to 18 previous errors; 9 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0425, E0599, E0605.
For more information about an error, try `rustc --explain E0277`.



=== ch07-00-building-applications example 6 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `TRANSACTIONS_FILE` in this scope
 --> /tmp/.tmprVsgtJ/main.rs:1:566
  |
1 | ...tion) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `report_data` in this scope
 --> /tmp/.tmprVsgtJ/main.rs:1:1894
  |
1 | ...t_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_...
  |                                                     ^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmprVsgtJ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) -> i32 { { { let transac...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmprVsgtJ/main.rs:1:123
  |
1 | ... { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) -> i32 { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } fn generate_report (month : i32) -> i32 { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . iter () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
1 + use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) -> i32 { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } fn generate_report (month : i32) -> i32 { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . iter () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmprVsgtJ/main.rs:1:1056
  |
1 | ... { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . iter () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) -> i32 { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } fn generate_report (month : i32) -> i32 { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . iter () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
1 + use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) -> i32 { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } fn generate_report (month : i32) -> i32 { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . iter () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmprVsgtJ/main.rs:1:1369
  |
1 | ... { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) -> i32 { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } fn generate_report (month : i32) -> i32 { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . iter () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
1 + use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) -> i32 { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } fn generate_report (month : i32) -> i32 { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . iter () { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
  |

error[E0425]: cannot find function `current_date` in this scope
 --> /tmp/.tmprVsgtJ/main.rs:1:294
  |
1 | ... new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) ....
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `append_csv` in this scope
 --> /tmp/.tmprVsgtJ/main.rs:1:554
  |
1 | ...ng () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_t...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `get_monthly_total` in this scope
 --> /tmp/.tmprVsgtJ/main.rs:1:625
  |
1 | ...FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if m...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `get_budget_limit` in this scope
 --> /tmp/.tmprVsgtJ/main.rs:1:679
  |
1 | ...thly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (fo...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `send_notification` in this scope
 --> /tmp/.tmprVsgtJ/main.rs:1:745
  |
1 | ...tegory) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmprVsgtJ/main.rs:1:821
  |
1 | ... ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } ...
  |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `load_transactions` in this scope
 --> /tmp/.tmprVsgtJ/main.rs:1:1079
  |
1 | ... ; fn add_transaction (amount : String , category : i32 , description : String) -> i32 { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } fn generate_report (month : i32) -> i32 { { { let transactions = load_transactions (m...
  |       ----------------------------------------------------------------------------------- similarly named function `add_transaction` defined here                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^^^^^^^^^^^^^^^^^ help: a function with a similar name exists: `add_transaction`

error[E0425]: cannot find function `group_by` in this scope
 --> /tmp/.tmprVsgtJ/main.rs:1:1131
  |
1 | ...oad_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{:?}" , format ! ...
  |                                                       ^^^^^^^^ not found in this scope

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmprVsgtJ/main.rs:1:1285
  |
1 | ..., "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category ...
  |                                                                --- ^ ----- i32
  |                                                                |
  |                                                                &str

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmprVsgtJ/main.rs:1:1548
  |
1 | ...otal ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , category , " $...
  |                                                        ^^^^ method not found in `i32`

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmprVsgtJ/main.rs:1:1507
  |
1 | ... sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{:?}" , format ! ("{}{}" , fo...
  |                                              ^^^^^^^ doesn't have a size known at compile-time
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: all local variables must have a statically known size

error[E0308]: mismatched types
 --> /tmp/.tmprVsgtJ/main.rs:1:1669
  |
1 | ...tegory , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}...
  |                                                       ^^^ expected `&str`, found `str`
  |
help: consider borrowing here
  |
1 | use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) -> i32 { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } fn generate_report (month : i32) -> i32 { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . iter () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + &bar) } } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      +

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmprVsgtJ/main.rs:1:1708
  |
1 | ...otal . to_s () , " ") + bar) } } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" ,...
  |                                                               --- ^ ----- i32
  |                                                               |
  |                                                               &str

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmprVsgtJ/main.rs:1:1788
  |
1 | ... , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; gene...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `generate_pdf` in this scope
 --> /tmp/.tmprVsgtJ/main.rs:1:1866
  |
1 | ...le = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmprVsgtJ/main.rs:1:1909
  |
1 | ...report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let mut TRANSACTIONS_...
  |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

warning: unused variable: `TRANSACTIONS_FILE`
 --> /tmp/.tmprVsgtJ/main.rs:1:2016
  |
1 | ...main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; let mut CATEGORIES = vec ! ["Food" , "Transport" ,...
  |                      ^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_TRANSACTIONS_FILE`
  |
  = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `CATEGORIES`
 --> /tmp/.tmprVsgtJ/main.rs:1:2090
  |
1 | .... to_string () ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
  |                             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_CATEGORIES`

warning: variable does not need to be mutable
 --> /tmp/.tmprVsgtJ/main.rs:1:2012
  |
1 | ... saved to " , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; let mut CAT...
  |                                                         ----^^^^^^^^^^^^^^^^^
  |                                                         |
  |                                                         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

warning: variable does not need to be mutable
 --> /tmp/.tmprVsgtJ/main.rs:1:2086
  |
1 | ... = "~/.budget/transactions.csv" . to_string () ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other...
  |                                                         ----^^^^^^^^^^
  |                                                         |
  |                                                         help: remove this `mut`

error: aborting due to 18 previous errors; 8 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0369, E0425, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch07-00-building-applications example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch07-00-building-applications example 8 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `null` in this scope
 --> /tmp/.tmpGk7lO7/main.rs:1:333
  |
1 | ...}" , "Email should be set") ; assert ! (user . id != null , "{}" , "ID should be generated") ; println ! ("✅ test_user_creation passed"...
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::ptr::null;
  |

error[E0425]: cannot find function `remove_file` in this scope
 --> /tmp/.tmpGk7lO7/main.rs:1:939
  |
1 | ...est == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_...
  |                                                     ^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_file;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpGk7lO7/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test_user_creation () -> i32 { { { let user = create_user ("Alice" . to_string () , "alice@example...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpGk7lO7/main.rs:1:71
  |
1 | ... { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert ! (user . name == "Alice" , "{}" , "Name should be set") ; assert ! (user . email == "alice@example.com" , "{}" , "Email should be set") ; assert ! (user . id != null , "{}" , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                            ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_user_creation () -> i32 { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert ! (user . name == "Alice" , "{}" , "Name should be set") ; assert ! (user . email == "alice@example.com" , "{}" , "Email should be set") ; assert ! (user . id != null , "{}" , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } fn test_data_persistence () -> i32 { { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("test" . to_string () , ("value") . to_string ()) ; map } ; { let mut test_file = "test_data.json" . to_string () ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let mut loaded = load_json (test_file) ; assert ! (loaded . test == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_user_creation () -> i32 { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert ! (user . name == "Alice" , "{}" , "Name should be set") ; assert ! (user . email == "alice@example.com" , "{}" , "Email should be set") ; assert ! (user . id != null , "{}" , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } fn test_data_persistence () -> i32 { { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("test" . to_string () , ("value") . to_string ()) ; map } ; { let mut test_file = "test_data.json" . to_string () ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let mut loaded = load_json (test_file) ; assert ! (loaded . test == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpGk7lO7/main.rs:1:462
  |
1 | ... { { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("test" . to_string () , ("value") . to_string ()) ; map } ; { let mut test_file = "test_data.json" . to_string () ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let mut loaded = load_json (test_file) ; assert ! (loaded . test == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_user_creation () -> i32 { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert ! (user . name == "Alice" , "{}" , "Name should be set") ; assert ! (user . email == "alice@example.com" , "{}" , "Email should be set") ; assert ! (user . id != null , "{}" , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } fn test_data_persistence () -> i32 { { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("test" . to_string () , ("value") . to_string ()) ; map } ; { let mut test_file = "test_data.json" . to_string () ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let mut loaded = load_json (test_file) ; assert ! (loaded . test == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_user_creation () -> i32 { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert ! (user . name == "Alice" , "{}" , "Name should be set") ; assert ! (user . email == "alice@example.com" , "{}" , "Email should be set") ; assert ! (user . id != null , "{}" , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } fn test_data_persistence () -> i32 { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("test" . to_string () , ("value") . to_string ()) ; map } ; { let mut test_file = "test_data.json" . to_string () ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let mut loaded = load_json (test_file) ; assert ! (loaded . test == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
  |

error[E0425]: cannot find function `create_user` in this scope
 --> /tmp/.tmpGk7lO7/main.rs:1:86
  |
1 | use std :: collections :: HashMap ; fn test_user_creation () -> i32 { { { let user = create_user ("Alice" . to_string () , "alice@example...
  |                                                                                      ^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpGk7lO7/main.rs:1:375
  |
1 | ...}" , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } fn test_data_persistence () -> i32 { { { let test_da...
  |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `save_json` in this scope
 --> /tmp/.tmpGk7lO7/main.rs:1:722
  |
1 | ...mut test_file = "test_data.json" . to_string () ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpGk7lO7/main.rs:1:768
  |
1 | ... ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let mut loaded = load_js...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `load_json` in this scope
 --> /tmp/.tmpGk7lO7/main.rs:1:846
  |
1 | ...}" , "File should be created") ; let mut loaded = load_json (test_file) ; assert ! (loaded . test == "value" , "{}" , "Data should per...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpGk7lO7/main.rs:1:965
  |
1 | ...") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_all_tests () { { println ! ("🧪 Running applic...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `test_error_handling` in this scope
 --> /tmp/.tmpGk7lO7/main.rs:1:1140
  |
1 | ...ser_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn ...
  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `test_performance` in this scope
 --> /tmp/.tmpGk7lO7/main.rs:1:1165
  |
1 | ...data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 10 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0308, E0425.
For more information about an error, try `rustc --explain E0308`.



=== ch07-00-building-applications example 9 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `VERSION` in this scope
 --> /tmp/.tmperIdC9/main.rs:1:181
  |
1 | ... let release_dir = format ! ("{}{}" , "release_" , VERSION) ; { create_dir_all (release_dir) ; copy_file ("main.ruchy" . to_string () ...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find function `create_dir_all` in this scope
 --> /tmp/.tmperIdC9/main.rs:1:194
  |
1 | ... = format ! ("{}{}" , "release_" , VERSION) ; { create_dir_all (release_dir) ; copy_file ("main.ruchy" . to_string () , join_path (rel...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::create_dir_all;
  |

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmperIdC9/main.rs:1:291
  |
1 | ...n.ruchy" . to_string () , join_path (release_dir , APP_NAME)) ; copy_dir ("resources" . to_string () , join_path (release_dir , "resou...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmperIdC9/main.rs:1:657
  |
1 | ...cho 'Installation complete! Run {} to start.'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (relea...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `VERSION` in this scope
 --> /tmp/.tmperIdC9/main.rs:1:668
  |
1 | ...lation complete! Run {} to start.'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , "i...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmperIdC9/main.rs:1:678
  |
1 | ...plete! Run {} to start.'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , "install.sh"...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmperIdC9/main.rs:1:689
  |
1 | ...{} to start.'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , "install.sh" . to_strin...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmperIdC9/main.rs:1:700
  |
1 | ....'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , "install.sh" . to_string ()) , ins...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmperIdC9/main.rs:1:836
  |
1 | ...ller) ; create_archive (format ! ("{}-{}.tar.gz" , APP_NAME , VERSION) , release_dir) ; println ! ("✅ Release built: {}-{}.tar.gz" , AP...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `VERSION` in this scope
 --> /tmp/.tmperIdC9/main.rs:1:847
  |
1 | ...ate_archive (format ! ("{}-{}.tar.gz" , APP_NAME , VERSION) , release_dir) ; println ! ("✅ Release built: {}-{}.tar.gz" , APP_NAME , VE...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmperIdC9/main.rs:1:918
  |
1 | ...ir) ; println ! ("✅ Release built: {}-{}.tar.gz" , APP_NAME , VERSION) } } } } fn main () { }
  |                                                        ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `VERSION` in this scope
 --> /tmp/.tmperIdC9/main.rs:1:929
  |
1 | ...ln ! ("✅ Release built: {}-{}.tar.gz" , APP_NAME , VERSION) } } } } fn main () { }
  |                                                        ^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmperIdC9/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn build_release () -> i32 { { println ! ("🔨 Building release version...") ; run_tests () ; { let rele...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `run_tests` in this scope
 --> /tmp/.tmperIdC9/main.rs:1:114
  |
1 | ...{ { println ! ("🔨 Building release version...") ; run_tests () ; { let release_dir = format ! ("{}{}" , "release_" , VERSION) ; { creat...
  |                                                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmperIdC9/main.rs:1:266
  |
1 | ...e_dir) ; copy_file ("main.ruchy" . to_string () , join_path (release_dir , APP_NAME)) ; copy_dir ("resources" . to_string () , join_pa...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `copy_file` in this scope
 --> /tmp/.tmperIdC9/main.rs:1:225
  |
1 | ...e_" , VERSION) ; { create_dir_all (release_dir) ; copy_file ("main.ruchy" . to_string () , join_path (release_dir , APP_NAME)) ; copy_...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmperIdC9/main.rs:1:343
  |
1 | ...P_NAME)) ; copy_dir ("resources" . to_string () , join_path (release_dir , "resources" . to_string ())) ; generate_docs (join_path (re...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `copy_dir` in this scope
 --> /tmp/.tmperIdC9/main.rs:1:304
  |
1 | ..._string () , join_path (release_dir , APP_NAME)) ; copy_dir ("resources" . to_string () , join_path (release_dir , "resources" . to_st...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmperIdC9/main.rs:1:414
  |
1 | ...r , "resources" . to_string ())) ; generate_docs (join_path (release_dir , "docs" . to_string ())) ; let mut installer = format ! ("#!...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `generate_docs` in this scope
 --> /tmp/.tmperIdC9/main.rs:1:399
  |
1 | ...h (release_dir , "resources" . to_string ())) ; generate_docs (join_path (release_dir , "docs" . to_string ())) ; let mut installer = ...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmperIdC9/main.rs:1:724
  |
1 | ...N , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , "install.sh" . to_string ()) , installer) ; create_archive ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmperIdC9/main.rs:1:712
  |
1 | ...AME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , "install.sh" . to_string ()) , installer) ; cre...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `create_archive` in this scope
 --> /tmp/.tmperIdC9/main.rs:1:793
  |
1 | ...r , "install.sh" . to_string ()) , installer) ; create_archive (format ! ("{}-{}.tar.gz" , APP_NAME , VERSION) , release_dir) ; printl...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmperIdC9/main.rs:1:873
  |
1 | ...ON) , release_dir) ; println ! ("✅ Release built: {}-{}.tar.gz" , APP_NAME , VERSION) } } } } fn main () { }
  |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 23 previous errors; 1 warning emitted

Some errors have detailed explanations: E0308, E0425.
For more information about an error, try `rustc --explain E0308`.



=== ch15-00-macros-metaprogramming example 1 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp7oD1f7/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn create_user (name : String , age : i32) -> String { { format ! ("{}{}" , format ! ("{}{}" , "User:...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp7oD1f7/main.rs:1:92
  |
1 | ...e : i32) -> String { { format ! ("{}{}" , format ! ("{}{}" , "User: " , name) , ", Age: ") + age . to_string () } } fn main () { let m...
  |                         ^^                                                                                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn create_user (name : String , age : i32) -> String { { format ! ("{}{}" , format ! ("{}{}" , "User: " , name) , ", Age: ") + age . to_string () } } fn main () { let mut user = create_user ("Alice" . to_string () , 30i32) ; println ! ("{:?}" , user) ; }
1 + use std :: collections :: HashMap ; fn create_user (name : String , age : i32) -> String { format ! ("{}{}" , format ! ("{}{}" , "User: " , name) , ", Age: ") + age . to_string () } fn main () { let mut user = create_user ("Alice" . to_string () , 30i32) ; println ! ("{:?}" , user) ; }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp7oD1f7/main.rs:1:164
  |
1 | ...("{}{}" , "User: " , name) , ", Age: ") + age . to_string () } } fn main () { let mut user = create_user ("Alice" . to_string () , 30i...
  |                                              ^^^^^^^^^^^^^^^^^^ expected `&str`, found `String`
  |
help: consider borrowing here
  |
1 | use std :: collections :: HashMap ; fn create_user (name : String , age : i32) -> String { { format ! ("{}{}" , format ! ("{}{}" , "User: " , name) , ", Age: ") + &age . to_string () } } fn main () { let mut user = create_user ("Alice" . to_string () , 30i32) ; println ! ("{:?}" , user) ; }
  |                                                                                                                                                                    +

warning: variable does not need to be mutable
 --> /tmp/.tmp7oD1f7/main.rs:1:204
  |
1 | ...", Age: ") + age . to_string () } } fn main () { let mut user = create_user ("Alice" . to_string () , 30i32) ; println ! ("{:?}" , use...
  |                                                         ----^^^^
  |                                                         |
  |                                                         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

error: aborting due to 1 previous error; 3 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch15-00-macros-metaprogramming example 2 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `User` in this scope
 --> /tmp/.tmp18pYhh/main.rs:1:59
  |
1 | use std :: collections :: HashMap ; fn debug_user (user : User) -> String { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "U...
  |                                                           ^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp18pYhh/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn debug_user (user : User) -> String { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "U...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp18pYhh/main.rs:1:77
  |
1 | ... { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "User { name: " , user . name) , ", age: ") + user . age . to_string () , " }") } } ...
  |       ^^                                                                                                                                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn debug_user (user : User) -> String { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "User { name: " , user . name) , ", age: ") + user . age . to_string () , " }") } } fn main () { struct User { name : String , age : i32 , } ; }
1 + use std :: collections :: HashMap ; fn debug_user (user : User) -> String { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "User { name: " , user . name) , ", age: ") + user . age . to_string () , " }") } fn main () { struct User { name : String , age : i32 , } ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmp18pYhh/main.rs:1:277
  |
1 | ...in () { struct User { name : String , age : i32 , } ; }
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error: aborting due to 1 previous error; 3 warnings emitted

For more information about this error, try `rustc --explain E0412`.



=== ch09-00-network-programming example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 2 ===

thread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:
"net::TcpListener" is not a valid Ident
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


=== ch09-00-network-programming example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 10 ===

thread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:
"net::PacketCapture" is not a valid Ident
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


=== ch07-00-error-handling-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `value` in this scope
 --> /tmp/.tmplKD3A6/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid") } } else { { println ! ("Invalid") ...
  |                                                                  ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmplKD3A6/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid") } } else { { println ! ("Invalid") ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmplKD3A6/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid") } } else { { println ! ("Invalid") ...
  |                                                                                 ^^                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid") } } else { { println ! ("Invalid") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { println ! ("Valid") } else { { println ! ("Invalid") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmplKD3A6/main.rs:1:114
  |
1 | ... = if value > 0i32 { { println ! ("Valid") } } else { { println ! ("Invalid") } } ; if let Some (s) = (& result as & dyn std :: any ::...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid") } } else { { println ! ("Invalid") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid") } } else { println ! ("Invalid") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error: aborting due to 1 previous error; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `status` in this scope
 --> /tmp/.tmpidKIYH/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match status { 0i32 => println ! ("Error") , 1i32 => println ! ("Warning") ...
  |                                                                     ^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpidKIYH/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match status { 0i32 => println ! ("Error") , 1i32 => println ! ("Warning") ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `age` in this scope
 --> /tmp/.tmpYRlgZ1/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match age { 0i32 => println ! ("Invalid age") , 1i32 ..= 17i32 => println !...
  |                                                                     ^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpYRlgZ1/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match age { 0i32 => println ! ("Invalid age") , 1i32 ..= 17i32 => println !...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 7 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `input` in this scope
 --> /tmp/.tmpPZenlL/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed") } } els...
  |                                                                  ^^^^^ not found in this scope

error[E0425]: cannot find value `input` in this scope
 --> /tmp/.tmpPZenlL/main.rs:1:159
  |
1 | ...ive input not allowed") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_re...
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpPZenlL/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed") } } els...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpPZenlL/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed") } } els...
  |                                                                                 ^^                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { println ! ("Error: Negative input not allowed") } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpPZenlL/main.rs:1:142
  |
1 | ...ln ! ("Error: Negative input not allowed") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any ::...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed") } } else { process_input (input) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `process_input` in this scope
 --> /tmp/.tmpPZenlL/main.rs:1:144
  |
1 | ...rror: Negative input not allowed") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . ...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 8 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `score` in this scope
 --> /tmp/.tmpTaDmlb/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match score { 0i32 ..= 59i32 => println ! ("Fail") , 60i32 ..= 79i32 => pri...
  |                                                                     ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpTaDmlb/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match score { 0i32 ..= 59i32 => println ! ("Fail") , 60i32 ..= 79i32 => pri...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 9 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `system_ready` in this scope
 --> /tmp/.tmpa3xbE2/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational") } } else { { println !...
  |                                                                  ^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpa3xbE2/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational") } } else { { println !...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpa3xbE2/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational") } } else { { println !...
  |                                                                                 ^^                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational") } } else { { println ! ("System not ready") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if system_ready { println ! ("System operational") } else { { println ! ("System not ready") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpa3xbE2/main.rs:1:127
  |
1 | ...y { { println ! ("System operational") } } else { { println ! ("System not ready") } } ; if let Some (s) = (& result as & dyn std :: a...
  |                                                      ^^                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational") } } else { { println ! ("System not ready") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational") } } else { println ! ("System not ready") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error: aborting due to 1 previous error; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch08-00-systems-programming example 1 ===
✗ Compilation failed: Compilation failed:
error[E0432]: unresolved import `std::system`
 --> /tmp/.tmpBcVVyp/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monit...
  |                                                                     ^^^^^^^^^^^^^ no `system` in the root

error[E0425]: cannot find function `list` in module `process`
 --> /tmp/.tmpBcVVyp/main.rs:1:2198
  |
1 | ...Processes by CPU:") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes...
  |                                                         ^^^^ not found in `process`

error[E0425]: cannot find function `sleep` in this scope
 --> /tmp/.tmpBcVVyp/main.rs:1:2482
  |
1 | ..., " ") + proc . cpu_percent . to_s () , "%")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::sleep;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpBcVVyp/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monit...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpBcVVyp/main.rs:1:85
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monit...
  |                                                                                     ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpBcVVyp/main.rs:1:108
  |
1 | ...sult = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===") ; let mut cpu_count = system :: cpu_count (...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpBcVVyp/main.rs:1:686
  |
1 | ... { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{:?}" , "=" * 50i32) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") + format_size (memory_info . total)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } } ; sleep (1000i32) } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===") ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! ("{:?}" , format ! ("{}{}" , "Host: " , hostname)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "OS: " , os_info . name) , " ") + os_info . version) ; println ! ("{:?}" , format ! ("{}{}" , "CPUs: " , cpu_count . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{:?}" , "=" * 50i32) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") + format_size (memory_info . total)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===") ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! ("{:?}" , format ! ("{}{}" , "Host: " , hostname)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "OS: " , os_info . name) , " ") + os_info . version) ; println ! ("{:?}" , format ! ("{}{}" , "CPUs: " , cpu_count . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("") ; loop { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{:?}" , "=" * 50i32) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") + format_size (memory_info . total)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } } ; sleep (1000i32) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpBcVVyp/main.rs:1:2282
  |
1 | ... { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } } ...
  |       ^^                                                                                                                                                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===") ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! ("{:?}" , format ! ("{}{}" , "Host: " , hostname)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "OS: " , os_info . name) , " ") + os_info . version) ; println ! ("{:?}" , format ! ("{}{}" , "CPUs: " , cpu_count . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{:?}" , "=" * 50i32) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") + format_size (memory_info . total)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===") ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! ("{:?}" , format ! ("{}{}" , "Host: " , hostname)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "OS: " , os_info . name) , " ") + os_info . version) ; println ! ("{:?}" , format ! ("{}{}" , "CPUs: " , cpu_count . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{:?}" , "=" * 50i32) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") + format_size (memory_info . total)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpBcVVyp/main.rs:1:631
  |
1 | ...ntln ! ("{:?}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("") ; loop { { { let cpu_usage = system :: ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `clear_screen` in this scope
 --> /tmp/.tmpBcVVyp/main.rs:1:882
  |
1 | ...mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmpBcVVyp/main.rs:1:978
  |
1 | ...tem Monitor - Press Ctrl+C to exit") ; println ! ("{:?}" , "=" * 50i32) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , fo...
  |                                                               --- ^ ----- i32
  |                                                               |
  |                                                               &str

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmpBcVVyp/main.rs:1:1134
  |
1 | ...age . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent ...
  |                                                        ^^^^ method not found in `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpBcVVyp/main.rs:1:1108
  |
1 | ..." , cpu_usage . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut me...
  |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `str`
  |
help: consider borrowing here
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===") ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! ("{:?}" , format ! ("{}{}" , "Host: " , hostname)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "OS: " , os_info . name) , " ") + os_info . version) ; println ! ("{:?}" , format ! ("{}{}" , "CPUs: " , cpu_count . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{:?}" , "=" * 50i32) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") + &("█" * cpu_usage * 50i32 . to_i ()) + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") + format_size (memory_info . total)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ++                                 +

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmpBcVVyp/main.rs:1:1148
  |
1 | ... . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = m...
  |                                                               --- ^ ----- i32
  |                                                               |
  |                                                               &str

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmpBcVVyp/main.rs:1:1178
  |
1 | ...50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ;...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmpBcVVyp/main.rs:1:1410
  |
1 | ...t . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{:?}" ...
  |                                                        ^^^^ method not found in `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpBcVVyp/main.rs:1:1382
  |
1 | ... mem_percent . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println...
  |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `str`
  |
help: consider borrowing here
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===") ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! ("{:?}" , format ! ("{}{}" , "Host: " , hostname)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "OS: " , os_info . name) , " ") + os_info . version) ; println ! ("{:?}" , format ! ("{}{}" , "CPUs: " , cpu_count . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{:?}" , "=" * 50i32) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") + &("█" * mem_percent * 50i32 . to_i ()) + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") + format_size (memory_info . total)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ++                                   +

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmpBcVVyp/main.rs:1:1424
  |
1 | ... to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{:?}" , f...
  |                                                               --- ^ ----- i32
  |                                                               |
  |                                                               &str

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmpBcVVyp/main.rs:1:1456
  |
1 | ...i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "     ...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpBcVVyp/main.rs:1:1542
  |
1 | ... format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") + format_size (memory_info . total)) ; pri...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpBcVVyp/main.rs:1:1587
  |
1 | ..." , format_size (memory_info . used)) , " / ") + format_size (memory_info . total)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpBcVVyp/main.rs:1:1699
  |
1 | ... ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" ,...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpBcVVyp/main.rs:1:1821
  |
1 | ... ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpBcVVyp/main.rs:1:1942
  |
1 | ...at ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{:?}" , format !...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpBcVVyp/main.rs:1:2072
  |
1 | ...at ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by...
  |                                                     ^^^^^^^^^^^ not found in this scope

warning: unreachable expression
 --> /tmp/.tmpBcVVyp/main.rs:1:2510
  |
1 | ... ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{:?}" , "=" * 50i32) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") + format_size (memory_info . total)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |       --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression
  |       |
  |       any code following this expression is unreachable
  |
  = note: `#[warn(unreachable_code)]` on by default

error: aborting due to 20 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0308, E0369, E0425, E0432, E0599.
For more information about an error, try `rustc --explain E0308`.



=== ch08-00-systems-programming example 2 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpqvtQe7/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut pid = process :: current_pid () ; let mut ppid = process :: paren...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpqvtQe7/main.rs:1:351
  |
1 | ... { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "PID: " , proc . pid . to_s ()) , ", Name: ") + proc . name , ", CPU: ") + proc . cpu_percent . to_s () , "%")) } } ...
  |       ^^                                                                                                                                                                                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { let mut pid = process :: current_pid () ; let mut ppid = process :: parent_pid () ; let mut exe_path = process :: executable_path () ; let mut args = process :: args () ; let mut env = process :: environment () ; let mut all_processes = process :: list () ; for proc in all_processes { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "PID: " , proc . pid . to_s ()) , ", Name: ") + proc . name , ", CPU: ") + proc . cpu_percent . to_s () , "%")) } } ; let mut chrome_procs = process :: find_by_name ("chrome" . to_string ()) ; let mut high_cpu_procs = process :: list () . into_iter () . filter (| p | p . cpu_percent > 50i32) . collect :: < Vec < _ >> () ; let mut proc = process :: from_pid (1234i32) ; proc . suspend () ; proc . resume () ; proc . terminate () ; proc . kill () ; let mut child = process :: spawn ("ls" . to_string () , vec ! ["-la"]) ; let mut output = child . wait_with_output () ; println ! ("{:?}" , output . stdout) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { let mut pid = process :: current_pid () ; let mut ppid = process :: parent_pid () ; let mut exe_path = process :: executable_path () ; let mut args = process :: args () ; let mut env = process :: environment () ; let mut all_processes = process :: list () ; for proc in all_processes { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "PID: " , proc . pid . to_s ()) , ", Name: ") + proc . name , ", CPU: ") + proc . cpu_percent . to_s () , "%")) } ; let mut chrome_procs = process :: find_by_name ("chrome" . to_string ()) ; let mut high_cpu_procs = process :: list () . into_iter () . filter (| p | p . cpu_percent > 50i32) . collect :: < Vec < _ >> () ; let mut proc = process :: from_pid (1234i32) ; proc . suspend () ; proc . resume () ; proc . terminate () ; proc . kill () ; let mut child = process :: spawn ("ls" . to_string () , vec ! ["-la"]) ; let mut output = child . wait_with_output () ; println ! ("{:?}" , output . stdout) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpqvtQe7/main.rs:1:79
  |
1 | ...in () { let result = { let mut pid = process :: current_pid () ; let mut ppid = process :: parent_pid () ; let mut exe_path = process ...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpqvtQe7/main.rs:1:122
  |
1 | ...s :: current_pid () ; let mut ppid = process :: parent_pid () ; let mut exe_path = process :: executable_path () ; let mut args = proc...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpqvtQe7/main.rs:1:168
  |
1 | ...: parent_pid () ; let mut exe_path = process :: executable_path () ; let mut args = process :: args () ; let mut env = process :: envi...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpqvtQe7/main.rs:1:215
  |
1 | ... executable_path () ; let mut args = process :: args () ; let mut env = process :: environment () ; let mut all_processes = process ::...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpqvtQe7/main.rs:1:250
  |
1 | ...= process :: args () ; let mut env = process :: environment () ; let mut all_processes = process :: list () ; for proc in all_processe...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpqvtQe7/main.rs:1:302
  |
1 | ...ronment () ; let mut all_processes = process :: list () ; for proc in all_processes { { println ! ("{:?}" , format ! ("{}{}" , format ...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpqvtQe7/main.rs:1:590
  |
1 | ..., "%")) } } ; let mut chrome_procs = process :: find_by_name ("chrome" . to_string ()) ; let mut high_cpu_procs = process :: list () ....
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpqvtQe7/main.rs:1:667
  |
1 | ...tring ()) ; let mut high_cpu_procs = process :: list () . into_iter () . filter (| p | p . cpu_percent > 50i32) . collect :: < Vec < _...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpqvtQe7/main.rs:1:788
  |
1 | ... :: < Vec < _ >> () ; let mut proc = process :: from_pid (1234i32) ; proc . suspend () ; proc . resume () ; proc . terminate () ; proc...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpqvtQe7/main.rs:1:914
  |
1 | ...) ; proc . kill () ; let mut child = process :: spawn ("ls" . to_string () , vec ! ["-la"]) ; let mut output = child . wait_with_outpu...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error: aborting due to 10 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0433`.



=== ch08-00-systems-programming example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-systems-programming example 4 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpUNubNV/main.rs:1:1035
  |
1 | ... data = shared . read (0i32 , 1024i32) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0425]: cannot find value `_000_000` in this scope
 --> /tmp/.tmpUNubNV/main.rs:1:568
  |
1 | ...d . to_s ())) ; if mem_info . available < 100i32 { _000_000 } ; { println ! ("WARNING: Low memory!") ; free_caches () } ; let mut mmap...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `READ_ONLY` in this scope
 --> /tmp/.tmpUNubNV/main.rs:1:710
  |
1 | ... :: map_file ("huge_dataset.bin" . to_string () , READ_ONLY) ; let mut data = mmap . read_range (0i32 , 1000000i32) ; mmap . close () ...
  |                                                      ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpUNubNV/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut mem_info = system :: memory_info () ; println ! ("{:?}" , format ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `system`
 --> /tmp/.tmpUNubNV/main.rs:1:84
  |
1 | ...) { let result = { let mut mem_info = system :: memory_info () ; println ! ("{:?}" , format ! ("{}{}" , "Total: " , mem_info . total ....
  |                                          ^^^^^^ use of unresolved module or unlinked crate `system`
  |
  = help: you might be missing a crate named `system`

error[E0425]: cannot find function `free_caches` in this scope
 --> /tmp/.tmpUNubNV/main.rs:1:620
  |
1 | ...0_000 } ; { println ! ("WARNING: Low memory!") ; free_caches () } ; let mut mmap = memory :: map_file ("huge_dataset.bin" . to_string ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `memory`
 --> /tmp/.tmpUNubNV/main.rs:1:654
  |
1 | ...) ; free_caches () } ; let mut mmap = memory :: map_file ("huge_dataset.bin" . to_string () , READ_ONLY) ; let mut data = mmap . read_...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `memory`
  |
  = help: you might be missing a crate named `memory`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `memory`
 --> /tmp/.tmpUNubNV/main.rs:1:813
  |
1 | ... ; mmap . close () ; let mut shared = memory :: create_shared ("my_buffer" . to_string () , 1024i32 * 1024i32) ; shared . write (0i32 ...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `memory`
  |
  = help: you might be missing a crate named `memory`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `memory`
 --> /tmp/.tmpUNubNV/main.rs:1:936
  |
1 | ...rite (0i32 , data) ; let mut shared = memory :: open_shared ("my_buffer" . to_string ()) ; let mut data = shared . read (0i32 , 1024i3...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `memory`
  |
  = help: you might be missing a crate named `memory`

error: aborting due to 8 previous errors; 1 warning emitted

Some errors have detailed explanations: E0425, E0433.
For more information about an error, try `rustc --explain E0425`.



=== ch08-00-systems-programming example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-systems-programming example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-systems-programming example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-systems-programming example 8 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `RECURSIVE` in this scope
 --> /tmp/.tmp4GkvUy/main.rs:1:130
  |
1 | ... = fs :: watch ("/path/to/watch" . to_string () , RECURSIVE) ; watcher . on ("created" , | path | { println ! ("{:?}" , format ! ("{}{...
  |                                                      ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp4GkvUy/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut watcher = fs :: watch ("/path/to/watch" . to_string () , RECURSIV...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`
 --> /tmp/.tmp4GkvUy/main.rs:1:83
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut watcher = fs :: watch ("/path/to/watch" . to_string () , RECURSIV...
  |                                                                                   ^^ use of unresolved module or unlinked crate `fs`
  |
  = help: you might be missing a crate named `fs`

error[E0425]: cannot find function `process_change` in this scope
 --> /tmp/.tmp4GkvUy/main.rs:1:356
  |
1 | ...format ! ("{}{}" , "File modified: " , path)) ; process_change (path) }) ; watcher . on ("deleted" , | path | { println ! ("{:?}" , fo...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 1 warning emitted

Some errors have detailed explanations: E0425, E0433.
For more information about an error, try `rustc --explain E0425`.



=== ch08-00-systems-programming example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-advanced-functions-tdd example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-advanced-functions-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `Type` in this scope
 --> /tmp/.tmpXMkkPT/main.rs:1:60
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |                                                            ^^^^ not found in this scope

error[E0412]: cannot find type `ResultType` in this scope
 --> /tmp/.tmpXMkkPT/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |                                                                     ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `condition1` in this scope
 --> /tmp/.tmpXMkkPT/main.rs:1:87
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |                                                                                       ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `result1` in this scope
 --> /tmp/.tmpXMkkPT/main.rs:1:109
  |
1 | ...: Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn m...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `condition2` in this scope
 --> /tmp/.tmpXMkkPT/main.rs:1:126
  |
1 | ...ype { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `result2` in this scope
 --> /tmp/.tmpXMkkPT/main.rs:1:148
  |
1 | ... { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `default_result` in this scope
 --> /tmp/.tmpXMkkPT/main.rs:1:169
  |
1 | ...; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpXMkkPT/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpXMkkPT/main.rs:1:100
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |                                                                                                    ^^              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
1 + use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { return result1 } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXMkkPT/main.rs:1:139
  |
1 | ... { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |                                                              ^^              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
1 + use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { return result2 } ; return default_result } } fn main () { }
  |

error: aborting due to 7 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch08-00-advanced-functions-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `Type` in this scope
 --> /tmp/.tmpLSiEzD/main.rs:1:60
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |                                                            ^^^^ not found in this scope

error[E0412]: cannot find type `Type` in this scope
 --> /tmp/.tmpLSiEzD/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |                                                                     ^^^^ not found in this scope

error[E0425]: cannot find value `base_condition` in this scope
 --> /tmp/.tmpLSiEzD/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |                                                                                 ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `base_value` in this scope
 --> /tmp/.tmpLSiEzD/main.rs:1:107
  |
1 | ... : Type) -> Type { { if base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
  |                                                      ^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpLSiEzD/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpLSiEzD/main.rs:1:98
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |                                                                                                  ^^                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
1 + use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { return base_value } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
  |

error[E0425]: cannot find function `reduce` in this scope
 --> /tmp/.tmpLSiEzD/main.rs:1:160
  |
1 | ...ase_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
  |                                                        ^^^^^^ not found in this scope

error[E0425]: cannot find function `combine` in this scope
 --> /tmp/.tmpLSiEzD/main.rs:1:131
  |
1 | ... base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 6 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch08-00-advanced-functions-tdd example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 12 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch03-01-testing-functions example 1 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpR9QF7Z/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn add (a : i32 , b : i32) -> i32 { { a + b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpR9QF7Z/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn add (a : i32 , b : i32) -> i32 { { a + b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i...
  |                                                                         ^^     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add (a : i32 , b : i32) -> i32 { { a + b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i32 , b : i32) -> i32 { a + b } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) } } fn main () { }
  |

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpR9QF7Z/main.rs:1:193
  |
1 | ...q ! (add (0i32 , 0i32) , 0i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) } } fn main () { }
  |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0317`.



=== ch03-01-testing-functions example 2 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `actual` in this scope
 --> /tmp/.tmpQcQTRZ/main.rs:1:86
  |
1 | use std :: collections :: HashMap ; fn test_function_name () -> i32 { { assert_eq ! (actual , expected) } } fn main () { }
  |                                                                                      ^^^^^^ not found in this scope

error[E0425]: cannot find value `expected` in this scope
 --> /tmp/.tmpQcQTRZ/main.rs:1:95
  |
1 | use std :: collections :: HashMap ; fn test_function_name () -> i32 { { assert_eq ! (actual , expected) } } fn main () { }
  |                                                                                               ^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpQcQTRZ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test_function_name () -> i32 { { assert_eq ! (actual , expected) } } fn main () { }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpQcQTRZ/main.rs:1:71
  |
1 | use std :: collections :: HashMap ; fn test_function_name () -> i32 { { assert_eq ! (actual , expected) } } fn main () { }
  |                                                                       ^^                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_function_name () -> i32 { { assert_eq ! (actual , expected) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_function_name () -> i32 { assert_eq ! (actual , expected) } fn main () { }
  |

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpQcQTRZ/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn test_function_name () -> i32 { { assert_eq ! (actual , expected) } } fn main () { }
  |                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 3 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0317, E0425.
For more information about an error, try `rustc --explain E0317`.



=== ch03-01-testing-functions example 3 ===
✗ Compilation failed: Compilation failed:
error[E0433]: failed to resolve: there are too many leading `super` keywords
 --> /tmp/.tmpAkrA9B/main.rs:1:211
  |
1 | ...0i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }
  |                                              ^^^^^ there are too many leading `super` keywords

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpAkrA9B/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test_addition () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn test_subtraction () -> i...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpAkrA9B/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn test_addition () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn test_subtraction () -> i...
  |                                                                  ^^                                      ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_addition () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn test_subtraction () -> i32 { { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }
1 + use std :: collections :: HashMap ; fn test_addition () -> i32 { assert_eq ! (add (2i32 , 3i32) , 5i32) } fn test_subtraction () -> i32 { { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpAkrA9B/main.rs:1:143
  |
1 | ... 5i32) } } fn test_subtraction () -> i32 { { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }
  |                                               ^^                                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_addition () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn test_subtraction () -> i32 { { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }
1 + use std :: collections :: HashMap ; fn test_addition () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn test_subtraction () -> i32 { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } fn main () { use super :: * ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpAkrA9B/main.rs:1:224
  |
1 | ...2 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error[E0425]: cannot find function `add` in this scope
 --> /tmp/.tmpAkrA9B/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn test_addition () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn test_subtraction () -> i...
  |                                                                                 ^^^ not found in this scope
  |
help: use the `.` operator to call the method `Add::add` on `i32`
  |
1 - use std :: collections :: HashMap ; fn test_addition () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn test_subtraction () -> i32 { { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }
1 + use std :: collections :: HashMap ; fn test_addition () -> i32 { { assert_eq ! (2i32.add(3i32) , 5i32) } } fn test_subtraction () -> i32 { { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }
  |

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpAkrA9B/main.rs:1:68
  |
1 | use std :: collections :: HashMap ; fn test_addition () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn test_subtraction () -> i...
  |                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `subtract` in this scope
 --> /tmp/.tmpAkrA9B/main.rs:1:158
  |
1 | ...} } fn test_subtraction () -> i32 { { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }
  |                                                       ^^^^^^^^ not found in this scope

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpAkrA9B/main.rs:1:145
  |
1 | ...test_subtraction () -> i32 { { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 5 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0317, E0425, E0433.
For more information about an error, try `rustc --explain E0317`.



=== ch03-01-testing-functions example 4 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpt7f1zx/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b ==...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpt7f1zx/main.rs:1:78
  |
1 | use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b ==...
  |                                                                              ^^     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { a * b } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpt7f1zx/main.rs:1:129
  |
1 | ...} } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32...
  |                                               ^^                                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { if b == 0i32 { { 0i32 } } else { { a / b } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpt7f1zx/main.rs:1:146
  |
1 | ... b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2...
  |                                                                   ^^    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { 0i32 } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpt7f1zx/main.rs:1:164
  |
1 | ... : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn ...
  |                                                                  ^^     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { a / b } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpt7f1zx/main.rs:1:210
  |
1 | ...} } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (...
  |                                                             ^^                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { n % 2i32 == 0i32 } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpt7f1zx/main.rs:1:212
  |
1 | ...{ a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32...
  |                                            ---     ^^^^^^^^^^^^^^^^ expected `i32`, found `bool`
  |                                            |
  |                                            expected `i32` because of return type

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpt7f1zx/main.rs:1:357
  |
1 | ...tiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpt7f1zx/main.rs:1:527
  |
1 | ... (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32))...
  |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
 --> /tmp/.tmpt7f1zx/main.rs:1:603
  |
1 | ...0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert !...
  |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpt7f1zx/main.rs:1:631
  |
1 | ...-> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn ...
  |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpt7f1zx/main.rs:1:661
  |
1 | ...(4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpt7f1zx/main.rs:1:689
  |
1 | ...(3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpt7f1zx/main.rs:1:689
  |
1 | ... (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |                                           |
  |                                           expected `i32`, found `()`
  |                                           found here
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type

error: aborting due to 8 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0308, E0317.
For more information about an error, try `rustc --explain E0308`.



=== ch03-01-testing-functions example 5 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmprTczrd/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { le...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmprTczrd/main.rs:1:77
  |
1 | ... { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } ...
  |       ^^                                                                                                                                                                                                                                                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmprTczrd/main.rs:1:109
  |
1 | use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { le...
  |                                                                                                             ^^           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { - 999999i32 } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmprTczrd/main.rs:1:266
  |
1 | ... . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_fi...
  |                                                      ^^                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { max_val = numbers [i as usize] } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmprTczrd/main.rs:1:102
  |
1 | ...nd_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize...
  |                                            ----------------    ^^^^ expected `usize`, found `i32`
  |                                            |
  |                                            expected because this is `usize`
  |
help: change the type of the numeric literal from `i32` to `usize`
  |
1 - use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0usize { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
  |

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmprTczrd/main.rs:1:163
  |
1 | ...2 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] >...
  |                                              ^^^^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0308]: mismatched types
 --> /tmp/.tmprTczrd/main.rs:1:209
  |
1 | ...0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize...
  |                                              -   ^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                              |
  |                                              expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len ().try_into().unwrap() { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
  |                                                                                                                                                                                                                                 ++++++++++++++++++++

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmprTczrd/main.rs:1:242
  |
1 | ...while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val }...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmprTczrd/main.rs:1:287
  |
1 | ...as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0308]: mismatched types
 --> /tmp/.tmprTczrd/main.rs:1:394
  |
1 | ...-> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ;...
  |                            --------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `Vec<i32>`
  |                            |
  |                            arguments to this function are incorrect
  |
  = note: expected struct `String`
             found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmprTczrd/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { le...
  |                                        ^^^^^^^^  ----------------

error[E0308]: mismatched types
 --> /tmp/.tmprTczrd/main.rs:1:469
  |
1 | ...9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq !...
  |                                         --------  ^^^^^^^^^^^^^ expected `String`, found `Vec<i32>`
  |                                         |
  |                                         arguments to this function are incorrect
  |
  = note: expected struct `String`
             found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmprTczrd/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { le...
  |                                        ^^^^^^^^  ----------------

error[E0308]: mismatched types
 --> /tmp/.tmprTczrd/main.rs:1:518
  |
1 | ... (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]...
  |                                             --------  ^^^^^^^^ expected `String`, found `Vec<_>`
  |                                             |
  |                                             arguments to this function are incorrect
  |
  = note: expected struct `String`
             found struct `Vec<_>`
note: function defined here
 --> /tmp/.tmprTczrd/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { le...
  |                                        ^^^^^^^^  ----------------

error[E0308]: mismatched types
 --> /tmp/.tmprTczrd/main.rs:1:568
  |
1 | ... 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32])...
  |                               --------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `Vec<i32>`
  |                               |
  |                               arguments to this function are incorrect
  |
  = note: expected struct `String`
             found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmprTczrd/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { le...
  |                                        ^^^^^^^^  ----------------

error[E0308]: mismatched types
 --> /tmp/.tmprTczrd/main.rs:1:638
  |
1 | ...i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
  |                                   --------  ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `Vec<i32>`
  |                                   |
  |                                   arguments to this function are incorrect
  |
  = note: expected struct `String`
             found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmprTczrd/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { le...
  |                                        ^^^^^^^^  ----------------

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmprTczrd/main.rs:1:615
  |
1 | ..., - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
  |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 11 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0317.
For more information about an error, try `rustc --explain E0277`.



=== ch03-01-testing-functions example 6 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmphbNaZR/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { { raw_username . replace (" " , "_") } } fn count_...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmphbNaZR/main.rs:1:88
  |
1 | use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { { raw_username . replace (" " , "_") } } fn count_...
  |                                                                                        ^^                                  ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { { raw_username . replace (" " , "_") } } fn count_vowels (text : String) -> i32 { { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_username () -> i32 { { assert_eq ! (clean_username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () -> i32 { { assert_eq ! (count_vowels ("hello" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { raw_username . replace (" " , "_") } fn count_vowels (text : String) -> i32 { { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_username () -> i32 { { assert_eq ! (clean_username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () -> i32 { { assert_eq ! (count_vowels ("hello" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmphbNaZR/main.rs:1:170
  |
1 | ... { { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } ...
  |       ^^                                                                                                                                                                                                                         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { { raw_username . replace (" " , "_") } } fn count_vowels (text : String) -> i32 { { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_username () -> i32 { { assert_eq ! (clean_username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () -> i32 { { assert_eq ! (count_vowels ("hello" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { { raw_username . replace (" " , "_") } } fn count_vowels (text : String) -> i32 { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } fn test_clean_username () -> i32 { { assert_eq ! (clean_username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () -> i32 { { assert_eq ! (count_vowels ("hello" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmphbNaZR/main.rs:1:332
  |
1 | ... len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_use...
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { { raw_username . replace (" " , "_") } } fn count_vowels (text : String) -> i32 { { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_username () -> i32 { { assert_eq ! (clean_username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () -> i32 { { assert_eq ! (count_vowels ("hello" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { { raw_username . replace (" " , "_") } } fn count_vowels (text : String) -> i32 { { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { count = count + 1i32 } ; i = i + 1i32 } } ; count } } } } fn test_clean_username () -> i32 { { assert_eq ! (clean_username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () -> i32 { { assert_eq ! (count_vowels ("hello" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmphbNaZR/main.rs:1:90
  |
1 | ...me (raw_username : String) -> i32 { { raw_username . replace (" " , "_") } } fn count_vowels (text : String) -> i32 { { { let vowels =...
  |                                  ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`
  |                                  |
  |                                  expected `i32` because of return type

error[E0308]: mismatched types
 --> /tmp/.tmphbNaZR/main.rs:1:271
  |
1 | ...ut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } }...
  |                                               -   ^^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                               |
  |                                               expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { { raw_username . replace (" " , "_") } } fn count_vowels (text : String) -> i32 { { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len ().try_into().unwrap() { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_username () -> i32 { { assert_eq ! (clean_username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () -> i32 { { assert_eq ! (count_vowels ("hello" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
  |                                                                                                                                                                                                                                                                                            ++++++++++++++++++++

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmphbNaZR/main.rs:1:317
  |
1 | ...t . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0308]: mismatched types
 --> /tmp/.tmphbNaZR/main.rs:1:494
  |
1 | ..._username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert...
  |                                                 ^^^^^^^^^^^^^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmphbNaZR/main.rs:1:567
  |
1 | ...t_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vow...
  |                                                     ^^^^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmphbNaZR/main.rs:1:627
  |
1 | ... assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () -> i32 { { assert_eq ! (count_vowels ("hello" . to_...
  |                                                       ^^ expected `i32`, found `&str`

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmphbNaZR/main.rs:1:577
  |
1 | ... to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () -> i32 { { assert_eq ! (c...
  |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmphbNaZR/main.rs:1:912
  |
1 | ... . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
  |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 8 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0317.
For more information about an error, try `rustc --explain E0277`.



=== ch03-01-testing-functions example 7 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpDYqqC5/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpDYqqC5/main.rs:1:82
  |
1 | ... { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } ...
  |       ^^                                                                                                                                                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpDYqqC5/main.rs:1:104
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32...
  |                                                                                                        ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { "A" } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpDYqqC5/main.rs:1:141
  |
1 | ...2 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { "B" } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpDYqqC5/main.rs:1:178
  |
1 | ...lse { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } }...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { "C" } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpDYqqC5/main.rs:1:215
  |
1 | ...lse { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_cit...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { "D" } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpDYqqC5/main.rs:1:232
  |
1 | ... 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) ->...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { "F" } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpDYqqC5/main.rs:1:310
  |
1 | ..._vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq !...
  |                                                        ^^                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { age >= 18i32 && is_citizen } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:96
  |
1 | ...de (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } }...
  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`
  |                                      |        |
  |                                      |        expected `String`, found `i32`
  |                                      expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:106
  |
1 | ...calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i3...
  |                                        ---                           ^^^ expected `i32`, found `&str`
  |                                        |
  |                                        expected `i32` because of return type

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:133
  |
1 | ...re >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } }...
  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`
  |                                      |        |
  |                                      |        expected `String`, found `i32`
  |                                      expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:143
  |
1 | ...ore : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else ...
  |                     --- expected `i32` because of return type                          ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:170
  |
1 | ...re >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vo...
  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`
  |                                      |        |
  |                                      |        expected `String`, found `i32`
  |                                      expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:180
  |
1 | ...String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if s...
  |               --- expected `i32` because of return type                                                               ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:207
  |
1 | ...re >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : Strin...
  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`
  |                                      |        |
  |                                      |        expected `String`, found `i32`
  |                                      expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:217
  |
1 | ...-> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } ...
  |       --- expected `i32` because of return type                                                                                                    ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:234
  |
1 | ...-> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } ...
  |       --- expected `i32` because of return type                                                                                                                     ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:319
  |
1 | ... , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (...
  |                                       ---    ^^^^^- help: try using a conversion method: `.to_string()`
  |                                       |      |
  |                                       |      expected `String`, found `i32`
  |                                       expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:328
  |
1 | ...ing , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grad...
  |                                          ------------    ^^^^^^^^^^ expected `bool`, found `String`
  |                                          |
  |                                          expected because this is `bool`

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:312
  |
1 | ...: String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate...
  |                                       ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `bool`
  |                                       |
  |                                       expected `i32` because of return type

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:411
  |
1 | ...de () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_gr...
  |                                  ---------------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                  |                |
  |                                  |                expected `String`, found `i32`
  |                                  arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpDYqqC5/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32...
  |                                        ^^^^^^^^^^^^^^^  --------------

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:420
  |
1 | ... -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (...
  |                                                       ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:457
  |
1 | ...(95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_gr...
  |                                  ---------------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                  |                |
  |                                  |                expected `String`, found `i32`
  |                                  arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpDYqqC5/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32...
  |                                        ^^^^^^^^^^^^^^^  --------------

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:466
  |
1 | ...2) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (...
  |                                                       ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:503
  |
1 | ...(90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_gr...
  |                                  ---------------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                  |                |
  |                                  |                expected `String`, found `i32`
  |                                  arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpDYqqC5/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32...
  |                                        ^^^^^^^^^^^^^^^  --------------

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:512
  |
1 | ...2) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (...
  |                                                       ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:549
  |
1 | ...(89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_gr...
  |                                  ---------------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                  |                |
  |                                  |                expected `String`, found `i32`
  |                                  arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpDYqqC5/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32...
  |                                        ^^^^^^^^^^^^^^^  --------------

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:558
  |
1 | ...2) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (...
  |                                                       ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:595
  |
1 | ...(80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_gr...
  |                                  ---------------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                  |                |
  |                                  |                expected `String`, found `i32`
  |                                  arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpDYqqC5/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32...
  |                                        ^^^^^^^^^^^^^^^  --------------

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:604
  |
1 | ...2) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (...
  |                                                       ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:641
  |
1 | ...(79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i...
  |                                  ---------------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                  |                |
  |                                  |                expected `String`, found `i32`
  |                                  arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpDYqqC5/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32...
  |                                        ^^^^^^^^^^^^^^^  --------------

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:650
  |
1 | ...2) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { ...
  |                                                       ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:687
  |
1 | ...(59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; as...
  |                                  ---------------  ^^^^- help: try using a conversion method: `.to_string()`
  |                                  |                |
  |                                  |                expected `String`, found `i32`
  |                                  arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpDYqqC5/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32...
  |                                        ^^^^^^^^^^^^^^^  --------------

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:695
  |
1 | ...32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert...
  |                                                       ^^^ expected `i32`, found `&str`

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpDYqqC5/main.rs:1:657
  |
1 | ...alculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i3...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpDYqqC5/main.rs:1:745
  |
1 | ...n test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , ...
  |                                            ^^^^^^^^  -----   ---- expected `String`, found `bool`
  |                                                      |
  |                                                      expected `String`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpDYqqC5/main.rs:1:255
  |
1 | ...2 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn...
  |                                                ^^^^^^^^  ------------   -------------------
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32.to_string() , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ++++++++++++
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true.to_string())) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:735
  |
1 | ...} } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i...
  |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpDYqqC5/main.rs:1:782
  |
1 | ...! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 ...
  |                                            ^^^^^^^^  -----   ---- expected `String`, found `bool`
  |                                                      |
  |                                                      expected `String`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpDYqqC5/main.rs:1:255
  |
1 | ...2 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn...
  |                                                ^^^^^^^^  ------------   -------------------
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32.to_string() , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ++++++++++++
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true.to_string())) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:772
  |
1 | ...sert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (2...
  |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpDYqqC5/main.rs:1:821
  |
1 | ...(can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32...
  |                                            ^^^^^^^^  -----   ---- expected `String`, found `bool`
  |                                                      |
  |                                                      expected `String`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpDYqqC5/main.rs:1:255
  |
1 | ...2 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn...
  |                                                ^^^^^^^^  ------------   -------------------
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32.to_string() , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ++++++++++++
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true.to_string())) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:809
  |
1 | ...ert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote ...
  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpDYqqC5/main.rs:1:860
  |
1 | ...can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                           ^^^^^^^^  -----   ----- expected `String`, found `bool`
  |                                                     |
  |                                                     expected `String`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpDYqqC5/main.rs:1:255
  |
1 | ...2 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn...
  |                                                ^^^^^^^^  ------------   -------------------
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32.to_string() , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ++++++++++++
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false.to_string())) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:848
  |
1 | ...t ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpDYqqC5/main.rs:1:900
  |
1 | ...an_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                           ^^^^^^^^  -----   ----- expected `String`, found `bool`
  |                                                     |
  |                                                     expected `String`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpDYqqC5/main.rs:1:255
  |
1 | ...2 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn...
  |                                                ^^^^^^^^  ------------   -------------------
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32.to_string() , false)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ++++++++++++
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false.to_string())) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpDYqqC5/main.rs:1:888
  |
1 | ... ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpDYqqC5/main.rs:1:888
  |
1 | ...t ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |                                       |
  |                                       expected `i32`, found `()`
  |                                       found here
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type

error: aborting due to 38 previous errors; 8 warnings emitted

Some errors have detailed explanations: E0308, E0317.
For more information about an error, try `rustc --explain E0308`.



=== ch03-01-testing-functions example 8 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpKn0oQp/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test_fahrenheit_to_celsius () -> i32 { { assert_eq ! (fahrenheit_to_celsius (32i32) , 0i32) ; asse...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpKn0oQp/main.rs:1:304
  |
1 | ...it_to_celsius (fahrenheit : String) -> i32 { { return fahrenheit - 32i32 * 5i32 / 9i32 } } fn main () { }
  |                                                 ^^                                       ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_fahrenheit_to_celsius () -> i32 { { assert_eq ! (fahrenheit_to_celsius (32i32) , 0i32) ; assert_eq ! (fahrenheit_to_celsius (212i32) , 100i32) ; assert_eq ! (fahrenheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius (fahrenheit : String) -> i32 { { return fahrenheit - 32i32 * 5i32 / 9i32 } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_fahrenheit_to_celsius () -> i32 { { assert_eq ! (fahrenheit_to_celsius (32i32) , 0i32) ; assert_eq ! (fahrenheit_to_celsius (212i32) , 100i32) ; assert_eq ! (fahrenheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius (fahrenheit : String) -> i32 { return fahrenheit - 32i32 * 5i32 / 9i32 } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpKn0oQp/main.rs:1:117
  |
1 | ...() -> i32 { { assert_eq ! (fahrenheit_to_celsius (32i32) , 0i32) ; assert_eq ! (fahrenheit_to_celsius (212i32) , 100i32) ; assert_eq !...
  |                               ---------------------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                               |                      |
  |                               |                      expected `String`, found `i32`
  |                               arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpKn0oQp/main.rs:1:251
  |
1 | ...renheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius (fahrenheit : String) -> i32 { { return fahrenheit - 32i32 * 5i32 /...
  |                                                 ^^^^^^^^^^^^^^^^^^^^^  -------------------

error[E0308]: mismatched types
 --> /tmp/.tmpKn0oQp/main.rs:1:170
  |
1 | ...2) , 0i32) ; assert_eq ! (fahrenheit_to_celsius (212i32) , 100i32) ; assert_eq ! (fahrenheit_to_celsius (98.6f64) , 37i32) } } fn fahr...
  |                              ---------------------  ^^^^^^- help: try using a conversion method: `.to_string()`
  |                              |                      |
  |                              |                      expected `String`, found `i32`
  |                              arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpKn0oQp/main.rs:1:251
  |
1 | ...renheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius (fahrenheit : String) -> i32 { { return fahrenheit - 32i32 * 5i32 /...
  |                                                 ^^^^^^^^^^^^^^^^^^^^^  -------------------

error[E0308]: mismatched types
 --> /tmp/.tmpKn0oQp/main.rs:1:226
  |
1 | ... , 100i32) ; assert_eq ! (fahrenheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius (fahrenheit : String) -> i32 { { retur...
  |                              ---------------------  ^^^^^^^- help: try using a conversion method: `.to_string()`
  |                              |                      |
  |                              |                      expected `String`, found `f64`
  |                              arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpKn0oQp/main.rs:1:251
  |
1 | ...renheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius (fahrenheit : String) -> i32 { { return fahrenheit - 32i32 * 5i32 /...
  |                                                 ^^^^^^^^^^^^^^^^^^^^^  -------------------

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpKn0oQp/main.rs:1:190
  |
1 | ...lsius (212i32) , 100i32) ; assert_eq ! (fahrenheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius (fahrenheit : String) ->...
  |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0369]: cannot subtract `i32` from `String`
   --> /tmp/.tmpKn0oQp/main.rs:1:324
    |
1   | ..._celsius (fahrenheit : String) -> i32 { { return fahrenheit - 32i32 * 5i32 / 9i32 } } fn main () { }
    |                                                     ---------- ^ ------------------- i32
    |                                                     |
    |                                                     String
    |
note: the foreign item type `String` doesn't implement `Sub<i32>`
   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:360:1
    |
360 | pub struct String {
    | ^^^^^^^^^^^^^^^^^ not implement `Sub<i32>`

error: aborting due to 5 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0308, E0317, E0369.
For more information about an error, try `rustc --explain E0308`.



=== ch03-01-testing-functions example 9 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpKi3RBT/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test_divide_bad () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) } } fn test_divide_good (...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpKi3RBT/main.rs:1:68
  |
1 | use std :: collections :: HashMap ; fn test_divide_bad () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) } } fn test_divide_good (...
  |                                                                    ^^                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_divide_bad () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) } } fn test_divide_good () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (0i32 , 5i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_divide_bad () -> i32 { assert_eq ! (divide (10i32 , 2i32) , 5i32) } fn test_divide_good () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (0i32 , 5i32) , 0i32) } } fn main () { }
  |

error[E0425]: cannot find function `divide` in this scope
 --> /tmp/.tmpKi3RBT/main.rs:1:83
  |
1 | use std :: collections :: HashMap ; fn test_divide_bad () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) } } fn test_divide_good (...
  |                                                                                   ^^^^^^ not found in this scope

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpKi3RBT/main.rs:1:70
  |
1 | ...n test_divide_bad () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) } } fn test_divide_good () -> i32 { { assert_eq ! (divide (...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `divide` in this scope
 --> /tmp/.tmpKi3RBT/main.rs:1:164
  |
1 | ... } } fn test_divide_good () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (0i32 , 5i32) , 0i32) } } fn m...
  |                                                        ^^^^^^ not found in this scope

error[E0425]: cannot find function `divide` in this scope
 --> /tmp/.tmpKi3RBT/main.rs:1:209
  |
1 | ..._eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (0i32 , 5i32) , 0i32) } } fn main () { }
  |                                                        ^^^^^^ not found in this scope

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpKi3RBT/main.rs:1:196
  |
1 | ...(divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (0i32 , 5i32) , 0i32) } } fn main () { }
  |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 5 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0317, E0425.
For more information about an error, try `rustc --explain E0317`.



=== ch03-01-testing-functions example 10 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpZmS2zM/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn te...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpZmS2zM/main.rs:1:65
  |
1 | use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn te...
  |                                                                 ^^                                                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_useless () -> i32 { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpZmS2zM/main.rs:1:160
  |
1 | ...sult > 0i32) } } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
  |                                                  ^^                                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () -> i32 { assert_eq ! (add (2i32 , 3i32) , 5i32) } fn main () { }
  |

error[E0425]: cannot find function `add` in this scope
 --> /tmp/.tmpZmS2zM/main.rs:1:82
  |
1 | use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn te...
  |                                                                                  ^^^ not found in this scope
  |
help: use the `.` operator to call the method `Add::add` on `i32`
  |
1 - use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = 2i32.add(3i32) ; assert ! (result > 0i32) } } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
  |

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpZmS2zM/main.rs:1:102
  |
1 | ...2 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , ...
  |                                             ^^^^^^^^^^^^^^^^^^^^^^^^
  |                                             |
  |                                             expected `i32`, found `()`
  |                                             found here
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type

error[E0425]: cannot find function `add` in this scope
 --> /tmp/.tmpZmS2zM/main.rs:1:175
  |
1 | ...i32) } } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
  |                                                         ^^^ not found in this scope
  |
help: use the `.` operator to call the method `Add::add` on `i32`
  |
1 - use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () -> i32 { { assert_eq ! (2i32.add(3i32) , 5i32) } } fn main () { }
  |

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpZmS2zM/main.rs:1:162
  |
1 | ... } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 4 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0317, E0425.
For more information about an error, try `rustc --explain E0317`.



=== ch03-01-testing-functions example 11 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpKGD3bN/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test1 () -> i32 { { assert_eq ! (is_valid ("abc" . to_string ()) , false) } } fn test_password_too...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpKGD3bN/main.rs:1:58
  |
1 | use std :: collections :: HashMap ; fn test1 () -> i32 { { assert_eq ! (is_valid ("abc" . to_string ()) , false) } } fn test_password_too...
  |                                                          ^^                                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test1 () -> i32 { { assert_eq ! (is_valid ("abc" . to_string ()) , false) } } fn test_password_too_short () -> i32 { { assert_eq ! (is_valid_password ("abc" . to_string ()) , false) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test1 () -> i32 { assert_eq ! (is_valid ("abc" . to_string ()) , false) } fn test_password_too_short () -> i32 { { assert_eq ! (is_valid_password ("abc" . to_string ()) , false) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpKGD3bN/main.rs:1:157
  |
1 | ...st_password_too_short () -> i32 { { assert_eq ! (is_valid_password ("abc" . to_string ()) , false) } } fn main () { }
  |                                      ^^                                                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test1 () -> i32 { { assert_eq ! (is_valid ("abc" . to_string ()) , false) } } fn test_password_too_short () -> i32 { { assert_eq ! (is_valid_password ("abc" . to_string ()) , false) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test1 () -> i32 { { assert_eq ! (is_valid ("abc" . to_string ()) , false) } } fn test_password_too_short () -> i32 { assert_eq ! (is_valid_password ("abc" . to_string ()) , false) } fn main () { }
  |

error[E0425]: cannot find function `is_valid` in this scope
 --> /tmp/.tmpKGD3bN/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn test1 () -> i32 { { assert_eq ! (is_valid ("abc" . to_string ()) , false) } } fn test_password_too...
  |                                                                         ^^^^^^^^ not found in this scope

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpKGD3bN/main.rs:1:60
  |
1 | ...p ; fn test1 () -> i32 { { assert_eq ! (is_valid ("abc" . to_string ()) , false) } } fn test_password_too_short () -> i32 { { assert_e...
  |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `is_valid_password` in this scope
 --> /tmp/.tmpKGD3bN/main.rs:1:172
  |
1 | ...password_too_short () -> i32 { { assert_eq ! (is_valid_password ("abc" . to_string ()) , false) } } fn main () { }
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpKGD3bN/main.rs:1:159
  |
1 | ...o_short () -> i32 { { assert_eq ! (is_valid_password ("abc" . to_string ()) , false) } } fn main () { }
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 4 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0317, E0425.
For more information about an error, try `rustc --explain E0317`.



=== ch03-01-testing-functions example 12 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp7n7fzI/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test_is_strong_password () -> i32 { { assert ! (is_strong_password ("MyPass123!" . to_string ())) ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp7n7fzI/main.rs:1:413
  |
1 | ...assword : String) -> i32 { { if password . len () < 8i32 { { return false } } ; { let has_digit = password . chars () . any (| c | c ....
  |                                                               ^^            ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_is_strong_password () -> i32 { { assert ! (is_strong_password ("MyPass123!" . to_string ())) ; assert ! (! is_strong_password ("weak" . to_string ())) ; assert ! (! is_strong_password ("NoNumbers!" . to_string ())) ; assert ! (! is_strong_password ("nonumbers123" . to_string ())) } } fn is_strong_password (password : String) -> i32 { { if password . len () < 8i32 { { return false } } ; { let has_digit = password . chars () . any (| c | c . is_digit ()) ; { let mut has_special = password . chars () . any (| c | "!@#$%^&*" . contains (c)) ; return has_digit && has_special } } } } fn test_password_edge_cases () -> i32 { { assert ! (! is_strong_password ("" . to_string ())) ; assert ! (! is_strong_password ("12345678" . to_string ())) ; assert ! (! is_strong_password ("!!!!!!!!" . to_string ())) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_is_strong_password () -> i32 { { assert ! (is_strong_password ("MyPass123!" . to_string ())) ; assert ! (! is_strong_password ("weak" . to_string ())) ; assert ! (! is_strong_password ("NoNumbers!" . to_string ())) ; assert ! (! is_strong_password ("nonumbers123" . to_string ())) } } fn is_strong_password (password : String) -> i32 { { if password . len () < 8i32 { return false } ; { let has_digit = password . chars () . any (| c | c . is_digit ()) ; { let mut has_special = password . chars () . any (| c | "!@#$%^&*" . contains (c)) ; return has_digit && has_special } } } } fn test_password_edge_cases () -> i32 { { assert ! (! is_strong_password ("" . to_string ())) ; assert ! (! is_strong_password ("12345678" . to_string ())) ; assert ! (! is_strong_password ("!!!!!!!!" . to_string ())) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp7n7fzI/main.rs:1:78
  |
1 | ...password () -> i32 { { assert ! (is_strong_password ("MyPass123!" . to_string ())) ; assert ! (! is_strong_password ("weak" . to_strin...
  |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmp7n7fzI/main.rs:1:140
  |
1 | ...123!" . to_string ())) ; assert ! (! is_strong_password ("weak" . to_string ())) ; assert ! (! is_strong_password ("NoNumbers!" . to_s...
  |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmp7n7fzI/main.rs:1:198
  |
1 | ...k" . to_string ())) ; assert ! (! is_strong_password ("NoNumbers!" . to_string ())) ; assert ! (! is_strong_password ("nonumbers123" ....
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmp7n7fzI/main.rs:1:262
  |
1 | ..." . to_string ())) ; assert ! (! is_strong_password ("nonumbers123" . to_string ())) } } fn is_strong_password (password : String) -> ...
  |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmp7n7fzI/main.rs:1:262
  |
1 | ...!" . to_string ())) ; assert ! (! is_strong_password ("nonumbers123" . to_string ())) } } fn is_strong_password (password : String) ->...
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |                          |
  |                          expected `i32`, found `()`
  |                          found here
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type

error[E0308]: mismatched types
 --> /tmp/.tmp7n7fzI/main.rs:1:406
  |
1 | ...sword (password : String) -> i32 { { if password . len () < 8i32 { { return false } } ; { let has_digit = password . chars () . any (|...
  |                                            -----------------   ^^^^ expected `usize`, found `i32`
  |                                            |
  |                                            expected because this is `usize`
  |
help: change the type of the numeric literal from `i32` to `usize`
  |
1 - use std :: collections :: HashMap ; fn test_is_strong_password () -> i32 { { assert ! (is_strong_password ("MyPass123!" . to_string ())) ; assert ! (! is_strong_password ("weak" . to_string ())) ; assert ! (! is_strong_password ("NoNumbers!" . to_string ())) ; assert ! (! is_strong_password ("nonumbers123" . to_string ())) } } fn is_strong_password (password : String) -> i32 { { if password . len () < 8i32 { { return false } } ; { let has_digit = password . chars () . any (| c | c . is_digit ()) ; { let mut has_special = password . chars () . any (| c | "!@#$%^&*" . contains (c)) ; return has_digit && has_special } } } } fn test_password_edge_cases () -> i32 { { assert ! (! is_strong_password ("" . to_string ())) ; assert ! (! is_strong_password ("12345678" . to_string ())) ; assert ! (! is_strong_password ("!!!!!!!!" . to_string ())) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_is_strong_password () -> i32 { { assert ! (is_strong_password ("MyPass123!" . to_string ())) ; assert ! (! is_strong_password ("weak" . to_string ())) ; assert ! (! is_strong_password ("NoNumbers!" . to_string ())) ; assert ! (! is_strong_password ("nonumbers123" . to_string ())) } } fn is_strong_password (password : String) -> i32 { { if password . len () < 8usize { { return false } } ; { let has_digit = password . chars () . any (| c | c . is_digit ()) ; { let mut has_special = password . chars () . any (| c | "!@#$%^&*" . contains (c)) ; return has_digit && has_special } } } } fn test_password_edge_cases () -> i32 { { assert ! (! is_strong_password ("" . to_string ())) ; assert ! (! is_strong_password ("12345678" . to_string ())) ; assert ! (! is_strong_password ("!!!!!!!!" . to_string ())) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp7n7fzI/main.rs:1:422
  |
1 | ...rd (password : String) -> i32 { { if password . len () < 8i32 { { return false } } ; { let has_digit = password . chars () . any (| c ...
  |                              --- expected `i32` because of return type      ^^^^^ expected `i32`, found `bool`

error[E0061]: this method takes 1 argument but 0 arguments were supplied
   --> /tmp/.tmp7n7fzI/main.rs:1:489
    |
1   | ...git = password . chars () . any (| c | c . is_digit ()) ; { let mut has_special = password . chars () . any (| c | "!@#$%^&*" . contai...
    |                                               ^^^^^^^^--- argument #1 of type `u32` is missing
    |
note: method defined here
   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/char/methods.rs:343:18
    |
343 |     pub const fn is_digit(self, radix: u32) -> bool {
    |                  ^^^^^^^^
help: provide the argument
    |
1   | use std :: collections :: HashMap ; fn test_is_strong_password () -> i32 { { assert ! (is_strong_password ("MyPass123!" . to_string ())) ; assert ! (! is_strong_password ("weak" . to_string ())) ; assert ! (! is_strong_password ("NoNumbers!" . to_string ())) ; assert ! (! is_strong_password ("nonumbers123" . to_string ())) } } fn is_strong_password (password : String) -> i32 { { if password . len () < 8i32 { { return false } } ; { let has_digit = password . chars () . any (| c | c . is_digit(/* u32 */)) ; { let mut has_special = password . chars () . any (| c | "!@#$%^&*" . contains (c)) ; return has_digit && has_special } } } } fn test_password_edge_cases () -> i32 { { assert ! (! is_strong_password ("" . to_string ())) ; assert ! (! is_strong_password ("12345678" . to_string ())) ; assert ! (! is_strong_password ("!!!!!!!!" . to_string ())) } } fn main () { }
    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ~~~~~~~~~~~

error[E0308]: mismatched types
 --> /tmp/.tmp7n7fzI/main.rs:1:672
  |
1 | ...d_edge_cases () -> i32 { { assert ! (! is_strong_password ("" . to_string ())) ; assert ! (! is_strong_password ("12345678" . to_strin...
  |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmp7n7fzI/main.rs:1:726
  |
1 | ...("" . to_string ())) ; assert ! (! is_strong_password ("12345678" . to_string ())) ; assert ! (! is_strong_password ("!!!!!!!!" . to_s...
  |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmp7n7fzI/main.rs:1:788
  |
1 | ...78" . to_string ())) ; assert ! (! is_strong_password ("!!!!!!!!" . to_string ())) } } fn main () { }
  |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmp7n7fzI/main.rs:1:788
  |
1 | ...678" . to_string ())) ; assert ! (! is_strong_password ("!!!!!!!!" . to_string ())) } } fn main () { }
  |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |                            |
  |                            expected `i32`, found `()`
  |                            found here
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type

error: aborting due to 12 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0061, E0308, E0317.
For more information about an error, try `rustc --explain E0061`.



=== ch16-00-testing-quality example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 2 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpo1I6Sy/main.rs:1:500
  |
1 | ... . spawn (|| { heavy_computation () }) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0425]: cannot find value `spawn` in this scope
 --> /tmp/.tmpo1I6Sy/main.rs:1:82
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut handle = spawn ; { println ! ("Running in parallel!") ; compute_r...
  |                                                                                  ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::spawn;
  |

error[E0425]: cannot find value `spawn` in this scope
 --> /tmp/.tmpo1I6Sy/main.rs:1:248
  |
1 | ...ata = vec ! [1i32 , 2i32 , 3i32] ; let mut handle = spawn ; r#move ; { { let sum = data . sum () ; println ! ("{:?}" , format ! ("{}{}...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::spawn;
  |

error[E0425]: cannot find value `r#move` in this scope
 --> /tmp/.tmpo1I6Sy/main.rs:1:256
  |
1 | ...c ! [1i32 , 2i32 , 3i32] ; let mut handle = spawn ; r#move ; { { let sum = data . sum () ; println ! ("{:?}" , format ! ("{}{}" , "Sum...
  |                                                        ^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpo1I6Sy/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut handle = spawn ; { println ! ("Running in parallel!") ; compute_r...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `compute_result` in this scope
 --> /tmp/.tmpo1I6Sy/main.rs:1:129
  |
1 | ... spawn ; { println ! ("Running in parallel!") ; compute_result () } ; let mut result = handle . join () ; let mut data = vec ! [1i32 ,...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `sum` found for struct `Vec<i32>` in the current scope
 --> /tmp/.tmpo1I6Sy/main.rs:1:286
  |
1 | ...ut handle = spawn ; r#move ; { { let sum = data . sum () ; println ! ("{:?}" , format ! ("{}{}" , "Sum: " , sum . to_s ())) } } ; let ...
  |                                                      ^^^ `Vec<i32>` is not an iterator
  |
help: call `.into_iter()` first
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut handle = spawn ; { println ! ("Running in parallel!") ; compute_result () } ; let mut result = handle . join () ; let mut data = vec ! [1i32 , 2i32 , 3i32] ; let mut handle = spawn ; r#move ; { { let sum = data . into_iter().sum () ; println ! ("{:?}" , format ! ("{}{}" , "Sum: " , sum . to_s ())) } } ; let mut handle = Thread :: builder () . name ("worker") . stack_size (4i32 * 1024i32 * 1024i32) . spawn (|| { heavy_computation () }) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |                                                                                                                                                                                                                                                                                              ++++++++++++

error: aborting due to 6 previous errors; 1 warning emitted

Some errors have detailed explanations: E0425, E0599.
For more information about an error, try `rustc --explain E0425`.



=== ch14-00-concurrency example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 12 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 13 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch04-00-command-line-tools example 1 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpZCFISH/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("Word Counter Tool") ; print ! ("Enter filename: ") ; let mut ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpZCFISH/main.rs:1:396
  |
1 | ... input . pop () ; } } input } ; let mut content = read_file (filename) ; let mut words = content . split_whitespace () ; let mut word_...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 2 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmp2sJQpW/main.rs:1:1162
  |
1 | ... { input . pop () ; } } input } == "y" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp2sJQpW/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut name = { print ! ("{}" , "What's your name? ") ; std :: io :: Wri...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0599]: no method named `to_i` found for struct `String` in the current scope
 --> /tmp/.tmp2sJQpW/main.rs:1:777
  |
1 | ...ends_with ('\r') { input . pop () ; } } input } . to_i () ; let mut is_student = { print ! ("{}" , "Are you a student? (y/n) ") ; std ...
  |                                                      ^^^^ method not found in `String`

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0599`.



=== ch04-00-command-line-tools example 3 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpxFO0QP/main.rs:1:462
  |
1 | ... file_size ("data.txt" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpxFO0QP/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut content = read_file ("data.txt" . to_string ()) ; let mut lines =...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpxFO0QP/main.rs:1:83
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut content = read_file ("data.txt" . to_string ()) ; let mut lines =...
  |                                                                                   ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_lines` in this scope
 --> /tmp/.tmpxFO0QP/main.rs:1:139
  |
1 | ...ile ("data.txt" . to_string ()) ; let mut lines = read_lines ("data.txt" . to_string ()) ; write_file ("output.txt" . to_string () , "...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpxFO0QP/main.rs:1:180
  |
1 | ... lines = read_lines ("data.txt" . to_string ()) ; write_file ("output.txt" . to_string () , "Hello, World!" . to_string ()) ; append_f...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `timestamp` in this scope
 --> /tmp/.tmpxFO0QP/main.rs:1:331
  |
1 | ...to_string () , format ! ("{}{}" , "New entry: " , timestamp ())) ; let mut exists = file_exists ("config.txt" . to_string ()) ; let mu...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `append_file` in this scope
 --> /tmp/.tmpxFO0QP/main.rs:1:256
  |
1 | ...to_string () , "Hello, World!" . to_string ()) ; append_file ("log.txt" . to_string () , format ! ("{}{}" , "New entry: " , timestamp ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpxFO0QP/main.rs:1:365
  |
1 | ...New entry: " , timestamp ())) ; let mut exists = file_exists ("config.txt" . to_string ()) ; let mut size = file_size ("data.txt" . to...
  |                                                     ^^^^^^^^^^^ not found in this scope

error: aborting due to 7 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 4 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpZeuC3z/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut args = command_args () ; let mut program_name = args [0i32 as usi...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `command_args` in this scope
 --> /tmp/.tmpZeuC3z/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut args = command_args () ; let mut program_name = args [0i32 as usi...
  |                                                                                ^^^^^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `exit` in this scope
 --> /tmp/.tmphA5B00/main.rs:1:602
  |
1 | ..." , "Error: File '" , filename) , "' not found!")) ; exit (1i32) } } ; let mut content = read_file (filename) ; let mut lines = conten...
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::process::exit;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmphA5B00/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Text Processor ===") ; let mut filename = { print ! ("{}"...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmphA5B00/main.rs:1:468
  |
1 | ...ith ('\r') { input . pop () ; } } input } ; if ! file_exists (filename) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmphA5B00/main.rs:1:638
  |
1 | ...t found!")) ; exit (1i32) } } ; let mut content = read_file (filename) ; let mut lines = content . lines () ; println ! ("\nChoose ope...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0599]: no method named `to_i` found for struct `String` in the current scope
 --> /tmp/.tmphA5B00/main.rs:1:1240
  |
1 | ...ends_with ('\r') { input . pop () ; } } input } . to_i () ; match choice { 1i32 => { println ! ("{:?}" , format ! ("{}{}" , "Total lin...
  |                                                      ^^^^ method not found in `String`

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmphA5B00/main.rs:1:2203
  |
1 | ...= filename . replace (".txt" , "_modified.txt") ; write_file (output_file , new_content) ; println ! ("{:?}" , format ! ("{}{}" , "Sav...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmphA5B00/main.rs:1:2449
  |
1 | ...le = filename . replace (".txt" , "_upper.txt") ; write_file (output_file , upper_content) ; println ! ("{:?}" , format ! ("{}{}" , "S...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmphA5B00/main.rs:1:2822
  |
1 | ...le = filename . replace (".txt" , "_clean.txt") ; write_file (output_file , clean_content) ; println ! ("{:?}" , format ! ("{}{}" , "S...
  |                                                      ^^^^^^^^^^ not found in this scope

error: aborting due to 7 previous errors; 1 warning emitted

Some errors have detailed explanations: E0425, E0599.
For more information about an error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 6 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpiWeX87/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===") ; let mut log_file = { print ! ("{}" ,...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpiWeX87/main.rs:1:661
  |
1 | ... { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ...
  |       ^^                                                                                                                                                                                                  ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===") ; let mut log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===") ; let mut log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpiWeX87/main.rs:1:694
  |
1 | ... for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_co...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===") ; let mut log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===") ; let mut log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { success_count += 1i32 } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpiWeX87/main.rs:1:760
  |
1 | ...nt += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count...
  |                                                         ^^                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===") ; let mut log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===") ; let mut log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { not_found_count += 1i32 } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpiWeX87/main.rs:1:828
  |
1 | ...ount += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 1...
  |                                                           ^^                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===") ; let mut log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===") ; let mut log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { error_count += 1i32 } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpiWeX87/main.rs:1:1761
  |
1 | ... { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ...
  |       ^^                                                                                                                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===") ; let mut log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===") ; let mut log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `read_lines` in this scope
 --> /tmp/.tmpiWeX87/main.rs:1:482
  |
1 | ... { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_co...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpiWeX87/main.rs:1:1313
  |
1 | ...mat ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{:?}" , format...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpiWeX87/main.rs:1:1350
  |
1 | ...uccess_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , forma...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpiWeX87/main.rs:1:1486
  |
1 | ...! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{:?}" , form...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpiWeX87/main.rs:1:1525
  |
1 | ...ound_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , forma...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpiWeX87/main.rs:1:1660
  |
1 | ... ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; f...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpiWeX87/main.rs:1:1695
  |
1 | ... , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestam...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `extract_hour` in this scope
 --> /tmp/.tmpiWeX87/main.rs:1:1781
  |
1 | ...s = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `get` found for unit type `()` in the current scope
    --> /tmp/.tmpiWeX87/main.rs:1:1852
     |
1    | ...t_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hou...
     |                                                                     ^^^
     |
help: there is a method `ge` with a similar name, but with different arguments
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1438:5
     |
1438 |     fn ge(&self, other: &Rhs) -> bool {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `max_by_value` found for unit type `()` in the current scope
 --> /tmp/.tmpiWeX87/main.rs:1:1939
  |
1 | ...32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Bus...
  |                                                    ^^^^^^^^^^^^ method not found in `()`

error: aborting due to 10 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0425, E0599.
For more information about an error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 7 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp1rLLk3/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Batch File Renamer ===") ; let mut directory = { print ! ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp1rLLk3/main.rs:1:1296
  |
1 | ... { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") + new_name) ; renamed_count += 1i32 } } else { { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Batch File Renamer ===") ; let mut directory = { print ! ("{}" , "Enter directory path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") + new_name) ; renamed_count += 1i32 } } else { { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Batch File Renamer ===") ; let mut directory = { print ! ("{}" , "Enter directory path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") + new_name) ; renamed_count += 1i32 } } else { { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp1rLLk3/main.rs:1:1329
  |
1 | ... { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") + new_name) ; renamed_count += 1i32 } } else { { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Batch File Renamer ===") ; let mut directory = { print ! ("{}" , "Enter directory path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") + new_name) ; renamed_count += 1i32 } } else { { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Batch File Renamer ===") ; let mut directory = { print ! ("{}" , "Enter directory path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") + new_name) ; renamed_count += 1i32 } } else { { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp1rLLk3/main.rs:1:1671
  |
1 | ...named_count += 1i32 } } else { { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ; println ! ("{:...
  |                                   ^^                                                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Batch File Renamer ===") ; let mut directory = { print ! ("{}" , "Enter directory path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") + new_name) ; renamed_count += 1i32 } } else { { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Batch File Renamer ===") ; let mut directory = { print ! ("{}" , "Enter directory path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") + new_name) ; renamed_count += 1i32 } } else { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `list_files` in this scope
 --> /tmp/.tmp1rLLk3/main.rs:1:1220
  |
1 | ... { input . pop () ; } } input } ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if fil...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmp1rLLk3/main.rs:1:1410
  |
1 | ...ce (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ;...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmp1rLLk3/main.rs:1:1460
  |
1 | ...y , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ...
  |                                   ^^^^^^^^^ help: a local variable with a similar name exists: `old_path`

error[E0425]: cannot find function `rename_file` in this scope
 --> /tmp/.tmp1rLLk3/main.rs:1:1498
  |
1 | ...new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format !...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmp1rLLk3/main.rs:1:1849
  |
1 | ..., format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) ...
  |                                                        ^^^^ method not found in `i32`

error: aborting due to 5 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0425, E0599.
For more information about an error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 8 ===
✗ Compilation failed: Compilation failed:
error[E0423]: expected value, found macro `try`
 --> /tmp/.tmpIgG7rk/main.rs:1:445
  |
1 | ...rmission denied?)")) ; return false } } ; { let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! ("{:?}" , f...
  |                                                              ^^^^^ not a value

error[E0425]: cannot find value `catch` in this scope
 --> /tmp/.tmpIgG7rk/main.rs:1:482
  |
1 | ... let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! ("{:?}" , format ! ("{}{}" , "❌ Error reading file: " ,...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpIgG7rk/main.rs:1:490
  |
1 | ...tent = r#try ; { { read_file (filename) } ; catch ; error ; { println ! ("{:?}" , format ! ("{}{}" , "❌ Error reading file: " , error ....
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpIgG7rk/main.rs:1:566
  |
1 | ...?}" , format ! ("{}{}" , "❌ Error reading file: " , error . to_s ())) ; return false } ; let mut word_count = content . split_whitespac...
  |                                                         ^^^^^ not found in this scope

error[E0425]: cannot find function `exit` in this scope
 --> /tmp/.tmpIgG7rk/main.rs:1:1303
  |
1 | ...y!") } } else { { println ! ("Processing failed!") ; exit (1i32) } } ; }
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::process::exit;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpIgG7rk/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn process_file (filename : i32) -> i32 { { if ! file_exists (filename) { { println ! ("{:?}" , forma...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpIgG7rk/main.rs:1:1204
  |
1 | ...} input } ; if process_file (filename) { { println ! ("Processing completed successfully!") } } else { { println ! ("Processing failed...
  |                                             ^^                                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_file (filename : i32) -> i32 { { if ! file_exists (filename) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Error: File '" , filename) , "' does not exist")) ; return false } } ; if ! file_readable (filename) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Error: Cannot read file '" , filename) , "' (permission denied?)")) ; return false } } ; { let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! ("{:?}" , format ! ("{}{}" , "❌ Error reading file: " , error . to_s ())) ; return false } ; let mut word_count = content . split_whitespace () . len () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "✅ File processed: " , word_count . to_s ()) , " words")) ; return true } } } } fn main () { let mut filename = { print ! ("{}" , "Enter filename: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if process_file (filename) { { println ! ("Processing completed successfully!") } } else { { println ! ("Processing failed!") ; exit (1i32) } } ; }
1 + use std :: collections :: HashMap ; fn process_file (filename : i32) -> i32 { { if ! file_exists (filename) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Error: File '" , filename) , "' does not exist")) ; return false } } ; if ! file_readable (filename) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Error: Cannot read file '" , filename) , "' (permission denied?)")) ; return false } } ; { let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! ("{:?}" , format ! ("{}{}" , "❌ Error reading file: " , error . to_s ())) ; return false } ; let mut word_count = content . split_whitespace () . len () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "✅ File processed: " , word_count . to_s ()) , " words")) ; return true } } } } fn main () { let mut filename = { print ! ("{}" , "Enter filename: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; if process_file (filename) { println ! ("Processing completed successfully!") } else { { println ! ("Processing failed!") ; exit (1i32) } } ; }
  |

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpIgG7rk/main.rs:1:86
  |
1 | use std :: collections :: HashMap ; fn process_file (filename : i32) -> i32 { { if ! file_exists (filename) { { println ! ("{:?}" , forma...
  |                                                                                      ^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpIgG7rk/main.rs:1:233
  |
1 | ...-> i32 { { if ! file_exists (filename) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Error: File '" , filename) , "' does not exist")) ; return false } }...
  |       --- expected `i32` because of return type                                                                                                                        ^^^^^ expected `i32`, found `bool`

error[E0425]: cannot find function `file_readable` in this scope
 --> /tmp/.tmpIgG7rk/main.rs:1:250
  |
1 | ... "' does not exist")) ; return false } } ; if ! file_readable (filename) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , ...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpIgG7rk/main.rs:1:457
  |
1 | ... ; return false } } ; { let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! ("{:?}" , format ! ("{}{}" , "❌ ...
  |                                                      ^^^^^^^^^ not found in this scope

warning: unreachable statement
 --> /tmp/.tmpIgG7rk/main.rs:1:603
  |
1 | ...or . to_s ())) ; return false } ; let mut word_count = content . split_whitespace () . len () ; println ! ("{:?}" , format ! ("{}{}" ,...
  |                     ------------     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable statement
  |                     |
  |                     any code following this expression is unreachable
  |
  = note: `#[warn(unreachable_code)]` on by default

error[E0308]: mismatched types
 --> /tmp/.tmpIgG7rk/main.rs:1:1192
  |
1 | ...r') { input . pop () ; } } input } ; if process_file (filename) { { println ! ("Processing completed successfully!") } } else { { prin...
  |                                            ------------  ^^^^^^^^ expected `i32`, found `String`
  |                                            |
  |                                            arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpIgG7rk/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn process_file (filename : i32) -> i32 { { if ! file_exists (filename) { { println ! ("{:?}" , forma...
  |                                        ^^^^^^^^^^^^  --------------

error[E0308]: mismatched types
 --> /tmp/.tmpIgG7rk/main.rs:1:1178
  |
1 | ...\r') { input . pop () ; } } input } ; if process_file (filename) { { println ! ("Processing completed successfully!") } } else { { pri...
  |                                             ^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error: aborting due to 11 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0308, E0423, E0425.
For more information about an error, try `rustc --explain E0308`.



=== ch04-00-command-line-tools example 9 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `sleep` in this scope
 --> /tmp/.tmpgNjiUm/main.rs:1:845
  |
1 | .... to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } ...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::sleep;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpgNjiUm/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ;...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpgNjiUm/main.rs:1:549
  |
1 | ... { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                         ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress (files : String) -> i32 { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress (files : String) -> i32 { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpgNjiUm/main.rs:1:621
  |
1 | ... { { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ...
  |       ^^                                                                                                                                                                                                                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress (files : String) -> i32 { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress (files : String) -> i32 { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } ; println ! ("\n✅ All files processed!") } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpgNjiUm/main.rs:1:613
  |
1 | ... = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 ...
  |                                                   -   ^^^^^ expected `i32`, found `usize`
  |                                                   |
  |                                                   expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress (files : String) -> i32 { { { let total = files . len () ; { let mut i = 0i32 ; while i < total.try_into().unwrap() { { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ++++++++++++++++++++

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpgNjiUm/main.rs:1:643
  |
1 | ... ; while i < total { { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{:?}" , format ! (...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0308]: mismatched types
 --> /tmp/.tmpgNjiUm/main.rs:1:698
  |
1 | ...size] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" ,...
  |                                                     ^^^^^ expected `i32`, found `usize`

error[E0277]: cannot divide `i32` by `usize`
 --> /tmp/.tmpgNjiUm/main.rs:1:696
  |
1 | ...usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" ...
  |                                                    ^ no implementation for `i32 / usize`
  |
  = help: the trait `Div<usize>` is not implemented for `i32`
  = help: the following other types implement trait `Div<Rhs>`:
            `&i32` implements `Div<i32>`
            `&i32` implements `Div`
            `i32` implements `Div<&i32>`
            `i32` implements `Div`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpgNjiUm/main.rs:1:795
  |
1 | ...format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } ...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `process_file` in this scope
 --> /tmp/.tmpgNjiUm/main.rs:1:823
  |
1 | ...g... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All file...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpgNjiUm/main.rs:1:885
  |
1 | ...(100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } } fn main () { }
  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 8 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0425, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch04-00-command-line-tools example 10 ===
✗ Compilation failed: Compilation failed:
error: multiple unused formatting arguments
 --> /tmp/.tmpQciyHN/main.rs:1:291
  |
1 | ... 1i32 } } ; i = i + 1i32 } } ; println ! ("File has" , lines , "lines") } } } }
  |                                              ----------   ^^^^^   ^^^^^^^ argument never used
  |                                              |            |
  |                                              |            argument never used
  |                                              multiple missing formatting specifiers

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpQciyHN/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; let...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpQciyHN/main.rs:1:50
  |
1 | ... { { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("File has" , lines , "lines") } } } }
  |       ^^                                                                                                                                                                                                                                                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("File has" , lines , "lines") } } } }
1 + use std :: collections :: HashMap ; fn main () { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("File has" , lines , "lines") } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpQciyHN/main.rs:1:219
  |
1 | ...content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("File has" , lines ,...
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("File has" , lines , "lines") } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i as usize] == '\n' { lines = lines + 1i32 } ; i = i + 1i32 } } ; println ! ("File has" , lines , "lines") } } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpQciyHN/main.rs:1:164
  |
1 | ...t lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = ...
  |                                              -   ^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                              |
  |                                              expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len ().try_into().unwrap() { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("File has" , lines , "lines") } } } }
  |                                                                                                                                                                                    ++++++++++++++++++++

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpQciyHN/main.rs:1:197
  |
1 | ...while i < content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("File has"...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error: aborting due to 3 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.



=== ch04-00-command-line-tools example 11 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `TASK_FILE` in this scope
 --> /tmp/.tmpXuFVbn/main.rs:1:288
  |
1 | ...) } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `TASK_FILE` in this scope
 --> /tmp/.tmpXuFVbn/main.rs:1:322
  |
1 | ...if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `TASK_FILE` in this scope
 --> /tmp/.tmpXuFVbn/main.rs:1:451
  |
1 | ...{ let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_e...
  |                                                      ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpXuFVbn/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpXuFVbn/main.rs:1:301
  |
1 | ..._tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : Str...
  |                                                      ^^                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{:?}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { return read_lines (TASK_FILE) } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{:?}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXuFVbn/main.rs:1:399
  |
1 | ...ks (tasks : String) -> i32 { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : Str...
  |                                 ^^                                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{:?}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{:?}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXuFVbn/main.rs:1:762
  |
1 | ... { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{:?}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } }...
  |       ^^                                                                                                                                                                                                                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{:?}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{:?}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXuFVbn/main.rs:1:847
  |
1 | ... as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{:?}" , format ! ("{}{}...
  |                                                                   ^^      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{:?}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { "DONE" } else { { "PENDING" } } ; println ! ("{:?}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXuFVbn/main.rs:1:867
  |
1 | ... status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{:?}" , format ! ("{}{}" , i + 1i32 . to_s ()...
  |                                                                 ^^         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{:?}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { "PENDING" } ; println ! ("{:?}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXuFVbn/main.rs:1:1021
  |
1 | ... { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{:?}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{:?}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXuFVbn/main.rs:1:2140
  |
1 | ...) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.t...
  |                                                    ^^                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{:?}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{:?}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { println ! ("❌ Invalid task number") } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpXuFVbn/main.rs:1:275
  |
1 | ...! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } f...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_lines` in this scope
 --> /tmp/.tmpXuFVbn/main.rs:1:310
  |
1 | ... -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0599]: no method named `join` found for struct `String` in the current scope
 --> /tmp/.tmpXuFVbn/main.rs:1:425
  |
1 | ...asks : String) -> i32 { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) ...
  |                                                      ^^^^ method not found in `String`

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpXuFVbn/main.rs:1:439
  |
1 | ... -> i32 { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if ...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0069]: `return;` in a function whose return type is not `()`
 --> /tmp/.tmpXuFVbn/main.rs:1:581
  |
1 | ...sks : String) -> i32 { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}"...
  |                     --- expected `i32` because of this return type                        ^^^^^^ return type is not `()`
  |
help: give the `return` a value of the expected type
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return 42 } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{:?}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ++

error[E0599]: no method named `to_s` found for type `usize` in the current scope
 --> /tmp/.tmpXuFVbn/main.rs:1:690
  |
1 | ... ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task...
  |                                                        ^^^^ method not found in `usize`

error[E0308]: mismatched types
 --> /tmp/.tmpXuFVbn/main.rs:1:745
  |
1 | ... , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . start...
  |                                               -   ^^^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                               |
  |                                               expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len ().try_into().unwrap() { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{:?}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ++++++++++++++++++++

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpXuFVbn/main.rs:1:784
  |
1 | ...i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDIN...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpXuFVbn/main.rs:1:935
  |
1 | ...; println ! ("{:?}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i3...
  |                                                        ^^^^ method not found in `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpXuFVbn/main.rs:1:735
  |
1 | ...-> i32 { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{:?}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } f...
  |       --- expected `i32` because of return type                                                                                                                                                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `while` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{:?}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } /* `i32` value */ } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         +++++++++++++++++

error[E0599]: no method named `push` found for type `i32` in the current scope
 --> /tmp/.tmpXuFVbn/main.rs:1:1401
  |
1 | ...h ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task...
  |                                                        ^^^^ method not found in `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpXuFVbn/main.rs:1:1458
  |
1 | ...! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) -> i32 { { list_...
  |                                     ----------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                     |           |
  |                                     |           expected `String`, found `i32`
  |                                     arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpXuFVbn/main.rs:1:362
  |
1 | ... read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join ("\n") ; writ...
  |                                                         ^^^^^^^^^^  --------------

error[E0308]: mismatched types
 --> /tmp/.tmpXuFVbn/main.rs:1:1467
  |
1 | ...📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks)...
  |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
 --> /tmp/.tmpXuFVbn/main.rs:1:1557
  |
1 | ...e_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: ...
  |                                    ----------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                    |           |
  |                                    |           expected `String`, found `i32`
  |                                    arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpXuFVbn/main.rs:1:481
  |
1 | ...n ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! ("\n📝 ...
  |                                                         ^^^^^^^^^^  --------------

error[E0599]: no method named `to_i` found for struct `String` in the current scope
 --> /tmp/.tmpXuFVbn/main.rs:1:1940
  |
1 | ...ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usiz...
  |                                                      ^^^^ method not found in `String`

error[E0599]: no method named `len` found for type `i32` in the current scope
    --> /tmp/.tmpXuFVbn/main.rs:1:1993
     |
1    | ...} input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (...
     |                                                                     ^^^
     |
help: there is a method `le` with a similar name, but with different arguments
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1402:5
     |
1402 |     fn le(&self, other: &Rhs) -> bool {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
 --> /tmp/.tmpXuFVbn/main.rs:1:2088
  |
1 | ... usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } ...
  |                                      ----------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                      |           |
  |                                      |           expected `String`, found `i32`
  |                                      arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpXuFVbn/main.rs:1:362
  |
1 | ... read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join ("\n") ; writ...
  |                                                         ^^^^^^^^^^  --------------

error[E0308]: mismatched types
 --> /tmp/.tmpXuFVbn/main.rs:1:2097
  |
1 | ...ce ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main  ...
  |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
 --> /tmp/.tmpXuFVbn/main.rs:1:2142
  |
1 | ... ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_stri...
  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
 --> /tmp/.tmpXuFVbn/main.rs:1:2677
  |
1 | ...'\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (task...
  |                                                 ------   ^^^ expected `String`, found `&str`
  |                                                 |
  |                                                 this expression has type `String`

error[E0308]: mismatched types
 --> /tmp/.tmpXuFVbn/main.rs:1:2705
  |
1 | .... pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { ...
  |                                   ------                               ^^^ expected `String`, found `&str`
  |                                   |
  |                                   this expression has type `String`

error[E0308]: mismatched types
 --> /tmp/.tmpXuFVbn/main.rs:1:2731
  |
1 | ...} input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (t...
  |                      ------ this expression has type `String`                       ^^^ expected `String`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpXuFVbn/main.rs:1:2762
  |
1 | ...nput } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (task...
  |                   ------ this expression has type `String`                                                      ^^^ expected `String`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpXuFVbn/main.rs:1:3321
  |
1 | ...ch choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" =>...
  |       ------ this expression has type `String`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^^^ expected `String`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpXuFVbn/main.rs:1:2696
  |
1 | ...input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tas...
  |                                    ----------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                    |           |
  |                                    |           expected `String`, found `i32`
  |                                    arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpXuFVbn/main.rs:1:481
  |
1 | ...n ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! ("\n📝 ...
  |                                                         ^^^^^^^^^^  --------------

error[E0308]: mismatched types
 --> /tmp/.tmpXuFVbn/main.rs:1:2783
  |
1 | ...omplete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :...
  |                                    ----------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                    |           |
  |                                    |           expected `String`, found `i32`
  |                                    arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpXuFVbn/main.rs:1:481
  |
1 | ...n ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! ("\n📝 ...
  |                                                         ^^^^^^^^^^  --------------

error[E0599]: no method named `to_i` found for struct `String` in the current scope
 --> /tmp/.tmpXuFVbn/main.rs:1:3162
  |
1 | ...ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (inde...
  |                                                      ^^^^ method not found in `String`

error[E0599]: no method named `len` found for type `i32` in the current scope
    --> /tmp/.tmpXuFVbn/main.rs:1:3215
     |
1    | ...} input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("...
     |                                                                     ^^^
     |
help: there is a method `le` with a similar name, but with different arguments
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1402:5
     |
1402 |     fn le(&self, other: &Rhs) -> bool {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `remove` found for type `i32` in the current scope
 --> /tmp/.tmpXuFVbn/main.rs:1:3234
  |
1 | ...- 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task dele...
  |                                                                    ^^^^^^
  |
help: there is a method `rem` with a similar name
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{:?}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{:?}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let mut TASK_FILE = "tasks.txt" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . rem (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpXuFVbn/main.rs:1:3263
  |
1 | ...() { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!")...
  |                                    ----------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                    |           |
  |                                    |           expected `String`, found `i32`
  |                                    arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpXuFVbn/main.rs:1:362
  |
1 | ... read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join ("\n") ; writ...
  |                                                         ^^^^^^^^^^  --------------

error[E0308]: `match` arms have incompatible types
 --> /tmp/.tmpXuFVbn/main.rs:1:3179
  |
1 | ... ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } ...
  |       ------------          ------------------          ----------------          --------------------- this is found to be of type `i32`                                                                                                                                                                                                                                                                                                                                                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |       |                     |                           |
  |       |                     |                           this is found to be of type `i32`
  |       |                     this is found to be of type `i32`
  |       `match` arms have incompatible types

error: aborting due to 34 previous errors; 8 warnings emitted

Some errors have detailed explanations: E0069, E0277, E0308, E0425, E0599.
For more information about an error, try `rustc --explain E0069`.



=== ch04-00-command-line-tools example 13 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpgogL09/main.rs:1:337
  |
1 | ... ('\r') { input . pop () ; } } input } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpgogL09/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("Enter thing:") ; let mut thing = { let mut input = String :: ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch04-00-command-line-tools example 14 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found `let` statement
 --> /tmp/.tmpUTKNci/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let mut data = read_file ("/Users/noah/Desktop/data.txt" . to_string ()) ; ...
  |                                                               ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpUTKNci/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let mut data = read_file ("/Users/noah/Desktop/data.txt" . to_string ()) ; ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpUTKNci/main.rs:1:78
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let mut data = read_file ("/Users/noah/Desktop/data.txt" . to_string ()) ; ...
  |                                                                              ^^^^^^^^^ not found in this scope

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch12-00-traits-generics example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch03-00-functions-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `return_type` in this scope
 --> /tmp/.tmpg81S1u/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }
  |                                                                               ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `return_expression` in this scope
 --> /tmp/.tmpg81S1u/main.rs:1:95
  |
1 | use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }
  |                                                                                               ^^^^^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpg81S1u/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpg81S1u/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }
  |                                                                                             ^^                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }
1 + use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { return_expression } fn main () { }
  |

error: aborting due to 2 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch11-00-file-operations-tdd example 3 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp679z50/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp679z50/main.rs:1:71
  |
1 | use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if...
  |                                                                       ^^             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) -> i32 { { println ! ("Applying configuration...") ; println ! ("Config value:") ; println ! ("{:?}" , value) ; if validate_config (value) { { println ! ("Configuration applied successfully") } } else { { println ! ("Invalid configuration") } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }
1 + use std :: collections :: HashMap ; fn get_default_config () -> i32 { return 100i32 } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) -> i32 { { println ! ("Applying configuration...") ; println ! ("Config value:") ; println ! ("{:?}" , value) ; if validate_config (value) { { println ! ("Configuration applied successfully") } } else { { println ! ("Invalid configuration") } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp679z50/main.rs:1:174
  |
1 | ...e : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) -> i32 {...
  |                                                               ^^           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) -> i32 { { println ! ("Applying configuration...") ; println ! ("Config value:") ; println ! ("{:?}" , value) ; if validate_config (value) { { println ! ("Configuration applied successfully") } } else { { println ! ("Invalid configuration") } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }
1 + use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { return true } ; return false } } fn apply_config (value : i32) -> i32 { { println ! ("Applying configuration...") ; println ! ("Config value:") ; println ! ("{:?}" , value) ; if validate_config (value) { { println ! ("Configuration applied successfully") } } else { { println ! ("Invalid configuration") } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp679z50/main.rs:1:382
  |
1 | ... , value) ; if validate_config (value) { { println ! ("Configuration applied successfully") } } else { { println ! ("Invalid configura...
  |                                             ^^                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) -> i32 { { println ! ("Applying configuration...") ; println ! ("Config value:") ; println ! ("{:?}" , value) ; if validate_config (value) { { println ! ("Configuration applied successfully") } } else { { println ! ("Invalid configuration") } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }
1 + use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) -> i32 { { println ! ("Applying configuration...") ; println ! ("Config value:") ; println ! ("{:?}" , value) ; if validate_config (value) { println ! ("Configuration applied successfully") } else { { println ! ("Invalid configuration") } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp679z50/main.rs:1:444
  |
1 | ...onfiguration applied successfully") } } else { { println ! ("Invalid configuration") } } } } fn main () { { { let config = get_default...
  |                                                   ^^                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) -> i32 { { println ! ("Applying configuration...") ; println ! ("Config value:") ; println ! ("{:?}" , value) ; if validate_config (value) { { println ! ("Configuration applied successfully") } } else { { println ! ("Invalid configuration") } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }
1 + use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) -> i32 { { println ! ("Applying configuration...") ; println ! ("Config value:") ; println ! ("{:?}" , value) ; if validate_config (value) { { println ! ("Configuration applied successfully") } } else { println ! ("Invalid configuration") } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp679z50/main.rs:1:503
  |
1 | ...figuration") } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }
  |                                      ^^                                                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) -> i32 { { println ! ("Applying configuration...") ; println ! ("Config value:") ; println ! ("{:?}" , value) ; if validate_config (value) { { println ! ("Configuration applied successfully") } } else { { println ! ("Invalid configuration") } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }
1 + use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) -> i32 { { println ! ("Applying configuration...") ; println ! ("Config value:") ; println ! ("{:?}" , value) ; if validate_config (value) { { println ! ("Configuration applied successfully") } } else { { println ! ("Invalid configuration") } } } } fn main () { { let config = get_default_config () ; apply_config (config) } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp679z50/main.rs:1:384
  |
1 | ... validate_config (value) { { println ! ("Configuration applied successfully") } } else { { println ! ("Invalid configuration") } } } }...
  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
 --> /tmp/.tmp679z50/main.rs:1:446
  |
1 | ...applied successfully") } } else { { println ! ("Invalid configuration") } } } } fn main () { { { let config = get_default_config () ; ...
  |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
 --> /tmp/.tmp679z50/main.rs:1:544
  |
1 | ... } fn main () { { { let config = get_default_config () ; apply_config (config) } } }
  |                 -                                           ^^^^^^^^^^^^^^^^^^^^^- help: consider using a semicolon here: `;`
  |                 |                                           |
  |                 |                                           expected `()`, found `i32`
  |                 expected `()` because of default return type

error: aborting due to 3 previous errors; 6 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch11-00-file-operations-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `DataType` in this scope
 --> /tmp/.tmpTBDHxo/main.rs:1:56
  |
1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
  |                                                        ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `default_value` in this scope
 --> /tmp/.tmpTBDHxo/main.rs:1:76
  |
1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
  |                                                                            ^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpTBDHxo/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpTBDHxo/main.rs:1:67
  |
1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
  |                                                                   ^^                    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
1 + use std :: collections :: HashMap ; fn read_data () -> DataType { return default_value } fn main () { }
  |

error: aborting due to 2 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch11-00-file-operations-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `DataType` in this scope
 --> /tmp/.tmpaWnTda/main.rs:1:60
  |
1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...
  |                                                            ^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpaWnTda/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpaWnTda/main.rs:1:101
  |
1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...
  |                                                                                                     ^^           ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } fn main () { }
1 + use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { return true } ; return false } } fn main () { }
  |

error[E0425]: cannot find function `valid` in this scope
 --> /tmp/.tmpaWnTda/main.rs:1:85
  |
1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...
  |                                                                                     ^^^^^ not found in this scope

error: aborting due to 2 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch11-00-file-operations-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `ConfigType` in this scope
 --> /tmp/.tmpEeD1wP/main.rs:1:58
  |
1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...
  |                                                          ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `default_config` in this scope
 --> /tmp/.tmpEeD1wP/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...
  |                                                                                ^^^^^^^^^^^^^^ not found in this scope

error[E0412]: cannot find type `ConfigType` in this scope
 --> /tmp/.tmpEeD1wP/main.rs:1:124
  |
1 | ...eturn default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
  |                                                      ^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpEeD1wP/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpEeD1wP/main.rs:1:71
  |
1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...
  |                                                                       ^^                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
1 + use std :: collections :: HashMap ; fn load_config () -> ConfigType { return default_config } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpEeD1wP/main.rs:1:146
  |
1 | ...g } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
  |                                                         ^^                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
1 + use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { return validate (config) } fn main () { }
  |

error[E0425]: cannot find function `validate` in this scope
 --> /tmp/.tmpEeD1wP/main.rs:1:155
  |
1 | ...ve_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
  |                                                       ^^^^^^^^ not found in this scope

error: aborting due to 4 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch11-00-file-operations-tdd example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-control-flow-tdd example 8 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `condition` in this scope
 --> /tmp/.tmpJ5BSE6/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if condition { () } else { if other_condition { () } else { () } } ; if let...
  |                                                                  ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `other_condition` in this scope
 --> /tmp/.tmpJ5BSE6/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if condition { () } else { if other_condition { () } else { () } } ; if let...
  |                                                                                             ^^^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpJ5BSE6/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if condition { () } else { if other_condition { () } else { () } } ; if let...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 9 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `condition` in this scope
 --> /tmp/.tmpHV7hLn/main.rs:1:71
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start .. end { () } } ; if let S...
  |                                                                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `start` in this scope
 --> /tmp/.tmpHV7hLn/main.rs:1:106
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start .. end { () } } ; if let S...
  |                                                                                                          ^^^^^ not found in this scope

error[E0425]: cannot find value `end` in this scope
 --> /tmp/.tmpHV7hLn/main.rs:1:115
  |
1 | ... { while condition { () } ; for variable in start .. end { () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast...
  |                                                         ^^^ not found in this scope
  |
help: you might have meant to write `.` instead of `..`
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start .. end { () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start.end { () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpHV7hLn/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start .. end { () } } ; if let S...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 3 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 10 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `value` in this scope
 --> /tmp/.tmpQk1yFt/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match value { pattern1 => action1 , pattern2 => action2 , _ => default_acti...
  |                                                                     ^^^^^ not found in this scope

error[E0425]: cannot find value `action1` in this scope
 --> /tmp/.tmpQk1yFt/main.rs:1:89
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match value { pattern1 => action1 , pattern2 => action2 , _ => default_acti...
  |                                                                                         ^^^^^^^ not found in this scope

error[E0425]: cannot find value `action2` in this scope
 --> /tmp/.tmpQk1yFt/main.rs:1:111
  |
1 | ... = match value { pattern1 => action1 , pattern2 => action2 , _ => default_action , } ; if let Some (s) = (& result as & dyn std :: any...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `default_action` in this scope
 --> /tmp/.tmpQk1yFt/main.rs:1:126
  |
1 | ...attern1 => action1 , pattern2 => action2 , _ => default_action , } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcas...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpQk1yFt/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match value { pattern1 => action1 , pattern2 => action2 , _ => default_acti...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 4 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 11 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `user_input` in this scope
 --> /tmp/.tmpcBeyJm/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...
  |                                                                  ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `threshold` in this scope
 --> /tmp/.tmpcBeyJm/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...
  |                                                                               ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpcBeyJm/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpcBeyJm/main.rs:1:91
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...
  |                                                                                           ^^                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { process_high_value () } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpcBeyJm/main.rs:1:126
  |
1 | ...put > threshold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :...
  |                                                         ^^                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { process_normal_value () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `process_high_value` in this scope
 --> /tmp/.tmpcBeyJm/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...
  |                                                                                             ^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `process_normal_value` in this scope
 --> /tmp/.tmpcBeyJm/main.rs:1:128
  |
1 | ...shold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . d...
  |                                                 ^^^^^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 4 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 12 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp0l8g4M/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; while count < 10i32 { { do_something () ; count = ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `do_something` in this scope
 --> /tmp/.tmp0l8g4M/main.rs:1:112
  |
1 | ...{ let mut count = 0i32 ; while count < 10i32 { { do_something () ; count = count + 1i32 } } } ; if let Some (s) = (& result as & dyn s...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 14 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `status_code` in this scope
 --> /tmp/.tmp1Dzxll/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match status_code { 200i32 => println ! ("Success") , 404i32 => println ! (...
  |                                                                     ^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp1Dzxll/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match status_code { 200i32 => println ! ("Success") , 404i32 => println ! (...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== appendix-c-troubleshooting example 1 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpIa8ns9/main.rs:1:143
  |
1 | ... let mut x = 42i32 ; let mut y = 24i32 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpIa8ns9/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut x = 42i32 ; let mut y = 24i32 ; let mut x = 42i32 ; let mut y = 2...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== appendix-c-troubleshooting example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 4 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpR2OqOc/main.rs:1:159
  |
1 | ... ; let mut x = "string" . to_string () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpR2OqOc/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut x = "string" . to_string () ; let mut x = 42i32 ; let mut x = "st...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== appendix-c-troubleshooting example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 6 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpwL53XJ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut s = String :: from ("hello" . to_string ()) ; takes_ownership (s)...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `takes_ownership` in this scope
 --> /tmp/.tmpwL53XJ/main.rs:1:119
  |
1 | ... s = String :: from ("hello" . to_string ()) ; takes_ownership (s) ; println ! ("{:?}" , s) ; let mut s = String :: from ("hello" . to...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `takes_ownership` in this scope
 --> /tmp/.tmpwL53XJ/main.rs:1:220
  |
1 | ... s = String :: from ("hello" . to_string ()) ; takes_ownership (s . clone ()) ; println ! ("{:?}" , s) ; let mut s = String :: from ("...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `borrows_value` in this scope
 --> /tmp/.tmpwL53XJ/main.rs:1:332
  |
1 | ...t s = String :: from ("hello" . to_string ()) ; borrows_value (& s) ; println ! ("{:?}" , s) } ; if let Some (s) = (& result as & dyn ...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== appendix-c-troubleshooting example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 9 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp9LRtQD/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut v = vec ! [1i32 , 2i32 , 3i32] ; let mut item = v [5i32 as usize]...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp9LRtQD/main.rs:1:362
  |
1 | ...if let Some (item) = v . get (5i32) . cloned () { { println ! ("Item: {}" , item) } } } ; if let Some (s) = (& result as & dyn std :: ...
  |                                                      ^^                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { let mut v = vec ! [1i32 , 2i32 , 3i32] ; let mut item = v [5i32 as usize] ; let mut v = vec ! [1i32 , 2i32 , 3i32] ; match v . get (5i32) . cloned () { Some (item) => println ! ("Item: {}" , item) , None => println ! ("Index out of bounds") , } ; if let Some (item) = v . get (5i32) . cloned () { { println ! ("Item: {}" , item) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { let mut v = vec ! [1i32 , 2i32 , 3i32] ; let mut item = v [5i32 as usize] ; let mut v = vec ! [1i32 , 2i32 , 3i32] ; match v . get (5i32) . cloned () { Some (item) => println ! ("Item: {}" , item) , None => println ! ("Index out of bounds") , } ; if let Some (item) = v . get (5i32) . cloned () { println ! ("Item: {}" , item) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0277]: the type `[i32]` cannot be indexed by `i32`
   --> /tmp/.tmp9LRtQD/main.rs:1:197
    |
1   | ...! [1i32 , 2i32 , 3i32] ; match v . get (5i32) . cloned () { Some (item) => println ! ("Item: {}" , item) , None => println ! ("Index o...
    |                                       ---  ^^^^ slice indices are of type `usize` or ranges of `usize`
    |                                       |
    |                                       required by a bound introduced by this call
    |
    = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
    = help: the following other types implement trait `SliceIndex<T>`:
              `usize` implements `SliceIndex<ByteStr>`
              `usize` implements `SliceIndex<[T]>`
note: required by a bound in `core::slice::<impl [T]>::get`
   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:573:12
    |
571 |     pub fn get<I>(&self, index: I) -> Option<&I::Output>
    |            --- required by a bound in this associated function
572 |     where
573 |         I: SliceIndex<Self>,
    |            ^^^^^^^^^^^^^^^^ required by this bound in `core::slice::<impl [T]>::get`

error[E0277]: the type `[i32]` cannot be indexed by `i32`
   --> /tmp/.tmp9LRtQD/main.rs:1:342
    |
1   | ...s") , } ; if let Some (item) = v . get (5i32) . cloned () { { println ! ("Item: {}" , item) } } } ; if let Some (s) = (& result as & d...
    |                                       ---  ^^^^ slice indices are of type `usize` or ranges of `usize`
    |                                       |
    |                                       required by a bound introduced by this call
    |
    = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
    = help: the following other types implement trait `SliceIndex<T>`:
              `usize` implements `SliceIndex<ByteStr>`
              `usize` implements `SliceIndex<[T]>`
note: required by a bound in `core::slice::<impl [T]>::get`
   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:573:12
    |
571 |     pub fn get<I>(&self, index: I) -> Option<&I::Output>
    |            --- required by a bound in this associated function
572 |     where
573 |         I: SliceIndex<Self>,
    |            ^^^^^^^^^^^^^^^^ required by this bound in `core::slice::<impl [T]>::get`

error: aborting due to 2 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0277`.



=== appendix-c-troubleshooting example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 13 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 14 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 15 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 16 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpbTrkIV/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpbTrkIV/main.rs:1:102
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for...
  |                                                                                                      ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpbTrkIV/main.rs:1:162
  |
1 | ...ut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i...
  |                                                         ^^                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { list . insert (0i32 , i) } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpbTrkIV/main.rs:1:259
  |
1 | ...que = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any...
  |                                                          ^^                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { deque . push_front (i) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0308]: mismatched types
    --> /tmp/.tmpbTrkIV/main.rs:1:179
     |
1    | ...ew () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { ...
     |                                                ------  ^^^^ expected `usize`, found `i32`
     |                                                |
     |                                                arguments to this method are incorrect
     |
note: method defined here
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2034:12
     |
2034 |     pub fn insert(&mut self, index: usize, element: T) {
     |            ^^^^^^
help: change the type of the numeric literal from `i32` to `usize`
     |
1    - use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1    + use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0usize , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
     |

error: aborting due to 1 previous error; 4 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== appendix-c-troubleshooting example 17 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmp36r4Uj/main.rs:1:161
  |
1 | ...ut data = response . json () . await ? } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0425]: cannot find value `url` in this scope
 --> /tmp/.tmp36r4Uj/main.rs:1:100
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut response = reqwest :: get (url) . await ? ; let mut data = respon...
  |                                                                                                    ^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp36r4Uj/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut response = reqwest :: get (url) . await ? ; let mut data = respon...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
 --> /tmp/.tmp36r4Uj/main.rs:1:84
  |
1 | ... { let result = { let mut response = reqwest :: get (url) . await ? ; let mut data = response . json () . await ? } ; if let Some (s) ...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
  |
  = help: you might be missing a crate named `reqwest`

error: aborting due to 3 previous errors; 1 warning emitted

Some errors have detailed explanations: E0425, E0433.
For more information about an error, try `rustc --explain E0425`.



=== appendix-c-troubleshooting example 18 ===
✗ Compilation failed: Failed to transpile to Rust


=== appendix-c-troubleshooting example 19 ===
✗ Compilation failed: Failed to transpile to Rust


=== appendix-c-troubleshooting example 20 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 2 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpYQqhGM/main.rs:1:1597
  |
1 | ...e@email.com") . to_string ()) ; map }] } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpYQqhGM/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut sales_amounts = vec ! [1299i32 , 25i32 , 79i32 , 1299i32 , 399i32...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch05-00-data-processing example 3 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpTqFGar/main.rs:1:360
  |
1 | ...return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut ...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpTqFGar/main.rs:1:397
  |
1 | ...t mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut ...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpTqFGar/main.rs:1:416
  |
1 | ...rs . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers ....
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpTqFGar/main.rs:1:453
  |
1 | ...rs . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transa...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpTqFGar/main.rs:1:490
  |
1 | ...mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t |...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `transactions` in this scope
 --> /tmp/.tmpTqFGar/main.rs:1:530
  |
1 | ...inimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec <...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `transactions` in this scope
 --> /tmp/.tmpTqFGar/main.rs:1:649
  |
1 | ...lect :: < Vec < _ >> () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let ...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `transactions` in this scope
 --> /tmp/.tmpTqFGar/main.rs:1:753
  |
1 | ...lect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }
  |                                                     ^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpTqFGar/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpTqFGar/main.rs:1:100
  |
1 | ... { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } ...
  |       ^^                                                                                                                                                                                                                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }
1 + use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTqFGar/main.rs:1:148
  |
1 | ... { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ...
  |       ^^                                                                                                                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }
1 + use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTqFGar/main.rs:1:220
  |
1 | ...ield as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } ...
  |                                                     ^^                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }
1 + use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { groups [key as usize] = vec ! [] } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }
  |

error[E0277]: `String` is not an iterator
 --> /tmp/.tmpTqFGar/main.rs:1:138
  |
1 | ...groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize...
  |                                  ^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`
  |
  = help: the trait `Iterator` is not implemented for `String`
  = note: required for `String` to implement `IntoIterator`

error[E0599]: no method named `has_key` found for unit type `()` in the current scope
 --> /tmp/.tmpTqFGar/main.rs:1:204
  |
1 | ...et key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . pu...
  |                                                       ^^^^^^^ method not found in `()`

error[E0308]: mismatched types
 --> /tmp/.tmpTqFGar/main.rs:1:316
  |
1 | ...-> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } ...
  |       --- expected `i32` because of return type                                                                                                                                                                                     ^^^^^^ expected `i32`, found `()`

error[E0605]: non-primitive cast: `String` as `usize`
 --> /tmp/.tmpTqFGar/main.rs:1:170
  |
1 | ...rd [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) }...
  |        ^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error: aborting due to 12 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0425, E0599, E0605.
For more information about an error, try `rustc --explain E0277`.



=== ch05-00-data-processing example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 8 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpDrS9QS/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) -> i32 { { println ! ("{:?}" , format ! ("{}{}" , ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpDrS9QS/main.rs:1:317
  |
1 | ... { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") + bar , " ") + value . to_s ()) } } } } ...
  |       ^^                                                                                                                                                                                                           ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) -> i32 { { println ! ("{:?}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{:?}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . iter () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") + bar , " ") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("January" . to_string () , (45000i32) . to_string ()) ; map . insert ("February" . to_string () , (52000i32) . to_string ()) ; map . insert ("March" . to_string () , (48000i32) . to_string ()) ; map . insert ("April" . to_string () , (61000i32) . to_string ()) ; map . insert ("May" . to_string () , (58000i32) . to_string ()) ; map } ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
1 + use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) -> i32 { { println ! ("{:?}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{:?}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . iter () { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") + bar , " ") + value . to_s ()) } } } } } } } fn main () { let mut monthly_sales = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("January" . to_string () , (45000i32) . to_string ()) ; map . insert ("February" . to_string () , (52000i32) . to_string ()) ; map . insert ("March" . to_string () , (48000i32) . to_string ()) ; map . insert ("April" . to_string () , (61000i32) . to_string ()) ; map . insert ("May" . to_string () , (58000i32) . to_string ()) ; map } ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
  |

error[E0369]: cannot multiply `&str` by `usize`
 --> /tmp/.tmpDrS9QS/main.rs:1:179
  |
1 | ...rmat ! ("{}{}" , "\n" , title)) ; println ! ("{:?}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut ...
  |                                                          --- ^ -------------- usize
  |                                                          |
  |                                                          &str

error[E0599]: no method named `values` found for struct `String` in the current scope
 --> /tmp/.tmpDrS9QS/main.rs:1:224
  |
1 | ..."=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . it...
  |                                                     ^^^^^^ method not found in `String`

error[E0599]: no method named `iter` found for struct `String` in the current scope
 --> /tmp/.tmpDrS9QS/main.rs:1:307
  |
1 | ...x_bar_width = 50i32 ; for (key , value) in data . iter () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█...
  |                                                      ^^^^ method not found in `String`
  |
help: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`
  |
1 - use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) -> i32 { { println ! ("{:?}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{:?}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . iter () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") + bar , " ") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("January" . to_string () , (45000i32) . to_string ()) ; map . insert ("February" . to_string () , (52000i32) . to_string ()) ; map . insert ("March" . to_string () , (48000i32) . to_string ()) ; map . insert ("April" . to_string () , (61000i32) . to_string ()) ; map . insert ("May" . to_string () , (58000i32) . to_string ()) ; map } ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
1 + use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) -> i32 { { println ! ("{:?}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{:?}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . chars () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") + bar , " ") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("January" . to_string () , (45000i32) . to_string ()) ; map . insert ("February" . to_string () , (52000i32) . to_string ()) ; map . insert ("March" . to_string () , (48000i32) . to_string ()) ; map . insert ("April" . to_string () , (61000i32) . to_string ()) ; map . insert ("May" . to_string () , (58000i32) . to_string ()) ; map } ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
  |

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpDrS9QS/main.rs:1:379
  |
1 | ...value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}...
  |                                              ^^^^^^^ doesn't have a size known at compile-time
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: all local variables must have a statically known size

error[E0308]: mismatched types
 --> /tmp/.tmpDrS9QS/main.rs:1:489
  |
1 | ...ormat ! ("{}{}" , format ! ("{}{}" , key , " │") + bar , " ") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = ...
  |                                                       ^^^ expected `&str`, found `str`
  |
help: consider borrowing here
  |
1 | use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) -> i32 { { println ! ("{:?}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{:?}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . iter () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") + &bar , " ") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("January" . to_string () , (45000i32) . to_string ()) ; map . insert ("February" . to_string () , (52000i32) . to_string ()) ; map . insert ("March" . to_string () , (48000i32) . to_string ()) ; map . insert ("April" . to_string () , (61000i32) . to_string ()) ; map . insert ("May" . to_string () , (58000i32) . to_string ()) ; map } ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         +

error[E0308]: mismatched types
 --> /tmp/.tmpDrS9QS/main.rs:1:279
  |
1 | ...-> i32 { { println ! ("{:?}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{:?}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . iter () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") + bar , " ") + value . to_s ()) } } } } } ...
  |       --- expected `i32` because of return type                                                                                                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `for` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) -> i32 { { println ! ("{:?}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{:?}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . iter () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") + bar , " ") + value . to_s ()) } } } } /* `i32` value */ } } } } fn main () { let mut monthly_sales = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("January" . to_string () , (45000i32) . to_string ()) ; map . insert ("February" . to_string () , (52000i32) . to_string ()) ; map . insert ("March" . to_string () , (48000i32) . to_string ()) ; map . insert ("April" . to_string () , (61000i32) . to_string ()) ; map . insert ("May" . to_string () , (58000i32) . to_string ()) ; map } ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               +++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpDrS9QS/main.rs:1:1049
  |
1 | ... . to_string ()) ; map } ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
  |                               --------------  ^^^^^^^^^^^^^ expected `String`, found `HashMap<String, String>`
  |                               |
  |                               arguments to this function are incorrect
  |
  = note: expected struct `String`
             found struct `HashMap<String, String>`
note: function defined here
 --> /tmp/.tmpDrS9QS/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) -> i32 { { println ! ("{:?}" , format ! ("{}{}" , ...
  |                                        ^^^^^^^^^^^^^^  -------------

error: aborting due to 7 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0369, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch05-00-data-processing example 9 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpVPuI4M/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut sales_data = load_csv ("sales.csv" . to_string ()) ; let mut tota...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `load_csv` in this scope
 --> /tmp/.tmpVPuI4M/main.rs:1:86
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut sales_data = load_csv ("sales.csv" . to_string ()) ; let mut tota...
  |                                                                                      ^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-data-processing example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch01-02-hello-world example 2 ===
✗ Compilation failed: Compilation failed:
error: multiple unused formatting arguments
 --> /tmp/.tmpiUej8P/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello" , "World" , "from" , "Ruchy") } }
  |                                                               -------   ^^^^^^^   ^^^^^^   ^^^^^^^ argument never used
  |                                                               |         |         |
  |                                                               |         |         argument never used
  |                                                               |         argument never used
  |                                                               multiple missing formatting specifiers

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpiUej8P/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello" , "World" , "from" , "Ruchy") } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpiUej8P/main.rs:1:50
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello" , "World" , "from" , "Ruchy") } }
  |                                                  ^^                                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { println ! ("Hello" , "World" , "from" , "Ruchy") } }
1 + use std :: collections :: HashMap ; fn main () { println ! ("Hello" , "World" , "from" , "Ruchy") }
  |

error: aborting due to 1 previous error; 2 warnings emitted




=== ch01-02-hello-world example 3 ===
✗ Compilation failed: Compilation failed:
error: argument never used
 --> /tmp/.tmpsPHXEe/main.rs:1:114
  |
1 | ...et name = "Alice" . to_string () ; { println ! ("Hello," , name) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Hello, "...
  |                                                    --------   ^^^^ argument never used
  |                                                    |
  |                                                    formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpsPHXEe/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let name = "Alice" . to_string () ; { println ! ("Hello," , name) ; println ! ("{:?}...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpsPHXEe/main.rs:1:50
  |
1 | ... { { { let name = "Alice" . to_string () ; { println ! ("Hello," , name) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Hello, " , name) , "!")) } } } }
  |       ^^                                                                                                                                                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let name = "Alice" . to_string () ; { println ! ("Hello," , name) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Hello, " , name) , "!")) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let name = "Alice" . to_string () ; { println ! ("Hello," , name) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Hello, " , name) , "!")) } } }
  |

error: aborting due to 1 previous error; 2 warnings emitted




=== ch01-02-hello-world example 4 ===
✗ Compilation failed: Compilation failed:
error: argument never used
 --> /tmp/.tmpM3OVfg/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("The answer is" , 42i32) ; println ! ("Pi is approximately" , 3.14159f64) ;...
  |                                                               ---------------   ^^^^^ argument never used
  |                                                               |
  |                                                               formatting specifier missing

error: argument never used
 --> /tmp/.tmpM3OVfg/main.rs:1:125
  |
1 | ... ("The answer is" , 42i32) ; println ! ("Pi is approximately" , 3.14159f64) ; println ! ("Is Ruchy awesome?" , true) } }
  |                                            ---------------------   ^^^^^^^^^^ argument never used
  |                                            |
  |                                            formatting specifier missing

error: argument never used
 --> /tmp/.tmpM3OVfg/main.rs:1:172
  |
1 | ... approximately" , 3.14159f64) ; println ! ("Is Ruchy awesome?" , true) } }
  |                                               -------------------   ^^^^ argument never used
  |                                               |
  |                                               formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpM3OVfg/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("The answer is" , 42i32) ; println ! ("Pi is approximately" , 3.14159f64) ;...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 3 previous errors; 1 warning emitted




=== ch02-00-variables-types example 1 ===
✗ Compilation failed: Compilation failed:
error: multiple unused formatting arguments
 --> /tmp/.tmpz0mH2J/main.rs:1:161
  |
1 | ...t is_learning = true ; println ! ("Hi" , name , ", you're" , age , "years old!") ; println ! ("Currently learning Ruchy:" , is_learnin...
  |                                      ----   ^^^^   ^^^^^^^^^^   ^^^   ^^^^^^^^^^^^ argument never used
  |                                      |      |      |            |
  |                                      |      |      |            argument never used
  |                                      |      |      argument never used
  |                                      |      argument never used
  |                                      multiple missing formatting specifiers

error: argument never used
 --> /tmp/.tmpz0mH2J/main.rs:1:244
  |
1 | ... , age , "years old!") ; println ! ("Currently learning Ruchy:" , is_learning) } } } }
  |                                        ---------------------------   ^^^^^^^^^^^ argument never used
  |                                        |
  |                                        formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpz0mH2J/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let name = "Alice" . to_string () ; { let mut age = 25i32 ; let mut is_learning = tr...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpz0mH2J/main.rs:1:50
  |
1 | ... { { { let name = "Alice" . to_string () ; { let mut age = 25i32 ; let mut is_learning = true ; println ! ("Hi" , name , ", you're" , age , "years old!") ; println ! ("Currently learning Ruchy:" , is_learning) } } } }
  |       ^^                                                                                                                                                                                                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let name = "Alice" . to_string () ; { let mut age = 25i32 ; let mut is_learning = true ; println ! ("Hi" , name , ", you're" , age , "years old!") ; println ! ("Currently learning Ruchy:" , is_learning) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let name = "Alice" . to_string () ; { let mut age = 25i32 ; let mut is_learning = true ; println ! ("Hi" , name , ", you're" , age , "years old!") ; println ! ("Currently learning Ruchy:" , is_learning) } } }
  |

warning: variable does not need to be mutable
 --> /tmp/.tmpz0mH2J/main.rs:1:96
  |
1 | use std :: collections :: HashMap ; fn main () { { { let name = "Alice" . to_string () ; { let mut age = 25i32 ; let mut is_learning = tr...
  |                                                                                                ----^^^
  |                                                                                                |
  |                                                                                                help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

warning: variable does not need to be mutable
 --> /tmp/.tmpz0mH2J/main.rs:1:118
  |
1 | ..."Alice" . to_string () ; { let mut age = 25i32 ; let mut is_learning = true ; println ! ("Hi" , name , ", you're" , age , "years old!"...
  |                                                         ----^^^^^^^^^^^
  |                                                         |
  |                                                         help: remove this `mut`

error: aborting due to 2 previous errors; 4 warnings emitted




=== ch02-00-variables-types example 2 ===
✗ Compilation failed: Compilation failed:
error: argument never used
 --> /tmp/.tmpGEI5Yt/main.rs:1:422
  |
1 | ...ut is_enrolled = ! has_graduated ; println ! ("Student:" , full_name) ; println ! ("Score:" , score , "(" , percentage , "%)") ; print...
  |                                                  ----------   ^^^^^^^^^ argument never used
  |                                                  |
  |                                                  formatting specifier missing

error: multiple unused formatting arguments
 --> /tmp/.tmpGEI5Yt/main.rs:1:457
  |
1 | ...Student:" , full_name) ; println ! ("Score:" , score , "(" , percentage , "%)") ; println ! ("Temperature:" , temperature , "°C") ; pr...
  |                                        --------   ^^^^^   ^^^   ^^^^^^^^^^   ^^^^ argument never used
  |                                        |          |       |     |
  |                                        |          |       |     argument never used
  |                                        |          |       argument never used
  |                                        |          argument never used
  |                                        multiple missing formatting specifiers

error: multiple unused formatting arguments
 --> /tmp/.tmpGEI5Yt/main.rs:1:520
  |
1 | ... "(" , percentage , "%)") ; println ! ("Temperature:" , temperature , "°C") ; println ! ("Status: student=" , is_student , ", graduate...
  |                                           --------------   ^^^^^^^^^^^   ^^^^ argument never used
  |                                           |                |
  |                                           |                argument never used
  |                                           multiple missing formatting specifiers

error: multiple unused formatting arguments
 --> /tmp/.tmpGEI5Yt/main.rs:1:574
  |
1 | ...ure , "°C") ; println ! ("Status: student=" , is_student , ", graduated=" , has_graduated) } } } }
  |                             ------------------   ^^^^^^^^^^   ^^^^^^^^^^^^^^   ^^^^^^^^^^^^^ argument never used
  |                             |                    |            |
  |                             |                    |            argument never used
  |                             |                    argument never used
  |                             multiple missing formatting specifiers

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpGEI5Yt/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let first_name = "John" . to_string () ; { let mut last_name = "Doe" . to_string () ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpGEI5Yt/main.rs:1:50
  |
1 | ... { { { let first_name = "John" . to_string () ; { let mut last_name = "Doe" . to_string () ; let mut full_name = format ! ("{}{}" , first_name , " ") + last_name ; let mut score = 95i32 ; let mut percentage = 95.5f64 ; let mut temperature = - 10i32 ; let mut is_student = true ; let mut has_graduated = false ; let mut is_enrolled = ! has_graduated ; println ! ("Student:" , full_name) ; println ! ("Score:" , score , "(" , percentage , "%)") ; println ! ("Temperature:" , temperature , "°C") ; println ! ("Status: student=" , is_student , ", graduated=" , has_graduated) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let first_name = "John" . to_string () ; { let mut last_name = "Doe" . to_string () ; let mut full_name = format ! ("{}{}" , first_name , " ") + last_name ; let mut score = 95i32 ; let mut percentage = 95.5f64 ; let mut temperature = - 10i32 ; let mut is_student = true ; let mut has_graduated = false ; let mut is_enrolled = ! has_graduated ; println ! ("Student:" , full_name) ; println ! ("Score:" , score , "(" , percentage , "%)") ; println ! ("Temperature:" , temperature , "°C") ; println ! ("Status: student=" , is_student , ", graduated=" , has_graduated) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let first_name = "John" . to_string () ; { let mut last_name = "Doe" . to_string () ; let mut full_name = format ! ("{}{}" , first_name , " ") + last_name ; let mut score = 95i32 ; let mut percentage = 95.5f64 ; let mut temperature = - 10i32 ; let mut is_student = true ; let mut has_graduated = false ; let mut is_enrolled = ! has_graduated ; println ! ("Student:" , full_name) ; println ! ("Score:" , score , "(" , percentage , "%)") ; println ! ("Temperature:" , temperature , "°C") ; println ! ("Status: student=" , is_student , ", graduated=" , has_graduated) } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpGEI5Yt/main.rs:1:199
  |
1 | ...name = format ! ("{}{}" , first_name , " ") + last_name ; let mut score = 95i32 ; let mut percentage = 95.5f64 ; let mut temperature =...
  |                                                  ^^^^^^^^^ expected `&str`, found `String`
  |
help: consider borrowing here
  |
1 | use std :: collections :: HashMap ; fn main () { { { let first_name = "John" . to_string () ; { let mut last_name = "Doe" . to_string () ; let mut full_name = format ! ("{}{}" , first_name , " ") + &last_name ; let mut score = 95i32 ; let mut percentage = 95.5f64 ; let mut temperature = - 10i32 ; let mut is_student = true ; let mut has_graduated = false ; let mut is_enrolled = ! has_graduated ; println ! ("Student:" , full_name) ; println ! ("Score:" , score , "(" , percentage , "%)") ; println ! ("Temperature:" , temperature , "°C") ; println ! ("Status: student=" , is_student , ", graduated=" , has_graduated) } } } }
  |                                                                                                                                                                                                       +

error: aborting due to 5 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch02-00-variables-types example 3 ===
✗ Compilation failed: Compilation failed:
error: multiple unused formatting arguments
 --> /tmp/.tmpgY3BKf/main.rs:1:358
  |
1 | ...um = total_points > 150i32 ; println ! ("Welcome back," , username , "!") ; println ! ("Logins:" , login_count , ", Points:" , total_p...
  |                                            ---------------   ^^^^^^^^   ^^^ argument never used
  |                                            |                 |
  |                                            |                 argument never used
  |                                            multiple missing formatting specifiers

error: multiple unused formatting arguments
 --> /tmp/.tmpgY3BKf/main.rs:1:399
  |
1 | ..., username , "!") ; println ! ("Logins:" , login_count , ", Points:" , total_points) ; println ! ("Premium status:" , is_premium) } } } }
  |                                   ---------   ^^^^^^^^^^^   ^^^^^^^^^^^   ^^^^^^^^^^^^ argument never used
  |                                   |           |             |
  |                                   |           |             argument never used
  |                                   |           argument never used
  |                                   multiple missing formatting specifiers

error: argument never used
 --> /tmp/.tmpgY3BKf/main.rs:1:474
  |
1 | ... ", Points:" , total_points) ; println ! ("Premium status:" , is_premium) } } } }
  |                                              -----------------   ^^^^^^^^^^ argument never used
  |                                              |
  |                                              formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpgY3BKf/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let username = "programmer2024" . to_string () ; { let mut login_count = 1i32 ; let ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpgY3BKf/main.rs:1:50
  |
1 | ... { { { let username = "programmer2024" . to_string () ; { let mut login_count = 1i32 ; let mut is_premium = false ; let mut welcome_bonus = 100i32 ; let mut total_points = welcome_bonus + login_count * 10i32 ; login_count = login_count + 1i32 ; is_premium = total_points > 150i32 ; println ! ("Welcome back," , username , "!") ; println ! ("Logins:" , login_count , ", Points:" , total_points) ; println ! ("Premium status:" , is_premium) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let username = "programmer2024" . to_string () ; { let mut login_count = 1i32 ; let mut is_premium = false ; let mut welcome_bonus = 100i32 ; let mut total_points = welcome_bonus + login_count * 10i32 ; login_count = login_count + 1i32 ; is_premium = total_points > 150i32 ; println ! ("Welcome back," , username , "!") ; println ! ("Logins:" , login_count , ", Points:" , total_points) ; println ! ("Premium status:" , is_premium) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let username = "programmer2024" . to_string () ; { let mut login_count = 1i32 ; let mut is_premium = false ; let mut welcome_bonus = 100i32 ; let mut total_points = welcome_bonus + login_count * 10i32 ; login_count = login_count + 1i32 ; is_premium = total_points > 150i32 ; println ! ("Welcome back," , username , "!") ; println ! ("Logins:" , login_count , ", Points:" , total_points) ; println ! ("Premium status:" , is_premium) } } }
  |

warning: value assigned to `is_premium` is never read
 --> /tmp/.tmpgY3BKf/main.rs:1:142
  |
1 | ...2024" . to_string () ; { let mut login_count = 1i32 ; let mut is_premium = false ; let mut welcome_bonus = 100i32 ; let mut total_poin...
  |                                                                  ^^^^^^^^^^
  |
  = help: maybe it is overwritten before being read?
  = note: `#[warn(unused_assignments)]` on by default

warning: variable does not need to be mutable
 --> /tmp/.tmpgY3BKf/main.rs:1:167
  |
1 | ...ogin_count = 1i32 ; let mut is_premium = false ; let mut welcome_bonus = 100i32 ; let mut total_points = welcome_bonus + login_count *...
  |                                                         ----^^^^^^^^^^^^^
  |                                                         |
  |                                                         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

warning: variable does not need to be mutable
 --> /tmp/.tmpgY3BKf/main.rs:1:200
  |
1 | ...emium = false ; let mut welcome_bonus = 100i32 ; let mut total_points = welcome_bonus + login_count * 10i32 ; login_count = login_coun...
  |                                                         ----^^^^^^^^^^^^
  |                                                         |
  |                                                         help: remove this `mut`

error: aborting due to 3 previous errors; 5 warnings emitted




=== ch02-00-variables-types example 4 ===
✗ Compilation failed: Compilation failed:
error: argument never used
 --> /tmp/.tmpnSv1P6/main.rs:1:287
  |
1 | ...e , true , true] ; println ! ("First language:" , favorite_languages [0i32 as usize]) ; println ! ("Today's temp:" , daily_temperature...
  |                                  -----------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
  |                                  |
  |                                  formatting specifier missing

error: multiple unused formatting arguments
 --> /tmp/.tmpnSv1P6/main.rs:1:354
  |
1 | ...32 as usize]) ; println ! ("Today's temp:" , daily_temperatures [0i32 as usize] , "°C") ; println ! ("I know" , favorite_languages . l...
  |                               ---------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^ argument never used
  |                               |                 |
  |                               |                 argument never used
  |                               multiple missing formatting specifiers

error: multiple unused formatting arguments
 --> /tmp/.tmpnSv1P6/main.rs:1:421
  |
1 | ...as usize] , "°C") ; println ! ("I know" , favorite_languages . len () , "languages") } } } }
  |                                   --------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^ argument never used
  |                                   |          |
  |                                   |          argument never used
  |                                   multiple missing formatting specifiers

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpnSv1P6/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let favorite_languages = vec ! ["Python" , "Rust" , "Ruchy"] ; { let mut daily_tempe...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpnSv1P6/main.rs:1:50
  |
1 | ... { { { let favorite_languages = vec ! ["Python" , "Rust" , "Ruchy"] ; { let mut daily_temperatures = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let mut task_completed = vec ! [true , false , true , true] ; println ! ("First language:" , favorite_languages [0i32 as usize]) ; println ! ("Today's temp:" , daily_temperatures [0i32 as usize] , "°C") ; println ! ("I know" , favorite_languages . len () , "languages") } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let favorite_languages = vec ! ["Python" , "Rust" , "Ruchy"] ; { let mut daily_temperatures = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let mut task_completed = vec ! [true , false , true , true] ; println ! ("First language:" , favorite_languages [0i32 as usize]) ; println ! ("Today's temp:" , daily_temperatures [0i32 as usize] , "°C") ; println ! ("I know" , favorite_languages . len () , "languages") } } } }
1 + use std :: collections :: HashMap ; fn main () { { let favorite_languages = vec ! ["Python" , "Rust" , "Ruchy"] ; { let mut daily_temperatures = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let mut task_completed = vec ! [true , false , true , true] ; println ! ("First language:" , favorite_languages [0i32 as usize]) ; println ! ("Today's temp:" , daily_temperatures [0i32 as usize] , "°C") ; println ! ("I know" , favorite_languages . len () , "languages") } } }
  |

warning: unused variable: `task_completed`
 --> /tmp/.tmpnSv1P6/main.rs:1:202
  |
1 | ..., 26.2f64] ; let mut task_completed = vec ! [true , false , true , true] ; println ! ("First language:" , favorite_languages [0i32 as ...
  |                         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_task_completed`
  |
  = note: `#[warn(unused_variables)]` on by default

warning: variable does not need to be mutable
 --> /tmp/.tmpnSv1P6/main.rs:1:123
  |
1 | ...guages = vec ! ["Python" , "Rust" , "Ruchy"] ; { let mut daily_temperatures = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let mut ta...
  |                                                         ----^^^^^^^^^^^^^^^^^^
  |                                                         |
  |                                                         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

warning: variable does not need to be mutable
 --> /tmp/.tmpnSv1P6/main.rs:1:198
  |
1 | ... = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let mut task_completed = vec ! [true , false , true , true] ; println ! ("First langu...
  |                                                         ----^^^^^^^^^^^^^^
  |                                                         |
  |                                                         help: remove this `mut`

error: aborting due to 3 previous errors; 5 warnings emitted




=== ch02-00-variables-types example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `user_name` in this scope
 --> /tmp/.tmpER9MtQ/main.rs:1:52
  |
1 | use std :: collections :: HashMap ; fn main () { { user_name = "Alice" } }
  |                                                    ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpER9MtQ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { user_name = "Alice" } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpER9MtQ/main.rs:1:50
  |
1 | use std :: collections :: HashMap ; fn main () { { user_name = "Alice" } }
  |                                                  ^^                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { user_name = "Alice" } }
1 + use std :: collections :: HashMap ; fn main () { user_name = "Alice" }
  |

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch02-00-variables-types example 6 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpsMtnJ5/main.rs:1:117
  |
1 | use std :: collections :: HashMap ; fn main () { { { let age = "25" . to_string () ; let mut next_year = age + 1i32 } } }
  |                                                                                                                     ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpsMtnJ5/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let age = "25" . to_string () ; let mut next_year = age + 1i32 } } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpsMtnJ5/main.rs:1:50
  |
1 | use std :: collections :: HashMap ; fn main () { { { let age = "25" . to_string () ; let mut next_year = age + 1i32 } } }
  |                                                  ^^                                                                  ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let age = "25" . to_string () ; let mut next_year = age + 1i32 } } }
1 + use std :: collections :: HashMap ; fn main () { { let age = "25" . to_string () ; let mut next_year = age + 1i32 } }
  |

error: aborting due to 1 previous error; 2 warnings emitted




=== ch02-00-variables-types example 8 ===
✗ Compilation failed: Compilation failed:
error: multiple unused formatting arguments
 --> /tmp/.tmpqsZLfz/main.rs:1:132
  |
1 | ...ng () ; { let mut age = 25i32 ; println ! ("Hi" , name , ", age" , age) } } } }
  |                                               ----   ^^^^   ^^^^^^^   ^^^ argument never used
  |                                               |      |      |
  |                                               |      |      argument never used
  |                                               |      argument never used
  |                                               multiple missing formatting specifiers

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpqsZLfz/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let name = "Alice" . to_string () ; { let mut age = 25i32 ; println ! ("Hi" , name ,...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpqsZLfz/main.rs:1:50
  |
1 | ...n main () { { { let name = "Alice" . to_string () ; { let mut age = 25i32 ; println ! ("Hi" , name , ", age" , age) } } } }
  |                ^^                                                                                                         ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let name = "Alice" . to_string () ; { let mut age = 25i32 ; println ! ("Hi" , name , ", age" , age) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let name = "Alice" . to_string () ; { let mut age = 25i32 ; println ! ("Hi" , name , ", age" , age) } } }
  |

warning: variable does not need to be mutable
 --> /tmp/.tmpqsZLfz/main.rs:1:96
  |
1 | use std :: collections :: HashMap ; fn main () { { { let name = "Alice" . to_string () ; { let mut age = 25i32 ; println ! ("Hi" , name ,...
  |                                                                                                ----^^^
  |                                                                                                |
  |                                                                                                help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

error: aborting due to 1 previous error; 3 warnings emitted




=== ch02-00-variables-types example 9 ===
✗ Compilation failed: Compilation failed:
error: multiple unused formatting arguments
 --> /tmp/.tmpCCQqxy/main.rs:1:812
  |
1 | ..._adult && lives_in_tech_city ; println ! ("Profile:" , name , age , city) ; println ! ("Math:" , sum , difference , average) ; println...
  |                                              ----------   ^^^^   ^^^   ^^^^ argument never used
  |                                              |            |      |
  |                                              |            |      argument never used
  |                                              |            argument never used
  |                                              multiple missing formatting specifiers

error: multiple unused formatting arguments
 --> /tmp/.tmpCCQqxy/main.rs:1:854
  |
1 | ...le:" , name , age , city) ; println ! ("Math:" , sum , difference , average) ; println ! ("Contact:" , username , email) ; println ! (...
  |                                           -------   ^^^   ^^^^^^^^^^   ^^^^^^^ argument never used
  |                                           |         |     |
  |                                           |         |     argument never used
  |                                           |         argument never used
  |                                           multiple missing formatting specifiers

error: multiple unused formatting arguments
 --> /tmp/.tmpCCQqxy/main.rs:1:908
  |
1 | ... sum , difference , average) ; println ! ("Contact:" , username , email) ; println ! ("Status:" , is_adult , lives_in_tech_city , read...
  |                                              ----------   ^^^^^^^^   ^^^^^ argument never used
  |                                              |            |
  |                                              |            argument never used
  |                                              multiple missing formatting specifiers

error: multiple unused formatting arguments
 --> /tmp/.tmpCCQqxy/main.rs:1:951
  |
1 | ...rname , email) ; println ! ("Status:" , is_adult , lives_in_tech_city , ready_for_job) } } } }
  |                                ---------   ^^^^^^^^   ^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^ argument never used
  |                                |           |          |
  |                                |           |          argument never used
  |                                |           argument never used
  |                                multiple missing formatting specifiers

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpCCQqxy/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let name = "Alex" . to_string () ; { let mut age = 28i32 ; let mut city = "San Franc...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpCCQqxy/main.rs:1:50
  |
1 | ... { { { let name = "Alex" . to_string () ; { let mut age = 28i32 ; let mut city = "San Francisco" . to_string () ; let mut hobby = "rock climbing" . to_string () ; let mut goal = "master Ruchy in 30 days" . to_string () ; let mut num1 = 15i32 ; let mut num2 = 25i32 ; let mut sum = num1 + num2 ; let mut difference = num1 - num2 ; let mut average = num1 + num2 / 2i32 ; let mut first_name = "Alex" . to_string () ; let mut last_name = "Johnson" . to_string () ; let mut username = format ! ("{}{}" , first_name , "_") + last_name ; let mut email = format ! ("{}{}" , username , "@example.com") ; let mut is_adult = age >= 18i32 ; let mut lives_in_tech_city = city == "San Francisco" ; let mut ready_for_job = is_adult && lives_in_tech_city ; println ! ("Profile:" , name , age , city) ; println ! ("Math:" , sum , difference , average) ; println ! ("Contact:" , username , email) ; println ! ("Status:" , is_adult , lives_in_tech_city , ready_for_job) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let name = "Alex" . to_string () ; { let mut age = 28i32 ; let mut city = "San Francisco" . to_string () ; let mut hobby = "rock climbing" . to_string () ; let mut goal = "master Ruchy in 30 days" . to_string () ; let mut num1 = 15i32 ; let mut num2 = 25i32 ; let mut sum = num1 + num2 ; let mut difference = num1 - num2 ; let mut average = num1 + num2 / 2i32 ; let mut first_name = "Alex" . to_string () ; let mut last_name = "Johnson" . to_string () ; let mut username = format ! ("{}{}" , first_name , "_") + last_name ; let mut email = format ! ("{}{}" , username , "@example.com") ; let mut is_adult = age >= 18i32 ; let mut lives_in_tech_city = city == "San Francisco" ; let mut ready_for_job = is_adult && lives_in_tech_city ; println ! ("Profile:" , name , age , city) ; println ! ("Math:" , sum , difference , average) ; println ! ("Contact:" , username , email) ; println ! ("Status:" , is_adult , lives_in_tech_city , ready_for_job) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let name = "Alex" . to_string () ; { let mut age = 28i32 ; let mut city = "San Francisco" . to_string () ; let mut hobby = "rock climbing" . to_string () ; let mut goal = "master Ruchy in 30 days" . to_string () ; let mut num1 = 15i32 ; let mut num2 = 25i32 ; let mut sum = num1 + num2 ; let mut difference = num1 - num2 ; let mut average = num1 + num2 / 2i32 ; let mut first_name = "Alex" . to_string () ; let mut last_name = "Johnson" . to_string () ; let mut username = format ! ("{}{}" , first_name , "_") + last_name ; let mut email = format ! ("{}{}" , username , "@example.com") ; let mut is_adult = age >= 18i32 ; let mut lives_in_tech_city = city == "San Francisco" ; let mut ready_for_job = is_adult && lives_in_tech_city ; println ! ("Profile:" , name , age , city) ; println ! ("Math:" , sum , difference , average) ; println ! ("Contact:" , username , email) ; println ! ("Status:" , is_adult , lives_in_tech_city , ready_for_job) } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpCCQqxy/main.rs:1:566
  |
1 | ...name = format ! ("{}{}" , first_name , "_") + last_name ; let mut email = format ! ("{}{}" , username , "@example.com") ; let mut is_a...
  |                                                  ^^^^^^^^^ expected `&str`, found `String`
  |
help: consider borrowing here
  |
1 | use std :: collections :: HashMap ; fn main () { { { let name = "Alex" . to_string () ; { let mut age = 28i32 ; let mut city = "San Francisco" . to_string () ; let mut hobby = "rock climbing" . to_string () ; let mut goal = "master Ruchy in 30 days" . to_string () ; let mut num1 = 15i32 ; let mut num2 = 25i32 ; let mut sum = num1 + num2 ; let mut difference = num1 - num2 ; let mut average = num1 + num2 / 2i32 ; let mut first_name = "Alex" . to_string () ; let mut last_name = "Johnson" . to_string () ; let mut username = format ! ("{}{}" , first_name , "_") + &last_name ; let mut email = format ! ("{}{}" , username , "@example.com") ; let mut is_adult = age >= 18i32 ; let mut lives_in_tech_city = city == "San Francisco" ; let mut ready_for_job = is_adult && lives_in_tech_city ; println ! ("Profile:" , name , age , city) ; println ! ("Math:" , sum , difference , average) ; println ! ("Contact:" , username , email) ; println ! ("Status:" , is_adult , lives_in_tech_city , ready_for_job) } } } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      +

error: aborting due to 5 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch06-00-data-structures-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpzzNxnv/main.rs:1:198
  |
1 | ...ut greeting = "Welcome" . to_string () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpzzNxnv/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut message = "Hello World" . to_string () ; let mut name = "Alice" ....
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch06-00-data-structures-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpdkSC3R/main.rs:1:151
  |
1 | ... number = 100i32 ; let mut flag = true } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpdkSC3R/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut text = "Count" . to_string () ; let mut number = 100i32 ; let mut...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch06-00-data-structures-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpxfDhHt/main.rs:1:190
  |
1 | ...; let mut title = "Mr." . to_string () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpxfDhHt/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut first_name = "John" . to_string () ; let mut last_name = "Doe" . ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch06-00-data-structures-tdd example 7 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpT9vEJX/main.rs:1:179
  |
1 | ...mut unit = "Fahrenheit" . to_string () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpT9vEJX/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut label = "Temperature" . to_string () ; let mut value = 72i32 ; le...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch06-00-data-structures-tdd example 8 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpZLpy1s/main.rs:1:171
  |
1 | ... . to_string () ; let mut debug = true } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpZLpy1s/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut app_name = "MyApp" . to_string () ; let mut version = "1.0" . to_...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch03-00-functions example 1 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpMuzgXI/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let name = "Alice" . to_string () ; { let mut a = 15i32 ; let mut b = 27i32 ; let mu...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpMuzgXI/main.rs:1:50
  |
1 | ... { { { let name = "Alice" . to_string () ; { let mut a = 15i32 ; let mut b = 27i32 ; let mut greeting = format ! ("{}{}" , format ! ("{}{}" , "Hello, " , name) , "! Welcome to Ruchy!") ; let mut sum = a + b ; let mut result_message = format ! ("{}{}" , format ! ("{}{}" , a , " + ") + b , " = ") + sum ; println ! ("{:?}" , greeting) ; println ! ("{:?}" , result_message) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                  ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let name = "Alice" . to_string () ; { let mut a = 15i32 ; let mut b = 27i32 ; let mut greeting = format ! ("{}{}" , format ! ("{}{}" , "Hello, " , name) , "! Welcome to Ruchy!") ; let mut sum = a + b ; let mut result_message = format ! ("{}{}" , format ! ("{}{}" , a , " + ") + b , " = ") + sum ; println ! ("{:?}" , greeting) ; println ! ("{:?}" , result_message) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let name = "Alice" . to_string () ; { let mut a = 15i32 ; let mut b = 27i32 ; let mut greeting = format ! ("{}{}" , format ! ("{}{}" , "Hello, " , name) , "! Welcome to Ruchy!") ; let mut sum = a + b ; let mut result_message = format ! ("{}{}" , format ! ("{}{}" , a , " + ") + b , " = ") + sum ; println ! ("{:?}" , greeting) ; println ! ("{:?}" , result_message) } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpMuzgXI/main.rs:1:332
  |
1 | ... format ! ("{}{}" , format ! ("{}{}" , a , " + ") + b , " = ") + sum ; println ! ("{:?}" , greeting) ; println ! ("{:?}" , result_mess...
  |                                                        ^ expected `&str`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpMuzgXI/main.rs:1:345
  |
1 | ...{}" , format ! ("{}{}" , a , " + ") + b , " = ") + sum ; println ! ("{:?}" , greeting) ; println ! ("{:?}" , result_message) } } } }
  |                                                       ^^^ expected `&str`, found `i32`

error: aborting due to 2 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 2 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp3niM8P/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let input1 = 10i32 ; { let mut input2 = 20i32 ; let mut sum = input1 + input2 ; let ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp3niM8P/main.rs:1:50
  |
1 | ... { { { let input1 = 10i32 ; { let mut input2 = 20i32 ; let mut sum = input1 + input2 ; let mut product = input1 * input2 ; let mut average = sum / 2i32 ; let mut result = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Sum: " , sum) , ", Product: ") + product , ", Average: ") + average ; println ! ("{:?}" , result) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let input1 = 10i32 ; { let mut input2 = 20i32 ; let mut sum = input1 + input2 ; let mut product = input1 * input2 ; let mut average = sum / 2i32 ; let mut result = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Sum: " , sum) , ", Product: ") + product , ", Average: ") + average ; println ! ("{:?}" , result) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let input1 = 10i32 ; { let mut input2 = 20i32 ; let mut sum = input1 + input2 ; let mut product = input1 * input2 ; let mut average = sum / 2i32 ; let mut result = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Sum: " , sum) , ", Product: ") + product , ", Average: ") + average ; println ! ("{:?}" , result) } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp3niM8P/main.rs:1:309
  |
1 | ...at ! ("{}{}" , "Sum: " , sum) , ", Product: ") + product , ", Average: ") + average ; println ! ("{:?}" , result) } } } }
  |                                                     ^^^^^^^ expected `&str`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmp3niM8P/main.rs:1:336
  |
1 | ...m) , ", Product: ") + product , ", Average: ") + average ; println ! ("{:?}" , result) } } } }
  |                                                     ^^^^^^^ expected `&str`, found `i32`

error: aborting due to 2 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 3 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpyFQaRc/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let user_name = "Alice" . to_string () ; { let mut greeting_template = format ! ("{}...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpyFQaRc/main.rs:1:50
  |
1 | ... { { { let user_name = "Alice" . to_string () ; { let mut greeting_template = format ! ("{}{}" , format ! ("{}{}" , "Hello, " , user_name) , "! Welcome!") ; let mut num1 = 15i32 ; let mut num2 = 27i32 ; let mut operation = "addition" . to_string () ; let mut calc_result = num1 + num2 ; let mut calc_display = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , operation , ": ") + num1 , " + ") + num2 , " = ") + calc_result ; println ! ("{:?}" , greeting_template) ; println ! ("{:?}" , calc_display) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let user_name = "Alice" . to_string () ; { let mut greeting_template = format ! ("{}{}" , format ! ("{}{}" , "Hello, " , user_name) , "! Welcome!") ; let mut num1 = 15i32 ; let mut num2 = 27i32 ; let mut operation = "addition" . to_string () ; let mut calc_result = num1 + num2 ; let mut calc_display = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , operation , ": ") + num1 , " + ") + num2 , " = ") + calc_result ; println ! ("{:?}" , greeting_template) ; println ! ("{:?}" , calc_display) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let user_name = "Alice" . to_string () ; { let mut greeting_template = format ! ("{}{}" , format ! ("{}{}" , "Hello, " , user_name) , "! Welcome!") ; let mut num1 = 15i32 ; let mut num2 = 27i32 ; let mut operation = "addition" . to_string () ; let mut calc_result = num1 + num2 ; let mut calc_display = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , operation , ": ") + num1 , " + ") + num2 , " = ") + calc_result ; println ! ("{:?}" , greeting_template) ; println ! ("{:?}" , calc_display) } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpyFQaRc/main.rs:1:434
  |
1 | ... ("{}{}" , format ! ("{}{}" , operation , ": ") + num1 , " + ") + num2 , " = ") + calc_result ; println ! ("{:?}" , greeting_template)...
  |                                                      ^^^^ expected `&str`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpyFQaRc/main.rs:1:450
  |
1 | ...t ! ("{}{}" , operation , ": ") + num1 , " + ") + num2 , " = ") + calc_result ; println ! ("{:?}" , greeting_template) ; println ! ("{...
  |                                                      ^^^^ expected `&str`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpyFQaRc/main.rs:1:466
  |
1 | ...tion , ": ") + num1 , " + ") + num2 , " = ") + calc_result ; println ! ("{:?}" , greeting_template) ; println ! ("{:?}" , calc_display...
  |                                                   ^^^^^^^^^^^ expected `&str`, found `i32`

error: aborting due to 3 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 4 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpRex0Fa/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = "San Francisco" . to_string ()...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpRex0Fa/main.rs:1:50
  |
1 | ... { { { let temperature_f = 68i32 ; { let mut user_location = "San Francisco" . to_string () ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Weather in " , user_location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{:?}" , weather_report) ; println ! ("{:?}" , comfort_message) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = "San Francisco" . to_string () ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Weather in " , user_location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{:?}" , weather_report) ; println ! ("{:?}" , comfort_message) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let temperature_f = 68i32 ; { let mut user_location = "San Francisco" . to_string () ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Weather in " , user_location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{:?}" , weather_report) ; println ! ("{:?}" , comfort_message) } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpRex0Fa/main.rs:1:516
  |
1 | ... "°C)") ; let mut comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{:?}" ...
  |                                                            ^^                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = "San Francisco" . to_string () ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Weather in " , user_location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{:?}" , weather_report) ; println ! ("{:?}" , comfort_message) } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = "San Francisco" . to_string () ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Weather in " , user_location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfortable { "Perfect weather!" } else { { "Dress accordingly" } } ; println ! ("{:?}" , weather_report) ; println ! ("{:?}" , comfort_message) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpRex0Fa/main.rs:1:548
  |
1 | ... = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{:?}" , weather_report) ; println ! ("{...
  |                                                           ^^                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = "San Francisco" . to_string () ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Weather in " , user_location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{:?}" , weather_report) ; println ! ("{:?}" , comfort_message) } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = "San Francisco" . to_string () ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Weather in " , user_location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfortable { { "Perfect weather!" } } else { "Dress accordingly" } ; println ! ("{:?}" , weather_report) ; println ! ("{:?}" , comfort_message) } } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpRex0Fa/main.rs:1:419
  |
1 | ...}" , "Weather in " , user_location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfo...
  |                                                  ^^^^^^^^^^^^^ expected `&str`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpRex0Fa/main.rs:1:445
  |
1 | ...location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfortable { { "Perfect weathe...
  |                                                  ^^^^^^^^^^^^^ expected `&str`, found `i32`

error: aborting due to 2 previous errors; 4 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 5 ===
✗ Compilation failed: Compilation failed:
error: argument never used
 --> /tmp/.tmpOKQXNC/main.rs:1:595
  |
1 | ...love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{:?}" , excited...
  |                                                 --------------   ^^^^ argument never used
  |                                                 |
  |                                                 formatting specifier missing

error: argument never used
 --> /tmp/.tmpOKQXNC/main.rs:1:628
  |
1 | ...rintln ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{:?}" , excited) } } } }
  |                                                  -----------   ^^^^^^^^ argument never used
  |                                                  |
  |                                                  formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpOKQXNC/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpOKQXNC/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f...
  |                                                                  ^^     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{:?}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { x * x } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{:?}" , excited) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpOKQXNC/main.rs:1:117
  |
1 | ... } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , la...
  |                                              ^^                                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{:?}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { let pi = 3.14159f64 ; pi * square (radius) } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{:?}" , excited) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpOKQXNC/main.rs:1:233
  |
1 | ...t_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout (message : String) -> i32 { {...
  |                                             ^^                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{:?}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { format ! ("{}{}" , first_name , "_") + last_name } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{:?}" , excited) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpOKQXNC/main.rs:1:325
  |
1 | ..._name } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32...
  |                                                   ^^                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{:?}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout (message : String) -> i32 { format ! ("{}{}" , message , "!!!") } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{:?}" , excited) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpOKQXNC/main.rs:1:380
  |
1 | ... { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{:?}" , excited) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{:?}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("Circle area:" , area) ; println ! ("Username:" , username) ; println ! ("{:?}" , excited) } } }
  |

error[E0277]: cannot multiply `f64` by `i32`
 --> /tmp/.tmpOKQXNC/main.rs:1:146
  |
1 | ...ius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 ...
  |                                                     ^ no implementation for `f64 * i32`
  |
  = help: the trait `Mul<i32>` is not implemented for `f64`
  = help: the following other types implement trait `Mul<Rhs>`:
            `&f64` implements `Mul<f64>`
            `&f64` implements `Mul`
            `f64` implements `Mul<&f64>`
            `f64` implements `Mul`

error[E0308]: mismatched types
 --> /tmp/.tmpOKQXNC/main.rs:1:274
  |
1 | ... i32 { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!...
  |                                                    ^^^^^^^^^ expected `&str`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpOKQXNC/main.rs:1:235
  |
1 | ... , last_name : i32) -> i32 { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout (message : String) -> i32 { { format ! ("...
  |                           ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`
  |                           |
  |                           expected `i32` because of return type

error[E0308]: mismatched types
 --> /tmp/.tmpOKQXNC/main.rs:1:327
  |
1 | ...n shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let m...
  |                                  ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`
  |                                  |
  |                                  expected `i32` because of return type
  |
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpOKQXNC/main.rs:1:437
  |
1 | ...let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . t...
  |                       ^^^^^^^^^^^^^  ----------------------   ------------------------ expected `i32`, found `String`
  |                                      |
  |                                      expected `i32`, found `String`
  |
note: function defined here
 --> /tmp/.tmpOKQXNC/main.rs:1:173
  |
1 | ....14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , first_name ...
  |                                              ^^^^^^^^^^^^^  ----------------   ---------------

error: aborting due to 7 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.



=== ch03-00-functions example 6 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp8RsetZ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i3...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp8RsetZ/main.rs:1:72
  |
1 | use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i3...
  |                                                                        ^^                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { number % 2i32 == 0i32 } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp8RsetZ/main.rs:1:142
  |
1 | ... { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } ...
  |       ^^                                                                                                                                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp8RsetZ/main.rs:1:164
  |
1 | ...n grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { "A" } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp8RsetZ/main.rs:1:201
  |
1 | ...2 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { "B" } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp8RsetZ/main.rs:1:238
  |
1 | ...lse { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } }...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { "C" } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp8RsetZ/main.rs:1:275
  |
1 | ...lse { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i3...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { "D" } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp8RsetZ/main.rs:1:292
  |
1 | ... 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { "F" } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp8RsetZ/main.rs:1:350
  |
1 | ... { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } ...
  |       ^^                                                                                                                                                                                                                                                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp8RsetZ/main.rs:1:386
  |
1 | ...number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "la...
  |                                                                  ^^      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { "even" } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp8RsetZ/main.rs:1:406
  |
1 | ...i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "s...
  |                                                                  ^^     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { "odd" } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp8RsetZ/main.rs:1:453
  |
1 | ...n" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" ...
  |                                                                 ^^       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { "large" } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp8RsetZ/main.rs:1:474
  |
1 | ... } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , ...
  |                                                                 ^^       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { "small" } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp8RsetZ/main.rs:1:74
  |
1 | use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i3...
  |                                                                  ---     ^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `bool`
  |                                                                  |
  |                                                                  expected `i32` because of return type

error[E0308]: mismatched types
 --> /tmp/.tmp8RsetZ/main.rs:1:156
  |
1 | ...er (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } }...
  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`
  |                                      |        |
  |                                      |        expected `String`, found `i32`
  |                                      expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmp8RsetZ/main.rs:1:166
  |
1 | ...fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i3...
  |                                        ---                           ^^^ expected `i32`, found `&str`
  |                                        |
  |                                        expected `i32` because of return type

error[E0308]: mismatched types
 --> /tmp/.tmp8RsetZ/main.rs:1:193
  |
1 | ...re >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } }...
  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`
  |                                      |        |
  |                                      |        expected `String`, found `i32`
  |                                      expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmp8RsetZ/main.rs:1:203
  |
1 | ...ore : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else ...
  |                     --- expected `i32` because of return type                          ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmp8RsetZ/main.rs:1:230
  |
1 | ...re >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn descri...
  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`
  |                                      |        |
  |                                      |        expected `String`, found `i32`
  |                                      expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmp8RsetZ/main.rs:1:240
  |
1 | ...String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if s...
  |               --- expected `i32` because of return type                                                               ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmp8RsetZ/main.rs:1:267
  |
1 | ...re >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let ...
  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`
  |                                      |        |
  |                                      |        expected `String`, found `i32`
  |                                      expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmp8RsetZ/main.rs:1:277
  |
1 | ...-> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } ...
  |       --- expected `i32` because of return type                                                                                                    ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmp8RsetZ/main.rs:1:294
  |
1 | ...-> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } ...
  |       --- expected `i32` because of return type                                                                                                                     ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmp8RsetZ/main.rs:1:372
  |
1 | ...umber (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "lar...
  |                                                   ^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmp8RsetZ/main.rs:1:490
  |
1 | ...-> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } ...
  |       --- expected `i32` because of return type                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`
  |
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
 --> /tmp/.tmp8RsetZ/main.rs:1:751
  |
1 | ...150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |                                   ------------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                   |             |
  |                                   |             expected `String`, found `i32`
  |                                   arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmp8RsetZ/main.rs:1:103
  |
1 | use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i3...
  |                                                                                                       ^^^^^^^^^^^^  --------------

error: aborting due to 13 previous errors; 13 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 7 ===
✗ Compilation failed: Compilation failed:
error: argument never used
 --> /tmp/.tmp4gp05s/main.rs:1:825
  |
1 | ...le" . to_string () ; println ! ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scor...
  |                                    ---------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
  |                                    |
  |                                    formatting specifier missing

error: argument never used
 --> /tmp/.tmp4gp05s/main.rs:1:890
  |
1 | ...total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
  |                                        ----------------   ^^^^^^^^^^^^^^^^^^^^^^ argument never used
  |                                        |
  |                                        formatting specifier missing

error: argument never used
 --> /tmp/.tmp4gp05s/main.rs:1:943
  |
1 | ..., find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
  |                                           -------------   ^^^^^^^^^^^^^^^^^^^ argument never used
  |                                           |
  |                                           formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp4gp05s/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; let mut i = 0i32 ; while i < p...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp4gp05s/main.rs:1:396
  |
1 | ... . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words...
  |                                                      ^^                              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" . to_string () ; println ! ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
1 + use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { max_val = numbers [i as usize] } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" . to_string () ; println ! ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp4gp05s/main.rs:1:506
  |
1 | ...n count_words (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = ...
  |                                           ^^                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" . to_string () ; println ! ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
1 + use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { let words = text . split (" ") ; words . len () } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" . to_string () ; println ! ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp4gp05s/main.rs:1:577
  |
1 | ... { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" . to_string () ; println ! ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" . to_string () ; println ! ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
1 + use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" . to_string () ; println ! ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp4gp05s/main.rs:1:137
  |
1 | ...t total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } f...
  |                                              -   ^^^^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                              |
  |                                              expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len ().try_into().unwrap() { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" . to_string () ; println ! ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
  |                                                                                                                                                        ++++++++++++++++++++

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmp4gp05s/main.rs:1:181
  |
1 | ...rices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mu...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0308]: mismatched types
 --> /tmp/.tmp4gp05s/main.rs:1:214
  |
1 | ...-> i32 { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } ...
  |       --- expected `i32` because of return type                                                                                                ^^^^^ expected `i32`, found `f64`

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmp4gp05s/main.rs:1:293
  |
1 | ...ng) -> i32 { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] >...
  |                                              ^^^^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0308]: mismatched types
 --> /tmp/.tmp4gp05s/main.rs:1:339
  |
1 | ...0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize...
  |                                              -   ^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                              |
  |                                              expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len ().try_into().unwrap() { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" . to_string () ; println ! ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
  |                                                                                                                                                                                                                                                                                                                                                                   ++++++++++++++++++++

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmp4gp05s/main.rs:1:372
  |
1 | ...while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val }...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmp4gp05s/main.rs:1:417
  |
1 | ...as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { ...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0599]: no method named `len` found for struct `std::str::Split` in the current scope
    --> /tmp/.tmp4gp05s/main.rs:1:551
     |
1    | ... : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5...
     |                                                                     ^^^
     |
help: there is a method `le` with a similar name, but with different arguments
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:3877:5
     |
3877 | /     fn le<I>(self, other: I) -> bool
3878 | |     where
3879 | |         I: IntoIterator,
3880 | |         Self::Item: PartialOrd<I::Item>,
3881 | |         Self: Sized,
     | |____________________^

error[E0308]: mismatched types
 --> /tmp/.tmp4gp05s/main.rs:1:842
  |
1 | ...() ; println ! ("Total cost: $" , calculate_total (shopping_cart)) ; println ! ("Highest score:" , find_max (test_scores)) ; println !...
  |                                      ---------------  ^^^^^^^^^^^^^ expected `String`, found `Vec<f64>`
  |                                      |
  |                                      arguments to this function are incorrect
  |
  = note: expected struct `String`
             found struct `Vec<f64>`
note: function defined here
 --> /tmp/.tmp4gp05s/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; let mut i = 0i32 ; while i < p...
  |                                        ^^^^^^^^^^^^^^^  ---------------

error[E0308]: mismatched types
 --> /tmp/.tmp4gp05s/main.rs:1:900
  |
1 | ...art)) ; println ! ("Highest score:" , find_max (test_scores)) ; println ! ("Word count:" , count_words (essay)) } } } }
  |                                          --------  ^^^^^^^^^^^ expected `String`, found `Vec<i32>`
  |                                          |
  |                                          arguments to this function are incorrect
  |
  = note: expected struct `String`
             found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmp4gp05s/main.rs:1:227
  |
1 | ...rices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ...
  |                                                         ^^^^^^^^  ----------------

error: aborting due to 13 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch03-00-functions example 9 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpU9YHmN/main.rs:1:256
  |
1 | ...t msg = greet ("Alice" . to_string ()) } }
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpU9YHmN/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn greet (name : String , age : String) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpU9YHmN/main.rs:1:86
  |
1 | ...) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") + age , " years old") } } fn main (...
  |               ^^                                                                                                           ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn greet (name : String , age : String) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") + age , " years old") } } fn main () { { let msg = greet ("Alice" . to_string ()) } }
1 + use std :: collections :: HashMap ; fn greet (name : String , age : String) -> i32 { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") + age , " years old") } fn main () { { let msg = greet ("Alice" . to_string ()) } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpU9YHmN/main.rs:1:176
  |
1 | ...ormat ! ("{}{}" , "Hi " , name) , ", you're ") + age , " years old") } } fn main () { { let msg = greet ("Alice" . to_string ()) } }
  |                                                     ^^^ expected `&str`, found `String`
  |
help: consider borrowing here
  |
1 | use std :: collections :: HashMap ; fn greet (name : String , age : String) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") + &age , " years old") } } fn main () { { let msg = greet ("Alice" . to_string ()) } }
  |                                                                                                                                                                                +

error[E0308]: mismatched types
 --> /tmp/.tmpU9YHmN/main.rs:1:88
  |
1 | ...ng) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") + age , " years old") } } fn main...
  |           ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`
  |           |
  |           expected `i32` because of return type
  |
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 3 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 10 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpv7yv52/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpv7yv52/main.rs:1:134
  |
1 | ...i32 ; x } } fn good_function (x : i32) -> i32 { { { let result = x + 1i32 ; result } } } fn main () { { println ! ("{:?}" , good_funct...
  |                                                    ^^                                  ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { let result = x + 1i32 ; result } } } fn main () { { println ! ("{:?}" , good_function (5i32)) } }
1 + use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { let result = x + 1i32 ; result } } fn main () { { println ! ("{:?}" , good_function (5i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpv7yv52/main.rs:1:188
  |
1 | ...sult = x + 1i32 ; result } } } fn main () { { println ! ("{:?}" , good_function (5i32)) } }
  |                                                ^^                                         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { let result = x + 1i32 ; result } } } fn main () { { println ! ("{:?}" , good_function (5i32)) } }
1 + use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { let result = x + 1i32 ; result } } } fn main () { println ! ("{:?}" , good_function (5i32)) }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpv7yv52/main.rs:1:85
  |
1 | use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { ...
  |                                                                                     ^^^^ expected `&str`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpv7yv52/main.rs:1:92
  |
1 | use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { ...
  |                                                                     ---                    ^ expected `i32`, found `String`
  |                                                                     |
  |                                                                     expected `i32` because of return type

error: aborting due to 2 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 12 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp7jhVoM/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bm...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp7jhVoM/main.rs:1:87
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bm...
  |                                                                                       ^^                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { celsius * 9i32 / 5i32 + 32i32 } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7jhVoM/main.rs:1:184
  |
1 | ..._bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_perce...
  |                                                     ^^                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { weight_kg / height_m * height_m } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7jhVoM/main.rs:1:288
  |
1 | ...ount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : Strin...
  |                                 ^^                                                                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { let discount = price * discount_percent / 100i32 ; price - discount } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7jhVoM/main.rs:1:405
  |
1 | ...fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) ...
  |                                           ^^                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { let words = text . split (" ") ; words . len () } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7jhVoM/main.rs:1:509
  |
1 | ... { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } ...
  |       ^^                                                                                                                                                                                                                                                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7jhVoM/main.rs:1:638
  |
1 | ...ords . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } }...
  |                    ^^                                                                                                 ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7jhVoM/main.rs:1:842
  |
1 | ... { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } ...
  |       ^^                                                                                                                                                                                                                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7jhVoM/main.rs:1:895
  |
1 | ...f energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time...
  |                                                      ^^                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { "Go for a run or hit the gym!" } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7jhVoM/main.rs:1:990
  |
1 | ... if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn ...
  |                                                        ^^                         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { "Perfect time for a walk" } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7jhVoM/main.rs:1:1029
  |
1 | ...e > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_...
  |                                                       ^^                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { "Maybe just relax and read" } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

error[E0599]: no method named `len` found for struct `std::str::Split` in the current scope
    --> /tmp/.tmp7jhVoM/main.rs:1:450
     |
1    | ... : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let wo...
     |                                                                     ^^^
     |
help: there is a method `le` with a similar name, but with different arguments
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:3877:5
     |
3877 | /     fn le<I>(self, other: I) -> bool
3878 | |     where
3879 | |         I: IntoIterator,
3880 | |         Self::Item: PartialOrd<I::Item>,
3881 | |         Self: Sized,
     | |____________________^

error[E0599]: no method named `len` found for struct `std::str::Split` in the current scope
    --> /tmp/.tmp7jhVoM/main.rs:1:629
     |
1    | ...tials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + ...
     |                                                                     ^^^
     |
help: there is a method `le` with a similar name, but with different arguments
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:3877:5
     |
3877 | /     fn le<I>(self, other: I) -> bool
3878 | |     where
3879 | |         I: IntoIterator,
3880 | |         Self::Item: PartialOrd<I::Item>,
3881 | |         Self: Sized,
     | |____________________^

error[E0608]: cannot index into a value of type `std::str::Split<'_, &str>`
 --> /tmp/.tmp7jhVoM/main.rs:1:659
  |
1 | ...t i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i3...
  |                                                                 ^^^^^^^^^^^^

error[E0308]: mismatched types
 --> /tmp/.tmp7jhVoM/main.rs:1:744
  |
1 | ...-> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } ...
  |       --- expected `i32` because of return type                                                                                                                                                                                                        ^^^^^^^^ expected `i32`, found `String`

error[E0308]: mismatched types
 --> /tmp/.tmp7jhVoM/main.rs:1:862
  |
1 | ...e_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_l...
  |                                   ------------   ^^^^- help: try using a conversion method: `.to_string()`
  |                                   |              |
  |                                   |              expected `String`, found `i32`
  |                                   expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmp7jhVoM/main.rs:1:887
  |
1 | ...{ { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available...
  |                                  --------------   ^^^^^- help: try using a conversion method: `.to_string()`
  |                                  |                |
  |                                  |                expected `String`, found `i32`
  |                                  expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmp7jhVoM/main.rs:1:897
  |
1 | ...ng) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 &...
  |           --- expected `i32` because of return type                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmp7jhVoM/main.rs:1:957
  |
1 | ...or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just re...
  |                                   ------------   ^^^^- help: try using a conversion method: `.to_string()`
  |                                   |              |
  |                                   |              expected `String`, found `i32`
  |                                   expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmp7jhVoM/main.rs:1:982
  |
1 | ...e { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } ...
  |                                  --------------   ^^^^^- help: try using a conversion method: `.to_string()`
  |                                  |                |
  |                                  |                expected `String`, found `i32`
  |                                  expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmp7jhVoM/main.rs:1:992
  |
1 | ...-> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } ...
  |       --- expected `i32` because of return type                                                                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmp7jhVoM/main.rs:1:1031
  |
1 | ...-> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } ...
  |       --- expected `i32` because of return type                                                                                                                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmp7jhVoM/main.rs:1:1180
  |
1 | ...enheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string...
  |                                          -------------          ^^^^^^^ expected `i32`, found `f64`
  |                                          |
  |                                          arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmp7jhVoM/main.rs:1:126
  |
1 | ...2 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m...
  |                                               ^^^^^^^^^^^^^                    --------------
help: change the type of the numeric literal from `f64` to `i32`
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1i32)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmp7jhVoM/main.rs:1:1281
  |
1 | ..._string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |                                       ^^^^^^^^^^^^^^^^^^  ----   ----- expected `String`, found `i32`
  |                                                           |
  |                                                           expected `String`, found `i32`
  |
note: function defined here
 --> /tmp/.tmp7jhVoM/main.rs:1:764
  |
1 | ...32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i3...
  |                                     ^^^^^^^^^^^^^^^^^^  ---------------------   -----------------------
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32.to_string() , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ++++++++++++
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32.to_string())) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ++++++++++++

error: aborting due to 13 previous errors; 11 warnings emitted

Some errors have detailed explanations: E0308, E0599, E0608.
For more information about an error, try `rustc --explain E0308`.


