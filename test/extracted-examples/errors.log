=== ch02-00-variables-types-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found `let` statement
 --> /tmp/.tmpjGjVkv/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let mut result = value1 + value2 ; if let Some (s) = (& result as & dyn std...
  |                                                               ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

error[E0425]: cannot find value `value1` in this scope
 --> /tmp/.tmpjGjVkv/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let mut result = value1 + value2 ; if let Some (s) = (& result as & dyn std...
  |                                                                                ^^^^^^ not found in this scope

error[E0425]: cannot find value `value2` in this scope
 --> /tmp/.tmpjGjVkv/main.rs:1:89
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let mut result = value1 + value2 ; if let Some (s) = (& result as & dyn std...
  |                                                                                         ^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpjGjVkv/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let mut result = value1 + value2 ; if let Some (s) = (& result as & dyn std...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 3 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch02-00-variables-types-tdd example 7 ===
✗ Compilation failed: Compilation failed:
error: expected one of `!`, `.`, `::`, `;`, `?`, `else`, `{`, or an operator, found `}`
 --> /tmp/.tmpR2PdGR/main.rs:1:182
  |
1 | ...ustment ; let mut final_result = step2 / divisor } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < Strin...
  |                                                     ^ expected one of 8 possible tokens

error[E0425]: cannot find value `initial_value` in this scope
 --> /tmp/.tmpR2PdGR/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut step1 = initial_value * factor ; let mut step2 = step1 + adjustme...
  |                                                                                 ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `factor` in this scope
 --> /tmp/.tmpR2PdGR/main.rs:1:97
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut step1 = initial_value * factor ; let mut step2 = step1 + adjustme...
  |                                                                                                 ^^^^^^ not found in this scope

error[E0425]: cannot find value `adjustment` in this scope
 --> /tmp/.tmpR2PdGR/main.rs:1:130
  |
1 | ... initial_value * factor ; let mut step2 = step1 + adjustment ; let mut final_result = step2 / divisor } ; if let Some (s) = (& result ...
  |                                                      ^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpR2PdGR/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut step1 = initial_value * factor ; let mut step2 = step1 + adjustme...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 4 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch02-00-variables-types-tdd example 8 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpYHp8e4/main.rs:1:117
  |
1 | ...3.14159f64 ; let mut GRAVITY = 9.81f64 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpYHp8e4/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut PI = 3.14159f64 ; let mut GRAVITY = 9.81f64 } ; if let Some (s) =...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch10-00-performance-optimization example 1 ===
✗ Compilation failed: Compilation failed:
error[E0432]: unresolved import `std::perf`
 --> /tmp/.tmpFQ3WAH/main.rs:1:967
  |
1 | ...eturn lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32)...
  |                                                      ^^^^^^^^^^^ no `perf` in the root

error[E0432]: unresolved import `std::parallel`
 --> /tmp/.tmpFQ3WAH/main.rs:1:987
  |
1 | ... } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = ...
  |                                                  ^^^^^^^^^^^^^^^ no `parallel` in the root

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpFQ3WAH/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpFQ3WAH/main.rs:1:207
  |
1 | ... { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } ...
  |       ^^                                                                                                                                                                                                                                                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpFQ3WAH/main.rs:1:257
  |
1 | ... { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ...
  |       ^^                                                                                                                                                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpFQ3WAH/main.rs:1:334
  |
1 | ...; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed...
  |                                  ^^                                                                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { if similar (processed , existing) { { processed . merge (existing) } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpFQ3WAH/main.rs:1:372
  |
1 | ...in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; retur...
  |                                                       ^^                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { processed . merge (existing) } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpFQ3WAH/main.rs:1:647
  |
1 | ... { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpFQ3WAH/main.rs:1:778
  |
1 | ... { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ...
  |       ^^                                                                                                                                 ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpFQ3WAH/main.rs:1:841
  |
1 | ...= item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return l...
  |                                                       ^^                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { lookup [key] . merge (item) } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpFQ3WAH/main.rs:1:882
  |
1 | ...s_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () ...
  |                                                           ^^                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { lookup [key] = item } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpFQ3WAH/main.rs:1:981
  |
1 | ... . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut n...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpFQ3WAH/main.rs:1:1005
  |
1 | ...main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: meas...
  |                                                        ^ help: remove this semicolon

error[E0277]: `T` is not an iterator
 --> /tmp/.tmpFQ3WAH/main.rs:1:250
  |
1 | ...T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results...
  |                                                         ^^^^ `T` is not an iterator
  |
  = note: required for `T` to implement `IntoIterator`
help: consider further restricting type parameter `T` with trait `Iterator`
  |
1 | use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |                                                                                                                                                                                           +++++++++++++++++++++

error[E0425]: cannot find function `expensive_transform` in this scope
 --> /tmp/.tmpFQ3WAH/main.rs:1:277
  |
1 | ...] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existi...
  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `similar` in this scope
 --> /tmp/.tmpFQ3WAH/main.rs:1:339
  |
1 | ...ransform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results ....
  |                                                       ^^^^^^^ not found in this scope

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `parallel`
 --> /tmp/.tmpFQ3WAH/main.rs:1:665
  |
1 | ...(data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for ite...
  |                                        ^^^^^^^^ use of unresolved module or unlinked crate `parallel`
  |
  = help: you might be missing a crate named `parallel`

error[E0425]: cannot find function `expensive_transform` in this scope
 --> /tmp/.tmpFQ3WAH/main.rs:1:700
  |
1 | ...results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key...
  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `has_key` found for unit type `()` in the current scope
 --> /tmp/.tmpFQ3WAH/main.rs:1:825
  |
1 | ...s { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } ...
  |                                                       ^^^^^^^ method not found in `()`

error[E0599]: no method named `values` found for unit type `()` in the current scope
 --> /tmp/.tmpFQ3WAH/main.rs:1:932
  |
1 | ... { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut ...
  |                                                       ^^^^^^ method not found in `()`

error[E0425]: cannot find function `generate_test_data` in this scope
 --> /tmp/.tmpFQ3WAH/main.rs:1:1022
  |
1 | ...rf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_na...
  |                                                  ^^^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 10 previous errors; 11 warnings emitted

Some errors have detailed explanations: E0277, E0425, E0432, E0433, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch10-00-performance-optimization example 2 ===

thread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:
"perf::CpuProfiler" is not a valid Ident
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


=== ch10-00-performance-optimization example 3 ===

thread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:
"string builder" is not a valid Ident
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


=== ch10-00-performance-optimization example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `fibonacci_cache` in this scope
 --> /tmp/.tmpN6NQzQ/main.rs:1:205
  |
1 | ... :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n ...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `fibonacci_cache` in this scope
 --> /tmp/.tmpN6NQzQ/main.rs:1:246
  |
1 | ... { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `fibonacci_cache` in this scope
 --> /tmp/.tmpN6NQzQ/main.rs:1:381
  |
1 | ...(n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmpN6NQzQ/main.rs:1:651
  |
1 | ...) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmpN6NQzQ/main.rs:1:687
  |
1 | ...[] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . p...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpN6NQzQ/main.rs:1:1420
  |
1 | ...> (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Ad...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpN6NQzQ/main.rs:1:1634
  |
1 | ...d :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add <...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `null` in this scope
 --> /tmp/.tmpN6NQzQ/main.rs:1:1934
  |
1 | ...if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::ptr::null;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpN6NQzQ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpN6NQzQ/main.rs:1:237
  |
1 | ...(n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { ...
  |                                                        ^^                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { return fibonacci_cache [n] } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpN6NQzQ/main.rs:1:302
  |
1 | ... return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32)...
  |                                                                    ^^ ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { n } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpN6NQzQ/main.rs:1:317
  |
1 | ...esult = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; r...
  |                                          ^^                                                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpN6NQzQ/main.rs:1:608
  |
1 | ... { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } ...
  |       ^^                                                                                                                                                                                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpN6NQzQ/main.rs:1:676
  |
1 | ...n ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; ret...
  |            ^^                                                                                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpN6NQzQ/main.rs:1:723
  |
1 | ...ge (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } }...
  |                                     ^^                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpN6NQzQ/main.rs:1:753
  |
1 | ..., items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_dupl...
  |                                                      ^^                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { duplicates . push (items [i]) } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpN6NQzQ/main.rs:1:1003
  |
1 | ... { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } ...
  |       ^^                                                                                                                                                                                                                 ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpN6NQzQ/main.rs:1:1123
  |
1 | ... ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_ar...
  |                                                         ^^                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { duplicates . add (item) } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpN6NQzQ/main.rs:1:1392
  |
1 | ...Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : st...
  |                                         ^^                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { for record in records { { database . insert (record) } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpN6NQzQ/main.rs:1:1418
  |
1 | ...ne > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops ::...
  |                                                        ^^                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { database . insert (record) } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpN6NQzQ/main.rs:1:1632
  |
1 | ... :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < ...
  |                                                    ^^                                 ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { database . insert_batch (records) } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpN6NQzQ/main.rs:1:1879
  |
1 | ... predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibo...
  |                                                 ^^                                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { if predicate (item) { { return item } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpN6NQzQ/main.rs:1:1903
  |
1 | ... : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cach...
  |                                                               ^^           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { return item } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |

error[E0369]: binary operation `<=` cannot be applied to type `T`
 --> /tmp/.tmpN6NQzQ/main.rs:1:292
  |
1 | ... (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n...
  |                                                                - ^^ ---- i32
  |                                                                |
  |                                                                T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                                                                                                                                                       +++++++++++++++++++++++++++

error[E0369]: cannot subtract `i32` from `T`
 --> /tmp/.tmpN6NQzQ/main.rs:1:337
  |
1 | ...let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = resul...
  |                                                                 - ^ ---- i32
  |                                                                 |
  |                                                                 T
  |
help: consider further restricting type parameter `T` with trait `Sub`
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Sub<i32> > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                                                                                                                                                       ++++++++++++++++++++

error[E0369]: cannot subtract `i32` from `T`
 --> /tmp/.tmpN6NQzQ/main.rs:1:365
  |
1 | ...{ n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn...
  |                                                                 - ^ ---- i32
  |                                                                 |
  |                                                                 T
  |
help: consider further restricting type parameter `T` with trait `Sub`
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Sub<i32, Output = T> > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                                                                                                                                                       ++++++++++++++++++++++++++++++++

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpN6NQzQ/main.rs:1:666
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                             ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           +++++++++++++++++++

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpN6NQzQ/main.rs:1:713
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                                                                            ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           +++++++++++++++++++

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpN6NQzQ/main.rs:1:734
  |
1 | ... ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; retu...
  |                                                                     ^^^

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpN6NQzQ/main.rs:1:747
  |
1 | ...j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates...
  |                                                                     ^^^

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpN6NQzQ/main.rs:1:780
  |
1 | ...n ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optim...
  |                                                                     ^^^

error[E0433]: failed to resolve: use of undeclared type `Set`
 --> /tmp/.tmpN6NQzQ/main.rs:1:1018
  |
1 | ... Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if see...
  |                                                       ^^^ use of undeclared type `Set`

error[E0433]: failed to resolve: use of undeclared type `Set`
 --> /tmp/.tmpN6NQzQ/main.rs:1:1057
  |
1 | ... let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . ad...
  |                                                       ^^^ use of undeclared type `Set`

error[E0277]: `T` is not an iterator
 --> /tmp/.tmpN6NQzQ/main.rs:1:1085
  |
1 | ...; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add ...
  |                                                         ^^^^^ `T` is not an iterator
  |
  = note: required for `T` to implement `IntoIterator`
help: consider further restricting type parameter `T` with trait `Iterator`
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      +++++++++++++++++++++

error[E0277]: `T` is not an iterator
 --> /tmp/.tmpN6NQzQ/main.rs:1:1408
  |
1 | ...ebug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std...
  |                                                        ^^^^^^^ `T` is not an iterator
  |
  = note: required for `T` to implement `IntoIterator`
help: consider further restricting type parameter `T` with trait `Iterator`
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         +++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpN6NQzQ/main.rs:1:1394
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } ...
  |       -                                                                                                                                                -     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |       |                                                                                                                                                |
  |       expected this type parameter                                                                                                                     expected `T` because of return type
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: the caller chooses a type for `T` which can be different from `()`
  = note: `for` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } /* `T` value */ } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           +++++++++++++++

error[E0277]: `T` is not an iterator
 --> /tmp/.tmpN6NQzQ/main.rs:1:1871
  |
1 | ...e > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main (...
  |                                                         ^^^^^ `T` is not an iterator
  |
  = note: required for `T` to implement `IntoIterator`
help: consider further restricting type parameter `T` with trait `Iterator`
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            +++++++++++++++++++++

error[E0618]: expected function, found `T`
 --> /tmp/.tmpN6NQzQ/main.rs:1:1884
  |
1 | ...e > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main (...
  |                     ---------                                        ^^^^^^^^^-------
  |                     |                                                |
  |                     `predicate` has type `T`                         call expression requires function

warning: unused variable: `fibonacci_cache`
 --> /tmp/.tmpN6NQzQ/main.rs:1:1964
  |
1 | ...n main () { let mut fibonacci_cache = () ; }
  |                        ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_fibonacci_cache`
  |
  = note: `#[warn(unused_variables)]` on by default

warning: variable does not need to be mutable
 --> /tmp/.tmpN6NQzQ/main.rs:1:1960
  |
1 | ...turn item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }
  |                                                         ----^^^^^^^^^^^^^^^
  |                                                         |
  |                                                         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

error: aborting due to 23 previous errors; 17 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0369, E0425, E0433, E0599, E0608, E0618.
For more information about an error, try `rustc --explain E0277`.



=== ch10-00-performance-optimization example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 8 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpc3iDIW/main.rs:1:478
  |
1 | ...\u{fe0f}  Sequential scan detected - consider adding index" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clau...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpc3iDIW/main.rs:1:480
  |
1 | ...n") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index" . to_string ()) ; { let table = extract_table (sql) ;...
  |                       -------------------------------------------------------------   ^^^^^^^^^^^^ argument never used
  |                       |
  |                       formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpc3iDIW/main.rs:1:1011
  |
1 | ...ample)) ; println ! ("Consider using JOIN or batch loading" . to_string ()) } } } } } } } } fn get_users_with_posts_naive () { { { let...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpc3iDIW/main.rs:1:1013
  |
1 | ...tern . example)) ; println ! ("Consider using JOIN or batch loading" . to_string ()) } } } } } } } } fn get_users_with_posts_naive () ...
  |                                  --------------------------------------   ^^^^^^^^^^^^ argument never used
  |                                  |
  |                                  formatting specifier missing

error[E0432]: unresolved import `std::db`
 --> /tmp/.tmpc3iDIW/main.rs:1:1539
  |
1 | ... []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp"...
  |                                          ^^^^^^^--
  |                                          |      |
  |                                          |      help: a similar name exists in the module: `dbg`
  |                                          no `db` in the root

error[E0432]: unresolved import `std::perf`
 --> /tmp/.tmpc3iDIW/main.rs:1:1557
  |
1 | ... unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_...
  |                                                      ^^^^^^^^^^^ no `perf` in the root

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpc3iDIW/main.rs:1:216
  |
1 | ...:: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql))...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpc3iDIW/main.rs:1:690
  |
1 | ...ere_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_lo...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpc3iDIW/main.rs:1:1094
  |
1 | ...fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = d...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpc3iDIW/main.rs:1:1176
  |
1 | ...M users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpc3iDIW/main.rs:1:1330
  |
1 | ... } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JO...
  |                                                       ^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpc3iDIW/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: f...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpc3iDIW/main.rs:1:201
  |
1 | ... { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading" . to_string ()) } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading" . to_string ()) } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
1 + use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading" . to_string ()) } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpc3iDIW/main.rs:1:804
  |
1 | ... { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading" . to_string ()) } } } } ...
  |       ^^                                                                                                                                                                                                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading" . to_string ()) } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
1 + use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading" . to_string ()) } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpc3iDIW/main.rs:1:1078
  |
1 | ... { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } ...
  |       ^^                                                                                                                                                                                                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading" . to_string ()) } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
1 + use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading" . to_string ()) } } } } } } } } fn get_users_with_posts_naive () { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpc3iDIW/main.rs:1:1159
  |
1 | ...r user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users }...
  |                      ^^                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading" . to_string ()) } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
1 + use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading" . to_string ()) } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpc3iDIW/main.rs:1:1321
  |
1 | ... { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } ...
  |       ^^                                                                                                                                                                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading" . to_string ()) } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
1 + use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading" . to_string ()) } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpc3iDIW/main.rs:1:1551
  |
1 | ...(& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myap...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpc3iDIW/main.rs:1:1571
  |
1 | ... } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ;...
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpc3iDIW/main.rs:1:480
  |
1 | ...quential scan detected - consider adding index" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `extract_table` in this scope
 --> /tmp/.tmpc3iDIW/main.rs:1:510
  |
1 | ...r adding index" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Sugge...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `extract_where` in this scope
 --> /tmp/.tmpc3iDIW/main.rs:1:557
  |
1 | ... extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `find_patterns` in this scope
 --> /tmp/.tmpc3iDIW/main.rs:1:750
  |
1 | ...et_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && ...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpc3iDIW/main.rs:1:1013
  |
1 | ...intln ! ("Consider using JOIN or batch loading" . to_string ()) } } } } } } } } fn get_users_with_posts_naive () { { { let users = dat...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpc3iDIW/main.rs:1:778
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading" . to_string ()) } } } } } ...
  |       - expected this type parameter                                                                                                               - expected `T` because of return type                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: the caller chooses a type for `T` which can be different from `()`
  = note: `for` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading" . to_string ()) } } } } /* `T` value */ } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           +++++++++++++++

error: aborting due to 17 previous errors; 8 warnings emitted

Some errors have detailed explanations: E0308, E0425, E0432.
For more information about an error, try `rustc --explain E0308`.



=== ch10-00-performance-optimization example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch04-00-modules-tdd example 2 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmp6Oxhzh/main.rs:1:114
  |
1 | use std :: collections :: HashMap ; fn main () { mod utils { pub fn greet () { { println ! ("Hello from module!" . to_string ()) } } } ; ...
  |                                                                                                                  ^ expected `,`

error: argument never used
 --> /tmp/.tmp6Oxhzh/main.rs:1:116
  |
1 | ...utils { pub fn greet () { { println ! ("Hello from module!" . to_string ()) } } } ; { utils :: greet () } }
  |                                           --------------------   ^^^^^^^^^^^^ argument never used
  |                                           |
  |                                           formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp6Oxhzh/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { mod utils { pub fn greet () { { println ! ("Hello from module!" . to_string ()) } } } ; ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmp6Oxhzh/main.rs:1:136
  |
1 | ...intln ! ("Hello from module!" . to_string ()) } } } ; { utils :: greet () } }
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp6Oxhzh/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn main () { mod utils { pub fn greet () { { println ! ("Hello from module!" . to_string ()) } } } ; ...
  |                                                                                ^^                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { mod utils { pub fn greet () { { println ! ("Hello from module!" . to_string ()) } } } ; { utils :: greet () } }
1 + use std :: collections :: HashMap ; fn main () { mod utils { pub fn greet () { println ! ("Hello from module!" . to_string ()) } } ; { utils :: greet () } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp6Oxhzh/main.rs:1:138
  |
1 | ...println ! ("Hello from module!" . to_string ()) } } } ; { utils :: greet () } }
  |                                                            ^^                 ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { mod utils { pub fn greet () { { println ! ("Hello from module!" . to_string ()) } } } ; { utils :: greet () } }
1 + use std :: collections :: HashMap ; fn main () { mod utils { pub fn greet () { { println ! ("Hello from module!" . to_string ()) } } } ; utils :: greet () }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmp6Oxhzh/main.rs:1:116
  |
1 | ...fn greet () { { println ! ("Hello from module!" . to_string ()) } } } ; { utils :: greet () } }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 4 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch04-00-modules-tdd example 3 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found keyword `mod`
 --> /tmp/.tmpxys8Oi/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod module_name { { pub fn public_function () { () } ; fn private_function ...
  |                                                               ^^^ expected expression

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpxys8Oi/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod module_name { { pub fn public_function () { () } ; fn private_function ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch04-00-modules-tdd example 4 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpFWVAeM/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpFWVAeM/main.rs:1:50
  |
1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }
  |                                                  ^^                                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }
1 + use std :: collections :: HashMap ; fn main () { module_name :: public_function () }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `module_name`
 --> /tmp/.tmpFWVAeM/main.rs:1:52
  |
1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }
  |                                                    ^^^^^^^^^^^ use of unresolved module or unlinked crate `module_name`
  |
  = help: you might be missing a crate named `module_name`

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0433`.



=== ch04-00-modules-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found keyword `mod`
 --> /tmp/.tmpzuCnhQ/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod math { { pub fn add (a : i32 , b : i32) -> i32 { { a + b } } ; pub fn s...
  |                                                               ^^^ expected expression

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpzuCnhQ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod math { { pub fn add (a : i32 , b : i32) -> i32 { { a + b } } ; pub fn s...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch04-00-modules-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found keyword `mod`
 --> /tmp/.tmp9R6fXX/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod strings { { pub fn greet () { { println ! ("Hello!" . to_string ()) } }...
  |                                                               ^^^ expected expression

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp9R6fXX/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod strings { { pub fn greet () { { println ! ("Hello!" . to_string ()) } }...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch09-00-collections-tdd example 1 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmphrF05N/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Counting to 5:" . to_string ()) ; for i in 0i32 .. 5i32 { { println ! ("{}...
  |                                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmphrF05N/main.rs:1:82
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Counting to 5:" . to_string ()) ; for i in 0i32 .. 5i32 { { println ! ("{}...
  |                                                               ----------------   ^^^^^^^^^^^^ argument never used
  |                                                               |
  |                                                               formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmphrF05N/main.rs:1:178
  |
1 | ...2 { { println ! ("{}" , i) } } ; println ! ("Done counting" . to_string ()) } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmphrF05N/main.rs:1:180
  |
1 | ...{ { println ! ("{}" , i) } } ; println ! ("Done counting" . to_string ()) } }
  |                                              ---------------   ^^^^^^^^^^^^ argument never used
  |                                              |
  |                                              formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmphrF05N/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Counting to 5:" . to_string ()) ; for i in 0i32 .. 5i32 { { println ! ("{}...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmphrF05N/main.rs:1:122
  |
1 | ...nting to 5:" . to_string ()) ; for i in 0i32 .. 5i32 { { println ! ("{}" , i) } } ; println ! ("Done counting" . to_string ()) } }
  |                                                           ^^                    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { println ! ("Counting to 5:" . to_string ()) ; for i in 0i32 .. 5i32 { { println ! ("{}" , i) } } ; println ! ("Done counting" . to_string ()) } }
1 + use std :: collections :: HashMap ; fn main () { { println ! ("Counting to 5:" . to_string ()) ; for i in 0i32 .. 5i32 { println ! ("{}" , i) } ; println ! ("Done counting" . to_string ()) } }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmphrF05N/main.rs:1:82
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Counting to 5:" . to_string ()) ; for i in 0i32 .. 5i32 { { println ! ("{}...
  |                                                                                  ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmphrF05N/main.rs:1:180
  |
1 | ...n ! ("{}" , i) } } ; println ! ("Done counting" . to_string ()) } }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 6 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 2 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmp6fZ7Y8/main.rs:1:172
  |
1 | ...sum = sum + i ; i = i + 1i32 } } ; println ! ("Sum of 1-5:" . to_string ()) ; println ! ("{}" , sum) } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmp6fZ7Y8/main.rs:1:174
  |
1 | ... = sum + i ; i = i + 1i32 } } ; println ! ("Sum of 1-5:" . to_string ()) ; println ! ("{}" , sum) } }
  |                                               -------------   ^^^^^^^^^^^^ argument never used
  |                                               |
  |                                               formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp6fZ7Y8/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { let mut sum = 0i32 ; let mut i = 1i32 ; while i <= 5i32 { { sum = sum + i ; i = i + 1i...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmp6fZ7Y8/main.rs:1:174
  |
1 | ...i ; i = i + 1i32 } } ; println ! ("Sum of 1-5:" . to_string ()) ; println ! ("{}" , sum) } }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 3 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpP8akSq/main.rs:1:74
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Pattern:" . to_string ()) ; for row in 0i32 .. 3i32 { { for col in 0i32 .....
  |                                                                          ^ expected `,`

error: argument never used
 --> /tmp/.tmpP8akSq/main.rs:1:76
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Pattern:" . to_string ()) ; for row in 0i32 .. 3i32 { { for col in 0i32 .....
  |                                                               ----------   ^^^^^^^^^^^^ argument never used
  |                                                               |
  |                                                               formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpP8akSq/main.rs:1:193
  |
1 | ...32 .. 3i32 { { if row + col % 2i32 == 0i32 { { print ! ("*" . to_string ()) } } else { { print ! (" " . to_string ()) } } } } ; printl...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpP8akSq/main.rs:1:195
  |
1 | ...32 { { if row + col % 2i32 == 0i32 { { print ! ("*" . to_string ()) } } else { { print ! (" " . to_string ()) } } } } ; println ! ("" ...
  |                                                    ---   ^^^^^^^^^^^^ argument never used
  |                                                    |
  |                                                    formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpP8akSq/main.rs:1:235
  |
1 | ... { { print ! ("*" . to_string ()) } } else { { print ! (" " . to_string ()) } } } } ; println ! ("" . to_string ()) } } } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpP8akSq/main.rs:1:237
  |
1 | ...nt ! ("*" . to_string ()) } } else { { print ! (" " . to_string ()) } } } } ; println ! ("" . to_string ()) } } } }
  |                                                    ---   ^^^^^^^^^^^^ argument never used
  |                                                    |
  |                                                    formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpP8akSq/main.rs:1:275
  |
1 | ...se { { print ! (" " . to_string ()) } } } } ; println ! ("" . to_string ()) } } } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpP8akSq/main.rs:1:277
  |
1 | ...int ! (" " . to_string ()) } } } } ; println ! ("" . to_string ()) } } } }
  |                                                    --   ^^^^^^^^^^^^ argument never used
  |                                                    |
  |                                                    formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpP8akSq/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Pattern:" . to_string ()) ; for row in 0i32 .. 3i32 { { for col in 0i32 .....
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpP8akSq/main.rs:1:146
  |
1 | ...2 .. 3i32 { { if row + col % 2i32 == 0i32 { { print ! ("*" . to_string ()) } } else { { print ! (" " . to_string ()) } } } } ; println...
  |                ^^                                                                                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { println ! ("Pattern:" . to_string ()) ; for row in 0i32 .. 3i32 { { for col in 0i32 .. 3i32 { { if row + col % 2i32 == 0i32 { { print ! ("*" . to_string ()) } } else { { print ! (" " . to_string ()) } } } } ; println ! ("" . to_string ()) } } } }
1 + use std :: collections :: HashMap ; fn main () { { println ! ("Pattern:" . to_string ()) ; for row in 0i32 .. 3i32 { { for col in 0i32 .. 3i32 { if row + col % 2i32 == 0i32 { { print ! ("*" . to_string ()) } } else { { print ! (" " . to_string ()) } } } ; println ! ("" . to_string ()) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpP8akSq/main.rs:1:178
  |
1 | ... in 0i32 .. 3i32 { { if row + col % 2i32 == 0i32 { { print ! ("*" . to_string ()) } } else { { print ! (" " . to_string ()) } } } } ; ...
  |                                                       ^^                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { println ! ("Pattern:" . to_string ()) ; for row in 0i32 .. 3i32 { { for col in 0i32 .. 3i32 { { if row + col % 2i32 == 0i32 { { print ! ("*" . to_string ()) } } else { { print ! (" " . to_string ()) } } } } ; println ! ("" . to_string ()) } } } }
1 + use std :: collections :: HashMap ; fn main () { { println ! ("Pattern:" . to_string ()) ; for row in 0i32 .. 3i32 { { for col in 0i32 .. 3i32 { { if row + col % 2i32 == 0i32 { print ! ("*" . to_string ()) } else { { print ! (" " . to_string ()) } } } } ; println ! ("" . to_string ()) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpP8akSq/main.rs:1:220
  |
1 | ...= 0i32 { { print ! ("*" . to_string ()) } } else { { print ! (" " . to_string ()) } } } } ; println ! ("" . to_string ()) } } } }
  |                                                       ^^                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { println ! ("Pattern:" . to_string ()) ; for row in 0i32 .. 3i32 { { for col in 0i32 .. 3i32 { { if row + col % 2i32 == 0i32 { { print ! ("*" . to_string ()) } } else { { print ! (" " . to_string ()) } } } } ; println ! ("" . to_string ()) } } } }
1 + use std :: collections :: HashMap ; fn main () { { println ! ("Pattern:" . to_string ()) ; for row in 0i32 .. 3i32 { { for col in 0i32 .. 3i32 { { if row + col % 2i32 == 0i32 { { print ! ("*" . to_string ()) } } else { print ! (" " . to_string ()) } } } ; println ! ("" . to_string ()) } } } }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpP8akSq/main.rs:1:76
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Pattern:" . to_string ()) ; for row in 0i32 .. 3i32 { { for col in 0i32 .....
  |                                                                            ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpP8akSq/main.rs:1:195
  |
1 | ... { if row + col % 2i32 == 0i32 { { print ! ("*" . to_string ()) } } else { { print ! (" " . to_string ()) } } } } ; println ! ("" . to...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpP8akSq/main.rs:1:237
  |
1 | ... ("*" . to_string ()) } } else { { print ! (" " . to_string ()) } } } } ; println ! ("" . to_string ()) } } } }
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpP8akSq/main.rs:1:277
  |
1 | ... ! (" " . to_string ()) } } } } ; println ! ("" . to_string ()) } } } }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 12 previous errors; 4 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `start` in this scope
 --> /tmp/.tmpbqnroG/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{}" , variable) } } ; if let S...
  |                                                                               ^^^^^ not found in this scope

error[E0425]: cannot find value `end` in this scope
 --> /tmp/.tmpbqnroG/main.rs:1:88
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{}" , variable) } } ; if let S...
  |                                                                                        ^^^ not found in this scope
  |
help: you might have meant to write `.` instead of `..`
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{}" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for variable in start.end { { println ! ("{}" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpbqnroG/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{}" , variable) } } ; if let S...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpbqnroG/main.rs:1:94
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{}" , variable) } } ; if let S...
  |                                                                                              ^^                           ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{}" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { println ! ("{}" , variable) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error: aborting due to 2 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `initial_value` in this scope
 --> /tmp/.tmpuEBIHI/main.rs:1:87
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut accumulator = initial_value ; let mut counter = start ; while cou...
  |                                                                                       ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `start` in this scope
 --> /tmp/.tmpuEBIHI/main.rs:1:121
  |
1 | ...mut accumulator = initial_value ; let mut counter = start ; while counter <= end { { accumulator = update (accumulator , counter) ; co...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `end` in this scope
 --> /tmp/.tmpuEBIHI/main.rs:1:146
  |
1 | ...l_value ; let mut counter = start ; while counter <= end { { accumulator = update (accumulator , counter) ; counter = counter + 1i32 }...
  |                                                         ^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpuEBIHI/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut accumulator = initial_value ; let mut counter = start ; while cou...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `update` in this scope
 --> /tmp/.tmpuEBIHI/main.rs:1:168
  |
1 | ...er = start ; while counter <= end { { accumulator = update (accumulator , counter) ; counter = counter + 1i32 } } } ; if let Some (s) ...
  |                                                        ^^^^^^ not found in this scope

error: aborting due to 4 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `height` in this scope
 --> /tmp/.tmpfg4XYs/main.rs:1:84
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (out...
  |                                                                                    ^^^^^^ not found in this scope

error[E0425]: cannot find value `width` in this scope
 --> /tmp/.tmpfg4XYs/main.rs:1:116
  |
1 | ...or outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn s...
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpfg4XYs/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (out...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpfg4XYs/main.rs:1:93
  |
1 | ...ult = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as ...
  |                                        ^^                                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { for inner in 0i32 .. width { { process (outer , inner) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpfg4XYs/main.rs:1:124
  |
1 | ...r in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: a...
  |                                                         ^^                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { process (outer , inner) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `process` in this scope
 --> /tmp/.tmpfg4XYs/main.rs:1:126
  |
1 | ... 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :...
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 7 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpFB7CEJ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! ("{}" , r...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpFB7CEJ/main.rs:1:88
  |
1 | ...et result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! ("{}" , result) } } } ; if let Some (s) = (& result as &...
  |                                         ^^                                                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! ("{}" , result) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { let result = process (i) ; println ! ("{}" , result) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `process` in this scope
 --> /tmp/.tmpFB7CEJ/main.rs:1:105
  |
1 | ...result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! ("{}" , result) } } } ; if let Some (s) = (& result as & dy...
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 9 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `height` in this scope
 --> /tmp/.tmpNmkVN2/main.rs:1:82
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = ca...
  |                                                                                  ^^^^^^ not found in this scope

error[E0425]: cannot find value `width` in this scope
 --> /tmp/.tmpNmkVN2/main.rs:1:112
  |
1 | ... = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let...
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpNmkVN2/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = ca...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpNmkVN2/main.rs:1:91
  |
1 | ... in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) ...
  |                         ^^                                                                                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpNmkVN2/main.rs:1:120
  |
1 | ...eight { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result a...
  |                                         ^^                                                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { let value = calculate (row , col) ; display (value) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `calculate` in this scope
 --> /tmp/.tmpNmkVN2/main.rs:1:136
  |
1 | ...ht { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as &...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `display` in this scope
 --> /tmp/.tmpNmkVN2/main.rs:1:160
  |
1 | ..... width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any)...
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 4 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 10 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpBHto0t/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { c...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpBHto0t/main.rs:1:114
  |
1 | ... count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & dyn...
  |                                              ^^                                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { if condition (i) { { count = count + 1i32 } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpBHto0t/main.rs:1:135
  |
1 | ... 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & dyn std :: ...
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { count = count + 1i32 } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `condition` in this scope
 --> /tmp/.tmpBHto0t/main.rs:1:119
  |
1 | ...mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & ...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch19-00-real-world-projects example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch19-00-real-world-projects example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch19-00-real-world-projects example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch19-00-real-world-projects example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== conclusion example 2 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpusQQ53/main.rs:1:266
  |
1 | ...()) ; let mut add_one = | x | x + 1i32 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`
 --> /tmp/.tmpusQQ53/main.rs:1:182
  |
1 | ...e: " . to_string ()) ; let mut contents = fs :: read_to_string ("file.txt" . to_string ()) ; let mut add_one = | x | x + 1i32 } ; if l...
  |                                              ^^ use of unresolved module or unlinked crate `fs`
  |
  = help: you might be missing a crate named `fs`
help: consider importing this module
  |
1 + use std::fs;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpusQQ53/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut arr = vec ! [1i32 , 2i32 , 3i32] ; let mut name = input ("Enter n...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpusQQ53/main.rs:1:123
  |
1 | ...t arr = vec ! [1i32 , 2i32 , 3i32] ; let mut name = input ("Enter name: " . to_string ()) ; let mut contents = fs :: read_to_string ("...
  |                                                        ^^^^^ not found in this scope

error: aborting due to 3 previous errors; 1 warning emitted

Some errors have detailed explanations: E0425, E0433.
For more information about an error, try `rustc --explain E0425`.



=== ch11-00-advanced-patterns example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 12 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 3 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `xFF` in this scope
 --> /tmp/.tmpUJM9ct/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...
  |                                                                                ^^^ not found in this scope

error[E0425]: cannot find value `o77` in this scope
 --> /tmp/.tmpUJM9ct/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...
  |                                                                                             ^^^ not found in this scope

error[E0425]: cannot find value `b1010` in this scope
 --> /tmp/.tmpUJM9ct/main.rs:1:106
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...
  |                                                                                                          ^^^^^ not found in this scope

error[E0425]: cannot find value `_000_000` in this scope
 --> /tmp/.tmpUJM9ct/main.rs:1:121
  |
1 | ... ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f64 ; 2f64 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; i32 ; 3.14f64 ; ...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `e6` in this scope
 --> /tmp/.tmpUJM9ct/main.rs:1:156
  |
1 | ...2 ; b1010 ; 1i32 ; _000_000 ; 3.14f64 ; 2f64 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; i32 ; 3.14f64 ; f64 ; 100i32 ; u8 } ; if let Som...
  |                                                          ^^ not found in this scope

error[E0423]: expected value, found builtin type `i32`
 --> /tmp/.tmpUJM9ct/main.rs:1:188
  |
1 | ... ; 3.14f64 ; 2f64 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; i32 ; 3.14f64 ; f64 ; 100i32 ; u8 } ; if let Some (s) = (& result as & dyn ...
  |                                                               ^^^ not a value

error[E0423]: expected value, found builtin type `f64`
 --> /tmp/.tmpUJM9ct/main.rs:1:204
  |
1 | ...4 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; i32 ; 3.14f64 ; f64 ; 100i32 ; u8 } ; if let Some (s) = (& result as & dyn std :: any :: An...
  |                                                               ^^^ not a value

error[E0423]: expected value, found builtin type `u8`
 --> /tmp/.tmpUJM9ct/main.rs:1:219
  |
1 | ...; 0.00000000015f64 ; 42i32 ; i32 ; 3.14f64 ; f64 ; 100i32 ; u8 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_...
  |                                                                ^^ not a value

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpUJM9ct/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 8 previous errors; 1 warning emitted

Some errors have detailed explanations: E0423, E0425.
For more information about an error, try `rustc --explain E0423`.



=== appendix-b-syntax-reference example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 6 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found `let` statement
 --> /tmp/.tmpYolxRE/main.rs:1:275
  |
1 | ...147483648i64 ; let mut uint = 4294967295i64 ; let mut long = - ! let mut ulong = ! let mut size = - 1i32 ; let mut usize = 1i32 ; let ...
  |                                                                     ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

error: expected expression, found `let` statement
 --> /tmp/.tmpYolxRE/main.rs:1:293
  |
1 | ... mut uint = 4294967295i64 ; let mut long = - ! let mut ulong = ! let mut size = - 1i32 ; let mut usize = 1i32 ; let mut single = 3.14f...
  |                                                                     ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpYolxRE/main.rs:1:469
  |
1 | ...xt = "hello" ; let mut owned = "world" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpYolxRE/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut flag = true ; let mut small = - 128i32 ; let mut byte = 255i32 ; ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 3 previous errors; 1 warning emitted




=== appendix-b-syntax-reference example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 11 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `value` in this scope
 --> /tmp/.tmprqJ21a/main.rs:1:71
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { match value { 0i32 => "zero" , 1i32 | 2i32 => "one or two" , 3i32 ..= 10i...
  |                                                                       ^^^^^ not found in this scope

error[E0425]: cannot find value `point` in this scope
 --> /tmp/.tmprqJ21a/main.rs:1:234
  |
1 | ...=> "big number" , _ => "something else" , } ; match point { Point { x : 0i32 , y : 0i32 } => "origin" , Point { x , y : 0i32 } => form...
  |                                                        ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmprqJ21a/main.rs:1:242
  |
1 | ...number" , _ => "something else" , } ; match point { Point { x : 0i32 , y : 0i32 } => "origin" , Point { x , y : 0i32 } => format ! ("{...
  |                                                        ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmprqJ21a/main.rs:1:286
  |
1 | ...point { Point { x : 0i32 , y : 0i32 } => "origin" , Point { x , y : 0i32 } => format ! ("{}{}" , format ! ("{}{}" , "on x-axis at " , ...
  |                                                        ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmprqJ21a/main.rs:1:390
  |
1 | ...! ("{}{}" , "on x-axis at " , x . to_s ()) , ",") , Point { x : 0i32 , y } => format ! ("{}{}" , format ! ("{}{}" , "on y-axis at " , ...
  |                                                        ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmprqJ21a/main.rs:1:494
  |
1 | ...! ("{}{}" , "on y-axis at " , y . to_s ()) , ",") , Point { x , y } => format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "point...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `number` in this scope
 --> /tmp/.tmprqJ21a/main.rs:1:639
  |
1 | .... to_s ()) , ", ") + y . to_s () , ")") , } ; match number { n if n < 0i32 => "negative" , n if n > 0i32 => "positive" , _ => "zero" ,...
  |                                                        ^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmprqJ21a/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { match value { 0i32 => "zero" , 1i32 | 2i32 => "one or two" , 3i32 ..= 10i...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0308]: `match` arms have incompatible types
 --> /tmp/.tmprqJ21a/main.rs:1:312
  |
1 | ... ; match point { Point { x : 0i32 , y : 0i32 } => "origin" , Point { x , y : 0i32 } => format ! ("{}{}" , format ! ("{}{}" , "on x-axis at " , x . to_s ()) , ",") , ...
  |       -----------                                    --------                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `String`
  |       |                                              |
  |       |                                              this is found to be of type `&str`
  |       `match` arms have incompatible types
  |
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 8 previous errors; 1 warning emitted

Some errors have detailed explanations: E0308, E0422, E0425.
For more information about an error, try `rustc --explain E0308`.



=== appendix-b-syntax-reference example 12 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 13 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 14 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 15 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 16 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 17 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 18 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 19 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 20 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 21 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 22 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 23 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 24 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 25 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 26 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 27 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 28 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 29 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 30 ===
✗ Compilation failed: Failed to transpile to Rust


=== appendix-b-syntax-reference example 31 ===
✗ Compilation failed: Failed to transpile to Rust


=== appendix-b-syntax-reference example 32 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 33 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 34 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 35 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-input-output-tdd example 1 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmp75gbMg/main.rs:1:85
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("=== Output Demo ===" . to_string ()) ; println ! ("Number: " . to_string (...
  |                                                                                     ^ expected `,`

error: argument never used
 --> /tmp/.tmp75gbMg/main.rs:1:87
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("=== Output Demo ===" . to_string ()) ; println ! ("Number: " . to_string (...
  |                                                               ---------------------   ^^^^^^^^^^^^ argument never used
  |                                                               |
  |                                                               formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmp75gbMg/main.rs:1:125
  |
1 | ...== Output Demo ===" . to_string ()) ; println ! ("Number: " . to_string ()) ; println ! ("{}" , 42i32) ; println ! ("Boolean: " . to_s...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmp75gbMg/main.rs:1:127
  |
1 | ...tput Demo ===" . to_string ()) ; println ! ("Number: " . to_string ()) ; println ! ("{}" , 42i32) ; println ! ("Boolean: " . to_string...
  |                                                ----------   ^^^^^^^^^^^^ argument never used
  |                                                |
  |                                                formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmp75gbMg/main.rs:1:193
  |
1 | ...ing ()) ; println ! ("{}" , 42i32) ; println ! ("Boolean: " . to_string ()) ; println ! ("{}" , true) ; println ! ("=== End Demo ===" ...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmp75gbMg/main.rs:1:195
  |
1 | ...()) ; println ! ("{}" , 42i32) ; println ! ("Boolean: " . to_string ()) ; println ! ("{}" , true) ; println ! ("=== End Demo ===" . to...
  |                                                -----------   ^^^^^^^^^^^^ argument never used
  |                                                |
  |                                                formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmp75gbMg/main.rs:1:267
  |
1 | ...) ; println ! ("{}" , true) ; println ! ("=== End Demo ===" . to_string ()) } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmp75gbMg/main.rs:1:269
  |
1 | ... ; println ! ("{}" , true) ; println ! ("=== End Demo ===" . to_string ()) } }
  |                                            ------------------   ^^^^^^^^^^^^ argument never used
  |                                            |
  |                                            formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp75gbMg/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("=== Output Demo ===" . to_string ()) ; println ! ("Number: " . to_string (...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmp75gbMg/main.rs:1:87
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("=== Output Demo ===" . to_string ()) ; println ! ("Number: " . to_string (...
  |                                                                                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmp75gbMg/main.rs:1:127
  |
1 | ...mo ===" . to_string ()) ; println ! ("Number: " . to_string ()) ; println ! ("{}" , 42i32) ; println ! ("Boolean: " . to_string ()) ; ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmp75gbMg/main.rs:1:195
  |
1 | ...intln ! ("{}" , 42i32) ; println ! ("Boolean: " . to_string ()) ; println ! ("{}" , true) ; println ! ("=== End Demo ===" . to_string ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmp75gbMg/main.rs:1:269
  |
1 | ...! ("{}" , true) ; println ! ("=== End Demo ===" . to_string ()) } }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 12 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch10-00-input-output-tdd example 2 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpDOHD9Z/main.rs:1:159
  |
1 | ...let mut height = 5.6f64 ; println ! ("=== User Profile ===" . to_string ()) ; println ! ("Name:" . to_string ()) ; println ! ("{}" , n...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpDOHD9Z/main.rs:1:161
  |
1 | ... let mut height = 5.6f64 ; println ! ("=== User Profile ===" . to_string ()) ; println ! ("Name:" . to_string ()) ; println ! ("{}" , ...
  |                                          ----------------------   ^^^^^^^^^^^^ argument never used
  |                                          |
  |                                          formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpDOHD9Z/main.rs:1:196
  |
1 | ..."=== User Profile ===" . to_string ()) ; println ! ("Name:" . to_string ()) ; println ! ("{}" , name) ; println ! ("Age:" . to_string ...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpDOHD9Z/main.rs:1:198
  |
1 | ...ser Profile ===" . to_string ()) ; println ! ("Name:" . to_string ()) ; println ! ("{}" , name) ; println ! ("Age:" . to_string ()) ; ...
  |                                                  -------   ^^^^^^^^^^^^ argument never used
  |                                                  |
  |                                                  formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpDOHD9Z/main.rs:1:258
  |
1 | ...to_string ()) ; println ! ("{}" , name) ; println ! ("Age:" . to_string ()) ; println ! ("{}" , age) ; println ! ("Height:" . to_strin...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpDOHD9Z/main.rs:1:260
  |
1 | ...ng ()) ; println ! ("{}" , name) ; println ! ("Age:" . to_string ()) ; println ! ("{}" , age) ; println ! ("Height:" . to_string ()) ;...
  |                                                  ------   ^^^^^^^^^^^^ argument never used
  |                                                  |
  |                                                  formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpDOHD9Z/main.rs:1:322
  |
1 | ..._string ()) ; println ! ("{}" , age) ; println ! ("Height:" . to_string ()) ; println ! ("{}" , height) ; println ! ("================...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpDOHD9Z/main.rs:1:324
  |
1 | ...ng ()) ; println ! ("{}" , age) ; println ! ("Height:" . to_string ()) ; println ! ("{}" , height) ; println ! ("================" . t...
  |                                                 ---------   ^^^^^^^^^^^^ argument never used
  |                                                 |
  |                                                 formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpDOHD9Z/main.rs:1:398
  |
1 | ...; println ! ("{}" , height) ; println ! ("================" . to_string ()) } } } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpDOHD9Z/main.rs:1:400
  |
1 | ... println ! ("{}" , height) ; println ! ("================" . to_string ()) } } } }
  |                                            ------------------   ^^^^^^^^^^^^ argument never used
  |                                            |
  |                                            formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpDOHD9Z/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let name = "Alice" ; { let mut age = 30i32 ; let mut height = 5.6f64 ; println ! ("=...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpDOHD9Z/main.rs:1:50
  |
1 | ... { { { let name = "Alice" ; { let mut age = 30i32 ; let mut height = 5.6f64 ; println ! ("=== User Profile ===" . to_string ()) ; println ! ("Name:" . to_string ()) ; println ! ("{}" , name) ; println ! ("Age:" . to_string ()) ; println ! ("{}" , age) ; println ! ("Height:" . to_string ()) ; println ! ("{}" , height) ; println ! ("================" . to_string ()) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let name = "Alice" ; { let mut age = 30i32 ; let mut height = 5.6f64 ; println ! ("=== User Profile ===" . to_string ()) ; println ! ("Name:" . to_string ()) ; println ! ("{}" , name) ; println ! ("Age:" . to_string ()) ; println ! ("{}" , age) ; println ! ("Height:" . to_string ()) ; println ! ("{}" , height) ; println ! ("================" . to_string ()) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let name = "Alice" ; { let mut age = 30i32 ; let mut height = 5.6f64 ; println ! ("=== User Profile ===" . to_string ()) ; println ! ("Name:" . to_string ()) ; println ! ("{}" , name) ; println ! ("Age:" . to_string ()) ; println ! ("{}" , age) ; println ! ("Height:" . to_string ()) ; println ! ("{}" , height) ; println ! ("================" . to_string ()) } } }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpDOHD9Z/main.rs:1:161
  |
1 | ...ht = 5.6f64 ; println ! ("=== User Profile ===" . to_string ()) ; println ! ("Name:" . to_string ()) ; println ! ("{}" , name) ; print...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpDOHD9Z/main.rs:1:198
  |
1 | ...ofile ===" . to_string ()) ; println ! ("Name:" . to_string ()) ; println ! ("{}" , name) ; println ! ("Age:" . to_string ()) ; printl...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpDOHD9Z/main.rs:1:260
  |
1 | ...) ; println ! ("{}" , name) ; println ! ("Age:" . to_string ()) ; println ! ("{}" , age) ; println ! ("Height:" . to_string ()) ; prin...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpDOHD9Z/main.rs:1:324
  |
1 | ...; println ! ("{}" , age) ; println ! ("Height:" . to_string ()) ; println ! ("{}" , height) ; println ! ("================" . to_strin...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpDOHD9Z/main.rs:1:400
  |
1 | ...("{}" , height) ; println ! ("================" . to_string ()) } } } }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 15 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch10-00-input-output-tdd example 3 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpsRcBvc/main.rs:1:91
  |
1 | use std :: collections :: HashMap ; fn display_menu () { { println ! ("=== Main Menu ===" . to_string ()) ; println ! ("1. View Profile" ...
  |                                                                                           ^ expected `,`

error: argument never used
 --> /tmp/.tmpsRcBvc/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn display_menu () { { println ! ("=== Main Menu ===" . to_string ()) ; println ! ("1. View Profile" ...
  |                                                                       -------------------   ^^^^^^^^^^^^ argument never used
  |                                                                       |
  |                                                                       formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpsRcBvc/main.rs:1:138
  |
1 | ...in Menu ===" . to_string ()) ; println ! ("1. View Profile" . to_string ()) ; println ! ("2. Settings" . to_string ()) ; println ! ("3...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpsRcBvc/main.rs:1:140
  |
1 | ...n Menu ===" . to_string ()) ; println ! ("1. View Profile" . to_string ()) ; println ! ("2. Settings" . to_string ()) ; println ! ("3....
  |                                             -----------------   ^^^^^^^^^^^^ argument never used
  |                                             |
  |                                             formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpsRcBvc/main.rs:1:181
  |
1 | ...1. View Profile" . to_string ()) ; println ! ("2. Settings" . to_string ()) ; println ! ("3. Exit" . to_string ()) ; println ! ("=====...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpsRcBvc/main.rs:1:183
  |
1 | ...View Profile" . to_string ()) ; println ! ("2. Settings" . to_string ()) ; println ! ("3. Exit" . to_string ()) ; println ! ("========...
  |                                               -------------   ^^^^^^^^^^^^ argument never used
  |                                               |
  |                                               formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpsRcBvc/main.rs:1:220
  |
1 | ...tln ! ("2. Settings" . to_string ()) ; println ! ("3. Exit" . to_string ()) ; println ! ("=================" . to_string ()) } } fn ma...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpsRcBvc/main.rs:1:222
  |
1 | ... ("2. Settings" . to_string ()) ; println ! ("3. Exit" . to_string ()) ; println ! ("=================" . to_string ()) } } fn main ()...
  |                                                 ---------   ^^^^^^^^^^^^ argument never used
  |                                                 |
  |                                                 formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpsRcBvc/main.rs:1:269
  |
1 | ...("3. Exit" . to_string ()) ; println ! ("=================" . to_string ()) } } fn main () { { display_menu () ; println ! ("Menu disp...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpsRcBvc/main.rs:1:271
  |
1 | ...("3. Exit" . to_string ()) ; println ! ("=================" . to_string ()) } } fn main () { { display_menu () ; println ! ("Menu disp...
  |                                            -------------------   ^^^^^^^^^^^^ argument never used
  |                                            |
  |                                            formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpsRcBvc/main.rs:1:363
  |
1 | ... display_menu () ; println ! ("Menu displayed successfully" . to_string ()) } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpsRcBvc/main.rs:1:365
  |
1 | ...) { { display_menu () ; println ! ("Menu displayed successfully" . to_string ()) } }
  |                                       -----------------------------   ^^^^^^^^^^^^ argument never used
  |                                       |
  |                                       formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpsRcBvc/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn display_menu () { { println ! ("=== Main Menu ===" . to_string ()) ; println ! ("1. View Profile" ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpsRcBvc/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn display_menu () { { println ! ("=== Main Menu ===" . to_string ()) ; println ! ("1. View Profile" ...
  |                                                                                             ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpsRcBvc/main.rs:1:140
  |
1 | ... . to_string ()) ; println ! ("1. View Profile" . to_string ()) ; println ! ("2. Settings" . to_string ()) ; println ! ("3. Exit" . to...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpsRcBvc/main.rs:1:183
  |
1 | ...ile" . to_string ()) ; println ! ("2. Settings" . to_string ()) ; println ! ("3. Exit" . to_string ()) ; println ! ("=================...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpsRcBvc/main.rs:1:222
  |
1 | ...ettings" . to_string ()) ; println ! ("3. Exit" . to_string ()) ; println ! ("=================" . to_string ()) } } fn main () { { di...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpsRcBvc/main.rs:1:271
  |
1 | ... to_string ()) ; println ! ("=================" . to_string ()) } } fn main () { { display_menu () ; println ! ("Menu displayed succes...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpsRcBvc/main.rs:1:365
  |
1 | ...u () ; println ! ("Menu displayed successfully" . to_string ()) } }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 18 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch10-00-input-output-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmp9JE0uX/main.rs:1:91
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("text message" . to_string ()) ; println ! ("{}" , variable) ;...
  |                                                                                           ^ expected `,`

error: argument never used
 --> /tmp/.tmp9JE0uX/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("text message" . to_string ()) ; println ! ("{}" , variable) ;...
  |                                                                            --------------   ^^^^^^^^^^^^ argument never used
  |                                                                            |
  |                                                                            formatting specifier missing

error[E0425]: cannot find value `variable` in this scope
 --> /tmp/.tmp9JE0uX/main.rs:1:127
  |
1 | ..."text message" . to_string ()) ; println ! ("{}" , variable) ; println ! ("{}" , 42i32) ; println ! ("{}" , true) } ; if let Some (s) ...
  |                                                       ^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp9JE0uX/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("text message" . to_string ()) ; println ! ("{}" , variable) ;...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmp9JE0uX/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("text message" . to_string ()) ; println ! ("{}" , variable) ;...
  |                                                                                             ^^^^^^^^^ not found in this scope

error: aborting due to 4 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch10-00-input-output-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpM1sfqJ/main.rs:1:108
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut data = value ; println ! ("Label:" . to_string ()) ; println ! ("...
  |                                                                                                            ^ expected `,`

error: argument never used
 --> /tmp/.tmpM1sfqJ/main.rs:1:110
  |
1 | ...result = { let mut data = value ; println ! ("Label:" . to_string ()) ; println ! ("{}" , data) } ; if let Some (s) = (& result as & d...
  |                                                 --------   ^^^^^^^^^^^^ argument never used
  |                                                 |
  |                                                 formatting specifier missing

error[E0425]: cannot find value `value` in this scope
 --> /tmp/.tmpM1sfqJ/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut data = value ; println ! ("Label:" . to_string ()) ; println ! ("...
  |                                                                                ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpM1sfqJ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut data = value ; println ! ("Label:" . to_string ()) ; println ! ("...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpM1sfqJ/main.rs:1:110
  |
1 | ... = { let mut data = value ; println ! ("Label:" . to_string ()) ; println ! ("{}" , data) } ; if let Some (s) = (& result as & dyn std...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 4 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch10-00-input-output-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmptMSVr7/main.rs:1:89
  |
1 | use std :: collections :: HashMap ; fn display_options () { { println ! ("=== Menu ===" . to_string ()) ; println ! ("1. Option One" . to...
  |                                                                                         ^ expected `,`

error: argument never used
 --> /tmp/.tmptMSVr7/main.rs:1:91
  |
1 | use std :: collections :: HashMap ; fn display_options () { { println ! ("=== Menu ===" . to_string ()) ; println ! ("1. Option One" . to...
  |                                                                          --------------   ^^^^^^^^^^^^ argument never used
  |                                                                          |
  |                                                                          formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmptMSVr7/main.rs:1:134
  |
1 | ..."=== Menu ===" . to_string ()) ; println ! ("1. Option One" . to_string ()) ; println ! ("2. Option Two" . to_string ()) ; println ! (...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmptMSVr7/main.rs:1:136
  |
1 | ...== Menu ===" . to_string ()) ; println ! ("1. Option One" . to_string ()) ; println ! ("2. Option Two" . to_string ()) ; println ! ("=...
  |                                              ---------------   ^^^^^^^^^^^^ argument never used
  |                                              |
  |                                              formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmptMSVr7/main.rs:1:179
  |
1 | ...1. Option One" . to_string ()) ; println ! ("2. Option Two" . to_string ()) ; println ! ("============" . to_string ()) } } fn main ()...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmptMSVr7/main.rs:1:181
  |
1 | ... Option One" . to_string ()) ; println ! ("2. Option Two" . to_string ()) ; println ! ("============" . to_string ()) } } fn main () { }
  |                                              ---------------   ^^^^^^^^^^^^ argument never used
  |                                              |
  |                                              formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmptMSVr7/main.rs:1:223
  |
1 | ..."2. Option Two" . to_string ()) ; println ! ("============" . to_string ()) } } fn main () { }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmptMSVr7/main.rs:1:225
  |
1 | ... Option Two" . to_string ()) ; println ! ("============" . to_string ()) } } fn main () { }
  |                                              --------------   ^^^^^^^^^^^^ argument never used
  |                                              |
  |                                              formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmptMSVr7/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn display_options () { { println ! ("=== Menu ===" . to_string ()) ; println ! ("1. Option One" . to...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmptMSVr7/main.rs:1:91
  |
1 | use std :: collections :: HashMap ; fn display_options () { { println ! ("=== Menu ===" . to_string ()) ; println ! ("1. Option One" . to...
  |                                                                                           ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmptMSVr7/main.rs:1:136
  |
1 | ...=" . to_string ()) ; println ! ("1. Option One" . to_string ()) ; println ! ("2. Option Two" . to_string ()) ; println ! ("===========...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmptMSVr7/main.rs:1:181
  |
1 | ...e" . to_string ()) ; println ! ("2. Option Two" . to_string ()) ; println ! ("============" . to_string ()) } } fn main () { }
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmptMSVr7/main.rs:1:225
  |
1 | ...wo" . to_string ()) ; println ! ("============" . to_string ()) } } fn main () { }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 12 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch10-00-input-output-tdd example 7 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpiVP56x/main.rs:1:111
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut value = 100i32 ; println ! ("Result:" . to_string ()) ; println !...
  |                                                                                                               ^ expected `,`

error: argument never used
 --> /tmp/.tmpiVP56x/main.rs:1:113
  |
1 | ...sult = { let mut value = 100i32 ; println ! ("Result:" . to_string ()) ; println ! ("{}" , value) } ; if let Some (s) = (& result as &...
  |                                                 ---------   ^^^^^^^^^^^^ argument never used
  |                                                 |
  |                                                 formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpiVP56x/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut value = 100i32 ; println ! ("Result:" . to_string ()) ; println !...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpiVP56x/main.rs:1:113
  |
1 | ...{ let mut value = 100i32 ; println ! ("Result:" . to_string ()) ; println ! ("{}" , value) } ; if let Some (s) = (& result as & dyn st...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch10-00-input-output-tdd example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-input-output-tdd example 9 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmptwVrEc/main.rs:1:92
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("Processing..." . to_string ()) ; println ! ("Complete!" . to_...
  |                                                                                            ^ expected `,`

error: argument never used
 --> /tmp/.tmptwVrEc/main.rs:1:94
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("Processing..." . to_string ()) ; println ! ("Complete!" . to_...
  |                                                                            ---------------   ^^^^^^^^^^^^ argument never used
  |                                                                            |
  |                                                                            formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmptwVrEc/main.rs:1:133
  |
1 | ...! ("Processing..." . to_string ()) ; println ! ("Complete!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmptwVrEc/main.rs:1:135
  |
1 | ...Processing..." . to_string ()) ; println ! ("Complete!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . ...
  |                                                -----------   ^^^^^^^^^^^^ argument never used
  |                                                |
  |                                                formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmptwVrEc/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("Processing..." . to_string ()) ; println ! ("Complete!" . to_...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmptwVrEc/main.rs:1:94
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("Processing..." . to_string ()) ; println ! ("Complete!" . to_...
  |                                                                                              ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmptwVrEc/main.rs:1:135
  |
1 | ...ng..." . to_string ()) ; println ! ("Complete!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 6 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch10-00-input-output-tdd example 10 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpRZ4hVH/main.rs:1:91
  |
1 | use std :: collections :: HashMap ; fn show_options () { { println ! ("Choose an option:" . to_string ()) ; println ! ("1. Start" . to_st...
  |                                                                                           ^ expected `,`

error: argument never used
 --> /tmp/.tmpRZ4hVH/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn show_options () { { println ! ("Choose an option:" . to_string ()) ; println ! ("1. Start" . to_st...
  |                                                                       -------------------   ^^^^^^^^^^^^ argument never used
  |                                                                       |
  |                                                                       formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpRZ4hVH/main.rs:1:131
  |
1 | ..."Choose an option:" . to_string ()) ; println ! ("1. Start" . to_string ()) ; println ! ("2. Stop" . to_string ()) ; println ! ("3. He...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpRZ4hVH/main.rs:1:133
  |
1 | ...se an option:" . to_string ()) ; println ! ("1. Start" . to_string ()) ; println ! ("2. Stop" . to_string ()) ; println ! ("3. Help" ....
  |                                                ----------   ^^^^^^^^^^^^ argument never used
  |                                                |
  |                                                formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpRZ4hVH/main.rs:1:170
  |
1 | ...rintln ! ("1. Start" . to_string ()) ; println ! ("2. Stop" . to_string ()) ; println ! ("3. Help" . to_string ()) } } fn main () { }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpRZ4hVH/main.rs:1:172
  |
1 | ...n ! ("1. Start" . to_string ()) ; println ! ("2. Stop" . to_string ()) ; println ! ("3. Help" . to_string ()) } } fn main () { }
  |                                                 ---------   ^^^^^^^^^^^^ argument never used
  |                                                 |
  |                                                 formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpRZ4hVH/main.rs:1:209
  |
1 | ...println ! ("2. Stop" . to_string ()) ; println ! ("3. Help" . to_string ()) } } fn main () { }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpRZ4hVH/main.rs:1:211
  |
1 | ...ln ! ("2. Stop" . to_string ()) ; println ! ("3. Help" . to_string ()) } } fn main () { }
  |                                                 ---------   ^^^^^^^^^^^^ argument never used
  |                                                 |
  |                                                 formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpRZ4hVH/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn show_options () { { println ! ("Choose an option:" . to_string ()) ; println ! ("1. Start" . to_st...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpRZ4hVH/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn show_options () { { println ! ("Choose an option:" . to_string ()) ; println ! ("1. Start" . to_st...
  |                                                                                             ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpRZ4hVH/main.rs:1:133
  |
1 | ...ption:" . to_string ()) ; println ! ("1. Start" . to_string ()) ; println ! ("2. Stop" . to_string ()) ; println ! ("3. Help" . to_str...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpRZ4hVH/main.rs:1:172
  |
1 | .... Start" . to_string ()) ; println ! ("2. Stop" . to_string ()) ; println ! ("3. Help" . to_string ()) } } fn main () { }
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpRZ4hVH/main.rs:1:211
  |
1 | ...2. Stop" . to_string ()) ; println ! ("3. Help" . to_string ()) } } fn main () { }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 12 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch18-00-deployment-devops example 1 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpFHjjC0/main.rs:1:637
  |
1 | ...loyment . commit () ; println ! ("✅ Deployment successful!" . to_string ()) } } else { { deployment . rollback () ; println ! ("⚠\u{fe0...
  |                                                                 ^ expected `,`

error: argument never used
 --> /tmp/.tmpFHjjC0/main.rs:1:639
  |
1 | ...deployment . commit () ; println ! ("✅ Deployment successful!" . to_string ()) } } else { { deployment . rollback () ; println ! ("⚠\u{...
  |                                        ---------------------------   ^^^^^^^^^^^^ argument never used
  |                                        |
  |                                        formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpFHjjC0/main.rs:1:749
  |
1 | ...) ; println ! ("⚠\u{fe0f}  Rolled back to previous version" . to_string ()) } } } ; if let Some (s) = (& result as & dyn std :: any ::...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpFHjjC0/main.rs:1:751
  |
1 | .... rollback () ; println ! ("⚠\u{fe0f}  Rolled back to previous version" . to_string ()) } } } ; if let Some (s) = (& result as & dyn s...
  |                               --------------------------------------------   ^^^^^^^^^^^^ argument never used
  |                               |
  |                               formatting specifier missing

error[E0432]: unresolved import `std::deploy`
 --> /tmp/.tmpFHjjC0/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: deploy ; ; let mut config = DeployConfig { app : "my-app" . to...
  |                                                                     ^^^^^^^^^^^^^ no `deploy` in the root

error[E0422]: cannot find struct, variant or union type `DeployConfig` in this scope
 --> /tmp/.tmpFHjjC0/main.rs:1:104
  |
1 | ...esult = { use std :: deploy ; ; let mut config = DeployConfig { app : "my-app" . to_string () , environment : env :: var ("DEPLOY_ENV"...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `env`
 --> /tmp/.tmpFHjjC0/main.rs:1:165
  |
1 | ... "my-app" . to_string () , environment : env :: var ("DEPLOY_ENV" . to_string ()) , strategy : BlueGreen , health_check : "/health" . ...
  |                                             ^^^ use of unresolved module or unlinked crate `env`
  |
  = help: you might be missing a crate named `env`
help: consider importing this module
  |
1 + use std::env;
  |

error[E0425]: cannot find value `BlueGreen` in this scope
 --> /tmp/.tmpFHjjC0/main.rs:1:219
  |
1 | ...:: var ("DEPLOY_ENV" . to_string ()) , strategy : BlueGreen , health_check : "/health" . to_string () , rollback_on_failure : true , }...
  |                                                      ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpFHjjC0/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: deploy ; ; let mut config = DeployConfig { app : "my-app" . to...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpFHjjC0/main.rs:1:85
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: deploy ; ; let mut config = DeployConfig { app : "my-app" . to...
  |                                                                                     ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpFHjjC0/main.rs:1:639
  |
1 | ...mmit () ; println ! ("✅ Deployment successful!" . to_string ()) } } else { { deployment . rollback () ; println ! ("⚠\u{fe0f}  Rolled b...
  |                                                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpFHjjC0/main.rs:1:751
  |
1 | ...! ("⚠\u{fe0f}  Rolled back to previous version" . to_string ()) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . down...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 10 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0422, E0425, E0432, E0433.
For more information about an error, try `rustc --explain E0422`.



=== ch18-00-deployment-devops example 2 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch18-00-deployment-devops example 3 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch18-00-deployment-devops example 4 ===
✗ Compilation failed: Compilation failed:
error[E0432]: unresolved import `feature_flags`
 --> /tmp/.tmpAbVA7O/main.rs:1:69
  |
1 | ...n main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ("api_key" . to_string ()) ; let m...
  |                                   ^^^^^^^^^^^^^ use of unresolved module or unlinked crate `feature_flags`
  |
help: you might be missing a crate named `feature_flags`, add it to your project and import it in your code
  |
1 + extern crate feature_flags;
  |

error[E0425]: cannot find value `user` in this scope
 --> /tmp/.tmpAbVA7O/main.rs:1:456
  |
1 | ...) , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percen...
  |                                                         ^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpAbVA7O/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpAbVA7O/main.rs:1:106
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ...
  |                                                                                                          ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpAbVA7O/main.rs:1:464
  |
1 | ...ue)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage i...
  |                                                           ^^                    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ("api_key" . to_string ()) ; let mut new_algorithm = Flag :: new ("new-algorithm" . to_string ()) . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new ("beta_users" . to_string () , true) , Rule :: new ("internal_users" . to_string () , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ("api_key" . to_string ()) ; let mut new_algorithm = Flag :: new ("new-algorithm" . to_string ()) . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new ("beta_users" . to_string () , true) , Rule :: new ("internal_users" . to_string () , true)]) ; if flags . is_enabled (new_algorithm , user) { use_new_algorithm () } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpAbVA7O/main.rs:1:498
  |
1 | ..._algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 7...
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ("api_key" . to_string ()) ; let mut new_algorithm = Flag :: new ("new-algorithm" . to_string ()) . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new ("beta_users" . to_string () , true) , Rule :: new ("internal_users" . to_string () , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ("api_key" . to_string ()) ; let mut new_algorithm = Flag :: new ("new-algorithm" . to_string ()) . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new ("beta_users" . to_string () , true) , Rule :: new ("internal_users" . to_string () , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { use_old_algorithm () } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0433]: failed to resolve: use of undeclared type `Rule`
 --> /tmp/.tmpAbVA7O/main.rs:1:309
  |
1 | ...lout_percentage (10i32) . targeting_rules (vec ! [Rule :: new ("beta_users" . to_string () , true) , Rule :: new ("internal_users" . t...
  |                                                      ^^^^ use of undeclared type `Rule`

error[E0433]: failed to resolve: use of undeclared type `Rule`
 --> /tmp/.tmpAbVA7O/main.rs:1:360
  |
1 | ...ule :: new ("beta_users" . to_string () , true) , Rule :: new ("internal_users" . to_string () , true)]) ; if flags . is_enabled (new_...
  |                                                      ^^^^ use of undeclared type `Rule`

error[E0425]: cannot find function `use_new_algorithm` in this scope
 --> /tmp/.tmpAbVA7O/main.rs:1:466
  |
1 | ...ew_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 ,...
  |                             ^^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists: `new_algorithm`

error[E0425]: cannot find function `use_old_algorithm` in this scope
 --> /tmp/.tmpAbVA7O/main.rs:1:500
  |
1 | ..., user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `monitor_metrics` in this scope
 --> /tmp/.tmpAbVA7O/main.rs:1:647
  |
1 | ...s . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `metrics_degraded` in this scope
 --> /tmp/.tmpAbVA7O/main.rs:1:671
  |
1 | ...orithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 8 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0425, E0432, E0433.
For more information about an error, try `rustc --explain E0425`.



=== ch18-00-deployment-devops example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch18-00-deployment-devops example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch18-00-deployment-devops example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch18-00-deployment-devops example 8 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch01-03-interpreter-scripting example 1 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `ruchy` in this scope
 --> /tmp/.tmpGxBqwH/main.rs:1:65
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "2 + 2" } ; if let Some (s) = (& result as & dyn std :: any :...
  |                                                                 ^^^^^ not found in this scope

error[E0425]: cannot find value `e` in this scope
 --> /tmp/.tmpGxBqwH/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "2 + 2" } ; if let Some (s) = (& result as & dyn std :: any :...
  |                                                                         ^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpGxBqwH/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "2 + 2" } ; if let Some (s) = (& result as & dyn std :: any :...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 2 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `ruchy` in this scope
 --> /tmp/.tmpYwRSUa/main.rs:1:65
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let name = \"World\"; \"Hello \" + name + \"!\"" } ; if let ...
  |                                                                 ^^^^^ not found in this scope

error[E0425]: cannot find value `e` in this scope
 --> /tmp/.tmpYwRSUa/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let name = \"World\"; \"Hello \" + name + \"!\"" } ; if let ...
  |                                                                         ^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpYwRSUa/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let name = \"World\"; \"Hello \" + name + \"!\"" } ; if let ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 3 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `ruchy` in this scope
 --> /tmp/.tmpEjvJrU/main.rs:1:65
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let nums = [1, 2, 3]; nums[1]" } ; if let Some (s) = (& resu...
  |                                                                 ^^^^^ not found in this scope

error[E0425]: cannot find value `e` in this scope
 --> /tmp/.tmpEjvJrU/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let nums = [1, 2, 3]; nums[1]" } ; if let Some (s) = (& resu...
  |                                                                         ^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpEjvJrU/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let nums = [1, 2, 3]; nums[1]" } ; if let Some (s) = (& resu...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 4 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpzf5zcD/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let small_int = 42i32 ; { let mut result = small_int * 2i32 ; let mut pi = 3.14159f6...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpzf5zcD/main.rs:1:50
  |
1 | ... { { { let small_int = 42i32 ; { let mut result = small_int * 2i32 ; let mut pi = 3.14159f64 ; let mut area = pi * 5f64 * 5f64 ; let mut greeting = "Hello" ; let mut name = "Ruchy" ; let mut data = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32] ; println ! ("{}" , data [2i32]) } } } }
  |       ^^                                                                                                                                                                                                                                                                              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let small_int = 42i32 ; { let mut result = small_int * 2i32 ; let mut pi = 3.14159f64 ; let mut area = pi * 5f64 * 5f64 ; let mut greeting = "Hello" ; let mut name = "Ruchy" ; let mut data = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32] ; println ! ("{}" , data [2i32]) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let small_int = 42i32 ; { let mut result = small_int * 2i32 ; let mut pi = 3.14159f64 ; let mut area = pi * 5f64 * 5f64 ; let mut greeting = "Hello" ; let mut name = "Ruchy" ; let mut data = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32] ; println ! ("{}" , data [2i32]) } } }
  |

error[E0277]: the type `[i32]` cannot be indexed by `i32`
 --> /tmp/.tmpzf5zcD/main.rs:1:312
  |
1 | ...32 , 5i32] ; println ! ("{}" , data [2i32]) } } } }
  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`
  |
  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `Vec<i32>` to implement `Index<i32>`

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0277`.



=== ch01-03-interpreter-scripting example 5 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpazRDS3/main.rs:1:782
  |
1 | ...T { { if b == 0i32 { { println ! ("Error: Division by zero" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x =...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpazRDS3/main.rs:1:784
  |
1 | ...-> T { { if b == 0i32 { { println ! ("Error: Division by zero" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let ...
  |                                         -------------------------   ^^^^^^^^^^^^ argument never used
  |                                         |
  |                                         formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpazRDS3/main.rs:1:909
  |
1 | ...let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:" . to_string ()) ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpazRDS3/main.rs:1:911
  |
1 | ...x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:" . to_string ()) ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:" ....
  |                                                -----------   ^^^^^^^^^^^^ argument never used
  |                                                |
  |                                                formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpazRDS3/main.rs:1:986
  |
1 | ... println ! ("{}" , add (x , y)) ; println ! ("Subtraction:" . to_string ()) ; println ! ("{}" , subtract (x , y)) ; println ! ("Multip...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpazRDS3/main.rs:1:988
  |
1 | ...intln ! ("{}" , add (x , y)) ; println ! ("Subtraction:" . to_string ()) ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplic...
  |                                              --------------   ^^^^^^^^^^^^ argument never used
  |                                              |
  |                                              formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpazRDS3/main.rs:1:1071
  |
1 | ... ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:" . to_string ()) ; println ! ("{}" , multiply (x , y)) ; println ! ("Divisi...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpazRDS3/main.rs:1:1073
  |
1 | ...! ("{}" , subtract (x , y)) ; println ! ("Multiplication:" . to_string ()) ; println ! ("{}" , multiply (x , y)) ; println ! ("Divisio...
  |                                             -----------------   ^^^^^^^^^^^^ argument never used
  |                                             |
  |                                             formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpazRDS3/main.rs:1:1150
  |
1 | ...rintln ! ("{}" , multiply (x , y)) ; println ! ("Division:" . to_string ()) ; println ! ("{}" , divide (x , y)) } } } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpazRDS3/main.rs:1:1152
  |
1 | ...ln ! ("{}" , multiply (x , y)) ; println ! ("Division:" . to_string ()) ; println ! ("{}" , divide (x , y)) } } } }
  |                                                -----------   ^^^^^^^^^^^^ argument never used
  |                                                |
  |                                                formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpazRDS3/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Disp...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpazRDS3/main.rs:1:197
  |
1 | ...isplay + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ...
  |                                                                  ^^     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:" . to_string ()) ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:" . to_string ()) ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:" . to_string ()) ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:" . to_string ()) ; println ! ("{}" , divide (x , y)) } } } }
1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { a + b } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:" . to_string ()) ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:" . to_string ()) ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:" . to_string ()) ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:" . to_string ()) ; println ! ("{}" , divide (x , y)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpazRDS3/main.rs:1:374
  |
1 | ...isplay + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ...
  |                                                                  ^^     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:" . to_string ()) ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:" . to_string ()) ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:" . to_string ()) ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:" . to_string ()) ; println ! ("{}" , divide (x , y)) } } } }
1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { a - b } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:" . to_string ()) ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:" . to_string ()) ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:" . to_string ()) ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:" . to_string ()) ; println ! ("{}" , divide (x , y)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpazRDS3/main.rs:1:551
  |
1 | ...isplay + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: op...
  |                                                                  ^^     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:" . to_string ()) ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:" . to_string ()) ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:" . to_string ()) ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:" . to_string ()) ; println ! ("{}" , divide (x , y)) } } } }
1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { a * b } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:" . to_string ()) ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:" . to_string ()) ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:" . to_string ()) ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:" . to_string ()) ; println ! ("{}" , divide (x , y)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpazRDS3/main.rs:1:726
  |
1 | ... b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { ...
  |                   ^^                                                                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:" . to_string ()) ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:" . to_string ()) ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:" . to_string ()) ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:" . to_string ()) ; println ! ("{}" , divide (x , y)) } } } }
1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { if b == 0i32 { { println ! ("Error: Division by zero" . to_string ()) ; 0i32 } } else { { a / b } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:" . to_string ()) ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:" . to_string ()) ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:" . to_string ()) ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:" . to_string ()) ; println ! ("{}" , divide (x , y)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpazRDS3/main.rs:1:816
  |
1 | ... ("Error: Division by zero" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; pr...
  |                                                                  ^^     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:" . to_string ()) ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:" . to_string ()) ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:" . to_string ()) ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:" . to_string ()) ; println ! ("{}" , divide (x , y)) } } } }
1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero" . to_string ()) ; 0i32 } } else { a / b } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:" . to_string ()) ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:" . to_string ()) ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:" . to_string ()) ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:" . to_string ()) ; println ! ("{}" , divide (x , y)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpazRDS3/main.rs:1:845
  |
1 | ... { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:" . to_string ()) ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:" . to_string ()) ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:" . to_string ()) ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:" . to_string ()) ; println ! ("{}" , divide (x , y)) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:" . to_string ()) ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:" . to_string ()) ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:" . to_string ()) ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:" . to_string ()) ; println ! ("{}" , divide (x , y)) } } } }
1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:" . to_string ()) ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:" . to_string ()) ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:" . to_string ()) ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:" . to_string ()) ; println ! ("{}" , divide (x , y)) } } }
  |

error[E0369]: cannot subtract `T` from `T`
 --> /tmp/.tmpazRDS3/main.rs:1:378
  |
1 | ...splay + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: o...
  |                                                                   - ^ - T
  |                                                                   |
  |                                                                   T
  |
help: consider further restricting type parameter `T` with trait `Sub`
  |
1 | use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Sub<Output = T> > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:" . to_string ()) ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:" . to_string ()) ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:" . to_string ()) ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:" . to_string ()) ; println ! ("{}" , divide (x , y)) } } } }
  |                                                                                                                                                                                                                                                                                                                                                             +++++++++++++++++++++++++++

error[E0369]: binary operation `==` cannot be applied to type `T`
 --> /tmp/.tmpazRDS3/main.rs:1:733
  |
1 | ...+ std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero" . to_string ()) ; 0i32 ...
  |                                                                - ^^ ---- i32
  |                                                                |
  |                                                                T
  |
help: consider further restricting type parameter `T` with trait `PartialEq`
  |
1 | use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialEq<i32> > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:" . to_string ()) ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:" . to_string ()) ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:" . to_string ()) ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:" . to_string ()) ; println ! ("{}" , divide (x , y)) } } } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ++++++++++++++++++++++++++

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpazRDS3/main.rs:1:784
  |
1 | ...= 0i32 { { println ! ("Error: Division by zero" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { l...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpazRDS3/main.rs:1:800
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero" . to_string ()) ; 0i32 } ...
  |       - expected this type parameter                                                                                                                     - expected `T` because of return type                                         ^^^^ expected type parameter `T`, found `i32`
  |
  = note: expected type parameter `T`
                       found type `i32`
  = note: the caller chooses a type for `T` which can be different from `i32`

error[E0369]: cannot divide `T` by `T`
 --> /tmp/.tmpazRDS3/main.rs:1:820
  |
1 | ...("Error: Division by zero" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; pri...
  |                                                                   - ^ - T
  |                                                                   |
  |                                                                   T
  |
help: consider further restricting type parameter `T` with trait `Div`
  |
1 | use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Div<Output = T> > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! ("Addition:" . to_string ()) ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:" . to_string ()) ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:" . to_string ()) ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:" . to_string ()) ; println ! ("{}" , divide (x , y)) } } } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             +++++++++++++++++++++++++++

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpazRDS3/main.rs:1:911
  |
1 | ...2 ; { let mut y = 3i32 ; println ! ("Addition:" . to_string ()) ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:" . to_stri...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpazRDS3/main.rs:1:988
  |
1 | ..."{}" , add (x , y)) ; println ! ("Subtraction:" . to_string ()) ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:" ....
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpazRDS3/main.rs:1:1073
  |
1 | ...ubtract (x , y)) ; println ! ("Multiplication:" . to_string ()) ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:" . to_st...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpazRDS3/main.rs:1:1152
  |
1 | ...}" , multiply (x , y)) ; println ! ("Division:" . to_string ()) ; println ! ("{}" , divide (x , y)) } } } }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 19 previous errors; 7 warnings emitted

Some errors have detailed explanations: E0308, E0369, E0425.
For more information about an error, try `rustc --explain E0308`.



=== ch01-03-interpreter-scripting example 6 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpwuaEEK/main.rs:1:169
  |
1 | ... 6i32 , 7i32 , 8i32 , 9i32 , 10i32] ; { println ! ("First:" . to_string ()) ; println ! ("{}" , numbers [0i32]) ; println ! ("Last:" ....
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpwuaEEK/main.rs:1:171
  |
1 | ..., 7i32 , 8i32 , 9i32 , 10i32] ; { println ! ("First:" . to_string ()) ; println ! ("{}" , numbers [0i32]) ; println ! ("Last:" . to_st...
  |                                                 --------   ^^^^^^^^^^^^ argument never used
  |                                                 |
  |                                                 formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpwuaEEK/main.rs:1:242
  |
1 | ...)) ; println ! ("{}" , numbers [0i32]) ; println ! ("Last:" . to_string ()) ; println ! ("{}" , numbers [9i32]) ; let mut sum = 0i32 ;...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpwuaEEK/main.rs:1:244
  |
1 | ...rintln ! ("{}" , numbers [0i32]) ; println ! ("Last:" . to_string ()) ; println ! ("{}" , numbers [9i32]) ; let mut sum = 0i32 ; let m...
  |                                                  -------   ^^^^^^^^^^^^ argument never used
  |                                                  |
  |                                                  formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpwuaEEK/main.rs:1:419
  |
1 | ... = sum + numbers [i] ; i = i + 1i32 } } ; println ! ("Sum:" . to_string ()) ; println ! ("{}" , sum) ; let mut average = sum / 10i32 ;...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpwuaEEK/main.rs:1:421
  |
1 | ...+ numbers [i] ; i = i + 1i32 } } ; println ! ("Sum:" . to_string ()) ; println ! ("{}" , sum) ; let mut average = sum / 10i32 ; printl...
  |                                                  ------   ^^^^^^^^^^^^ argument never used
  |                                                  |
  |                                                  formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpwuaEEK/main.rs:1:516
  |
1 | ...um) ; let mut average = sum / 10i32 ; println ! ("Average:" . to_string ()) ; println ! ("{}" , average) } } } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpwuaEEK/main.rs:1:518
  |
1 | ... let mut average = sum / 10i32 ; println ! ("Average:" . to_string ()) ; println ! ("{}" , average) } } } }
  |                                                ----------   ^^^^^^^^^^^^ argument never used
  |                                                |
  |                                                formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpwuaEEK/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let numbers = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32 , 6i32 , 7i32 , 8i32 , 9i32 , ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpwuaEEK/main.rs:1:50
  |
1 | ... { { { let numbers = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32 , 6i32 , 7i32 , 8i32 , 9i32 , 10i32] ; { println ! ("First:" . to_string ()) ; println ! ("{}" , numbers [0i32]) ; println ! ("Last:" . to_string ()) ; println ! ("{}" , numbers [9i32]) ; let mut sum = 0i32 ; let mut i = 0i32 ; while i < 10i32 { { sum = sum + numbers [i] ; i = i + 1i32 } } ; println ! ("Sum:" . to_string ()) ; println ! ("{}" , sum) ; let mut average = sum / 10i32 ; println ! ("Average:" . to_string ()) ; println ! ("{}" , average) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let numbers = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32 , 6i32 , 7i32 , 8i32 , 9i32 , 10i32] ; { println ! ("First:" . to_string ()) ; println ! ("{}" , numbers [0i32]) ; println ! ("Last:" . to_string ()) ; println ! ("{}" , numbers [9i32]) ; let mut sum = 0i32 ; let mut i = 0i32 ; while i < 10i32 { { sum = sum + numbers [i] ; i = i + 1i32 } } ; println ! ("Sum:" . to_string ()) ; println ! ("{}" , sum) ; let mut average = sum / 10i32 ; println ! ("Average:" . to_string ()) ; println ! ("{}" , average) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let numbers = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32 , 6i32 , 7i32 , 8i32 , 9i32 , 10i32] ; { println ! ("First:" . to_string ()) ; println ! ("{}" , numbers [0i32]) ; println ! ("Last:" . to_string ()) ; println ! ("{}" , numbers [9i32]) ; let mut sum = 0i32 ; let mut i = 0i32 ; while i < 10i32 { { sum = sum + numbers [i] ; i = i + 1i32 } } ; println ! ("Sum:" . to_string ()) ; println ! ("{}" , sum) ; let mut average = sum / 10i32 ; println ! ("Average:" . to_string ()) ; println ! ("{}" , average) } } }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpwuaEEK/main.rs:1:171
  |
1 | ... , 8i32 , 9i32 , 10i32] ; { println ! ("First:" . to_string ()) ; println ! ("{}" , numbers [0i32]) ; println ! ("Last:" . to_string (...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0277]: the type `[i32]` cannot be indexed by `i32`
 --> /tmp/.tmpwuaEEK/main.rs:1:214
  |
1 | ...ing ()) ; println ! ("{}" , numbers [0i32]) ; println ! ("Last:" . to_string ()) ; println ! ("{}" , numbers [9i32]) ; let mut sum = 0...
  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`
  |
  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `Vec<i32>` to implement `Index<i32>`

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpwuaEEK/main.rs:1:244
  |
1 | ... ! ("{}" , numbers [0i32]) ; println ! ("Last:" . to_string ()) ; println ! ("{}" , numbers [9i32]) ; let mut sum = 0i32 ; let mut i =...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0277]: the type `[i32]` cannot be indexed by `i32`
 --> /tmp/.tmpwuaEEK/main.rs:1:287
  |
1 | ...ing ()) ; println ! ("{}" , numbers [9i32]) ; let mut sum = 0i32 ; let mut i = 0i32 ; while i < 10i32 { { sum = sum + numbers [i] ; i ...
  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`
  |
  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `Vec<i32>` to implement `Index<i32>`

error[E0277]: the type `[i32]` cannot be indexed by `i32`
 --> /tmp/.tmpwuaEEK/main.rs:1:377
  |
1 | ...ile i < 10i32 { { sum = sum + numbers [i] ; i = i + 1i32 } } ; println ! ("Sum:" . to_string ()) ; println ! ("{}" , sum) ; let mut av...
  |                                           ^ slice indices are of type `usize` or ranges of `usize`
  |
  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `Vec<i32>` to implement `Index<i32>`

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpwuaEEK/main.rs:1:421
  |
1 | ...bers [i] ; i = i + 1i32 } } ; println ! ("Sum:" . to_string ()) ; println ! ("{}" , sum) ; let mut average = sum / 10i32 ; println ! (...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpwuaEEK/main.rs:1:518
  |
1 | ...t average = sum / 10i32 ; println ! ("Average:" . to_string ()) ; println ! ("{}" , average) } } } }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 15 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0277, E0425.
For more information about an error, try `rustc --explain E0277`.



=== ch01-03-interpreter-scripting example 7 ===
✗ Compilation failed: Compilation failed:
error[E0434]: can't capture dynamic environment in a fn item
 --> /tmp/.tmp4kFrLu/main.rs:1:229
  |
1 | ...sted () { { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; { let nested_var = "I'm nested" ; println ! ("{}" , nested_...
  |                                                                  ^^^^^^^^^
  |
  = help: use the `|| { ... }` closure form instead

error[E0425]: cannot find value `global_var` in this scope
 --> /tmp/.tmp4kFrLu/main.rs:1:117
  |
1 | ... local" ; { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; fn nested () { { println ! ("{}" , global_var) ; println ! ...
  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `local_var`

error[E0425]: cannot find value `global_var` in this scope
 --> /tmp/.tmp4kFrLu/main.rs:1:197
  |
1 | ...sted () { { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; { let nested_var = "I'm nested" ; println ! ("{}" , nested_...
  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `local_var`

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp4kFrLu/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn demonstrate_scope () { { { let local_var = "I'm local" ; { println ! ("{}" , global_var) ; println...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp4kFrLu/main.rs:1:63
  |
1 | ... { { { let local_var = "I'm local" ; { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; fn nested () { { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; { let nested_var = "I'm nested" ; println ! ("{}" , nested_var) } } } ; nested () } } } } ...
  |       ^^                                                                                                                                                                                                                                                                      ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn demonstrate_scope () { { { let local_var = "I'm local" ; { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; fn nested () { { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; { let nested_var = "I'm nested" ; println ! ("{}" , nested_var) } } } ; nested () } } } } fn main () { let mut global_var = "I'm global" ; { demonstrate_scope () } }
1 + use std :: collections :: HashMap ; fn demonstrate_scope () { { let local_var = "I'm local" ; { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; fn nested () { { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; { let nested_var = "I'm nested" ; println ! ("{}" , nested_var) } } } ; nested () } } } fn main () { let mut global_var = "I'm global" ; { demonstrate_scope () } }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmp4kFrLu/main.rs:1:312
  |
1 | ... "I'm nested" ; println ! ("{}" , nested_var) } } } ; nested () } } } } fn main () { let mut global_var = "I'm global" ; { demonstrate...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp4kFrLu/main.rs:1:381
  |
1 | ...} } } fn main () { let mut global_var = "I'm global" ; { demonstrate_scope () } }
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn demonstrate_scope () { { { let local_var = "I'm local" ; { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; fn nested () { { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; { let nested_var = "I'm nested" ; println ! ("{}" , nested_var) } } } ; nested () } } } } fn main () { let mut global_var = "I'm global" ; { demonstrate_scope () } }
1 + use std :: collections :: HashMap ; fn demonstrate_scope () { { { let local_var = "I'm local" ; { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; fn nested () { { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; { let nested_var = "I'm nested" ; println ! ("{}" , nested_var) } } } ; nested () } } } } fn main () { let mut global_var = "I'm global" ; demonstrate_scope () }
  |

warning: unused variable: `global_var`
 --> /tmp/.tmp4kFrLu/main.rs:1:353
  |
1 | ...} } fn main () { let mut global_var = "I'm global" ; { demonstrate_scope () } }
  |                             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_global_var`
  |
  = note: `#[warn(unused_variables)]` on by default

warning: variable does not need to be mutable
 --> /tmp/.tmp4kFrLu/main.rs:1:349
  |
1 | ...sted_var) } } } ; nested () } } } } fn main () { let mut global_var = "I'm global" ; { demonstrate_scope () } }
  |                                                         ----^^^^^^^^^^
  |                                                         |
  |                                                         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

error: aborting due to 3 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0425, E0434.
For more information about an error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 8 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmp6XLWTe/main.rs:1:196
  |
1 | ..., arr [5i32]) } } else { { println ! ("Index out of bounds" . to_string ()) } } } } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmp6XLWTe/main.rs:1:198
  |
1 | ... , arr [5i32]) } } else { { println ! ("Index out of bounds" . to_string ()) } } } } }
  |                                           ---------------------   ^^^^^^^^^^^^ argument never used
  |                                           |
  |                                           formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp6XLWTe/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp6XLWTe/main.rs:1:50
  |
1 | ... { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , arr [5i32]) } } else { { println ! ("Index out of bounds" . to_string ()) } } } } }
  |       ^^                                                                                                                                                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , arr [5i32]) } } else { { println ! ("Index out of bounds" . to_string ()) } } } } }
1 + use std :: collections :: HashMap ; fn main () { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , arr [5i32]) } } else { { println ! ("Index out of bounds" . to_string ()) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp6XLWTe/main.rs:1:118
  |
1 | ...! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , arr [5i32]) } } else { { println ! ("Index out of bounds" . to_s...
  |                                                      ^^                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , arr [5i32]) } } else { { println ! ("Index out of bounds" . to_string ()) } } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { println ! ("{}" , arr [5i32]) } else { { println ! ("Index out of bounds" . to_string ()) } } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp6XLWTe/main.rs:1:161
  |
1 | ...println ! ("{}" , arr [5i32]) } } else { { println ! ("Index out of bounds" . to_string ()) } } } } }
  |                                             ^^                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , arr [5i32]) } } else { { println ! ("Index out of bounds" . to_string ()) } } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , arr [5i32]) } } else { println ! ("Index out of bounds" . to_string ()) } } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp6XLWTe/main.rs:1:103
  |
1 | ...let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , arr [5i32]) } } else { { println ! ("Index out of ...
  |                                              ----   ^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                              |
  |                                              expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len ().try_into().unwrap() { { println ! ("{}" , arr [5i32]) } } else { { println ! ("Index out of bounds" . to_string ()) } } } } }
  |                                                                                                                   ++++++++++++++++++++

error[E0277]: the type `[i32]` cannot be indexed by `i32`
 --> /tmp/.tmp6XLWTe/main.rs:1:143
  |
1 | ... . len () { { println ! ("{}" , arr [5i32]) } } else { { println ! ("Index out of bounds" . to_string ()) } } } } }
  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`
  |
  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `Vec<i32>` to implement `Index<i32>`

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmp6XLWTe/main.rs:1:198
  |
1 | ...) } } else { { println ! ("Index out of bounds" . to_string ()) } } } } }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 5 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0425.
For more information about an error, try `rustc --explain E0277`.



=== ch01-03-interpreter-scripting example 10 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmperMK6N/main.rs:1:430
  |
1 | ...-> T { { { let doubled = x * 2i32 ; { println ! ("Doubled:" . to_string ()) ; println ! ("{}" , doubled) } } } } fn main () { }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmperMK6N/main.rs:1:432
  |
1 | ...{ { { let doubled = x * 2i32 ; { println ! ("Doubled:" . to_string ()) ; println ! ("{}" , doubled) } } } } fn main () { }
  |                                                ----------   ^^^^^^^^^^^^ argument never used
  |                                                |
  |                                                formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmperMK6N/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn get_double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmperMK6N/main.rs:1:196
  |
1 | ...mt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } } fn process_and_print < T : std :: ops :: Add < Output = T ...
  |                                                                 ^^        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn get_double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } } fn process_and_print < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; { println ! ("Doubled:" . to_string ()) ; println ! ("{}" , doubled) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn get_double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { x * 2i32 } fn process_and_print < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; { println ! ("Doubled:" . to_string ()) ; println ! ("{}" , doubled) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmperMK6N/main.rs:1:377
  |
1 | ...(x : T) -> T { { { let doubled = x * 2i32 ; { println ! ("Doubled:" . to_string ()) ; println ! ("{}" , doubled) } } } } fn main () { }
  |                   ^^                                                                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn get_double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } } fn process_and_print < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; { println ! ("Doubled:" . to_string ()) ; println ! ("{}" , doubled) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn get_double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } } fn process_and_print < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { let doubled = x * 2i32 ; { println ! ("Doubled:" . to_string ()) ; println ! ("{}" , doubled) } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmperMK6N/main.rs:1:202
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } ...
  |       -                                                                                                                                                -   ^^^^ expected type parameter `T`, found `i32`
  |       |                                                                                                                                                |
  |       expected this type parameter                                                                                                                     expected because this is `T`
  |
  = note: expected type parameter `T`
                       found type `i32`

error[E0308]: mismatched types
 --> /tmp/.tmperMK6N/main.rs:1:399
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; ...
  |       -                                                                                                                                                                -   ^^^^ expected type parameter `T`, found `i32`
  |       |                                                                                                                                                                |
  |       expected this type parameter                                                                                                                                     expected because this is `T`
  |
  = note: expected type parameter `T`
                       found type `i32`

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmperMK6N/main.rs:1:432
  |
1 | ...et doubled = x * 2i32 ; { println ! ("Doubled:" . to_string ()) ; println ! ("{}" , doubled) } } } } fn main () { }
  |                                                      ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmperMK6N/main.rs:1:448
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; { println ! ("Doubled:" . to_string ()) ; println ! ("{}" , doubled) } ...
  |       - expected this type parameter                                                                                                                                                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 6 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0308, E0425.
For more information about an error, try `rustc --explain E0308`.



=== ch01-03-interpreter-scripting example 12 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpxm8gp4/main.rs:1:183
  |
1 | ...t mut x = 42i32 ; let mut y = calc (z) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0425]: cannot find value `items` in this scope
 --> /tmp/.tmpxm8gp4/main.rs:1:133
  |
1 | ...nt = 42i32 ; let mut total_price = calculate_price (items) ; let mut x = 42i32 ; let mut y = calc (z) } ; if let Some (s) = (& result ...
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpxm8gp4/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut user_count = 42i32 ; let mut total_price = calculate_price (items...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `calculate_price` in this scope
 --> /tmp/.tmpxm8gp4/main.rs:1:116
  |
1 | ...mut user_count = 42i32 ; let mut total_price = calculate_price (items) ; let mut x = 42i32 ; let mut y = calc (z) } ; if let Some (s) ...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 13 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmp6SBayT/main.rs:1:190
  |
1 | ...] ; let mut last_grade = grades [4i32] } } } }
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp6SBayT/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let mut first_grade =...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp6SBayT/main.rs:1:50
  |
1 | ... { { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let mut first_grade = grades [0i32] ; let mut last_grade = grades [4i32] } } } }
  |       ^^                                                                                                                                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let mut first_grade = grades [0i32] ; let mut last_grade = grades [4i32] } } } }
1 + use std :: collections :: HashMap ; fn main () { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let mut first_grade = grades [0i32] ; let mut last_grade = grades [4i32] } } }
  |

error[E0277]: the type `[i32]` cannot be indexed by `i32`
 --> /tmp/.tmp6SBayT/main.rs:1:147
  |
1 | ...2] ; { let mut first_grade = grades [0i32] ; let mut last_grade = grades [4i32] } } } }
  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`
  |
  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `Vec<i32>` to implement `Index<i32>`

error: aborting due to 2 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0277`.



=== ch01-03-interpreter-scripting example 14 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpzslMim/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: D...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpzslMim/main.rs:1:192
  |
1 | ...mt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } } fn main () { { { let x = 5i32 ; { let mut result = double ...
  |                                                                 ^^        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } } fn main () { { { let x = 5i32 ; { let mut result = double (x) ; println ! ("{}" , result) } } } }
1 + use std :: collections :: HashMap ; fn double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { n * 2i32 } fn main () { { { let x = 5i32 ; { let mut result = double (x) ; println ! ("{}" , result) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpzslMim/main.rs:1:220
  |
1 | ...n * 2i32 } } fn main () { { { let x = 5i32 ; { let mut result = double (x) ; println ! ("{}" , result) } } } }
  |                              ^^                                                                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } } fn main () { { { let x = 5i32 ; { let mut result = double (x) ; println ! ("{}" , result) } } } }
1 + use std :: collections :: HashMap ; fn double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } } fn main () { { let x = 5i32 ; { let mut result = double (x) ; println ! ("{}" , result) } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpzslMim/main.rs:1:198
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } ...
  |       -                                                                                                                                                -   ^^^^ expected type parameter `T`, found `i32`
  |       |                                                                                                                                                |
  |       expected this type parameter                                                                                                                     expected because this is `T`
  |
  = note: expected type parameter `T`
                       found type `i32`

warning: variable does not need to be mutable
 --> /tmp/.tmpzslMim/main.rs:1:245
  |
1 | ...{ n * 2i32 } } fn main () { { { let x = 5i32 ; { let mut result = double (x) ; println ! ("{}" , result) } } } }
  |                                                         ----^^^^^^
  |                                                         |
  |                                                         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

error: aborting due to 1 previous error; 4 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch01-03-interpreter-scripting example 15 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpvnszJa/main.rs:1:420
  |
1 | ... test1 && test2 && test3 { { println ! ("All tests passed!" . to_string ()) } } else { { println ! ("Some tests failed" . to_string ()...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpvnszJa/main.rs:1:422
  |
1 | ... test1 && test2 && test3 { { println ! ("All tests passed!" . to_string ()) } } else { { println ! ("Some tests failed" . to_string ()...
  |                                            -------------------   ^^^^^^^^^^^^ argument never used
  |                                            |
  |                                            formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpvnszJa/main.rs:1:480
  |
1 | .... to_string ()) } } else { { println ! ("Some tests failed" . to_string ()) } } } } } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpvnszJa/main.rs:1:482
  |
1 | .... to_string ()) } } else { { println ! ("Some tests failed" . to_string ()) } } } } } }
  |                                            -------------------   ^^^^^^^^^^^^ argument never used
  |                                            |
  |                                            formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpvnszJa/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Disp...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpvnszJa/main.rs:1:197
  |
1 | ...isplay + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn main () { { { let test1 = add (2i32 , 3i32) == 5i32 ; { l...
  |                                                                  ^^     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn main () { { { let test1 = add (2i32 , 3i32) == 5i32 ; { let mut test2 = add (0i32 , 0i32) == 0i32 ; let mut test3 = add (- 1i32 , 1i32) == 0i32 ; if test1 && test2 && test3 { { println ! ("All tests passed!" . to_string ()) } } else { { println ! ("Some tests failed" . to_string ()) } } } } } }
1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { a + b } fn main () { { { let test1 = add (2i32 , 3i32) == 5i32 ; { let mut test2 = add (0i32 , 0i32) == 0i32 ; let mut test3 = add (- 1i32 , 1i32) == 0i32 ; if test1 && test2 && test3 { { println ! ("All tests passed!" . to_string ()) } } else { { println ! ("Some tests failed" . to_string ()) } } } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpvnszJa/main.rs:1:222
  |
1 | ... { { { let test1 = add (2i32 , 3i32) == 5i32 ; { let mut test2 = add (0i32 , 0i32) == 0i32 ; let mut test3 = add (- 1i32 , 1i32) == 0i32 ; if test1 && test2 && test3 { { println ! ("All tests passed!" . to_string ()) } } else { { println ! ("Some tests failed" . to_string ()) } } } } } }
  |       ^^                                                                                                                                                                                                                                                                                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn main () { { { let test1 = add (2i32 , 3i32) == 5i32 ; { let mut test2 = add (0i32 , 0i32) == 0i32 ; let mut test3 = add (- 1i32 , 1i32) == 0i32 ; if test1 && test2 && test3 { { println ! ("All tests passed!" . to_string ()) } } else { { println ! ("Some tests failed" . to_string ()) } } } } } }
1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn main () { { let test1 = add (2i32 , 3i32) == 5i32 ; { let mut test2 = add (0i32 , 0i32) == 0i32 ; let mut test3 = add (- 1i32 , 1i32) == 0i32 ; if test1 && test2 && test3 { { println ! ("All tests passed!" . to_string ()) } } else { { println ! ("Some tests failed" . to_string ()) } } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpvnszJa/main.rs:1:387
  |
1 | ...2) == 0i32 ; if test1 && test2 && test3 { { println ! ("All tests passed!" . to_string ()) } } else { { println ! ("Some tests failed"...
  |                                              ^^                                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn main () { { { let test1 = add (2i32 , 3i32) == 5i32 ; { let mut test2 = add (0i32 , 0i32) == 0i32 ; let mut test3 = add (- 1i32 , 1i32) == 0i32 ; if test1 && test2 && test3 { { println ! ("All tests passed!" . to_string ()) } } else { { println ! ("Some tests failed" . to_string ()) } } } } } }
1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn main () { { { let test1 = add (2i32 , 3i32) == 5i32 ; { let mut test2 = add (0i32 , 0i32) == 0i32 ; let mut test3 = add (- 1i32 , 1i32) == 0i32 ; if test1 && test2 && test3 { println ! ("All tests passed!" . to_string ()) } else { { println ! ("Some tests failed" . to_string ()) } } } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpvnszJa/main.rs:1:447
  |
1 | ...tests passed!" . to_string ()) } } else { { println ! ("Some tests failed" . to_string ()) } } } } } }
  |                                              ^^                                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn main () { { { let test1 = add (2i32 , 3i32) == 5i32 ; { let mut test2 = add (0i32 , 0i32) == 0i32 ; let mut test3 = add (- 1i32 , 1i32) == 0i32 ; if test1 && test2 && test3 { { println ! ("All tests passed!" . to_string ()) } } else { { println ! ("Some tests failed" . to_string ()) } } } } } }
1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn main () { { { let test1 = add (2i32 , 3i32) == 5i32 ; { let mut test2 = add (0i32 , 0i32) == 0i32 ; let mut test3 = add (- 1i32 , 1i32) == 0i32 ; if test1 && test2 && test3 { { println ! ("All tests passed!" . to_string ()) } } else { println ! ("Some tests failed" . to_string ()) } } } } }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpvnszJa/main.rs:1:422
  |
1 | ...st2 && test3 { { println ! ("All tests passed!" . to_string ()) } } else { { println ! ("Some tests failed" . to_string ()) } } } } } }
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpvnszJa/main.rs:1:482
  |
1 | ...()) } } else { { println ! ("Some tests failed" . to_string ()) } } } } } }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 6 previous errors; 5 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch17-00-documentation example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 5 ===
✗ Compilation failed: Compilation failed:
error: expected item, found `{`
 --> /tmp/.tmp6BMecg/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { mod handlers { { } } ; mod services { { } } } ; if let Some (s) = (& resu...
  |                                                                                ^ expected item
  |
  = note: for a full list of items that can appear in modules, see <https://doc.rust-lang.org/reference/items.html>

error: expected item, found `{`
 --> /tmp/.tmp6BMecg/main.rs:1:103
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { mod handlers { { } } ; mod services { { } } } ; if let Some (s) = (& resu...
  |                                                                                                       ^ expected item
  |
  = note: for a full list of items that can appear in modules, see <https://doc.rust-lang.org/reference/items.html>

error: expected item, found `}`
 --> /tmp/.tmp6BMecg/main.rs:1:109
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { mod handlers { { } } ; mod services { { } } } ; if let Some (s) = (& resu...
  |                                                                                                             ^ expected item
  |
  = note: for a full list of items that can appear in modules, see <https://doc.rust-lang.org/reference/items.html>

error: aborting due to 3 previous errors




=== ch17-00-documentation example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 9 ===
✗ Compilation failed: Compilation failed:
error[E0670]: `async fn` is not permitted in Rust 2015
 --> /tmp/.tmp3wlN1H/main.rs:1:37
  |
1 | use std :: collections :: HashMap ; async fn request_flow () { { client . send_request () ; server . validate () ; server . process () ; ...
  |                                     ^^^^^ to use `async fn`, switch to Rust 2018 or later
  |
  = help: pass `--edition 2024` to `rustc`
  = note: for more on editions, read https://doc.rust-lang.org/edition-guide

error[E0425]: cannot find value `client` in this scope
 --> /tmp/.tmp3wlN1H/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; async fn request_flow () { { client . send_request () ; server . validate () ; server . process () ; ...
  |                                                                  ^^^^^^ not found in this scope

error[E0425]: cannot find value `server` in this scope
 --> /tmp/.tmp3wlN1H/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; async fn request_flow () { { client . send_request () ; server . validate () ; server . process () ; ...
  |                                                                                             ^^^^^^ not found in this scope

error[E0425]: cannot find value `server` in this scope
 --> /tmp/.tmp3wlN1H/main.rs:1:116
  |
1 | ...{ client . send_request () ; server . validate () ; server . process () ; server . respond () } } fn main () { impl ConfigBuilder { } ; }
  |                                                        ^^^^^^ not found in this scope

error[E0425]: cannot find value `server` in this scope
 --> /tmp/.tmp3wlN1H/main.rs:1:138
  |
1 | ...t () ; server . validate () ; server . process () ; server . respond () } } fn main () { impl ConfigBuilder { } ; }
  |                                                        ^^^^^^ not found in this scope

error[E0412]: cannot find type `ConfigBuilder` in this scope
 --> /tmp/.tmp3wlN1H/main.rs:1:180
  |
1 | ... () ; server . respond () } } fn main () { impl ConfigBuilder { } ; }
  |                                                    ^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp3wlN1H/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; async fn request_flow () { { client . send_request () ; server . validate () ; server . process () ; ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmp3wlN1H/main.rs:1:198
  |
1 | ... respond () } } fn main () { impl ConfigBuilder { } ; }
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error: aborting due to 6 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0412, E0425, E0670.
For more information about an error, try `rustc --explain E0412`.



=== ch17-00-documentation example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch06-00-file-operations example 1 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmpX3pZzi/main.rs:1:148
  |
1 | ... = { Documents : vec ! [".pdf" , ".doc" , ".docx" , ".txt"] , Images : vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"] , Videos : vec ! [".mp4" , ".avi" , ".mov" , ".mkv"] , Code : vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"] , Data : vec ! [".csv" , ".json" , ".xml" , ".xlsx"] , } ; ...
  |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Desktop Organizer ===" . to_string ()) ; let mut file_categories = { SomeStruct { Documents : vec ! [".pdf" , ".doc" , ".docx" , ".txt"] , Images : vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"] , Videos : vec ! [".mp4" , ".avi" , ".mov" , ".mkv"] , Code : vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"] , Data : vec ! [".csv" , ".json" , ".xml" , ".xlsx"] , } } ; let mut source_dir = "~/Desktop" ; let mut files = list_files (source_dir) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } } } } ; println ! ("✅ Desktop organized!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |                                                                                                                                                    ++++++++++++                                                                                                                                                                                                                                                                                                  +

error: expected `,`, found `.`
 --> /tmp/.tmpX3pZzi/main.rs:1:104
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Desktop Organizer ===" . to_string ()) ; let mut file_cat...
  |                                                                                                        ^ expected `,`

error: argument never used
 --> /tmp/.tmpX3pZzi/main.rs:1:106
  |
1 | ...main () { let result = { println ! ("=== Desktop Organizer ===" . to_string ()) ; let mut file_categories = { Documents : vec ! [".pdf...
  |                                        ---------------------------   ^^^^^^^^^^^^ argument never used
  |                                        |
  |                                        formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpX3pZzi/main.rs:1:1327
  |
1 | ...break } } } } } } } } } ; println ! ("✅ Desktop organized!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any)...
  |                                                                 ^ expected `,`

error: argument never used
 --> /tmp/.tmpX3pZzi/main.rs:1:1329
  |
1 | ... break } } } } } } } } } ; println ! ("✅ Desktop organized!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any...
  |                                          -----------------------   ^^^^^^^^^^^^ argument never used
  |                                          |
  |                                          formatting specifier missing

error[E0425]: cannot find function `create_dir` in this scope
 --> /tmp/.tmpX3pZzi/main.rs:1:903
  |
1 | ... , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , format ! ("{}{}" , "Created folder: " , ...
  |                                                      ^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::create_dir;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpX3pZzi/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Desktop Organizer ===" . to_string ()) ; let mut file_cat...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpX3pZzi/main.rs:1:656
  |
1 | ... { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Desktop Organizer ===" . to_string ()) ; let mut file_categories = { Documents : vec ! [".pdf" , ".doc" , ".docx" , ".txt"] , Images : vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"] , Videos : vec ! [".mp4" , ".avi" , ".mov" , ".mkv"] , Code : vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"] , Data : vec ! [".csv" , ".json" , ".xml" , ".xlsx"] , } ; let mut source_dir = "~/Desktop" ; let mut files = list_files (source_dir) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } } } } ; println ! ("✅ Desktop organized!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Desktop Organizer ===" . to_string ()) ; let mut file_categories = { Documents : vec ! [".pdf" , ".doc" , ".docx" , ".txt"] , Images : vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"] , Videos : vec ! [".mp4" , ".avi" , ".mov" , ".mkv"] , Code : vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"] , Data : vec ! [".csv" , ".json" , ".xml" , ".xlsx"] , } ; let mut source_dir = "~/Desktop" ; let mut files = list_files (source_dir) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } } } ; println ! ("✅ Desktop organized!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpX3pZzi/main.rs:1:770
  |
1 | ... { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Desktop Organizer ===" . to_string ()) ; let mut file_categories = { Documents : vec ! [".pdf" , ".doc" , ".docx" , ".txt"] , Images : vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"] , Videos : vec ! [".mp4" , ".avi" , ".mov" , ".mkv"] , Code : vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"] , Data : vec ! [".csv" , ".json" , ".xml" , ".xlsx"] , } ; let mut source_dir = "~/Desktop" ; let mut files = list_files (source_dir) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } } } } ; println ! ("✅ Desktop organized!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Desktop Organizer ===" . to_string ()) ; let mut file_categories = { Documents : vec ! [".pdf" , ".doc" , ".docx" , ".txt"] , Images : vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"] , Videos : vec ! [".mp4" , ".avi" , ".mov" , ".mkv"] , Code : vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"] , Data : vec ! [".csv" , ".json" , ".xml" , ".xlsx"] , } ; let mut source_dir = "~/Desktop" ; let mut files = list_files (source_dir) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } } } ; println ! ("✅ Desktop organized!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpX3pZzi/main.rs:1:811
  |
1 | ... { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Desktop Organizer ===" . to_string ()) ; let mut file_categories = { Documents : vec ! [".pdf" , ".doc" , ".docx" , ".txt"] , Images : vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"] , Videos : vec ! [".mp4" , ".avi" , ".mov" , ".mkv"] , Code : vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"] , Data : vec ! [".csv" , ".json" , ".xml" , ".xlsx"] , } ; let mut source_dir = "~/Desktop" ; let mut files = list_files (source_dir) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } } } } ; println ! ("✅ Desktop organized!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Desktop Organizer ===" . to_string ()) ; let mut file_categories = { Documents : vec ! [".pdf" , ".doc" , ".docx" , ".txt"] , Images : vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"] , Videos : vec ! [".mp4" , ".avi" , ".mov" , ".mkv"] , Code : vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"] , Data : vec ! [".csv" , ".json" , ".xml" , ".xlsx"] , } ; let mut source_dir = "~/Desktop" ; let mut files = list_files (source_dir) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") + category , "/")) ; break } } } } } } } } ; println ! ("✅ Desktop organized!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpX3pZzi/main.rs:1:106
  |
1 | ...sult = { println ! ("=== Desktop Organizer ===" . to_string ()) ; let mut file_categories = { Documents : vec ! [".pdf" , ".doc" , ".d...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `list_files` in this scope
 --> /tmp/.tmpX3pZzi/main.rs:1:490
  |
1 | ...et mut source_dir = "~/Desktop" ; let mut files = list_files (source_dir) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "F...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `get_extension` in this scope
 --> /tmp/.tmpX3pZzi/main.rs:1:676
  |
1 | ...ze")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . ite...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpX3pZzi/main.rs:1:832
  |
1 | ...ons . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (t...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `dir_exists` in this scope
 --> /tmp/.tmpX3pZzi/main.rs:1:875
  |
1 | ..._dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , format ! ("{...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpX3pZzi/main.rs:1:1021
  |
1 | ...ted folder: " , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpX3pZzi/main.rs:1:1075
  |
1 | ..._path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" ,...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `move_file` in this scope
 --> /tmp/.tmpX3pZzi/main.rs:1:1107
  |
1 | ...mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , format ! ("{}{}" , format ! ("{...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpX3pZzi/main.rs:1:1329
  |
1 | ...} } } } } } ; println ! ("✅ Desktop organized!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_...
  |                                                       ^^^^^^^^^ not found in this scope

error: aborting due to 15 previous errors; 4 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch06-00-file-operations example 2 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpGbSh92/main.rs:1:541
  |
1 | ...(".././data//file.txt" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0425]: cannot find function `set_current_dir` in this scope
 --> /tmp/.tmpGbSh92/main.rs:1:108
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; set_current_dir ("/home/user/p...
  |                                                                                                            ^^^^^^^^^^^^^^^
  |
help: a local variable with a similar name exists
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; set_current_dir ("/home/user/projects" . to_string ()) ; let mut full_path = absolute_path ("data.txt" . to_string ()) ; let mut parent = parent_dir (full_path) ; let mut filename = file_name (full_path) ; let mut extension = file_extension (full_path) ; let mut project_path = join_path (home_dir () , "projects" . to_string () , "my_app" . to_string ()) ; let mut clean_path = normalize_path (".././data//file.txt" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; current_dir ("/home/user/projects" . to_string ()) ; let mut full_path = absolute_path ("data.txt" . to_string ()) ; let mut parent = parent_dir (full_path) ; let mut filename = file_name (full_path) ; let mut extension = file_extension (full_path) ; let mut project_path = join_path (home_dir () , "projects" . to_string () , "my_app" . to_string ()) ; let mut clean_path = normalize_path (".././data//file.txt" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |
help: consider importing this function
  |
1 + use std::env::set_current_dir;
  |

error[E0425]: cannot find function `home_dir` in this scope
 --> /tmp/.tmpGbSh92/main.rs:1:397
  |
1 | ...on (full_path) ; let mut project_path = join_path (home_dir () , "projects" . to_string () , "my_app" . to_string ()) ; let mut clean_...
  |                                                       ^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::env::home_dir;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpGbSh92/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; set_current_dir ("/home/user/p...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `get_current_dir` in this scope
 --> /tmp/.tmpGbSh92/main.rs:1:87
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; set_current_dir ("/home/user/p...
  |                                                                                       ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `absolute_path` in this scope
 --> /tmp/.tmpGbSh92/main.rs:1:185
  |
1 | ...projects" . to_string ()) ; let mut full_path = absolute_path ("data.txt" . to_string ()) ; let mut parent = parent_dir (full_path) ; ...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `parent_dir` in this scope
 --> /tmp/.tmpGbSh92/main.rs:1:246
  |
1 | ...tring ()) ; let mut parent = parent_dir (full_path) ; let mut filename = file_name (full_path) ; let mut extension = file_extension (f...
  |                                 ^^^^^^^^^^ help: a local variable with a similar name exists: `current_dir`

error[E0425]: cannot find function `file_name` in this scope
 --> /tmp/.tmpGbSh92/main.rs:1:290
  |
1 | ...ent = parent_dir (full_path) ; let mut filename = file_name (full_path) ; let mut extension = file_extension (full_path) ; let mut pro...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_extension` in this scope
 --> /tmp/.tmpGbSh92/main.rs:1:334
  |
1 | ...e = file_name (full_path) ; let mut extension = file_extension (full_path) ; let mut project_path = join_path (home_dir () , "projects...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpGbSh92/main.rs:1:386
  |
1 | ...le_extension (full_path) ; let mut project_path = join_path (home_dir () , "projects" . to_string () , "my_app" . to_string ()) ; let ...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 9 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch06-00-file-operations example 3 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpXBv1G7/main.rs:1:562
  |
1 | ...mut can_execute = is_executable (path) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpXBv1G7/main.rs:1:344
  |
1 | ..."system.conf" . to_string ()) ; let mut is_file = is_file (path) ; let mut is_dir = is_directory (path) ; let mut is_symlink = is_symb...
  |                                                               ^^^^ not a value

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpXBv1G7/main.rs:1:383
  |
1 | ... is_file = is_file (path) ; let mut is_dir = is_directory (path) ; let mut is_symlink = is_symbolic_link (path) ; let mut can_read = i...
  |                                                               ^^^^ not a value

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpXBv1G7/main.rs:1:430
  |
1 | ..._directory (path) ; let mut is_symlink = is_symbolic_link (path) ; let mut can_read = is_readable (path) ; let mut can_write = is_writ...
  |                                                               ^^^^ not a value

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpXBv1G7/main.rs:1:470
  |
1 | ... is_symbolic_link (path) ; let mut can_read = is_readable (path) ; let mut can_write = is_writable (path) ; let mut can_execute = is_e...
  |                                                               ^^^^ not a value

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpXBv1G7/main.rs:1:511
  |
1 | ...ad = is_readable (path) ; let mut can_write = is_writable (path) ; let mut can_execute = is_executable (path) } ; if let Some (s) = (&...
  |                                                               ^^^^ not a value

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpXBv1G7/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut exists = file_exists ("config.json" . to_string ()) ; let mut siz...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpXBv1G7/main.rs:1:82
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut exists = file_exists ("config.json" . to_string ()) ; let mut siz...
  |                                                                                  ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_size` in this scope
 --> /tmp/.tmpXBv1G7/main.rs:1:142
  |
1 | ...s ("config.json" . to_string ()) ; let mut size = file_size ("data.csv" . to_string ()) ; let mut modified = file_modified_time ("log....
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_modified_time` in this scope
 --> /tmp/.tmpXBv1G7/main.rs:1:201
  |
1 | ...ata.csv" . to_string ()) ; let mut modified = file_modified_time ("log.txt" . to_string ()) ; let mut is_read_only = is_readonly ("sys...
  |                                                  ^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_readonly` in this scope
 --> /tmp/.tmpXBv1G7/main.rs:1:272
  |
1 | ...og.txt" . to_string ()) ; let mut is_read_only = is_readonly ("system.conf" . to_string ()) ; let mut is_file = is_file (path) ; let m...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_file` in this scope
 --> /tmp/.tmpXBv1G7/main.rs:1:335
  |
1 | ...("system.conf" . to_string ()) ; let mut is_file = is_file (path) ; let mut is_dir = is_directory (path) ; let mut is_symlink = is_sym...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_directory` in this scope
 --> /tmp/.tmpXBv1G7/main.rs:1:369
  |
1 | ... mut is_file = is_file (path) ; let mut is_dir = is_directory (path) ; let mut is_symlink = is_symbolic_link (path) ; let mut can_read...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_symbolic_link` in this scope
 --> /tmp/.tmpXBv1G7/main.rs:1:412
  |
1 | ...r = is_directory (path) ; let mut is_symlink = is_symbolic_link (path) ; let mut can_read = is_readable (path) ; let mut can_write = i...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_readable` in this scope
 --> /tmp/.tmpXBv1G7/main.rs:1:457
  |
1 | ...k = is_symbolic_link (path) ; let mut can_read = is_readable (path) ; let mut can_write = is_writable (path) ; let mut can_execute = i...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_writable` in this scope
 --> /tmp/.tmpXBv1G7/main.rs:1:498
  |
1 | ..._read = is_readable (path) ; let mut can_write = is_writable (path) ; let mut can_execute = is_executable (path) } ; if let Some (s) =...
  |                                                     ^^^^^^^^^^^ not found in this scope

error: aborting due to 15 previous errors; 1 warning emitted

Some errors have detailed explanations: E0423, E0425.
For more information about an error, try `rustc --explain E0423`.



=== ch06-00-file-operations example 4 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `create_dir` in this scope
 --> /tmp/.tmpnrhmRB/main.rs:1:406
  |
1 | ... process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" ....
  |                                                      ^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::create_dir;
  |

error[E0425]: cannot find function `create_dir_all` in this scope
 --> /tmp/.tmpnrhmRB/main.rs:1:449
  |
1 | ...() { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" ....
  |                                                    ^^^^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::create_dir_all;
  |

error[E0425]: cannot find function `remove_dir` in this scope
 --> /tmp/.tmpnrhmRB/main.rs:1:507
  |
1 | ...ir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" ...
  |                                                      ^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_dir;
  |

error[E0425]: cannot find function `remove_dir_all` in this scope
 --> /tmp/.tmpnrhmRB/main.rs:1:552
  |
1 | ... ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_dir_all;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpnrhmRB/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpnrhmRB/main.rs:1:202
  |
1 | ... { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } ...
  |       ^^                                                                                                                                                                                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
1 + use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpnrhmRB/main.rs:1:255
  |
1 | ... { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } ...
  |       ^^                                                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
1 + use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpnrhmRB/main.rs:1:320
  |
1 | ...h = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
1 + use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { walk_directory (path) } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpnrhmRB/main.rs:1:355
  |
1 | ..._directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . t...
  |                                                           ^^                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
1 + use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { process_file (path) } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
  |

error[E0425]: cannot find function `list_dir` in this scope
 --> /tmp/.tmpnrhmRB/main.rs:1:218
  |
1 | ...: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpnrhmRB/main.rs:1:270
  |
1 | ...st_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else {...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_directory` in this scope
 --> /tmp/.tmpnrhmRB/main.rs:1:298
  |
1 | ...ems { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } ...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0277]: cannot add `()` to `()`
 --> /tmp/.tmpnrhmRB/main.rs:1:338
  |
1 | ... , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (...
  |                                          --------------  ^^^^ no implementation for `() + ()`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `()`
note: required by a bound in `walk_directory`
 --> /tmp/.tmpnrhmRB/main.rs:1:61
  |
1 | ...ap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt ...
  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `walk_directory`

error[E0277]: cannot multiply `()` by `()`
 --> /tmp/.tmpnrhmRB/main.rs:1:338
  |
1 | ... , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (...
  |                                          --------------  ^^^^ no implementation for `() * ()`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `()`
note: required by a bound in `walk_directory`
 --> /tmp/.tmpnrhmRB/main.rs:1:96
  |
1 | ... ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T {...
  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `walk_directory`

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpnrhmRB/main.rs:1:338
  |
1 | ... if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folde...
  |                                --------------  ^^^^ the trait `std::fmt::Display` is not implemented for `()`
  |                                |
  |                                required by a bound introduced by this call
  |
note: required by a bound in `walk_directory`
 --> /tmp/.tmpnrhmRB/main.rs:1:131
  |
1 | ...std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (di...
  |                                       ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `walk_directory`

error[E0425]: cannot find function `process_file` in this scope
 --> /tmp/.tmpnrhmRB/main.rs:1:357
  |
1 | ...ry (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpnrhmRB/main.rs:1:235
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } ...
  |       -                                                                                                                                            -                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |       |                                                                                                                                            |
  |       expected this type parameter                                                                                                                 expected `T` because of return type
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: the caller chooses a type for `T` which can be different from `()`
  = note: `for` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } /* `T` value */ } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                   +++++++++++++++

error[E0425]: cannot find function `list_dir` in this scope
 --> /tmp/.tmpnrhmRB/main.rs:1:629
  |
1 | ...th_contents" . to_string ()) ; let mut all_items = list_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `list_files` in this scope
 --> /tmp/.tmpnrhmRB/main.rs:1:682
  |
1 | ...t_dir ("." . to_string ()) ; let mut files_only = list_files ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_str...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `list_directories` in this scope
 --> /tmp/.tmpnrhmRB/main.rs:1:736
  |
1 | ...les ("." . to_string ()) ; let mut dirs_only = list_directories ("." . to_string ()) ; }
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 15 previous errors; 5 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0425.
For more information about an error, try `rustc --explain E0277`.



=== ch06-00-file-operations example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch06-00-file-operations example 6 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmp4ewgLG/main.rs:1:749
  |
1 | ...h) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes...
  |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ SomeStruct { original : file_hashes [hash] , duplicate : path , size : size , hash : hash , } }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===" . to_string ()) ; let mut search_dir = input ("Enter directory to search: " . to_string ()) ; let mut min_size = input ("Minimum file size (bytes, 0 for all): " . to_string ()) . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!" . to_string ()) } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = input ("\nDelete duplicates? (y/n): " . to_string ()) ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ++++++++++++                                                                                    +

error: expected `,`, found `.`
 --> /tmp/.tmp4ewgLG/main.rs:1:958
  |
1 | ...} } fn main () { println ! ("=== Duplicate File Finder ===" . to_string ()) ; let mut search_dir = input ("Enter directory to search: ...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmp4ewgLG/main.rs:1:960
  |
1 | ...} } } } } fn main () { println ! ("=== Duplicate File Finder ===" . to_string ()) ; let mut search_dir = input ("Enter directory to se...
  |                                      -------------------------------   ^^^^^^^^^^^^ argument never used
  |                                      |
  |                                      formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmp4ewgLG/main.rs:1:1407
  |
1 | ... is_empty () { { println ! ("\n✅ No duplicate files found!" . to_string ()) } } else { { println ! ("{}" , format ! ("{}{}" , format ! ...
  |                                                                 ^ expected `,`

error: argument never used
 --> /tmp/.tmp4ewgLG/main.rs:1:1409
  |
1 | ...ates . is_empty () { { println ! ("\n✅ No duplicate files found!" . to_string ()) } } else { { println ! ("{}" , format ! ("{}{}" , for...
  |                                      --------------------------------   ^^^^^^^^^^^^ argument never used
  |                                      |
  |                                      formatting specifier missing

error[E0425]: cannot find value `min_size` in this scope
 --> /tmp/.tmp4ewgLG/main.rs:1:649
  |
1 | ...th) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { du...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `file_hashes` in this scope
 --> /tmp/.tmp4ewgLG/main.rs:1:697
  |
1 | ... min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] ,...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `duplicates` in this scope
 --> /tmp/.tmp4ewgLG/main.rs:1:730
  |
1 | ...file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size ...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `file_hashes` in this scope
 --> /tmp/.tmp4ewgLG/main.rs:1:846
  |
1 | ...th , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `remove_file` in this scope
 --> /tmp/.tmp4ewgLG/main.rs:1:2111
  |
1 | ... . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , du...
  |                                                     ^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_file;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp4ewgLG/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp4ewgLG/main.rs:1:198
  |
1 | ...Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: o...
  |                                      ^^                                                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===" . to_string ()) ; let mut search_dir = input ("Enter directory to search: " . to_string ()) ; let mut min_size = input ("Minimum file size (bytes, 0 for all): " . to_string ()) . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!" . to_string ()) } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = input ("\nDelete duplicates? (y/n): " . to_string ()) ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { let content = read_bytes (path) ; return sha256 (content) } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===" . to_string ()) ; let mut search_dir = input ("Enter directory to search: " . to_string ()) ; let mut min_size = input ("Minimum file size (bytes, 0 for all): " . to_string ()) . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!" . to_string ()) } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = input ("\nDelete duplicates? (y/n): " . to_string ()) ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp4ewgLG/main.rs:1:431
  |
1 | ... { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===" . to_string ()) ; let mut search_dir = input ("Enter directory to search: " . to_string ()) ; let mut min_size = input ("Minimum file size (bytes, 0 for all): " . to_string ()) . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!" . to_string ()) } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = input ("\nDelete duplicates? (y/n): " . to_string ()) ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===" . to_string ()) ; let mut search_dir = input ("Enter directory to search: " . to_string ()) ; let mut min_size = input ("Minimum file size (bytes, 0 for all): " . to_string ()) . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!" . to_string ()) } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = input ("\nDelete duplicates? (y/n): " . to_string ()) ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp4ewgLG/main.rs:1:484
  |
1 | ... { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===" . to_string ()) ; let mut search_dir = input ("Enter directory to search: " . to_string ()) ; let mut min_size = input ("Minimum file size (bytes, 0 for all): " . to_string ()) . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!" . to_string ()) } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = input ("\nDelete duplicates? (y/n): " . to_string ()) ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===" . to_string ()) ; let mut search_dir = input ("Enter directory to search: " . to_string ()) ; let mut min_size = input ("Minimum file size (bytes, 0 for all): " . to_string ()) . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!" . to_string ()) } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = input ("\nDelete duplicates? (y/n): " . to_string ()) ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp4ewgLG/main.rs:1:549
  |
1 | ...h = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size ...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===" . to_string ()) ; let mut search_dir = input ("Enter directory to search: " . to_string ()) ; let mut min_size = input ("Minimum file size (bytes, 0 for all): " . to_string ()) . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!" . to_string ()) } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = input ("\nDelete duplicates? (y/n): " . to_string ()) ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { scan_directory (path) } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===" . to_string ()) ; let mut search_dir = input ("Enter directory to search: " . to_string ()) ; let mut min_size = input ("Minimum file size (bytes, 0 for all): " . to_string ()) . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!" . to_string ()) } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = input ("\nDelete duplicates? (y/n): " . to_string ()) ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp4ewgLG/main.rs:1:604
  |
1 | ... { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===" . to_string ()) ; let mut search_dir = input ("Enter directory to search: " . to_string ()) ; let mut min_size = input ("Minimum file size (bytes, 0 for all): " . to_string ()) . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!" . to_string ()) } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = input ("\nDelete duplicates? (y/n): " . to_string ()) ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===" . to_string ()) ; let mut search_dir = input ("Enter directory to search: " . to_string ()) ; let mut min_size = input ("Minimum file size (bytes, 0 for all): " . to_string ()) . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!" . to_string ()) } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = input ("\nDelete duplicates? (y/n): " . to_string ()) ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp4ewgLG/main.rs:1:660
  |
1 | ... { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } ...
  |       ^^                                                                                                                                                                                                                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===" . to_string ()) ; let mut search_dir = input ("Enter directory to search: " . to_string ()) ; let mut min_size = input ("Minimum file size (bytes, 0 for all): " . to_string ()) . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!" . to_string ()) } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = input ("\nDelete duplicates? (y/n): " . to_string ()) ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===" . to_string ()) ; let mut search_dir = input ("Enter directory to search: " . to_string ()) ; let mut min_size = input ("Minimum file size (bytes, 0 for all): " . to_string ()) . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!" . to_string ()) } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = input ("\nDelete duplicates? (y/n): " . to_string ()) ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp4ewgLG/main.rs:1:728
  |
1 | ..._key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { fi...
  |                  ^^                                                                                                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===" . to_string ()) ; let mut search_dir = input ("Enter directory to search: " . to_string ()) ; let mut min_size = input ("Minimum file size (bytes, 0 for all): " . to_string ()) . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!" . to_string ()) } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = input ("\nDelete duplicates? (y/n): " . to_string ()) ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===" . to_string ()) ; let mut search_dir = input ("Enter directory to search: " . to_string ()) ; let mut min_size = input ("Minimum file size (bytes, 0 for all): " . to_string ()) . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!" . to_string ()) } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = input ("\nDelete duplicates? (y/n): " . to_string ()) ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp4ewgLG/main.rs:1:844
  |
1 | ... : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (...
  |                                                        ^^                         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===" . to_string ()) ; let mut search_dir = input ("Enter directory to search: " . to_string ()) ; let mut min_size = input ("Minimum file size (bytes, 0 for all): " . to_string ()) . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!" . to_string ()) } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = input ("\nDelete duplicates? (y/n): " . to_string ()) ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { file_hashes [hash] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===" . to_string ()) ; let mut search_dir = input ("Enter directory to search: " . to_string ()) ; let mut min_size = input ("Minimum file size (bytes, 0 for all): " . to_string ()) . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!" . to_string ()) } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = input ("\nDelete duplicates? (y/n): " . to_string ()) ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp4ewgLG/main.rs:1:1362
  |
1 | ...ir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!" . to_string ()) } } else { { println ! ("{}" , format ...
  |                                        ^^                                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===" . to_string ()) ; let mut search_dir = input ("Enter directory to search: " . to_string ()) ; let mut min_size = input ("Minimum file size (bytes, 0 for all): " . to_string ()) . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!" . to_string ()) } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = input ("\nDelete duplicates? (y/n): " . to_string ()) ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===" . to_string ()) ; let mut search_dir = input ("Enter directory to search: " . to_string ()) ; let mut min_size = input ("Minimum file size (bytes, 0 for all): " . to_string ()) . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { println ! ("\n✅ No duplicate files found!" . to_string ()) } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = input ("\nDelete duplicates? (y/n): " . to_string ()) ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

error[E0425]: cannot find function `read_bytes` in this scope
 --> /tmp/.tmp4ewgLG/main.rs:1:216
  |
1 | ...bug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `sha256` in this scope
 --> /tmp/.tmp4ewgLG/main.rs:1:243
  |
1 | ...-> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + ...
  |                                                        ^^^^^^ not found in this scope

error[E0425]: cannot find function `list_dir` in this scope
 --> /tmp/.tmp4ewgLG/main.rs:1:447
  |
1 | ...: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmp4ewgLG/main.rs:1:499
  |
1 | ...st_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else {...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_directory` in this scope
 --> /tmp/.tmp4ewgLG/main.rs:1:527
  |
1 | ...ems { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let ...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0277]: cannot add `()` to `()`
 --> /tmp/.tmp4ewgLG/main.rs:1:567
  |
1 | ... , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >...
  |                                          --------------  ^^^^ no implementation for `() + ()`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `()`
note: required by a bound in `scan_directory`
 --> /tmp/.tmp4ewgLG/main.rs:1:290
  |
1 | ... } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt ...
  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `scan_directory`

error[E0277]: cannot multiply `()` by `()`
 --> /tmp/.tmp4ewgLG/main.rs:1:567
  |
1 | ... , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >...
  |                                          --------------  ^^^^ no implementation for `() * ()`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `()`
note: required by a bound in `scan_directory`
 --> /tmp/.tmp4ewgLG/main.rs:1:325
  |
1 | ... ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T {...
  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `scan_directory`

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmp4ewgLG/main.rs:1:567
  |
1 | ... if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size...
  |                                --------------  ^^^^ the trait `std::fmt::Display` is not implemented for `()`
  |                                |
  |                                required by a bound introduced by this call
  |
note: required by a bound in `scan_directory`
 --> /tmp/.tmp4ewgLG/main.rs:1:360
  |
1 | ...std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (di...
  |                                       ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `scan_directory`

error[E0425]: cannot find function `is_file` in this scope
 --> /tmp/.tmp4ewgLG/main.rs:1:587
  |
1 | ...ory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let ha...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_size` in this scope
 --> /tmp/.tmp4ewgLG/main.rs:1:619
  |
1 | ...th) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_h...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmp4ewgLG/main.rs:1:464
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } ...
  |       -                                                                                                                                            -                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |       |                                                                                                                                            |
  |       expected this type parameter                                                                                                                 expected `T` because of return type
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: the caller chooses a type for `T` which can be different from `()`
  = note: `for` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } /* `T` value */ } } } fn main () { println ! ("=== Duplicate File Finder ===" . to_string ()) ; let mut search_dir = input ("Enter directory to search: " . to_string ()) ; let mut min_size = input ("Minimum file size (bytes, 0 for all): " . to_string ()) . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!" . to_string ()) } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = input ("\nDelete duplicates? (y/n): " . to_string ()) ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                +++++++++++++++

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmp4ewgLG/main.rs:1:960
  |
1 | ...() { println ! ("=== Duplicate File Finder ===" . to_string ()) ; let mut search_dir = input ("Enter directory to search: " . to_strin...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmp4ewgLG/main.rs:1:997
  |
1 | ... Finder ===" . to_string ()) ; let mut search_dir = input ("Enter directory to search: " . to_string ()) ; let mut min_size = input ("...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmp4ewgLG/main.rs:1:1071
  |
1 | ...y to search: " . to_string ()) ; let mut min_size = input ("Minimum file size (bytes, 0 for all): " . to_string ()) . to_i () ; printl...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmp4ewgLG/main.rs:1:1409
  |
1 | ... { { println ! ("\n✅ No duplicate files found!" . to_string ()) } } else { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\...
  |                                                       ^^^^^^^^^ not found in this scope

error[E0599]: no method named `to_s` found for type `usize` in the current scope
 --> /tmp/.tmp4ewgLG/main.rs:1:1538
  |
1 | ...}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplica...
  |                                                       ^^^^ method not found in `usize`

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmp4ewgLG/main.rs:1:1823
  |
1 | ... println ! ("{}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{}" , forma...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmp4ewgLG/main.rs:1:1949
  |
1 | ... , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let mut action = input ("\nDelete duplicates? (y/n): "...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmp4ewgLG/main.rs:1:1997
  |
1 | ..." , format_size (total_wasted))) ; let mut action = input ("\nDelete duplicates? (y/n): " . to_string ()) ; if action . lower () == "y...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmp4ewgLG/main.rs:1:2289
  |
1 | ...at ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |                                                      ^^^^^^^^^^^ not found in this scope

error: aborting due to 30 previous errors; 10 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0425, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch06-00-file-operations example 7 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmpQYDeWZ/main.rs:1:145
  |
1 | ...)) ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = "/var/...
  |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===" . to_string ()) ; let mut log_config = { SomeStruct { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } } ; let mut log_dir = "/var/log/myapp" ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |                                                                                                                                                 ++++++++++++                                                                                   +

error: expected `,`, found `.`
 --> /tmp/.tmpQYDeWZ/main.rs:1:106
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===" . to_string ()) ; let mut log_co...
  |                                                                                                          ^ expected `,`

error: argument never used
 --> /tmp/.tmpQYDeWZ/main.rs:1:108
  |
1 | ...ain () { let result = { println ! ("=== Log Rotation System ===" . to_string ()) ; let mut log_config = { max_size : 10i32 * 1024i32 *...
  |                                       -----------------------------   ^^^^^^^^^^^^ argument never used
  |                                       |
  |                                       formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpQYDeWZ/main.rs:1:1474
  |
1 | ...e)) } } } } } } } ; println ! ("\n✅ Log rotation complete!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any)...
  |                                                                 ^ expected `,`

error: argument never used
 --> /tmp/.tmpQYDeWZ/main.rs:1:1476
  |
1 | ..._file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: ...
  |                                       -----------------------------   ^^^^^^^^^^^^ argument never used
  |                                       |
  |                                       formatting specifier missing

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmpQYDeWZ/main.rs:1:592
  |
1 | ... , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = for...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0425]: cannot find function `remove_file` in this scope
 --> /tmp/.tmpQYDeWZ/main.rs:1:879
  |
1 | ... { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } }...
  |                                                     ^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_file;
  |

error[E0425]: cannot find function `remove_file` in this scope
 --> /tmp/.tmpQYDeWZ/main.rs:1:1173
  |
1 | ...ath , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "...
  |                                                     ^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_file;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpQYDeWZ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===" . to_string ()) ; let mut log_co...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpQYDeWZ/main.rs:1:368
  |
1 | ... { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===" . to_string ()) ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = "/var/log/myapp" ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===" . to_string ()) ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = "/var/log/myapp" ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } ; println ! ("\n✅ Log rotation complete!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpQYDeWZ/main.rs:1:650
  |
1 | ... { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===" . to_string ()) ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = "/var/log/myapp" ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===" . to_string ()) ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = "/var/log/myapp" ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpQYDeWZ/main.rs:1:833
  |
1 | ... { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } }...
  |       ^^                                                                                                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===" . to_string ()) ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = "/var/log/myapp" ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===" . to_string ()) ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = "/var/log/myapp" ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpQYDeWZ/main.rs:1:877
  |
1 | ...ackup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } }...
  |                                                         ^^                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===" . to_string ()) ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = "/var/log/myapp" ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===" . to_string ()) ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = "/var/log/myapp" ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { remove_file (old_backup) } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpQYDeWZ/main.rs:1:915
  |
1 | ... 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! (...
  |                                                  ^^                                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===" . to_string ()) ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = "/var/log/myapp" ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Rotation System ===" . to_string ()) ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = "/var/log/myapp" ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , log_file , ".") + i . to_s () ; { let mut new_backup = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { rename_file (old_backup , new_backup) } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpQYDeWZ/main.rs:1:108
  |
1 | ...lt = { println ! ("=== Log Rotation System ===" . to_string ()) ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_ba...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpQYDeWZ/main.rs:1:292
  |
1 | ...ir = "/var/log/myapp" ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files { { { let ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `glob` in this scope
 --> /tmp/.tmpQYDeWZ/main.rs:1:286
  |
1 | ...mut log_dir = "/var/log/myapp" ; let mut log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; for log_file in log_files {...
  |                                                         ^^^^ not found in this scope

error[E0425]: cannot find function `file_size` in this scope
 --> /tmp/.tmpQYDeWZ/main.rs:1:383
  |
1 | ...())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , format ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpQYDeWZ/main.rs:1:551
  |
1 | ...at ! ("{}{}" , "Rotating " , log_file) , " (") + format_size (size) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i3...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpQYDeWZ/main.rs:1:793
  |
1 | ...p = format ! ("{}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 ...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpQYDeWZ/main.rs:1:806
  |
1 | ...}{}" , log_file , ".") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `rename_file` in this scope
 --> /tmp/.tmpQYDeWZ/main.rs:1:917
  |
1 | ...- 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `rename_file` in this scope
 --> /tmp/.tmpQYDeWZ/main.rs:1:1033
  |
1 | ...p_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (ba...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `compress_file` in this scope
 --> /tmp/.tmpQYDeWZ/main.rs:1:1101
  |
1 | ...e , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (b...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpQYDeWZ/main.rs:1:1307
  |
1 | ..."  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "  ...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpQYDeWZ/main.rs:1:1476
  |
1 | ...} } } ; println ! ("\n✅ Log rotation complete!" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_...
  |                                                       ^^^^^^^^^ not found in this scope

error: aborting due to 20 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0425, E0599.
For more information about an error, try `rustc --explain E0425`.



=== ch06-00-file-operations example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch06-00-file-operations example 9 ===
✗ Compilation failed: Compilation failed:
error[E0423]: expected value, found macro `try`
 --> /tmp/.tmpXUtjdM/main.rs:1:460
  |
1 | ...: No read permission for: " , path)) ; return false } } ; r#try ; { { let content = read_file (path) ; { process_content (content) ; r...
  |                                                              ^^^^^ not a value

error[E0425]: cannot find value `catch` in this scope
 --> /tmp/.tmpXUtjdM/main.rs:1:555
  |
1 | ...; { process_content (content) ; return true } } } ; catch ; error ; { println ! ("{}" , format ! ("{}{}" , "Error processing file: " ,...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpXUtjdM/main.rs:1:563
  |
1 | ...ess_content (content) ; return true } } } ; catch ; error ; { println ! ("{}" , format ! ("{}{}" , "Error processing file: " , error ....
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpXUtjdM/main.rs:1:638
  |
1 | ...}" , format ! ("{}{}" , "Error processing file: " , error . to_s ())) ; { let error_log = "errors.log" ; { let mut timestamp = current...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpXUtjdM/main.rs:1:863
  |
1 | ...{}" , timestamp . to_s () , ": ") + path , " - ") + error . to_s () , "\n")) ; return false } } } } } fn main () { }
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpXUtjdM/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn safe_file_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + st...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpXUtjdM/main.rs:1:215
  |
1 | ... fmt :: Debug + Clone > (path : T) -> T { { if ! file_exists (path) { { println ! ("{}" , format ! ("{}{}" , "Error: File not found: "...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpXUtjdM/main.rs:1:319
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { if ! file_exists (path) { { println ! ("{}" , format ! ("{}{}" , "Error: File not found: " , path)) ; return false } ...
  |       - expected this type parameter                                                                                                                - expected `T` because of return type                                                                              ^^^^^ expected type parameter `T`, found `bool`
  |
  = note: expected type parameter `T`
                       found type `bool`
  = note: the caller chooses a type for `T` which can be different from `bool`

error[E0425]: cannot find function `is_readable` in this scope
 --> /tmp/.tmpXUtjdM/main.rs:1:336
  |
1 | ... not found: " , path)) ; return false } } ; if ! is_readable (path) { { println ! ("{}" , format ! ("{}{}" , "Error: No read permissio...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpXUtjdM/main.rs:1:486
  |
1 | ...)) ; return false } } ; r#try ; { { let content = read_file (path) ; { process_content (content) ; return true } } } ; catch ; error ;...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `process_content` in this scope
 --> /tmp/.tmpXUtjdM/main.rs:1:507
  |
1 | ...r#try ; { { let content = read_file (path) ; { process_content (content) ; return true } } } ; catch ; error ; { println ! ("{}" , for...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

warning: unreachable statement
 --> /tmp/.tmpXUtjdM/main.rs:1:555
  |
1 | ...th) ; { process_content (content) ; return true } } } ; catch ; error ; { println ! ("{}" , format ! ("{}{}" , "Error processing file:...
  |                                        -----------         ^^^^^^^ unreachable statement
  |                                        |
  |                                        any code following this expression is unreachable
  |
  = note: `#[warn(unreachable_code)]` on by default

error[E0425]: cannot find function `current_datetime` in this scope
 --> /tmp/.tmpXUtjdM/main.rs:1:713
  |
1 | ...ror_log = "errors.log" ; { let mut timestamp = current_datetime () ; append_file (error_log , format ! ("{}{}" , format ! ("{}{}" , fo...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpXUtjdM/main.rs:1:847
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { if ! file_exists (path) { { println ! ("{}" , format ! ("{}{}" , "Error: File not found: " , path)) ; return false } } ; if ! is_readable (path) { { println ! ("{}" , format ! ("{}{}" , "Error: No read permission for: " , path)) ; return false } } ; r#try ; { { let content = read_file (path) ; { process_content (content) ; return true } } } ; catch ; error ; { println ! ("{}" , format ! ("{}{}" , "Error processing file: " , error . to_s ())) ; { let error_log = "errors.log" ; { let mut timestamp = current_datetime () ; append_file (error_log , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , timestamp . to_s () , ": ") + path , ...
  |       - found this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^^^^ expected `&str`, found type parameter `T`
  |
  = note:   expected reference `&str`
          found type parameter `T`

error[E0425]: cannot find function `append_file` in this scope
 --> /tmp/.tmpXUtjdM/main.rs:1:735
  |
1 | ...g" ; { let mut timestamp = current_datetime () ; append_file (error_log , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , tim...
  |                                                     ^^^^^^^^^^^ not found in this scope

error: aborting due to 13 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0308, E0423, E0425.
For more information about an error, try `rustc --explain E0308`.



=== ch06-00-file-operations example 10 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpHjQFl0/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files ("data" . to_string ()) ; for file in files { ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpHjQFl0/main.rs:1:138
  |
1 | ... { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } }...
  |       ^^                                                                                                                           ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files ("data" . to_string ()) ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files ("data" . to_string ()) ; for file in files { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpHjQFl0/main.rs:1:195
  |
1 | ...ze (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } } ; if let Some (s) = (& r...
  |                                       ^^                                                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files ("data" . to_string ()) ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files ("data" . to_string ()) ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `list_files` in this scope
 --> /tmp/.tmpHjQFl0/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files ("data" . to_string ()) ; for file in files { ...
  |                                                                                 ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_size` in this scope
 --> /tmp/.tmpHjQFl0/main.rs:1:153
  |
1 | ...o_string ()) ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "la...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `move_file` in this scope
 --> /tmp/.tmpHjQFl0/main.rs:1:197
  |
1 | ...ize = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } } ; if let So...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch20-00-tooling example 1 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpfZeJRj/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } }...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpfZeJRj/main.rs:1:72
  |
1 | ... calculate_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = ...
  |                                     ^^                                                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{}" , result) } } }
1 + use std :: collections :: HashMap ; fn calculate_something (x : i64) { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{}" , result) } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpfZeJRj/main.rs:1:156
  |
1 | ...eturn y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{}" , result) } } }
  |                                 ^^                                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{}" , result) } } }
1 + use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { let result = calculate_something (10i32) ; println ! ("{}" , result) } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpfZeJRj/main.rs:1:119
  |
1 | ...) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ;...
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot add `i32` to `i64`
 --> /tmp/.tmpfZeJRj/main.rs:1:117
  |
1 | ...) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ;...
  |                                                     ^ no implementation for `i64 + i32`
  |
  = help: the trait `Add<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Add<Rhs>`:
            `&i64` implements `Add<i64>`
            `&i64` implements `Add`
            `i64` implements `Add<&i64>`
            `i64` implements `Add`

error[E0308]: mismatched types
 --> /tmp/.tmpfZeJRj/main.rs:1:133
  |
1 | ...e_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate...
  |                         - help: try adding a return type: `-> i64`                      ^ expected `()`, found `i64`

error[E0308]: mismatched types
 --> /tmp/.tmpfZeJRj/main.rs:1:194
  |
1 | ... } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{}" , result) } } }
  |                                         -------------------  ^^^^^ expected `i64`, found `i32`
  |                                         |
  |                                         arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpfZeJRj/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } }...
  |                                        ^^^^^^^^^^^^^^^^^^^  -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{}" , result) } } }
1 + use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i64) ; println ! ("{}" , result) } } }
  |

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpfZeJRj/main.rs:1:221
  |
1 | ...te_something (10i32) ; println ! ("{}" , result) } } }
  |                                       --    ^^^^^^ `()` cannot be formatted with the default formatter
  |                                       |
  |                                       required by this formatting parameter
  |
  = help: the trait `std::fmt::Display` is not implemented for `()`
  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 5 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.



=== ch20-00-tooling example 2 ===
✗ Compilation failed: Compilation failed:
error[E0428]: the name `fibonacci` is defined multiple times
 --> /tmp/.tmpEs4H5h/main.rs:1:155
  |
1 | ... ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { ...
  |       ----------------------------- previous definition of the value `fibonacci` here                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `fibonacci` redefined here
  |
  = note: `fibonacci` must be defined only once in the value namespace of this module

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpEs4H5h/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpEs4H5h/main.rs:1:69
  |
1 | ...nacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) ...
  |                             ^^                                                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpEs4H5h/main.rs:1:86
  |
1 | use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n...
  |                                                                                      ^^ ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { n } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpEs4H5h/main.rs:1:101
  |
1 | ...) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if ...
  |                                               ^^                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpEs4H5h/main.rs:1:187
  |
1 | ...nacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |                             ^^                                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpEs4H5h/main.rs:1:204
  |
1 | ... 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } f...
  |                                                                    ^^ ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { n } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpEs4H5h/main.rs:1:219
  |
1 | ...) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |                                               ^^                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpEs4H5h/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n...
  |                                                                          -    ^^^^ expected `i64`, found `i32`
  |                                                                          |
  |                                                                          expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i64 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpEs4H5h/main.rs:1:118
  |
1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32...
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmpEs4H5h/main.rs:1:116
  |
1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32...
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmpEs4H5h/main.rs:1:141
  |
1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fib...
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmpEs4H5h/main.rs:1:139
  |
1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fib...
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmpEs4H5h/main.rs:1:197
  |
1 | ...2) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn ma...
  |                                                    -    ^^^^ expected `i64`, found `i32`
  |                                                    |
  |                                                    expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i64 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpEs4H5h/main.rs:1:236
  |
1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmpEs4H5h/main.rs:1:234
  |
1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmpEs4H5h/main.rs:1:259
  |
1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmpEs4H5h/main.rs:1:257
  |
1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error: aborting due to 11 previous errors; 7 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0428.
For more information about an error, try `rustc --explain E0277`.



=== ch20-00-tooling example 3 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpPeCf55/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpPeCf55/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                                                         ^^     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { a + b } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpPeCf55/main.rs:1:126
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                                                                                                              ^^     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { a * b } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpPeCf55/main.rs:1:168
  |
1 | ... { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32...
  |                                                 ^^^  ----   ---- expected `i64`, found `i32`
  |                                                      |
  |                                                      expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpPeCf55/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                        ^^^  -------   -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i64 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i64) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0423]: expected function, found macro `assert_eq`
 --> /tmp/.tmpPeCf55/main.rs:1:157
  |
1 | ...i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ;...
  |                                                           ^^^^^^^^^ not a function
  |
help: use `!` to invoke the macro
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq! (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                                                      +

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpPeCf55/main.rs:1:207
  |
1 | ..._eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply ()...
  |                                                ^^^  ------   ---- expected `i64`, found `i32`
  |                                                     |
  |                                                     expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpPeCf55/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                        ^^^  -------   -------
help: you can convert an `i32` to an `i64`
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add ((- 1i32).into() , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                                                                                                    +      ++++++++
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i64) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0423]: expected function, found macro `assert_eq`
 --> /tmp/.tmpPeCf55/main.rs:1:196
  |
1 | ...test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) }...
  |                                                           ^^^^^^^^^ not a function
  |
help: use `!` to invoke the macro
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq! (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                                                                                             +

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpPeCf55/main.rs:1:248
  |
1 | ...eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) ,...
  |                                                 ^^^  ----   ---- expected `i64`, found `i32`
  |                                                      |
  |                                                      expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpPeCf55/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                        ^^^  -------   -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i64 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i64) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0423]: expected function, found macro `assert_eq`
 --> /tmp/.tmpPeCf55/main.rs:1:237
  |
1 | ...32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (mul...
  |                                                           ^^^^^^^^^ not a function
  |
help: use `!` to invoke the macro
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                                                                                                                                      +

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpPeCf55/main.rs:1:313
  |
1 | ...2) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (...
  |                                              ^^^^^^^^  ----   ---- expected `i64`, found `i32`
  |                                                        |
  |                                                        expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpPeCf55/main.rs:1:88
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                                                                        ^^^^^^^^  -------   -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i64 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i64) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0423]: expected function, found macro `assert_eq`
 --> /tmp/.tmpPeCf55/main.rs:1:302
  |
1 | ...(add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32)...
  |                                                           ^^^^^^^^^ not a function
  |
help: use `!` to invoke the macro
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq! (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                       +

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpPeCf55/main.rs:1:357
  |
1 | ...tiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main ...
  |                                             ^^^^^^^^  ------   ---- expected `i64`, found `i32`
  |                                                       |
  |                                                       expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpPeCf55/main.rs:1:88
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                                                                        ^^^^^^^^  -------   -------
help: you can convert an `i32` to an `i64`
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply ((- 1i32).into() , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                               +      ++++++++
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i64) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0423]: expected function, found macro `assert_eq`
 --> /tmp/.tmpPeCf55/main.rs:1:346
  |
1 | ...ply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100...
  |                                                           ^^^^^^^^^ not a function
  |
help: use `!` to invoke the macro
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                   +

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpPeCf55/main.rs:1:405
  |
1 | ...y (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                             ^^^^^^^^  ----   ------ expected `i64`, found `i32`
  |                                                       |
  |                                                       expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpPeCf55/main.rs:1:88
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                                                                        ^^^^^^^^  -------   -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i64 , 100i32) , 0i32) } } fn main () { }
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i64) , 0i32) } } fn main () { }
  |

error[E0423]: expected function, found macro `assert_eq`
 --> /tmp/.tmpPeCf55/main.rs:1:394
  |
1 | ...i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                           ^^^^^^^^^ not a function
  |
help: use `!` to invoke the macro
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                   +

error: aborting due to 12 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0308, E0423.
For more information about an error, try `rustc --explain E0308`.



=== ch20-00-tooling example 4 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmptWMKMM/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { { ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmptWMKMM/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { { ...
  |                                                                                ^^ ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } } fn main () { }
1 + use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { s } fn property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmptWMKMM/main.rs:1:136
  |
1 | ...se_twice_is_identity () { { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } } fn main () { }
  |                              ^^                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } } fn main () { }
1 + use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } fn main () { }
  |

error[E0423]: expected function, found macro `assert_eq`
 --> /tmp/.tmptWMKMM/main.rs:1:161
  |
1 | ...everse_twice_is_identity () { { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } } fn main () { }
  |                                                           ^^^^^^^^^ not a function
  |
help: use `!` to invoke the macro
  |
1 | use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq! (reverse_string (reverse_string (s)) , s) }) } } fn main () { }
  |                                                                                                                                                                          +

error[E0425]: cannot find function `property_test` in this scope
 --> /tmp/.tmptWMKMM/main.rs:1:138
  |
1 | ... property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } } fn m...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error: aborting due to 2 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0423, E0425.
For more information about an error, try `rustc --explain E0423`.



=== ch20-00-tooling example 5 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp7vtXcR/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative number...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp7vtXcR/main.rs:1:85
  |
1 | ...i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers" . to_string ()) } } ; if n == 0i32 || n == 1i32 ...
  |                                  ^^                                                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { panic ! ("Factorial not defined for negative numbers" . to_string ()) } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7vtXcR/main.rs:1:191
  |
1 | ...ive numbers" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                                   ^^    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers" . to_string ()) } } ; if n == 0i32 || n == 1i32 { 1i32 } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7vtXcR/main.rs:1:209
  |
1 | ... } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                         ^^                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { n * factorial (n - 1i32) } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp7vtXcR/main.rs:1:78
  |
1 | use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative number...
  |                                                                          -   ^^^^ expected `i64`, found `i32`
  |                                                                          |
  |                                                                          expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i64 { { panic ! ("Factorial not defined for negative numbers" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp7vtXcR/main.rs:1:171
  |
1 | ... for negative numbers" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main ...
  |                                                    -    ^^^^ expected `i64`, found `i32`
  |                                                    |
  |                                                    expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers" . to_string ()) } } ; if n == 0i64 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp7vtXcR/main.rs:1:184
  |
1 | ... numbers" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                    -    ^^^^ expected `i64`, found `i32`
  |                                                    |
  |                                                    expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers" . to_string ()) } } ; if n == 0i32 || n == 1i64 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp7vtXcR/main.rs:1:193
  |
1 | ...-> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } ...
  |       --- expected `i64` because of return type                                                                                         ^^^^ expected `i64`, found `i32`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i64 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp7vtXcR/main.rs:1:230
  |
1 | ...n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmp7vtXcR/main.rs:1:228
  |
1 | ...n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error: aborting due to 6 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.



=== ch20-00-tooling example 6 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmpTDeiMK/main.rs:1:276
  |
1 | ... { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_rec...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpTDeiMK/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpTDeiMK/main.rs:1:79
  |
1 | ... i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_...
  |                   ^^                                                                                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTDeiMK/main.rs:1:96
  |
1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - ...
  |                                                                                                ^^ ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { n } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTDeiMK/main.rs:1:111
  |
1 | ... { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n :...
  |                                     ^^                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTDeiMK/main.rs:1:288
  |
1 | ... ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { ben...
  |                                               ^^                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { let temp = a + b ; { a = b ; b = temp } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTDeiMK/main.rs:1:374
  |
1 | ...bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib...
  |                             ^^                                                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTDeiMK/main.rs:1:489
  |
1 | ...bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |                             ^^                                                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpTDeiMK/main.rs:1:89
  |
1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - ...
  |                                                                                    -    ^^^^ expected `i64`, found `i32`
  |                                                                                    |
  |                                                                                    expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i64 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpTDeiMK/main.rs:1:138
  |
1 | ...= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> ...
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmpTDeiMK/main.rs:1:136
  |
1 | ...= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> ...
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmpTDeiMK/main.rs:1:171
  |
1 | ...ci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mu...
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmpTDeiMK/main.rs:1:169
  |
1 | ...ci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mu...
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmpTDeiMK/main.rs:1:340
  |
1 | ...) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn b...
  |         --- expected `i64` because of return type                                                                              ^ expected `i64`, found `i32`
  |
help: you can convert an `i32` to an `i64`
  |
1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a.into() } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                     +++++++

error[E0308]: mismatched types
 --> /tmp/.tmpTDeiMK/main.rs:1:449
  |
1 | ...ci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . ...
  |                                         -------------------  ^^^^^ expected `i64`, found `i32`
  |                                         |
  |                                         arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpTDeiMK/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - ...
  |                                        ^^^^^^^^^^^^^^^^^^^  -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i64)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

error[E0423]: expected function, found attribute macro `bench`
 --> /tmp/.tmpTDeiMK/main.rs:1:376
  |
1 | ...; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i3...
  |                                                             ^^^^^ not a function

error[E0308]: mismatched types
 --> /tmp/.tmpTDeiMK/main.rs:1:564
  |
1 | ...ci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |                                         -------------------  ^^^^^ expected `i64`, found `i32`
  |                                         |
  |                                         arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpTDeiMK/main.rs:1:188
  |
1 | ...- 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for...
  |                                                        ^^^^^^^^^^^^^^^^^^^  -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i64)) } } fn main () { }
  |

error[E0423]: expected function, found attribute macro `bench`
 --> /tmp/.tmpTDeiMK/main.rs:1:491
  |
1 | ...cci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i3...
  |                                                             ^^^^^ not a function

error: aborting due to 11 previous errors; 7 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0423, E0425.
For more information about an error, try `rustc --explain E0277`.



=== ch07-00-building-applications example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch07-00-building-applications example 2 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmpirQFgi/main.rs:1:709
  |
1 | ... = { name : "MyApp" , version : "1.0.0" , config_dir : "~/.config/myapp" , data_dir : "~/.local/share/myapp" , cache_dir : "~/.cache/myapp" , } ; ...
  |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | use std :: collections :: HashMap ; fn create_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , email : T) -> T { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{}" , format ! ("{}{}" , "Member since: " , user . created)) } } fn main () { let mut APP = { SomeStruct { name : "MyApp" , version : "1.0.0" , config_dir : "~/.config/myapp" , data_dir : "~/.local/share/myapp" , cache_dir : "~/.cache/myapp" , } } ; let mut User = { id : null , name : "" , email : "" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ++++++++++++                                                                                                                                              +

error: struct literal body without path
 --> /tmp/.tmpirQFgi/main.rs:1:867
  |
1 | ..."~/.cache/myapp" , } ; let mut User = { id : null , name : "" , email : "" , created : null , } ; { init_app () ; load_config () ; run...
  |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | use std :: collections :: HashMap ; fn create_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , email : T) -> T { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{}" , format ! ("{}{}" , "Member since: " , user . created)) } } fn main () { let mut APP = { name : "MyApp" , version : "1.0.0" , config_dir : "~/.config/myapp" , data_dir : "~/.local/share/myapp" , cache_dir : "~/.cache/myapp" , } ; let mut User = { SomeStruct { id : null , name : "" , email : "" , created : null , } } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ++++++++++++                                                           +

error[E0425]: cannot find value `User` in this scope
 --> /tmp/.tmpirQFgi/main.rs:1:227
  |
1 | ...Clone > (name : T , email : T) -> T { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . ema...
  |                                                         ^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpirQFgi/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn create_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpirQFgi/main.rs:1:212
  |
1 | ... { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } ...
  |       ^^                                                                                                                                                                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn create_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , email : T) -> T { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{}" , format ! ("{}{}" , "Member since: " , user . created)) } } fn main () { let mut APP = { name : "MyApp" , version : "1.0.0" , config_dir : "~/.config/myapp" , data_dir : "~/.local/share/myapp" , cache_dir : "~/.cache/myapp" , } ; let mut User = { id : null , name : "" , email : "" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
1 + use std :: collections :: HashMap ; fn create_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , email : T) -> T { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } fn display_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{}" , format ! ("{}{}" , "Member since: " , user . created)) } } fn main () { let mut APP = { name : "MyApp" , version : "1.0.0" , config_dir : "~/.config/myapp" , data_dir : "~/.local/share/myapp" , cache_dir : "~/.cache/myapp" , } ; let mut User = { id : null , name : "" , email : "" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |

error[E0425]: cannot find function `generate_uuid` in this scope
 --> /tmp/.tmpirQFgi/main.rs:1:258
  |
1 | ...{ { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = curren...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `current_datetime` in this scope
 --> /tmp/.tmpirQFgi/main.rs:1:338
  |
1 | ...name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user < T : std :: ops :: Add < Out...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0609]: no field `name` on type `T`
 --> /tmp/.tmpirQFgi/main.rs:1:582
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! ("User: {} ({})" , user . name , ...
  |       - type parameter 'T' declared here                                                                                                                                                      ^^^^ unknown field

error[E0609]: no field `email` on type `T`
 --> /tmp/.tmpirQFgi/main.rs:1:596
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! ("User: {} ({})" , user . name , user . email) ;...
  |       - type parameter 'T' declared here                                                                                                                                                                    ^^^^^ unknown field

error[E0609]: no field `created` on type `T`
 --> /tmp/.tmpirQFgi/main.rs:1:668
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{}" , format ! ("{}{}" , "Member since: " , user . created)) ...
  |       - type parameter 'T' declared here                                                                                                                                                                                                                                            ^^^^^^^ unknown field

error[E0308]: mismatched types
 --> /tmp/.tmpirQFgi/main.rs:1:605
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{}" , format ! ("{}{}" , "Member since: " , user . created)) } ...
  |       - expected this type parameter                                                                                                                                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `init_app` in this scope
 --> /tmp/.tmpirQFgi/main.rs:1:929
  |
1 | ... , name : "" , email : "" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `load_config` in this scope
 --> /tmp/.tmpirQFgi/main.rs:1:943
  |
1 | ...mail : "" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `run_event_loop` in this scope
 --> /tmp/.tmpirQFgi/main.rs:1:960
  |
1 | ...d : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `cleanup` in this scope
 --> /tmp/.tmpirQFgi/main.rs:1:980
  |
1 | ...init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 13 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0308, E0425, E0609.
For more information about an error, try `rustc --explain E0308`.



=== ch07-00-building-applications example 3 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmpPfkhdI/main.rs:1:693
  |
1 | ... () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { SomeStruct { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ++++++++++++                                                                                           +

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpPfkhdI/main.rs:1:214
  |
1 | ...t :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () ...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpPfkhdI/main.rs:1:236
  |
1 | ...key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty {...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpPfkhdI/main.rs:1:303
  |
1 | ... true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `APP` in this scope
 --> /tmp/.tmpPfkhdI/main.rs:1:351
  |
1 | ...{ if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_jso...
  |                                                         ^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpPfkhdI/main.rs:1:435
  |
1 | ...to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file ...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpPfkhdI/main.rs:1:445
  |
1 | ...()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_pat...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `APP` in this scope
 --> /tmp/.tmpPfkhdI/main.rs:1:530
  |
1 | ...} fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { S...
  |                                                         ^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpPfkhdI/main.rs:1:610
  |
1 | ..." . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE =...
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpPfkhdI/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fm...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpPfkhdI/main.rs:1:298
  |
1 | ... { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } ...
  |       ^^                                                                                                                                                                              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
1 + use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpPfkhdI/main.rs:1:319
  |
1 | ... { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } ...
  |       ^^                                                                                                                                                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
1 + use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpPfkhdI/main.rs:1:498
  |
1 | ... { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } ...
  |       ^^                                                                                                                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
1 + use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } fn main () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpPfkhdI/main.rs:1:608
  |
1 | ...string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { user...
  |                                               ^^                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
1 + use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { STATE = parse_json (read_file (state_file)) } } } } fn main () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
  |

error[E0425]: cannot find function `trigger_save` in this scope
 --> /tmp/.tmpPfkhdI/main.rs:1:259
  |
1 | ...{ { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpPfkhdI/main.rs:1:340
  |
1 | ...te () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_json` in this scope
 --> /tmp/.tmpPfkhdI/main.rs:1:426
  |
1 | ...json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let sta...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpPfkhdI/main.rs:1:401
  |
1 | ...ate.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let...
  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `state_file`

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpPfkhdI/main.rs:1:519
  |
1 | ...} } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_fil...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpPfkhdI/main.rs:1:581
  |
1 | ...P . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpPfkhdI/main.rs:1:630
  |
1 | ... file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { users : vec ! [] , ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `parse_json` in this scope
 --> /tmp/.tmpPfkhdI/main.rs:1:618
  |
1 | ...ing ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { users :...
  |                                                      ^^^^^^^^^^ not found in this scope

error: aborting due to 17 previous errors; 5 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-building-applications example 4 ===
✗ Compilation failed: Compilation failed:
error[E0423]: expected value, found macro `try`
 --> /tmp/.tmpwPQpHo/main.rs:1:234
  |
1 | ... Clone > (operation_fn : T , fallback_value : T) -> T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; r...
  |                                                              ^^^^^ not a value

error[E0425]: cannot find value `catch` in this scope
 --> /tmp/.tmpwPQpHo/main.rs:1:271
  |
1 | ... : T) -> T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < ...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpwPQpHo/main.rs:1:279
  |
1 | ... T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std ...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpwPQpHo/main.rs:1:300
  |
1 | ...rn operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Outpu...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmpwPQpHo/main.rs:1:543
  |
1 | ..._fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0423]: expected value, found macro `try`
 --> /tmp/.tmpwPQpHo/main.rs:1:568
  |
1 | ...pts : T) -> T { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_att...
  |                                                              ^^^^^ not a value

error[E0425]: cannot find value `catch` in this scope
 --> /tmp/.tmpwPQpHo/main.rs:1:605
  |
1 | ..._attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , format !...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpwPQpHo/main.rs:1:613
  |
1 | ...s) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , format ! ("{}{}"...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpwPQpHo/main.rs:1:780
  |
1 | ...fter " , max_attempts . to_s ()) , " attempts: ") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; ...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpwPQpHo/main.rs:1:808
  |
1 | ... ()) , " attempts: ") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Att...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `sleep` in this scope
 --> /tmp/.tmpwPQpHo/main.rs:1:958
  |
1 | ...retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::sleep;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpwPQpHo/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn safe_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpwPQpHo/main.rs:1:526
  |
1 | ... { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Failed after " , max_attempts . to_s ()) , " attempts: ") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn safe_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , fallback_value : T) -> T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Failed after " , max_attempts . to_s ()) , " attempts: ") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn safe_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , fallback_value : T) -> T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Failed after " , max_attempts . to_s ()) , " attempts: ") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } fn main () { }
  |

error[E0618]: expected function, found `T`
 --> /tmp/.tmpwPQpHo/main.rs:1:251
  |
1 | ... Clone > (operation_fn : T , fallback_value : T) -> T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; r...
  |              ------------                                                     ^^^^^^^^^^^^---
  |              |                                                                |
  |              `operation_fn` has type `T`                                      call expression requires function

warning: unreachable statement
 --> /tmp/.tmpwPQpHo/main.rs:1:271
  |
1 | ..._value : T) -> T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_re...
  |                                   ----------------------     ^^^^^^^ unreachable statement
  |                                   |
  |                                   any code following this expression is unreachable
  |
  = note: `#[warn(unreachable_code)]` on by default

error[E0425]: cannot find function `log_error` in this scope
 --> /tmp/.tmpwPQpHo/main.rs:1:289
  |
1 | ... ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Ad...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0618]: expected function, found `T`
 --> /tmp/.tmpwPQpHo/main.rs:1:585
  |
1 | ...one > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catc...
  |           ------------                                                                                           ^^^^^^^^^^^^---
  |           |                                                                                                      |
  |           `operation_fn` has type `T`                                                                            call expression requires function

warning: unreachable statement
 --> /tmp/.tmpwPQpHo/main.rs:1:605
  |
1 | ...e (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , fo...
  |                                   ----------------------     ^^^^^^^ unreachable statement
  |                                   |
  |                                   any code following this expression is unreachable

error[E0369]: cannot subtract `i32` from `T`
 --> /tmp/.tmpwPQpHo/main.rs:1:650
  |
1 | ...rn operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , ...
  |                                                           ------------ ^ ---- i32
  |                                                           |
  |                                                           T
  |
help: consider further restricting type parameter `T` with trait `Sub`
  |
1 | use std :: collections :: HashMap ; fn safe_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , fallback_value : T) -> T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Sub<i32> > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Failed after " , max_attempts . to_s ()) , " attempts: ") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ++++++++++++++++++++

error[E0599]: no method named `to_s` found for type parameter `T` in the current scope
 --> /tmp/.tmpwPQpHo/main.rs:1:752
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Failed after " , max_attempts . to_s ())...
  |       - method `to_s` not found for this type parameter                                                                                                                                                                                                                                                                                                                                                               ^^^^ method not found in `T`

error[E0308]: mismatched types
 --> /tmp/.tmpwPQpHo/main.rs:1:938
  |
1 | ...Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }
  |                                                       ^^^^ expected `u32`, found `i32`

error[E0277]: cannot add `i32` to `u32`
 --> /tmp/.tmpwPQpHo/main.rs:1:936
  |
1 | ...Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }
  |                                                     ^ no implementation for `u32 + i32`
  |
  = help: the trait `Add<i32>` is not implemented for `u32`
  = help: the following other types implement trait `Add<Rhs>`:
            `&u32` implements `Add<u32>`
            `&u32` implements `Add`
            `u32` implements `Add<&u32>`
            `u32` implements `Add`

error[E0308]: mismatched types
 --> /tmp/.tmpwPQpHo/main.rs:1:528
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Failed after " , max_attempts . to_s ()) , " attempts: ") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } }...
  |       -                                                                                                                                                                        -     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |       |                                                                                                                                                                        |
  |       expected this type parameter                                                                                                                                             expected `T` because of return type
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: the caller chooses a type for `T` which can be different from `()`
  = note: `for` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | use std :: collections :: HashMap ; fn safe_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , fallback_value : T) -> T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Failed after " , max_attempts . to_s ()) , " attempts: ") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } /* `T` value */ } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     +++++++++++++++

error: aborting due to 19 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0369, E0423, E0425, E0599, E0618.
For more information about an error, try `rustc --explain E0277`.



=== ch07-00-building-applications example 5 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmpCXSCym/main.rs:1:1136
  |
1 | ...swords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_password...
  |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { SomeStruct { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ++++++++++++                                                                                                        +

error: expected `,`, found `.`
 --> /tmp/.tmpCXSCym/main.rs:1:1686
  |
1 | ...d (password) ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } el...
  |                                                                 ^ expected `,`

error: argument never used
 --> /tmp/.tmpCXSCym/main.rs:1:1688
  |
1 | ...lipboard (password) ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } }...
  |                                     ----------------------------------   ^^^^^^^^^^^^ argument never used
  |                                     |
  |                                     formatting specifier missing

error[E0425]: cannot find value `MASTER_KEY` in this scope
 --> /tmp/.tmpCXSCym/main.rs:1:1596
  |
1 | ... { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboa...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `null` in this scope
 --> /tmp/.tmpCXSCym/main.rs:1:1885
  |
1 | ..., site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" ; }
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::ptr::null;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpCXSCym/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpCXSCym/main.rs:1:206
  |
1 | ... { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } ...
  |       ^^                                                                                                                                                                                                                                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" ; }
1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpCXSCym/main.rs:1:290
  |
1 | ... enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base...
  |                    ^^                                                                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" ; }
1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpCXSCym/main.rs:1:612
  |
1 | ... { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } ...
  |       ^^                                                                                                                                                                                                                                                                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" ; }
1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpCXSCym/main.rs:1:730
  |
1 | ...merate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return d...
  |                ^^                                                                                                         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" ; }
1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpCXSCym/main.rs:1:1075
  |
1 | ... { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } ...
  |       ^^                                                                                                                                                                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" ; }
1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpCXSCym/main.rs:1:1440
  |
1 | ... { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" ; }
1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpCXSCym/main.rs:1:1512
  |
1 | ... { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } e...
  |       ^^                                                                                                                                                                                                                                                 ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" ; }
1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpCXSCym/main.rs:1:1766
  |
1 | ...clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut ...
  |                                 ^^                                                                         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" ; }
1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" ; }
  |

error[E0599]: no method named `chars` found for type parameter `T` in the current scope
 --> /tmp/.tmpCXSCym/main.rs:1:264
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars ()...
  |       - method `chars` not found for this type parameter                                                                                                                                                                    ^^^^^ method not found in `T`

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpCXSCym/main.rs:1:324
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                  ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" ; }
  |                                                                                                                                                                                +++++++++++++++++++

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpCXSCym/main.rs:1:313
  |
1 | ...n text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) ...
  |                                                              ^^^^^^^^^^^^^^^^^^

error[E0425]: cannot find function `base64_encode` in this scope
 --> /tmp/.tmpCXSCym/main.rs:1:404
  |
1 | ... . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + ...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `base64_decode` in this scope
 --> /tmp/.tmpCXSCym/main.rs:1:628
  |
1 | ...encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes ....
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpCXSCym/main.rs:1:764
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                                                         ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = "~/.passwords.enc" ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 +++++++++++++++++++

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpCXSCym/main.rs:1:753
  |
1 | ... , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . cod...
  |                                                              ^^^^^^^^^^^^^^^^^^

error[E0425]: cannot find function `char_from_code` in this scope
 --> /tmp/.tmpCXSCym/main.rs:1:792
  |
1 | ...ar = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } }...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `load_passwords` in this scope
 --> /tmp/.tmpCXSCym/main.rs:1:1095
  |
1 | ... : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (p...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `save_passwords` in this scope
 --> /tmp/.tmpCXSCym/main.rs:1:1241
  |
1 | ...STER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = ...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `load_passwords` in this scope
 --> /tmp/.tmpCXSCym/main.rs:1:1460
  |
1 | ... } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords ()...
  |       ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- similarly named function `add_password` defined here                                                                                                                                                                                                                                                                                                                                               ^^^^^^^^^^^^^^ help: a function with a similar name exists: `add_password`

error[E0425]: cannot find function `copy_to_clipboard` in this scope
 --> /tmp/.tmpCXSCym/main.rs:1:1610
  |
1 | ...d = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!" . to_string (...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpCXSCym/main.rs:1:1688
  |
1 | ... ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { print...
  |                                                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `clear_clipboard` in this scope
 --> /tmp/.tmpCXSCym/main.rs:1:1731
  |
1 | ..." . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `spawn_after` in this scope
 --> /tmp/.tmpCXSCym/main.rs:1:1704
  |
1 | ...Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , form...
  |                                                      ^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpCXSCym/main.rs:1:1768
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , format ! ("{}{}" , "❌ No password found for " , site)) } } ...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 21 previous errors; 9 warnings emitted

Some errors have detailed explanations: E0308, E0425, E0599, E0608.
For more information about an error, try `rustc --explain E0308`.



=== ch07-00-building-applications example 6 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmpFNMSNl/main.rs:1:261
  |
1 | ... let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TR...
  |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { SomeStruct { date : current_date () , amount : amount , category : category , description : description , } } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
  |                                                                                                                                                                                                                                                                     ++++++++++++                                                                                                  +

error[E0425]: cannot find value `TRANSACTIONS_FILE` in this scope
 --> /tmp/.tmpFNMSNl/main.rs:1:374
  |
1 | ...description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `report_data` in this scope
 --> /tmp/.tmpFNMSNl/main.rs:1:1817
  |
1 | ...t_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , format ! ("{}{}" , "\n📄 Report saved to " , report_fi...
  |                                                     ^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpFNMSNl/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std ::...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpFNMSNl/main.rs:1:239
  |
1 | ... { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
1 + use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpFNMSNl/main.rs:1:988
  |
1 | ... { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
1 + use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpFNMSNl/main.rs:1:1298
  |
1 | ... { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
1 + use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
  |

error[E0425]: cannot find function `append_csv` in this scope
 --> /tmp/.tmpFNMSNl/main.rs:1:362
  |
1 | ...ry : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_t...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `get_monthly_total` in this scope
 --> /tmp/.tmpFNMSNl/main.rs:1:433
  |
1 | ...FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if m...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `get_budget_limit` in this scope
 --> /tmp/.tmpFNMSNl/main.rs:1:487
  |
1 | ...thly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (fo...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `send_notification` in this scope
 --> /tmp/.tmpFNMSNl/main.rs:1:553
  |
1 | ...tegory) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpFNMSNl/main.rs:1:629
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } ...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `load_transactions` in this scope
 --> /tmp/.tmpFNMSNl/main.rs:1:1011
  |
1 | ... ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (m...
  |       ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- similarly named function `add_transaction` defined here                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^^^^^^^^^^^^^^^^^ help: a function with a similar name exists: `add_transaction`

error[E0425]: cannot find function `group_by` in this scope
 --> /tmp/.tmpFNMSNl/main.rs:1:1063
  |
1 | ...oad_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{}" , format ! ("...
  |                                                       ^^^^^^^^ not found in this scope

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmpFNMSNl/main.rs:1:1213
  |
1 | ..." , "\n📊 Budget Report for " , month)) ; println ! ("{}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category ...
  |                                                                --- ^ ----- i32
  |                                                                |
  |                                                                &str

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmpFNMSNl/main.rs:1:1477
  |
1 | ...otal ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $")...
  |                                                        ^^^^ method not found in `i32`

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpFNMSNl/main.rs:1:1436
  |
1 | ... sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , form...
  |                                              ^^^^^^^ doesn't have a size known at compile-time
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: all local variables must have a statically known size

error[E0308]: mismatched types
 --> /tmp/.tmpFNMSNl/main.rs:1:1596
  |
1 | ...tegory , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , format ! ("{}{}" ...
  |                                                       ^^^ expected `&str`, found `str`
  |
help: consider borrowing here
  |
1 | use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") + monthly_spent . to_s () , "/$") + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + &bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             +

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmpFNMSNl/main.rs:1:1633
  |
1 | ..._total . to_s () , " ") + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , format ! ("{}{}" , "Total:          $" , t...
  |                                                               --- ^ ----- i32
  |                                                               |
  |                                                               &str

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpFNMSNl/main.rs:1:1711
  |
1 | ... , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; gene...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `generate_pdf` in this scope
 --> /tmp/.tmpFNMSNl/main.rs:1:1789
  |
1 | ...le = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , format ! ("{}{}" , "\n📄 R...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpFNMSNl/main.rs:1:1832
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , "category" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{}" , "=" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") + category_total . to_s () , " ") + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let mut report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } ...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

warning: unused variable: `TRANSACTIONS_FILE`
 --> /tmp/.tmpFNMSNl/main.rs:1:1937
  |
1 | ...main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Ent...
  |                      ^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_TRANSACTIONS_FILE`
  |
  = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `CATEGORIES`
 --> /tmp/.tmpFNMSNl/main.rs:1:1996
  |
1 | ...nsactions.csv" ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
  |                             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_CATEGORIES`

warning: variable does not need to be mutable
 --> /tmp/.tmpFNMSNl/main.rs:1:1933
  |
1 | ... saved to " , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = "~/.budget/transactions.csv" ; let mut CATEGORIES = vec !...
  |                                                         ----^^^^^^^^^^^^^^^^^
  |                                                         |
  |                                                         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

warning: variable does not need to be mutable
 --> /tmp/.tmpFNMSNl/main.rs:1:1992
  |
1 | ...ANSACTIONS_FILE = "~/.budget/transactions.csv" ; let mut CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other...
  |                                                         ----^^^^^^^^^^
  |                                                         |
  |                                                         help: remove this `mut`

error: aborting due to 18 previous errors; 8 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0369, E0425, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch07-00-building-applications example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch07-00-building-applications example 8 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmpg19VvQ/main.rs:1:501
  |
1 | ... } } } fn test_data_persistence () { { { let test_data = { test : "value" , } ; { let mut test_file = "test_data.json" ; save_json (te...
  |                                                             ^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert (user . name == "Alice" , "Name should be set" . to_string ()) ; assert (user . email == "alice@example.com" , "Email should be set" . to_string ()) ; assert (user . id != null , "ID should be generated" . to_string ()) ; println ! ("✅ test_user_creation passed" . to_string ()) } } } } fn test_data_persistence () { { { let test_data = { SomeStruct { test : "value" , } } ; { let mut test_file = "test_data.json" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should be created" . to_string ()) ; let mut loaded = load_json (test_file) ; assert (loaded . test == "value" , "Data should persist" . to_string ()) ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed" . to_string ()) } } } } fn run_all_tests () { { println ! ("🧪 Running application tests..." . to_string ()) ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!" . to_string ()) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ++++++++++++                      +

error: expected `,`, found `.`
 --> /tmp/.tmpg19VvQ/main.rs:1:427
  |
1 | ... . to_string ()) ; println ! ("✅ test_user_creation passed" . to_string ()) } } } } fn test_data_persistence () { { { let test_data = {...
  |                                                                 ^ expected `,`

error: argument never used
 --> /tmp/.tmpg19VvQ/main.rs:1:429
  |
1 | ...ated" . to_string ()) ; println ! ("✅ test_user_creation passed" . to_string ()) } } } } fn test_data_persistence () { { { let test_dat...
  |                                       ------------------------------   ^^^^^^^^^^^^ argument never used
  |                                       |
  |                                       formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpg19VvQ/main.rs:1:864
  |
1 | ...e (test_file) ; println ! ("✅ test_data_persistence passed" . to_string ()) } } } } fn run_all_tests () { { println ! ("🧪 Running applic...
  |                                                                 ^ expected `,`

error: argument never used
 --> /tmp/.tmpg19VvQ/main.rs:1:866
  |
1 | ...ve_file (test_file) ; println ! ("✅ test_data_persistence passed" . to_string ()) } } } } fn run_all_tests () { { println ! ("🧪 Running ...
  |                                     ---------------------------------   ^^^^^^^^^^^^ argument never used
  |                                     |
  |                                     formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpg19VvQ/main.rs:1:956
  |
1 | ...ll_tests () { { println ! ("🧪 Running application tests..." . to_string ()) ; test_user_creation () ; test_data_persistence () ; test_e...
  |                                                                 ^ expected `,`

error: argument never used
 --> /tmp/.tmpg19VvQ/main.rs:1:958
  |
1 | ... run_all_tests () { { println ! ("🧪 Running application tests..." . to_string ()) ; test_user_creation () ; test_data_persistence () ; ...
  |                                     ---------------------------------   ^^^^^^^^^^^^ argument never used
  |                                     |
  |                                     formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpg19VvQ/main.rs:1:1107
  |
1 | ... ; test_performance () ; println ! ("\n✅ All tests passed!" . to_string ()) } } fn main () { }
  |                                                                 ^ expected `,`

error: argument never used
 --> /tmp/.tmpg19VvQ/main.rs:1:1109
  |
1 | ...() ; test_performance () ; println ! ("\n✅ All tests passed!" . to_string ()) } } fn main () { }
  |                                          ------------------------   ^^^^^^^^^^^^ argument never used
  |                                          |
  |                                          formatting specifier missing

error[E0425]: cannot find value `null` in this scope
 --> /tmp/.tmpg19VvQ/main.rs:1:336
  |
1 | ...hould be set" . to_string ()) ; assert (user . id != null , "ID should be generated" . to_string ()) ; println ! ("✅ test_user_creation...
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::ptr::null;
  |

error[E0425]: cannot find function `remove_file` in this scope
 --> /tmp/.tmpg19VvQ/main.rs:1:794
  |
1 | ...value" , "Data should persist" . to_string ()) ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed" . to_string ()) ...
  |                                                     ^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_file;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpg19VvQ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" ....
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpg19VvQ/main.rs:1:64
  |
1 | ... { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert (user . name == "Alice" , "Name should be set" . to_string ()) ; assert (user . email == "alice@example.com" , "Email should be set" . to_string ()) ; assert (user . id != null , "ID should be generated" . to_string ()) ; println ! ("✅ test_user_creation passed" . to_string ()) } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert (user . name == "Alice" , "Name should be set" . to_string ()) ; assert (user . email == "alice@example.com" , "Email should be set" . to_string ()) ; assert (user . id != null , "ID should be generated" . to_string ()) ; println ! ("✅ test_user_creation passed" . to_string ()) } } } } fn test_data_persistence () { { { let test_data = { test : "value" , } ; { let mut test_file = "test_data.json" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should be created" . to_string ()) ; let mut loaded = load_json (test_file) ; assert (loaded . test == "value" , "Data should persist" . to_string ()) ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed" . to_string ()) } } } } fn run_all_tests () { { println ! ("🧪 Running application tests..." . to_string ()) ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!" . to_string ()) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_user_creation () { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert (user . name == "Alice" , "Name should be set" . to_string ()) ; assert (user . email == "alice@example.com" , "Email should be set" . to_string ()) ; assert (user . id != null , "ID should be generated" . to_string ()) ; println ! ("✅ test_user_creation passed" . to_string ()) } } } fn test_data_persistence () { { { let test_data = { test : "value" , } ; { let mut test_file = "test_data.json" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should be created" . to_string ()) ; let mut loaded = load_json (test_file) ; assert (loaded . test == "value" , "Data should persist" . to_string ()) ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed" . to_string ()) } } } } fn run_all_tests () { { println ! ("🧪 Running application tests..." . to_string ()) ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!" . to_string ()) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpg19VvQ/main.rs:1:481
  |
1 | ... { { { let test_data = { test : "value" , } ; { let mut test_file = "test_data.json" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should be created" . to_string ()) ; let mut loaded = load_json (test_file) ; assert (loaded . test == "value" , "Data should persist" . to_string ()) ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed" . to_string ()) } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                 ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert (user . name == "Alice" , "Name should be set" . to_string ()) ; assert (user . email == "alice@example.com" , "Email should be set" . to_string ()) ; assert (user . id != null , "ID should be generated" . to_string ()) ; println ! ("✅ test_user_creation passed" . to_string ()) } } } } fn test_data_persistence () { { { let test_data = { test : "value" , } ; { let mut test_file = "test_data.json" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should be created" . to_string ()) ; let mut loaded = load_json (test_file) ; assert (loaded . test == "value" , "Data should persist" . to_string ()) ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed" . to_string ()) } } } } fn run_all_tests () { { println ! ("🧪 Running application tests..." . to_string ()) ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!" . to_string ()) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert (user . name == "Alice" , "Name should be set" . to_string ()) ; assert (user . email == "alice@example.com" , "Email should be set" . to_string ()) ; assert (user . id != null , "ID should be generated" . to_string ()) ; println ! ("✅ test_user_creation passed" . to_string ()) } } } } fn test_data_persistence () { { let test_data = { test : "value" , } ; { let mut test_file = "test_data.json" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should be created" . to_string ()) ; let mut loaded = load_json (test_file) ; assert (loaded . test == "value" , "Data should persist" . to_string ()) ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed" . to_string ()) } } } fn run_all_tests () { { println ! ("🧪 Running application tests..." . to_string ()) ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!" . to_string ()) } } fn main () { }
  |

error[E0425]: cannot find function `create_user` in this scope
 --> /tmp/.tmpg19VvQ/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" ....
  |                                                                               ^^^^^^^^^^^ not found in this scope

error[E0423]: expected function, found macro `assert`
 --> /tmp/.tmpg19VvQ/main.rs:1:157
  |
1 | ... to_string () , "alice@example.com" . to_string ()) ; { assert (user . name == "Alice" , "Name should be set" . to_string ()) ; assert...
  |                                                            ^^^^^^ not a function
  |
help: use `!` to invoke the macro
  |
1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert! (user . name == "Alice" , "Name should be set" . to_string ()) ; assert (user . email == "alice@example.com" , "Email should be set" . to_string ()) ; assert (user . id != null , "ID should be generated" . to_string ()) ; println ! ("✅ test_user_creation passed" . to_string ()) } } } } fn test_data_persistence () { { { let test_data = { test : "value" , } ; { let mut test_file = "test_data.json" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should be created" . to_string ()) ; let mut loaded = load_json (test_file) ; assert (loaded . test == "value" , "Data should persist" . to_string ()) ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed" . to_string ()) } } } } fn run_all_tests () { { println ! ("🧪 Running application tests..." . to_string ()) ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!" . to_string ()) } } fn main () { }
  |                                                                                                                                                                   +

error[E0423]: expected function, found macro `assert`
 --> /tmp/.tmpg19VvQ/main.rs:1:229
  |
1 | ...ame == "Alice" , "Name should be set" . to_string ()) ; assert (user . email == "alice@example.com" , "Email should be set" . to_strin...
  |                                                            ^^^^^^ not a function
  |
help: use `!` to invoke the macro
  |
1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert (user . name == "Alice" , "Name should be set" . to_string ()) ; assert! (user . email == "alice@example.com" , "Email should be set" . to_string ()) ; assert (user . id != null , "ID should be generated" . to_string ()) ; println ! ("✅ test_user_creation passed" . to_string ()) } } } } fn test_data_persistence () { { { let test_data = { test : "value" , } ; { let mut test_file = "test_data.json" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should be created" . to_string ()) ; let mut loaded = load_json (test_file) ; assert (loaded . test == "value" , "Data should persist" . to_string ()) ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed" . to_string ()) } } } } fn run_all_tests () { { println ! ("🧪 Running application tests..." . to_string ()) ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!" . to_string ()) } } fn main () { }
  |                                                                                                                                                                                                                                           +

error[E0423]: expected function, found macro `assert`
 --> /tmp/.tmpg19VvQ/main.rs:1:315
  |
1 | ...@example.com" , "Email should be set" . to_string ()) ; assert (user . id != null , "ID should be generated" . to_string ()) ; println...
  |                                                            ^^^^^^ not a function
  |
help: use `!` to invoke the macro
  |
1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert (user . name == "Alice" , "Name should be set" . to_string ()) ; assert (user . email == "alice@example.com" , "Email should be set" . to_string ()) ; assert! (user . id != null , "ID should be generated" . to_string ()) ; println ! ("✅ test_user_creation passed" . to_string ()) } } } } fn test_data_persistence () { { { let test_data = { test : "value" , } ; { let mut test_file = "test_data.json" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should be created" . to_string ()) ; let mut loaded = load_json (test_file) ; assert (loaded . test == "value" , "Data should persist" . to_string ()) ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed" . to_string ()) } } } } fn run_all_tests () { { println ! ("🧪 Running application tests..." . to_string ()) ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!" . to_string ()) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                 +

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpg19VvQ/main.rs:1:429
  |
1 | ... ()) ; println ! ("✅ test_user_creation passed" . to_string ()) } } } } fn test_data_persistence () { { { let test_data = { test : "val...
  |                                                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `save_json` in this scope
 --> /tmp/.tmpg19VvQ/main.rs:1:565
  |
1 | ...e" , } ; { let mut test_file = "test_data.json" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should b...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpg19VvQ/main.rs:1:609
  |
1 | ...n" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should be created" . to_string ()) ; let mut loaded =...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0423]: expected function, found macro `assert`
 --> /tmp/.tmpg19VvQ/main.rs:1:601
  |
1 | ... "test_data.json" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should be created" . to_string ()) ; l...
  |                                                            ^^^^^^ not a function
  |
help: use `!` to invoke the macro
  |
1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert (user . name == "Alice" , "Name should be set" . to_string ()) ; assert (user . email == "alice@example.com" , "Email should be set" . to_string ()) ; assert (user . id != null , "ID should be generated" . to_string ()) ; println ! ("✅ test_user_creation passed" . to_string ()) } } } } fn test_data_persistence () { { { let test_data = { test : "value" , } ; { let mut test_file = "test_data.json" ; save_json (test_file , test_data) ; assert! (file_exists (test_file) , "File should be created" . to_string ()) ; let mut loaded = load_json (test_file) ; assert (loaded . test == "value" , "Data should persist" . to_string ()) ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed" . to_string ()) } } } } fn run_all_tests () { { println ! ("🧪 Running application tests..." . to_string ()) ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!" . to_string ()) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                +

error[E0425]: cannot find function `load_json` in this scope
 --> /tmp/.tmpg19VvQ/main.rs:1:695
  |
1 | ...ld be created" . to_string ()) ; let mut loaded = load_json (test_file) ; assert (loaded . test == "value" , "Data should persist" . t...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0423]: expected function, found macro `assert`
 --> /tmp/.tmpg19VvQ/main.rs:1:719
  |
1 | ...o_string ()) ; let mut loaded = load_json (test_file) ; assert (loaded . test == "value" , "Data should persist" . to_string ()) ; rem...
  |                                                            ^^^^^^ not a function
  |
help: use `!` to invoke the macro
  |
1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert (user . name == "Alice" , "Name should be set" . to_string ()) ; assert (user . email == "alice@example.com" , "Email should be set" . to_string ()) ; assert (user . id != null , "ID should be generated" . to_string ()) ; println ! ("✅ test_user_creation passed" . to_string ()) } } } } fn test_data_persistence () { { { let test_data = { test : "value" , } ; { let mut test_file = "test_data.json" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should be created" . to_string ()) ; let mut loaded = load_json (test_file) ; assert! (loaded . test == "value" , "Data should persist" . to_string ()) ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed" . to_string ()) } } } } fn run_all_tests () { { println ! ("🧪 Running application tests..." . to_string ()) ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!" . to_string ()) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      +

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpg19VvQ/main.rs:1:866
  |
1 | ...) ; println ! ("✅ test_data_persistence passed" . to_string ()) } } } } fn run_all_tests () { { println ! ("🧪 Running application tests....
  |                                                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpg19VvQ/main.rs:1:958
  |
1 | ...{ { println ! ("🧪 Running application tests..." . to_string ()) ; test_user_creation () ; test_data_persistence () ; test_error_handlin...
  |                                                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `test_error_handling` in this scope
 --> /tmp/.tmpg19VvQ/main.rs:1:1025
  |
1 | ...ser_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!" . to_str...
  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `test_performance` in this scope
 --> /tmp/.tmpg19VvQ/main.rs:1:1050
  |
1 | ...data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!" . to_string ()) } } fn main () ...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpg19VvQ/main.rs:1:1109
  |
1 | ...ormance () ; println ! ("\n✅ All tests passed!" . to_string ()) } } fn main () { }
  |                                                       ^^^^^^^^^ not found in this scope

error: aborting due to 26 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0423, E0425.
For more information about an error, try `rustc --explain E0423`.



=== ch07-00-building-applications example 9 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpts47tq/main.rs:1:104
  |
1 | use std :: collections :: HashMap ; fn build_release () { { println ! ("🔨 Building release version..." . to_string ()) ; run_tests () ; { ...
  |                                                                                                         ^ expected `,`

error: argument never used
 --> /tmp/.tmpts47tq/main.rs:1:106
  |
1 | ...n build_release () { { println ! ("🔨 Building release version..." . to_string ()) ; run_tests () ; { let release_dir = format ! ("{}{}"...
  |                                      --------------------------------   ^^^^^^^^^^^^ argument never used
  |                                      |
  |                                      formatting specifier missing

error[E0425]: cannot find value `VERSION` in this scope
 --> /tmp/.tmpts47tq/main.rs:1:189
  |
1 | ... let release_dir = format ! ("{}{}" , "release_" , VERSION) ; { create_dir_all (release_dir) ; copy_file ("main.ruchy" . to_string () ...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find function `create_dir_all` in this scope
 --> /tmp/.tmpts47tq/main.rs:1:202
  |
1 | ... = format ! ("{}{}" , "release_" , VERSION) ; { create_dir_all (release_dir) ; copy_file ("main.ruchy" . to_string () , join_path (rel...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::create_dir_all;
  |

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmpts47tq/main.rs:1:299
  |
1 | ...n.ruchy" . to_string () , join_path (release_dir , APP_NAME)) ; copy_dir ("resources" . to_string () , join_path (release_dir , "resou...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmpts47tq/main.rs:1:665
  |
1 | ...cho 'Installation complete! Run {} to start.'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (relea...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `VERSION` in this scope
 --> /tmp/.tmpts47tq/main.rs:1:676
  |
1 | ...lation complete! Run {} to start.'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , "i...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmpts47tq/main.rs:1:686
  |
1 | ...plete! Run {} to start.'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , "install.sh"...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmpts47tq/main.rs:1:697
  |
1 | ...{} to start.'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , "install.sh" . to_strin...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmpts47tq/main.rs:1:708
  |
1 | ....'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , "install.sh" . to_string ()) , ins...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmpts47tq/main.rs:1:844
  |
1 | ...ller) ; create_archive (format ! ("{}-{}.tar.gz" , APP_NAME , VERSION) , release_dir) ; println ! ("✅ Release built: {}-{}.tar.gz" , AP...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `VERSION` in this scope
 --> /tmp/.tmpts47tq/main.rs:1:855
  |
1 | ...ate_archive (format ! ("{}-{}.tar.gz" , APP_NAME , VERSION) , release_dir) ; println ! ("✅ Release built: {}-{}.tar.gz" , APP_NAME , VE...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmpts47tq/main.rs:1:926
  |
1 | ...ir) ; println ! ("✅ Release built: {}-{}.tar.gz" , APP_NAME , VERSION) } } } } fn main () { }
  |                                                        ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `VERSION` in this scope
 --> /tmp/.tmpts47tq/main.rs:1:937
  |
1 | ...ln ! ("✅ Release built: {}-{}.tar.gz" , APP_NAME , VERSION) } } } } fn main () { }
  |                                                        ^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpts47tq/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn build_release () { { println ! ("🔨 Building release version..." . to_string ()) ; run_tests () ; { ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpts47tq/main.rs:1:106
  |
1 | ... { { println ! ("🔨 Building release version..." . to_string ()) ; run_tests () ; { let release_dir = format ! ("{}{}" , "release_" , VE...
  |                                                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `run_tests` in this scope
 --> /tmp/.tmpts47tq/main.rs:1:122
  |
1 | ..."🔨 Building release version..." . to_string ()) ; run_tests () ; { let release_dir = format ! ("{}{}" , "release_" , VERSION) ; { creat...
  |                                                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpts47tq/main.rs:1:274
  |
1 | ...e_dir) ; copy_file ("main.ruchy" . to_string () , join_path (release_dir , APP_NAME)) ; copy_dir ("resources" . to_string () , join_pa...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `copy_file` in this scope
 --> /tmp/.tmpts47tq/main.rs:1:233
  |
1 | ...e_" , VERSION) ; { create_dir_all (release_dir) ; copy_file ("main.ruchy" . to_string () , join_path (release_dir , APP_NAME)) ; copy_...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpts47tq/main.rs:1:351
  |
1 | ...P_NAME)) ; copy_dir ("resources" . to_string () , join_path (release_dir , "resources" . to_string ())) ; generate_docs (join_path (re...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `copy_dir` in this scope
 --> /tmp/.tmpts47tq/main.rs:1:312
  |
1 | ..._string () , join_path (release_dir , APP_NAME)) ; copy_dir ("resources" . to_string () , join_path (release_dir , "resources" . to_st...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpts47tq/main.rs:1:422
  |
1 | ...r , "resources" . to_string ())) ; generate_docs (join_path (release_dir , "docs" . to_string ())) ; let mut installer = format ! ("#!...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `generate_docs` in this scope
 --> /tmp/.tmpts47tq/main.rs:1:407
  |
1 | ...h (release_dir , "resources" . to_string ())) ; generate_docs (join_path (release_dir , "docs" . to_string ())) ; let mut installer = ...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpts47tq/main.rs:1:732
  |
1 | ...N , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , "install.sh" . to_string ()) , installer) ; create_archive ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpts47tq/main.rs:1:720
  |
1 | ...AME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , "install.sh" . to_string ()) , installer) ; cre...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `create_archive` in this scope
 --> /tmp/.tmpts47tq/main.rs:1:801
  |
1 | ...r , "install.sh" . to_string ()) , installer) ; create_archive (format ! ("{}-{}.tar.gz" , APP_NAME , VERSION) , release_dir) ; printl...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 25 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch15-00-macros-metaprogramming example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch15-00-macros-metaprogramming example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch15-00-macros-metaprogramming example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch15-00-macros-metaprogramming example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch15-00-macros-metaprogramming example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch15-00-macros-metaprogramming example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch15-00-macros-metaprogramming example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch15-00-macros-metaprogramming example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch15-00-macros-metaprogramming example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 2 ===

thread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:
"net::TcpListener" is not a valid Ident
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


=== ch09-00-network-programming example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 10 ===

thread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:
"net::PacketCapture" is not a valid Ident
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


=== ch07-00-error-handling-tdd example 1 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmp96zDBv/main.rs:1:82
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Before operation" . to_string ()) ; if true { { println ! ("Operation succ...
  |                                                                                  ^ expected `,`

error: argument never used
 --> /tmp/.tmp96zDBv/main.rs:1:84
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Before operation" . to_string ()) ; if true { { println ! ("Operation succ...
  |                                                               ------------------   ^^^^^^^^^^^^ argument never used
  |                                                               |
  |                                                               formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmp96zDBv/main.rs:1:146
  |
1 | ..._string ()) ; if true { { println ! ("Operation successful" . to_string ()) } } ; println ! ("After operation" . to_string ()) } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmp96zDBv/main.rs:1:148
  |
1 | ...o_string ()) ; if true { { println ! ("Operation successful" . to_string ()) } } ; println ! ("After operation" . to_string ()) } }
  |                                          ----------------------   ^^^^^^^^^^^^ argument never used
  |                                          |
  |                                          formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmp96zDBv/main.rs:1:197
  |
1 | ...cessful" . to_string ()) } } ; println ! ("After operation" . to_string ()) } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmp96zDBv/main.rs:1:199
  |
1 | ...essful" . to_string ()) } } ; println ! ("After operation" . to_string ()) } }
  |                                             -----------------   ^^^^^^^^^^^^ argument never used
  |                                             |
  |                                             formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp96zDBv/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Before operation" . to_string ()) ; if true { { println ! ("Operation succ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp96zDBv/main.rs:1:110
  |
1 | ... operation" . to_string ()) ; if true { { println ! ("Operation successful" . to_string ()) } } ; println ! ("After operation" . to_st...
  |                                            ^^                                                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { println ! ("Before operation" . to_string ()) ; if true { { println ! ("Operation successful" . to_string ()) } } ; println ! ("After operation" . to_string ()) } }
1 + use std :: collections :: HashMap ; fn main () { { println ! ("Before operation" . to_string ()) ; if true { println ! ("Operation successful" . to_string ()) } ; println ! ("After operation" . to_string ()) } }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmp96zDBv/main.rs:1:84
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Before operation" . to_string ()) ; if true { { println ! ("Operation succ...
  |                                                                                    ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmp96zDBv/main.rs:1:148
  |
1 | ...; if true { { println ! ("Operation successful" . to_string ()) } } ; println ! ("After operation" . to_string ()) } }
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmp96zDBv/main.rs:1:199
  |
1 | ...o_string ()) } } ; println ! ("After operation" . to_string ()) } }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 9 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 2 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpwCkJZ0/main.rs:1:123
  |
1 | ...r = 5i32 ; { if number > 0i32 { { println ! ("Valid number" . to_string ()) } } else { { println ! ("Invalid number" . to_string ()) }...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpwCkJZ0/main.rs:1:125
  |
1 | ... 5i32 ; { if number > 0i32 { { println ! ("Valid number" . to_string ()) } } else { { println ! ("Invalid number" . to_string ()) } } ...
  |                                              --------------   ^^^^^^^^^^^^ argument never used
  |                                              |
  |                                              formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpwCkJZ0/main.rs:1:180
  |
1 | ...r" . to_string ()) } } else { { println ! ("Invalid number" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! ...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpwCkJZ0/main.rs:1:182
  |
1 | ... . to_string ()) } } else { { println ! ("Invalid number" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! ("...
  |                                             ----------------   ^^^^^^^^^^^^ argument never used
  |                                             |
  |                                             formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpwCkJZ0/main.rs:1:286
  |
1 | ... zero == 0i32 { { println ! ("Warning: Zero value detected" . to_string ()) } } else { { println ! ("Non-zero value" . to_string ()) }...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpwCkJZ0/main.rs:1:288
  |
1 | ... ; if zero == 0i32 { { println ! ("Warning: Zero value detected" . to_string ()) } } else { { println ! ("Non-zero value" . to_string ...
  |                                      ------------------------------   ^^^^^^^^^^^^ argument never used
  |                                      |
  |                                      formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpwCkJZ0/main.rs:1:343
  |
1 | ...d" . to_string ()) } } else { { println ! ("Non-zero value" . to_string ()) } } } } } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpwCkJZ0/main.rs:1:345
  |
1 | ... . to_string ()) } } else { { println ! ("Non-zero value" . to_string ()) } } } } } }
  |                                             ----------------   ^^^^^^^^^^^^ argument never used
  |                                             |
  |                                             formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpwCkJZ0/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let number = 5i32 ; { if number > 0i32 { { println ! ("Valid number" . to_string ())...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpwCkJZ0/main.rs:1:50
  |
1 | ... { { { let number = 5i32 ; { if number > 0i32 { { println ! ("Valid number" . to_string ()) } } else { { println ! ("Invalid number" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! ("Warning: Zero value detected" . to_string ()) } } else { { println ! ("Non-zero value" . to_string ()) } } } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let number = 5i32 ; { if number > 0i32 { { println ! ("Valid number" . to_string ()) } } else { { println ! ("Invalid number" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! ("Warning: Zero value detected" . to_string ()) } } else { { println ! ("Non-zero value" . to_string ()) } } } } } }
1 + use std :: collections :: HashMap ; fn main () { { let number = 5i32 ; { if number > 0i32 { { println ! ("Valid number" . to_string ()) } } else { { println ! ("Invalid number" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! ("Warning: Zero value detected" . to_string ()) } } else { { println ! ("Non-zero value" . to_string ()) } } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpwCkJZ0/main.rs:1:95
  |
1 | ... { let number = 5i32 ; { if number > 0i32 { { println ! ("Valid number" . to_string ()) } } else { { println ! ("Invalid number" . to_...
  |                                                ^^                                         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let number = 5i32 ; { if number > 0i32 { { println ! ("Valid number" . to_string ()) } } else { { println ! ("Invalid number" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! ("Warning: Zero value detected" . to_string ()) } } else { { println ! ("Non-zero value" . to_string ()) } } } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let number = 5i32 ; { if number > 0i32 { println ! ("Valid number" . to_string ()) } else { { println ! ("Invalid number" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! ("Warning: Zero value detected" . to_string ()) } } else { { println ! ("Non-zero value" . to_string ()) } } } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpwCkJZ0/main.rs:1:150
  |
1 | ...("Valid number" . to_string ()) } } else { { println ! ("Invalid number" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 {...
  |                                               ^^                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let number = 5i32 ; { if number > 0i32 { { println ! ("Valid number" . to_string ()) } } else { { println ! ("Invalid number" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! ("Warning: Zero value detected" . to_string ()) } } else { { println ! ("Non-zero value" . to_string ()) } } } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let number = 5i32 ; { if number > 0i32 { { println ! ("Valid number" . to_string ()) } } else { println ! ("Invalid number" . to_string ()) } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! ("Warning: Zero value detected" . to_string ()) } } else { { println ! ("Non-zero value" . to_string ()) } } } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpwCkJZ0/main.rs:1:242
  |
1 | ...mut zero = 0i32 ; if zero == 0i32 { { println ! ("Warning: Zero value detected" . to_string ()) } } else { { println ! ("Non-zero valu...
  |                                        ^^                                                         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let number = 5i32 ; { if number > 0i32 { { println ! ("Valid number" . to_string ()) } } else { { println ! ("Invalid number" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! ("Warning: Zero value detected" . to_string ()) } } else { { println ! ("Non-zero value" . to_string ()) } } } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let number = 5i32 ; { if number > 0i32 { { println ! ("Valid number" . to_string ()) } } else { { println ! ("Invalid number" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { println ! ("Warning: Zero value detected" . to_string ()) } else { { println ! ("Non-zero value" . to_string ()) } } } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpwCkJZ0/main.rs:1:313
  |
1 | ...value detected" . to_string ()) } } else { { println ! ("Non-zero value" . to_string ()) } } } } } }
  |                                               ^^                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let number = 5i32 ; { if number > 0i32 { { println ! ("Valid number" . to_string ()) } } else { { println ! ("Invalid number" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! ("Warning: Zero value detected" . to_string ()) } } else { { println ! ("Non-zero value" . to_string ()) } } } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let number = 5i32 ; { if number > 0i32 { { println ! ("Valid number" . to_string ()) } } else { { println ! ("Invalid number" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! ("Warning: Zero value detected" . to_string ()) } } else { println ! ("Non-zero value" . to_string ()) } } } } }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpwCkJZ0/main.rs:1:125
  |
1 | ... if number > 0i32 { { println ! ("Valid number" . to_string ()) } } else { { println ! ("Invalid number" . to_string ()) } } ; let mut...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpwCkJZ0/main.rs:1:182
  |
1 | ...ng ()) } } else { { println ! ("Invalid number" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! ("Warning: Z...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpwCkJZ0/main.rs:1:288
  |
1 | ...2 { { println ! ("Warning: Zero value detected" . to_string ()) } } else { { println ! ("Non-zero value" . to_string ()) } } } } } }
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpwCkJZ0/main.rs:1:345
  |
1 | ...ng ()) } } else { { println ! ("Non-zero value" . to_string ()) } } } } } }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 12 previous errors; 6 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 3 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmprBqv4s/main.rs:1:131
  |
1 | ... match age { 0i32 => println ! ("Error: Age cannot be zero" . to_string ()) , 1i32 ..= 17i32 => println ! ("Minor" . to_string ()) , 1...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmprBqv4s/main.rs:1:133
  |
1 | ...32 ; match age { 0i32 => println ! ("Error: Age cannot be zero" . to_string ()) , 1i32 ..= 17i32 => println ! ("Minor" . to_string ())...
  |                                        ---------------------------   ^^^^^^^^^^^^ argument never used
  |                                        |
  |                                        formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmprBqv4s/main.rs:1:186
  |
1 | ...ero" . to_string ()) , 1i32 ..= 17i32 => println ! ("Minor" . to_string ()) , 18i32 ..= 65i32 => println ! ("Adult" . to_string ()) , ...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmprBqv4s/main.rs:1:188
  |
1 | ... to_string ()) , 1i32 ..= 17i32 => println ! ("Minor" . to_string ()) , 18i32 ..= 65i32 => println ! ("Adult" . to_string ()) , _ => p...
  |                                                  -------   ^^^^^^^^^^^^ argument never used
  |                                                  |
  |                                                  formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmprBqv4s/main.rs:1:242
  |
1 | ...or" . to_string ()) , 18i32 ..= 65i32 => println ! ("Adult" . to_string ()) , _ => println ! ("Senior" . to_string ()) , } } } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmprBqv4s/main.rs:1:244
  |
1 | ...to_string ()) , 18i32 ..= 65i32 => println ! ("Adult" . to_string ()) , _ => println ! ("Senior" . to_string ()) , } } } }
  |                                                  -------   ^^^^^^^^^^^^ argument never used
  |                                                  |
  |                                                  formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmprBqv4s/main.rs:1:285
  |
1 | ...intln ! ("Adult" . to_string ()) , _ => println ! ("Senior" . to_string ()) , } } } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmprBqv4s/main.rs:1:287
  |
1 | ...! ("Adult" . to_string ()) , _ => println ! ("Senior" . to_string ()) , } } } }
  |                                                 --------   ^^^^^^^^^^^^ argument never used
  |                                                 |
  |                                                 formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmprBqv4s/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let age = 25i32 ; match age { 0i32 => println ! ("Error: Age cannot be zero" . to_st...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmprBqv4s/main.rs:1:50
  |
1 | ... { { { let age = 25i32 ; match age { 0i32 => println ! ("Error: Age cannot be zero" . to_string ()) , 1i32 ..= 17i32 => println ! ("Minor" . to_string ()) , 18i32 ..= 65i32 => println ! ("Adult" . to_string ()) , _ => println ! ("Senior" . to_string ()) , } } } }
  |       ^^                                                                                                                                                                                                                                                              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let age = 25i32 ; match age { 0i32 => println ! ("Error: Age cannot be zero" . to_string ()) , 1i32 ..= 17i32 => println ! ("Minor" . to_string ()) , 18i32 ..= 65i32 => println ! ("Adult" . to_string ()) , _ => println ! ("Senior" . to_string ()) , } } } }
1 + use std :: collections :: HashMap ; fn main () { { let age = 25i32 ; match age { 0i32 => println ! ("Error: Age cannot be zero" . to_string ()) , 1i32 ..= 17i32 => println ! ("Minor" . to_string ()) , 18i32 ..= 65i32 => println ! ("Adult" . to_string ()) , _ => println ! ("Senior" . to_string ()) , } } }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmprBqv4s/main.rs:1:133
  |
1 | ... 0i32 => println ! ("Error: Age cannot be zero" . to_string ()) , 1i32 ..= 17i32 => println ! ("Minor" . to_string ()) , 18i32 ..= 65i...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmprBqv4s/main.rs:1:188
  |
1 | ...ring ()) , 1i32 ..= 17i32 => println ! ("Minor" . to_string ()) , 18i32 ..= 65i32 => println ! ("Adult" . to_string ()) , _ => println...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmprBqv4s/main.rs:1:244
  |
1 | ...ing ()) , 18i32 ..= 65i32 => println ! ("Adult" . to_string ()) , _ => println ! ("Senior" . to_string ()) , } } } }
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmprBqv4s/main.rs:1:287
  |
1 | ...ult" . to_string ()) , _ => println ! ("Senior" . to_string ()) , } } } }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 12 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmptr7NIm/main.rs:1:102
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid" . to_string ()) } } else { { println...
  |                                                                                                      ^ expected `,`

error: argument never used
 --> /tmp/.tmptr7NIm/main.rs:1:104
  |
1 | ...{ let result = if value > 0i32 { { println ! ("Valid" . to_string ()) } } else { { println ! ("Invalid" . to_string ()) } } ; if let S...
  |                                                  -------   ^^^^^^^^^^^^ argument never used
  |                                                  |
  |                                                  formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmptr7NIm/main.rs:1:152
  |
1 | ... ("Valid" . to_string ()) } } else { { println ! ("Invalid" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :: any :: A...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmptr7NIm/main.rs:1:154
  |
1 | ...lid" . to_string ()) } } else { { println ! ("Invalid" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) ....
  |                                                 ---------   ^^^^^^^^^^^^ argument never used
  |                                                 |
  |                                                 formatting specifier missing

error[E0425]: cannot find value `value` in this scope
 --> /tmp/.tmptr7NIm/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid" . to_string ()) } } else { { println...
  |                                                                  ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmptr7NIm/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid" . to_string ()) } } else { { println...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmptr7NIm/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid" . to_string ()) } } else { { println...
  |                                                                                 ^^                                  ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid" . to_string ()) } } else { { println ! ("Invalid" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { println ! ("Valid" . to_string ()) } else { { println ! ("Invalid" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmptr7NIm/main.rs:1:129
  |
1 | ... println ! ("Valid" . to_string ()) } } else { { println ! ("Invalid" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :...
  |                                                   ^^                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid" . to_string ()) } } else { { println ! ("Invalid" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid" . to_string ()) } } else { println ! ("Invalid" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmptr7NIm/main.rs:1:104
  |
1 | ...result = if value > 0i32 { { println ! ("Valid" . to_string ()) } } else { { println ! ("Invalid" . to_string ()) } } ; if let Some (s...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmptr7NIm/main.rs:1:154
  |
1 | ...to_string ()) } } else { { println ! ("Invalid" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downca...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 7 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpl0sDIl/main.rs:1:105
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match status { 0i32 => println ! ("Error" . to_string ()) , 1i32 => println...
  |                                                                                                         ^ expected `,`

error: argument never used
 --> /tmp/.tmpl0sDIl/main.rs:1:107
  |
1 | ...et result = match status { 0i32 => println ! ("Error" . to_string ()) , 1i32 => println ! ("Warning" . to_string ()) , 2i32 => println...
  |                                                  -------   ^^^^^^^^^^^^ argument never used
  |                                                  |
  |                                                  formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpl0sDIl/main.rs:1:152
  |
1 | ...n ! ("Error" . to_string ()) , 1i32 => println ! ("Warning" . to_string ()) , 2i32 => println ! ("Success" . to_string ()) , _ => prin...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpl0sDIl/main.rs:1:154
  |
1 | ..."Error" . to_string ()) , 1i32 => println ! ("Warning" . to_string ()) , 2i32 => println ! ("Success" . to_string ()) , _ => println !...
  |                                                 ---------   ^^^^^^^^^^^^ argument never used
  |                                                 |
  |                                                 formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpl0sDIl/main.rs:1:199
  |
1 | ...! ("Warning" . to_string ()) , 2i32 => println ! ("Success" . to_string ()) , _ => println ! ("Unknown" . to_string ()) , } ; if let S...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpl0sDIl/main.rs:1:201
  |
1 | ...arning" . to_string ()) , 2i32 => println ! ("Success" . to_string ()) , _ => println ! ("Unknown" . to_string ()) , } ; if let Some (...
  |                                                 ---------   ^^^^^^^^^^^^ argument never used
  |                                                 |
  |                                                 formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpl0sDIl/main.rs:1:243
  |
1 | ...ln ! ("Success" . to_string ()) , _ => println ! ("Unknown" . to_string ()) , } ; if let Some (s) = (& result as & dyn std :: any :: A...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpl0sDIl/main.rs:1:245
  |
1 | ...("Success" . to_string ()) , _ => println ! ("Unknown" . to_string ()) , } ; if let Some (s) = (& result as & dyn std :: any :: Any) ....
  |                                                 ---------   ^^^^^^^^^^^^ argument never used
  |                                                 |
  |                                                 formatting specifier missing

error[E0425]: cannot find value `status` in this scope
 --> /tmp/.tmpl0sDIl/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match status { 0i32 => println ! ("Error" . to_string ()) , 1i32 => println...
  |                                                                     ^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpl0sDIl/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match status { 0i32 => println ! ("Error" . to_string ()) , 1i32 => println...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpl0sDIl/main.rs:1:107
  |
1 | ...ult = match status { 0i32 => println ! ("Error" . to_string ()) , 1i32 => println ! ("Warning" . to_string ()) , 2i32 => println ! ("S...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpl0sDIl/main.rs:1:154
  |
1 | ... . to_string ()) , 1i32 => println ! ("Warning" . to_string ()) , 2i32 => println ! ("Success" . to_string ()) , _ => println ! ("Unkn...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpl0sDIl/main.rs:1:201
  |
1 | ... . to_string ()) , 2i32 => println ! ("Success" . to_string ()) , _ => println ! ("Unknown" . to_string ()) , } ; if let Some (s) = (&...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpl0sDIl/main.rs:1:245
  |
1 | ...ss" . to_string ()) , _ => println ! ("Unknown" . to_string ()) , } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downca...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 13 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpZptAQA/main.rs:1:108
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match age { 0i32 => println ! ("Invalid age" . to_string ()) , 1i32 ..= 17i...
  |                                                                                                            ^ expected `,`

error: argument never used
 --> /tmp/.tmpZptAQA/main.rs:1:110
  |
1 | ...et result = match age { 0i32 => println ! ("Invalid age" . to_string ()) , 1i32 ..= 17i32 => println ! ("Minor" . to_string ()) , 18i3...
  |                                               -------------   ^^^^^^^^^^^^ argument never used
  |                                               |
  |                                               formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpZptAQA/main.rs:1:163
  |
1 | ...age" . to_string ()) , 1i32 ..= 17i32 => println ! ("Minor" . to_string ()) , 18i32 ..= 65i32 => println ! ("Adult" . to_string ()) , ...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpZptAQA/main.rs:1:165
  |
1 | ... to_string ()) , 1i32 ..= 17i32 => println ! ("Minor" . to_string ()) , 18i32 ..= 65i32 => println ! ("Adult" . to_string ()) , _ => p...
  |                                                  -------   ^^^^^^^^^^^^ argument never used
  |                                                  |
  |                                                  formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpZptAQA/main.rs:1:219
  |
1 | ...or" . to_string ()) , 18i32 ..= 65i32 => println ! ("Adult" . to_string ()) , _ => println ! ("Senior" . to_string ()) , } ; if let So...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpZptAQA/main.rs:1:221
  |
1 | ...to_string ()) , 18i32 ..= 65i32 => println ! ("Adult" . to_string ()) , _ => println ! ("Senior" . to_string ()) , } ; if let Some (s)...
  |                                                  -------   ^^^^^^^^^^^^ argument never used
  |                                                  |
  |                                                  formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpZptAQA/main.rs:1:262
  |
1 | ...intln ! ("Adult" . to_string ()) , _ => println ! ("Senior" . to_string ()) , } ; if let Some (s) = (& result as & dyn std :: any :: A...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpZptAQA/main.rs:1:264
  |
1 | ...! ("Adult" . to_string ()) , _ => println ! ("Senior" . to_string ()) , } ; if let Some (s) = (& result as & dyn std :: any :: Any) . ...
  |                                                 --------   ^^^^^^^^^^^^ argument never used
  |                                                 |
  |                                                 formatting specifier missing

error[E0425]: cannot find value `age` in this scope
 --> /tmp/.tmpZptAQA/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match age { 0i32 => println ! ("Invalid age" . to_string ()) , 1i32 ..= 17i...
  |                                                                     ^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpZptAQA/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match age { 0i32 => println ! ("Invalid age" . to_string ()) , 1i32 ..= 17i...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpZptAQA/main.rs:1:110
  |
1 | ... = match age { 0i32 => println ! ("Invalid age" . to_string ()) , 1i32 ..= 17i32 => println ! ("Minor" . to_string ()) , 18i32 ..= 65i...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpZptAQA/main.rs:1:165
  |
1 | ...ring ()) , 1i32 ..= 17i32 => println ! ("Minor" . to_string ()) , 18i32 ..= 65i32 => println ! ("Adult" . to_string ()) , _ => println...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpZptAQA/main.rs:1:221
  |
1 | ...ing ()) , 18i32 ..= 65i32 => println ! ("Adult" . to_string ()) , _ => println ! ("Senior" . to_string ()) , } ; if let Some (s) = (& ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpZptAQA/main.rs:1:264
  |
1 | ...ult" . to_string ()) , _ => println ! ("Senior" . to_string ()) , } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downca...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 13 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 7 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpeAU7lr/main.rs:1:130
  |
1 | ...t < 0i32 { { println ! ("Error: Negative input not allowed" . to_string ()) } } else { { process_input (input) } } ; if let Some (s) =...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpeAU7lr/main.rs:1:132
  |
1 | ... if input < 0i32 { { println ! ("Error: Negative input not allowed" . to_string ()) } } else { { process_input (input) } } ; if let So...
  |                                    -----------------------------------   ^^^^^^^^^^^^ argument never used
  |                                    |
  |                                    formatting specifier missing

error[E0425]: cannot find value `input` in this scope
 --> /tmp/.tmpeAU7lr/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed" . to_str...
  |                                                                  ^^^^^ not found in this scope

error[E0425]: cannot find value `input` in this scope
 --> /tmp/.tmpeAU7lr/main.rs:1:174
  |
1 | ...llowed" . to_string ()) } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_re...
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpeAU7lr/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed" . to_str...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpeAU7lr/main.rs:1:81
  |
1 | ... { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed" . to_string ()) } } else { { process_input (input) ...
  |                                      ^^                                                              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed" . to_string ()) } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { println ! ("Error: Negative input not allowed" . to_string ()) } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpeAU7lr/main.rs:1:157
  |
1 | ...egative input not allowed" . to_string ()) } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any ::...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed" . to_string ()) } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed" . to_string ()) } } else { process_input (input) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpeAU7lr/main.rs:1:132
  |
1 | ... println ! ("Error: Negative input not allowed" . to_string ()) } } else { { process_input (input) } } ; if let Some (s) = (& result a...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `process_input` in this scope
 --> /tmp/.tmpeAU7lr/main.rs:1:159
  |
1 | ...input not allowed" . to_string ()) } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . ...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error: aborting due to 6 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 8 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpXG84uR/main.rs:1:113
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match score { 0i32 ..= 59i32 => println ! ("Fail" . to_string ()) , 60i32 ....
  |                                                                                                                 ^ expected `,`

error: argument never used
 --> /tmp/.tmpXG84uR/main.rs:1:115
  |
1 | ... = match score { 0i32 ..= 59i32 => println ! ("Fail" . to_string ()) , 60i32 ..= 79i32 => println ! ("Pass" . to_string ()) , 80i32 .....
  |                                                  ------   ^^^^^^^^^^^^ argument never used
  |                                                  |
  |                                                  formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpXG84uR/main.rs:1:168
  |
1 | ...ail" . to_string ()) , 60i32 ..= 79i32 => println ! ("Pass" . to_string ()) , 80i32 ..= 100i32 => println ! ("Excellent" . to_string (...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpXG84uR/main.rs:1:170
  |
1 | ...to_string ()) , 60i32 ..= 79i32 => println ! ("Pass" . to_string ()) , 80i32 ..= 100i32 => println ! ("Excellent" . to_string ()) , _ ...
  |                                                  ------   ^^^^^^^^^^^^ argument never used
  |                                                  |
  |                                                  formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpXG84uR/main.rs:1:229
  |
1 | ... to_string ()) , 80i32 ..= 100i32 => println ! ("Excellent" . to_string ()) , _ => println ! ("Invalid score" . to_string ()) , } ; if...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpXG84uR/main.rs:1:231
  |
1 | ...string ()) , 80i32 ..= 100i32 => println ! ("Excellent" . to_string ()) , _ => println ! ("Invalid score" . to_string ()) , } ; if let...
  |                                                -----------   ^^^^^^^^^^^^ argument never used
  |                                                |
  |                                                formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpXG84uR/main.rs:1:279
  |
1 | ...xcellent" . to_string ()) , _ => println ! ("Invalid score" . to_string ()) , } ; if let Some (s) = (& result as & dyn std :: any :: A...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpXG84uR/main.rs:1:281
  |
1 | ...ellent" . to_string ()) , _ => println ! ("Invalid score" . to_string ()) , } ; if let Some (s) = (& result as & dyn std :: any :: Any...
  |                                              ---------------   ^^^^^^^^^^^^ argument never used
  |                                              |
  |                                              formatting specifier missing

error[E0425]: cannot find value `score` in this scope
 --> /tmp/.tmpXG84uR/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match score { 0i32 ..= 59i32 => println ! ("Fail" . to_string ()) , 60i32 ....
  |                                                                     ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpXG84uR/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match score { 0i32 ..= 59i32 => println ! ("Fail" . to_string ()) , 60i32 ....
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpXG84uR/main.rs:1:115
  |
1 | ...tch score { 0i32 ..= 59i32 => println ! ("Fail" . to_string ()) , 60i32 ..= 79i32 => println ! ("Pass" . to_string ()) , 80i32 ..= 100...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpXG84uR/main.rs:1:170
  |
1 | ...ring ()) , 60i32 ..= 79i32 => println ! ("Pass" . to_string ()) , 80i32 ..= 100i32 => println ! ("Excellent" . to_string ()) , _ => pr...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpXG84uR/main.rs:1:231
  |
1 | ...)) , 80i32 ..= 100i32 => println ! ("Excellent" . to_string ()) , _ => println ! ("Invalid score" . to_string ()) , } ; if let Some (s...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpXG84uR/main.rs:1:281
  |
1 | ...to_string ()) , _ => println ! ("Invalid score" . to_string ()) , } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downca...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 13 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 9 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmptMSX6i/main.rs:1:115
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational" . to_string ()) } } els...
  |                                                                                                                   ^ expected `,`

error: argument never used
 --> /tmp/.tmptMSX6i/main.rs:1:117
  |
1 | ...esult = if system_ready { { println ! ("System operational" . to_string ()) } } else { { println ! ("System not ready" . to_string ())...
  |                                           --------------------   ^^^^^^^^^^^^ argument never used
  |                                           |
  |                                           formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmptMSX6i/main.rs:1:174
  |
1 | ... . to_string ()) } } else { { println ! ("System not ready" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :: any :: A...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmptMSX6i/main.rs:1:176
  |
1 | .... to_string ()) } } else { { println ! ("System not ready" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :: any :: An...
  |                                            ------------------   ^^^^^^^^^^^^ argument never used
  |                                            |
  |                                            formatting specifier missing

error[E0425]: cannot find value `system_ready` in this scope
 --> /tmp/.tmptMSX6i/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational" . to_string ()) } } els...
  |                                                                  ^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmptMSX6i/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational" . to_string ()) } } els...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmptMSX6i/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational" . to_string ()) } } els...
  |                                                                                 ^^                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational" . to_string ()) } } else { { println ! ("System not ready" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if system_ready { println ! ("System operational" . to_string ()) } else { { println ! ("System not ready" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmptMSX6i/main.rs:1:142
  |
1 | ...m operational" . to_string ()) } } else { { println ! ("System not ready" . to_string ()) } } ; if let Some (s) = (& result as & dyn s...
  |                                              ^^                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational" . to_string ()) } } else { { println ! ("System not ready" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational" . to_string ()) } } else { println ! ("System not ready" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmptMSX6i/main.rs:1:117
  |
1 | ...ystem_ready { { println ! ("System operational" . to_string ()) } } else { { println ! ("System not ready" . to_string ()) } } ; if le...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmptMSX6i/main.rs:1:176
  |
1 | ... ()) } } else { { println ! ("System not ready" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downca...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 7 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch08-00-systems-programming example 1 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpc1GSEb/main.rs:1:146
  |
1 | ... use std :: process ; ; println ! ("=== System Monitor ===" . to_string ()) ; let mut cpu_count = system :: cpu_count () ; let mut tot...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpc1GSEb/main.rs:1:148
  |
1 | ... ; use std :: process ; ; println ! ("=== System Monitor ===" . to_string ()) ; let mut cpu_count = system :: cpu_count () ; let mut t...
  |                                         ------------------------   ^^^^^^^^^^^^ argument never used
  |                                         |
  |                                         formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpc1GSEb/main.rs:1:683
  |
1 | ..., "Memory: " , format_size (total_memory))) ; println ! ("" . to_string ()) ; loop { { { let cpu_usage = system :: cpu_usage () ; { le...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpc1GSEb/main.rs:1:685
  |
1 | ...: " , format_size (total_memory))) ; println ! ("" . to_string ()) ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut mem...
  |                                                    --   ^^^^^^^^^^^^ argument never used
  |                                                    |
  |                                                    formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpc1GSEb/main.rs:1:973
  |
1 | ...een () ; println ! ("System Monitor - Press Ctrl+C to exit" . to_string ()) ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , forma...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpc1GSEb/main.rs:1:975
  |
1 | ... clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit" . to_string ()) ; println ! ("{}" , "=" * 50i32) ; println ! ("{...
  |                                  ---------------------------------------   ^^^^^^^^^^^^ argument never used
  |                                  |
  |                                  formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpc1GSEb/main.rs:1:2185
  |
1 | ...oad_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:" . to_string ()) ; let mut processes = process :: list () . sort_by (| p | ...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpc1GSEb/main.rs:1:2187
  |
1 | ...upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:" . to_string ()) ; let mut processes = process :: list () . sort_by (| p...
  |                                         -------------------------   ^^^^^^^^^^^^ argument never used
  |                                         |
  |                                         formatting specifier missing

error[E0432]: unresolved import `std::system`
 --> /tmp/.tmpc1GSEb/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monit...
  |                                                                     ^^^^^^^^^^^^^ no `system` in the root

error[E0425]: cannot find function `list` in module `process`
 --> /tmp/.tmpc1GSEb/main.rs:1:2234
  |
1 | ...U:" . to_string ()) ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes...
  |                                                         ^^^^ not found in `process`

error[E0425]: cannot find function `sleep` in this scope
 --> /tmp/.tmpc1GSEb/main.rs:1:2516
  |
1 | ..., " ") + proc . cpu_percent . to_s () , "%")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::sleep;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpc1GSEb/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monit...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpc1GSEb/main.rs:1:85
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monit...
  |                                                                                     ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpc1GSEb/main.rs:1:108
  |
1 | ...sult = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===" . to_string ()) ; let mut cpu_count = system...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpc1GSEb/main.rs:1:708
  |
1 | ... { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit" . to_string ()) ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") + format_size (memory_info . total)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:" . to_string ()) ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } } ; sleep (1000i32) } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===" . to_string ()) ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! ("{}" , format ! ("{}{}" , "Host: " , hostname)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "OS: " , os_info . name) , " ") + os_info . version) ; println ! ("{}" , format ! ("{}{}" , "CPUs: " , cpu_count . to_s ())) ; println ! ("{}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("" . to_string ()) ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit" . to_string ()) ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") + format_size (memory_info . total)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:" . to_string ()) ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===" . to_string ()) ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! ("{}" , format ! ("{}{}" , "Host: " , hostname)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "OS: " , os_info . name) , " ") + os_info . version) ; println ! ("{}" , format ! ("{}{}" , "CPUs: " , cpu_count . to_s ())) ; println ! ("{}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("" . to_string ()) ; loop { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit" . to_string ()) ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") + format_size (memory_info . total)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:" . to_string ()) ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } } ; sleep (1000i32) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpc1GSEb/main.rs:1:2318
  |
1 | ... { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } } ...
  |       ^^                                                                                                                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===" . to_string ()) ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! ("{}" , format ! ("{}{}" , "Host: " , hostname)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "OS: " , os_info . name) , " ") + os_info . version) ; println ! ("{}" , format ! ("{}{}" , "CPUs: " , cpu_count . to_s ())) ; println ! ("{}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("" . to_string ()) ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit" . to_string ()) ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") + format_size (memory_info . total)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:" . to_string ()) ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===" . to_string ()) ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! ("{}" , format ! ("{}{}" , "Host: " , hostname)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "OS: " , os_info . name) , " ") + os_info . version) ; println ! ("{}" , format ! ("{}{}" , "CPUs: " , cpu_count . to_s ())) ; println ! ("{}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("" . to_string ()) ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit" . to_string ()) ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") + format_size (memory_info . total)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:" . to_string ()) ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpc1GSEb/main.rs:1:148
  |
1 | ...process ; ; println ! ("=== System Monitor ===" . to_string ()) ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpc1GSEb/main.rs:1:638
  |
1 | ...rintln ! ("{}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("" . to_string ()) ; loop { { { let cpu_usa...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpc1GSEb/main.rs:1:685
  |
1 | ... , format_size (total_memory))) ; println ! ("" . to_string ()) ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `clear_screen` in this scope
 --> /tmp/.tmpc1GSEb/main.rs:1:904
  |
1 | ...mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit" . to_string ()) ...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpc1GSEb/main.rs:1:975
  |
1 | ...ntln ! ("System Monitor - Press Ctrl+C to exit" . to_string ()) ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , format ! ("{}{}" ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmpc1GSEb/main.rs:1:1013
  |
1 | ... Press Ctrl+C to exit" . to_string ()) ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , form...
  |                                                               --- ^ ----- i32
  |                                                               |
  |                                                               &str

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmpc1GSEb/main.rs:1:1167
  |
1 | ...age . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent ...
  |                                                        ^^^^ method not found in `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpc1GSEb/main.rs:1:1141
  |
1 | ..." , cpu_usage . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut me...
  |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `str`
  |
help: consider borrowing here
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===" . to_string ()) ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! ("{}" , format ! ("{}{}" , "Host: " , hostname)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "OS: " , os_info . name) , " ") + os_info . version) ; println ! ("{}" , format ! ("{}{}" , "CPUs: " , cpu_count . to_s ())) ; println ! ("{}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("" . to_string ()) ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit" . to_string ()) ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") + &("█" * cpu_usage * 50i32 . to_i ()) + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") + format_size (memory_info . total)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:" . to_string ()) ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ++                                 +

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmpc1GSEb/main.rs:1:1181
  |
1 | ... . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = m...
  |                                                               --- ^ ----- i32
  |                                                               |
  |                                                               &str

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmpc1GSEb/main.rs:1:1211
  |
1 | ...50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ;...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmpc1GSEb/main.rs:1:1441
  |
1 | ...t . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{}" , ...
  |                                                        ^^^^ method not found in `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpc1GSEb/main.rs:1:1413
  |
1 | ... mem_percent . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println...
  |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `str`
  |
help: consider borrowing here
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===" . to_string ()) ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! ("{}" , format ! ("{}{}" , "Host: " , hostname)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "OS: " , os_info . name) , " ") + os_info . version) ; println ! ("{}" , format ! ("{}{}" , "CPUs: " , cpu_count . to_s ())) ; println ! ("{}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("" . to_string ()) ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit" . to_string ()) ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") + &("█" * mem_percent * 50i32 . to_i ()) + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") + format_size (memory_info . total)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:" . to_string ()) ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ++                                   +

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmpc1GSEb/main.rs:1:1455
  |
1 | ... to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{}" , for...
  |                                                               --- ^ ----- i32
  |                                                               |
  |                                                               &str

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmpc1GSEb/main.rs:1:1487
  |
1 | ...i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "     " ...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpc1GSEb/main.rs:1:1571
  |
1 | ... format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") + format_size (memory_info . total)) ; pri...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpc1GSEb/main.rs:1:1616
  |
1 | ..." , format_size (memory_info . used)) , " / ") + format_size (memory_info . total)) ; println ! ("{}" , format ! ("{}{}" , format ! ("...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpc1GSEb/main.rs:1:1726
  |
1 | ... ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , f...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpc1GSEb/main.rs:1:1846
  |
1 | ... ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpc1GSEb/main.rs:1:1965
  |
1 | ...at ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{}" , format ! (...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpc1GSEb/main.rs:1:2093
  |
1 | ...at ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpc1GSEb/main.rs:1:2187
  |
1 | ..., "/s")) ; println ! ("\nTop Processes by CPU:" . to_string ()) ; let mut processes = process :: list () . sort_by (| p | - p . cpu_pe...
  |                                                      ^^^^^^^^^ not found in this scope

warning: unreachable expression
 --> /tmp/.tmpc1GSEb/main.rs:1:2544
  |
1 | ... ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit" . to_string ()) ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () , "|")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () , "|")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") + format_size (memory_info . total)) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:" . to_string ()) ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") + proc . name , " ") + proc . cpu_percent . to_s () , "%")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |       --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression
  |       |
  |       any code following this expression is unreachable
  |
  = note: `#[warn(unreachable_code)]` on by default

error: aborting due to 32 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0308, E0369, E0425, E0432, E0599.
For more information about an error, try `rustc --explain E0308`.



=== ch08-00-systems-programming example 2 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpQ5guIn/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut pid = process :: current_pid () ; let mut ppid = process :: paren...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpQ5guIn/main.rs:1:351
  |
1 | ... { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "PID: " , proc . pid . to_s ()) , ", Name: ") + proc . name , ", CPU: ") + proc . cpu_percent . to_s () , "%")) } } ...
  |       ^^                                                                                                                                                                                                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { let mut pid = process :: current_pid () ; let mut ppid = process :: parent_pid () ; let mut exe_path = process :: executable_path () ; let mut args = process :: args () ; let mut env = process :: environment () ; let mut all_processes = process :: list () ; for proc in all_processes { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "PID: " , proc . pid . to_s ()) , ", Name: ") + proc . name , ", CPU: ") + proc . cpu_percent . to_s () , "%")) } } ; let mut chrome_procs = process :: find_by_name ("chrome" . to_string ()) ; let mut high_cpu_procs = process :: list () . into_iter () . filter (| p | p . cpu_percent > 50i32) . collect () ; let mut proc = process :: from_pid (1234i32) ; proc . suspend () ; proc . resume () ; proc . terminate () ; proc . kill () ; let mut child = process :: spawn ("ls" . to_string () , vec ! ["-la"]) ; let mut output = child . wait_with_output () ; println ! ("{}" , output . stdout) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { let mut pid = process :: current_pid () ; let mut ppid = process :: parent_pid () ; let mut exe_path = process :: executable_path () ; let mut args = process :: args () ; let mut env = process :: environment () ; let mut all_processes = process :: list () ; for proc in all_processes { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "PID: " , proc . pid . to_s ()) , ", Name: ") + proc . name , ", CPU: ") + proc . cpu_percent . to_s () , "%")) } ; let mut chrome_procs = process :: find_by_name ("chrome" . to_string ()) ; let mut high_cpu_procs = process :: list () . into_iter () . filter (| p | p . cpu_percent > 50i32) . collect () ; let mut proc = process :: from_pid (1234i32) ; proc . suspend () ; proc . resume () ; proc . terminate () ; proc . kill () ; let mut child = process :: spawn ("ls" . to_string () , vec ! ["-la"]) ; let mut output = child . wait_with_output () ; println ! ("{}" , output . stdout) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpQ5guIn/main.rs:1:79
  |
1 | ...in () { let result = { let mut pid = process :: current_pid () ; let mut ppid = process :: parent_pid () ; let mut exe_path = process ...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpQ5guIn/main.rs:1:122
  |
1 | ...s :: current_pid () ; let mut ppid = process :: parent_pid () ; let mut exe_path = process :: executable_path () ; let mut args = proc...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpQ5guIn/main.rs:1:168
  |
1 | ...: parent_pid () ; let mut exe_path = process :: executable_path () ; let mut args = process :: args () ; let mut env = process :: envi...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpQ5guIn/main.rs:1:215
  |
1 | ... executable_path () ; let mut args = process :: args () ; let mut env = process :: environment () ; let mut all_processes = process ::...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpQ5guIn/main.rs:1:250
  |
1 | ...= process :: args () ; let mut env = process :: environment () ; let mut all_processes = process :: list () ; for proc in all_processe...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpQ5guIn/main.rs:1:302
  |
1 | ...ronment () ; let mut all_processes = process :: list () ; for proc in all_processes { { println ! ("{}" , format ! ("{}{}" , format ! ...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpQ5guIn/main.rs:1:588
  |
1 | ..., "%")) } } ; let mut chrome_procs = process :: find_by_name ("chrome" . to_string ()) ; let mut high_cpu_procs = process :: list () ....
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpQ5guIn/main.rs:1:665
  |
1 | ...tring ()) ; let mut high_cpu_procs = process :: list () . into_iter () . filter (| p | p . cpu_percent > 50i32) . collect () ; let mut...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpQ5guIn/main.rs:1:770
  |
1 | ...50i32) . collect () ; let mut proc = process :: from_pid (1234i32) ; proc . suspend () ; proc . resume () ; proc . terminate () ; proc...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpQ5guIn/main.rs:1:896
  |
1 | ...) ; proc . kill () ; let mut child = process :: spawn ("ls" . to_string () , vec ! ["-la"]) ; let mut output = child . wait_with_outpu...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error: aborting due to 10 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0433`.



=== ch08-00-systems-programming example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-systems-programming example 4 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpo0SCZG/main.rs:1:1040
  |
1 | ... data = shared . read (0i32 , 1024i32) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error: expected `,`, found `.`
 --> /tmp/.tmpo0SCZG/main.rs:1:607
  |
1 | ...< 100i32 { _000_000 } ; { println ! ("WARNING: Low memory!" . to_string ()) ; free_caches () } ; let mut mmap = memory :: map_file ("h...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpo0SCZG/main.rs:1:609
  |
1 | ... < 100i32 { _000_000 } ; { println ! ("WARNING: Low memory!" . to_string ()) ; free_caches () } ; let mut mmap = memory :: map_file ("...
  |                                          ----------------------   ^^^^^^^^^^^^ argument never used
  |                                          |
  |                                          formatting specifier missing

error[E0425]: cannot find value `_000_000` in this scope
 --> /tmp/.tmpo0SCZG/main.rs:1:558
  |
1 | ...d . to_s ())) ; if mem_info . available < 100i32 { _000_000 } ; { println ! ("WARNING: Low memory!" . to_string ()) ; free_caches () }...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `READ_ONLY` in this scope
 --> /tmp/.tmpo0SCZG/main.rs:1:715
  |
1 | ... :: map_file ("huge_dataset.bin" . to_string () , READ_ONLY) ; let mut data = mmap . read_range (0i32 , 1000000i32) ; mmap . close () ...
  |                                                      ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpo0SCZG/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut mem_info = system :: memory_info () ; println ! ("{}" , format ! ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `system`
 --> /tmp/.tmpo0SCZG/main.rs:1:84
  |
1 | ...) { let result = { let mut mem_info = system :: memory_info () ; println ! ("{}" , format ! ("{}{}" , "Total: " , mem_info . total . t...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `system`
  |
  = help: you might be missing a crate named `system`

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpo0SCZG/main.rs:1:609
  |
1 | ...000_000 } ; { println ! ("WARNING: Low memory!" . to_string ()) ; free_caches () } ; let mut mmap = memory :: map_file ("huge_dataset....
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `free_caches` in this scope
 --> /tmp/.tmpo0SCZG/main.rs:1:625
  |
1 | ...ntln ! ("WARNING: Low memory!" . to_string ()) ; free_caches () } ; let mut mmap = memory :: map_file ("huge_dataset.bin" . to_string ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `memory`
 --> /tmp/.tmpo0SCZG/main.rs:1:659
  |
1 | ...) ; free_caches () } ; let mut mmap = memory :: map_file ("huge_dataset.bin" . to_string () , READ_ONLY) ; let mut data = mmap . read_...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `memory`
  |
  = help: you might be missing a crate named `memory`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `memory`
 --> /tmp/.tmpo0SCZG/main.rs:1:818
  |
1 | ... ; mmap . close () ; let mut shared = memory :: create_shared ("my_buffer" . to_string () , 1024i32 * 1024i32) ; shared . write (0i32 ...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `memory`
  |
  = help: you might be missing a crate named `memory`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `memory`
 --> /tmp/.tmpo0SCZG/main.rs:1:941
  |
1 | ...rite (0i32 , data) ; let mut shared = memory :: open_shared ("my_buffer" . to_string ()) ; let mut data = shared . read (0i32 , 1024i3...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `memory`
  |
  = help: you might be missing a crate named `memory`

error: aborting due to 11 previous errors; 1 warning emitted

Some errors have detailed explanations: E0425, E0433.
For more information about an error, try `rustc --explain E0425`.



=== ch08-00-systems-programming example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-systems-programming example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-systems-programming example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-systems-programming example 8 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `RECURSIVE` in this scope
 --> /tmp/.tmpkYWXlu/main.rs:1:130
  |
1 | ... = fs :: watch ("/path/to/watch" . to_string () , RECURSIVE) ; watcher . on ("created" , | path | { println ! ("{}" , format ! ("{}{}"...
  |                                                      ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpkYWXlu/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut watcher = fs :: watch ("/path/to/watch" . to_string () , RECURSIV...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`
 --> /tmp/.tmpkYWXlu/main.rs:1:83
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut watcher = fs :: watch ("/path/to/watch" . to_string () , RECURSIV...
  |                                                                                   ^^ use of unresolved module or unlinked crate `fs`
  |
  = help: you might be missing a crate named `fs`

error[E0425]: cannot find function `process_change` in this scope
 --> /tmp/.tmpkYWXlu/main.rs:1:352
  |
1 | ...format ! ("{}{}" , "File modified: " , path)) ; process_change (path) }) ; watcher . on ("deleted" , | path | { println ! ("{}" , form...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 1 warning emitted

Some errors have detailed explanations: E0425, E0433.
For more information about an error, try `rustc --explain E0425`.



=== ch08-00-systems-programming example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-advanced-functions-tdd example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-advanced-functions-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `Type` in this scope
 --> /tmp/.tmp3VYqAs/main.rs:1:60
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |                                                            ^^^^ not found in this scope

error[E0412]: cannot find type `ResultType` in this scope
 --> /tmp/.tmp3VYqAs/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |                                                                     ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `condition1` in this scope
 --> /tmp/.tmp3VYqAs/main.rs:1:87
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |                                                                                       ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `result1` in this scope
 --> /tmp/.tmp3VYqAs/main.rs:1:109
  |
1 | ...: Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn m...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `condition2` in this scope
 --> /tmp/.tmp3VYqAs/main.rs:1:126
  |
1 | ...ype { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `result2` in this scope
 --> /tmp/.tmp3VYqAs/main.rs:1:148
  |
1 | ... { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `default_result` in this scope
 --> /tmp/.tmp3VYqAs/main.rs:1:169
  |
1 | ...; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp3VYqAs/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp3VYqAs/main.rs:1:100
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |                                                                                                    ^^              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
1 + use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { return result1 } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp3VYqAs/main.rs:1:139
  |
1 | ... { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |                                                              ^^              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
1 + use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { return result2 } ; return default_result } } fn main () { }
  |

error: aborting due to 7 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch08-00-advanced-functions-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `Type` in this scope
 --> /tmp/.tmp6ZlffK/main.rs:1:60
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |                                                            ^^^^ not found in this scope

error[E0412]: cannot find type `Type` in this scope
 --> /tmp/.tmp6ZlffK/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |                                                                     ^^^^ not found in this scope

error[E0425]: cannot find value `base_condition` in this scope
 --> /tmp/.tmp6ZlffK/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |                                                                                 ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `base_value` in this scope
 --> /tmp/.tmp6ZlffK/main.rs:1:107
  |
1 | ... : Type) -> Type { { if base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
  |                                                      ^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp6ZlffK/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp6ZlffK/main.rs:1:98
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |                                                                                                  ^^                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
1 + use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { return base_value } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
  |

error[E0425]: cannot find function `reduce` in this scope
 --> /tmp/.tmp6ZlffK/main.rs:1:160
  |
1 | ...ase_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
  |                                                        ^^^^^^ not found in this scope

error[E0425]: cannot find function `combine` in this scope
 --> /tmp/.tmp6ZlffK/main.rs:1:131
  |
1 | ... base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 6 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch08-00-advanced-functions-tdd example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 12 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch03-01-testing-functions example 1 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch03-01-testing-functions example 2 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch03-01-testing-functions example 3 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch03-01-testing-functions example 4 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch03-01-testing-functions example 5 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch03-01-testing-functions example 6 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch03-01-testing-functions example 7 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch03-01-testing-functions example 8 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch03-01-testing-functions example 9 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch03-01-testing-functions example 10 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch03-01-testing-functions example 11 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch03-01-testing-functions example 12 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch16-00-testing-quality example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 2 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmp8UZb1d/main.rs:1:513
  |
1 | ... . spawn (|| { heavy_computation () }) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error: expected `,`, found `.`
 --> /tmp/.tmp8UZb1d/main.rs:1:126
  |
1 | ...et mut handle = spawn ; { println ! ("Running in parallel!" . to_string ()) ; compute_result () } ; let mut result = handle . join () ...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmp8UZb1d/main.rs:1:128
  |
1 | ...let mut handle = spawn ; { println ! ("Running in parallel!" . to_string ()) ; compute_result () } ; let mut result = handle . join ()...
  |                                          ----------------------   ^^^^^^^^^^^^ argument never used
  |                                          |
  |                                          formatting specifier missing

error[E0425]: cannot find value `spawn` in this scope
 --> /tmp/.tmp8UZb1d/main.rs:1:82
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut handle = spawn ; { println ! ("Running in parallel!" . to_string ...
  |                                                                                  ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::spawn;
  |

error[E0425]: cannot find value `spawn` in this scope
 --> /tmp/.tmp8UZb1d/main.rs:1:263
  |
1 | ...ata = vec ! [1i32 , 2i32 , 3i32] ; let mut handle = spawn ; r#move ; { { let sum = data . sum () ; println ! ("{}" , format ! ("{}{}" ...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::spawn;
  |

error[E0425]: cannot find value `r#move` in this scope
 --> /tmp/.tmp8UZb1d/main.rs:1:271
  |
1 | ...c ! [1i32 , 2i32 , 3i32] ; let mut handle = spawn ; r#move ; { { let sum = data . sum () ; println ! ("{}" , format ! ("{}{}" , "Sum: ...
  |                                                        ^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp8UZb1d/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut handle = spawn ; { println ! ("Running in parallel!" . to_string ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmp8UZb1d/main.rs:1:128
  |
1 | ...e = spawn ; { println ! ("Running in parallel!" . to_string ()) ; compute_result () } ; let mut result = handle . join () ; let mut da...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `compute_result` in this scope
 --> /tmp/.tmp8UZb1d/main.rs:1:144
  |
1 | ...tln ! ("Running in parallel!" . to_string ()) ; compute_result () } ; let mut result = handle . join () ; let mut data = vec ! [1i32 ,...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `sum` found for struct `Vec<i32>` in the current scope
 --> /tmp/.tmp8UZb1d/main.rs:1:301
  |
1 | ...ut handle = spawn ; r#move ; { { let sum = data . sum () ; println ! ("{}" , format ! ("{}{}" , "Sum: " , sum . to_s ())) } } ; let mu...
  |                                                      ^^^ `Vec<i32>` is not an iterator
  |
help: call `.into_iter()` first
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut handle = spawn ; { println ! ("Running in parallel!" . to_string ()) ; compute_result () } ; let mut result = handle . join () ; let mut data = vec ! [1i32 , 2i32 , 3i32] ; let mut handle = spawn ; r#move ; { { let sum = data . into_iter().sum () ; println ! ("{}" , format ! ("{}{}" , "Sum: " , sum . to_s ())) } } ; let mut handle = Thread :: builder () . name ("worker") . stack_size (4i32 * 1024i32 * 1024i32) . spawn (|| { heavy_computation () }) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |                                                                                                                                                                                                                                                                                                             ++++++++++++

error: aborting due to 9 previous errors; 1 warning emitted

Some errors have detailed explanations: E0425, E0599.
For more information about an error, try `rustc --explain E0425`.



=== ch14-00-concurrency example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 12 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 13 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch04-00-command-line-tools example 1 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpCg3E49/main.rs:1:96
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("Word Counter Tool" . to_string ()) ; print ! ("Enter filename...
  |                                                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpCg3E49/main.rs:1:98
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("Word Counter Tool" . to_string ()) ; print ! ("Enter filename...
  |                                                                            -------------------   ^^^^^^^^^^^^ argument never used
  |                                                                            |
  |                                                                            formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpCg3E49/main.rs:1:142
  |
1 | ...Counter Tool" . to_string ()) ; print ! ("Enter filename: " . to_string ()) ; let mut filename = input () ; let mut content = read_fil...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpCg3E49/main.rs:1:144
  |
1 | ...ounter Tool" . to_string ()) ; print ! ("Enter filename: " . to_string ()) ; let mut filename = input () ; let mut content = read_file...
  |                                            ------------------   ^^^^^^^^^^^^ argument never used
  |                                            |
  |                                            formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpCg3E49/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("Word Counter Tool" . to_string ()) ; print ! ("Enter filename...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpCg3E49/main.rs:1:98
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("Word Counter Tool" . to_string ()) ; print ! ("Enter filename...
  |                                                                                                  ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpCg3E49/main.rs:1:144
  |
1 | ..." . to_string ()) ; print ! ("Enter filename: " . to_string ()) ; let mut filename = input () ; let mut content = read_file (filename)...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpCg3E49/main.rs:1:179
  |
1 | ...er filename: " . to_string ()) ; let mut filename = input () ; let mut content = read_file (filename) ; let mut words = content . spli...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpCg3E49/main.rs:1:208
  |
1 | ...; let mut filename = input () ; let mut content = read_file (filename) ; let mut words = content . split_whitespace () ; let mut word_...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 8 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 2 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmp5f9UYu/main.rs:1:274
  |
1 | ...tudent? (y/n) " . to_string ()) == "y" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp5f9UYu/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut name = input ("What's your name? " . to_string ()) ; let mut age ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmp5f9UYu/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut name = input ("What's your name? " . to_string ()) ; let mut age ...
  |                                                                                ^^^^^ not found in this scope

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmp5f9UYu/main.rs:1:140
  |
1 | ...What's your name? " . to_string ()) ; let mut age = input ("How old are you? " . to_string ()) . to_i () ; let mut is_student = input ...
  |                                                        ^^^^^ not found in this scope

error: aborting due to 3 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 3 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmp5yiL2U/main.rs:1:462
  |
1 | ... file_size ("data.txt" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp5yiL2U/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut content = read_file ("data.txt" . to_string ()) ; let mut lines =...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmp5yiL2U/main.rs:1:83
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut content = read_file ("data.txt" . to_string ()) ; let mut lines =...
  |                                                                                   ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_lines` in this scope
 --> /tmp/.tmp5yiL2U/main.rs:1:139
  |
1 | ...ile ("data.txt" . to_string ()) ; let mut lines = read_lines ("data.txt" . to_string ()) ; write_file ("output.txt" . to_string () , "...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmp5yiL2U/main.rs:1:180
  |
1 | ... lines = read_lines ("data.txt" . to_string ()) ; write_file ("output.txt" . to_string () , "Hello, World!" . to_string ()) ; append_f...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `timestamp` in this scope
 --> /tmp/.tmp5yiL2U/main.rs:1:331
  |
1 | ...to_string () , format ! ("{}{}" , "New entry: " , timestamp ())) ; let mut exists = file_exists ("config.txt" . to_string ()) ; let mu...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `append_file` in this scope
 --> /tmp/.tmp5yiL2U/main.rs:1:256
  |
1 | ...to_string () , "Hello, World!" . to_string ()) ; append_file ("log.txt" . to_string () , format ! ("{}{}" , "New entry: " , timestamp ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmp5yiL2U/main.rs:1:365
  |
1 | ...New entry: " , timestamp ())) ; let mut exists = file_exists ("config.txt" . to_string ()) ; let mut size = file_size ("data.txt" . to...
  |                                                     ^^^^^^^^^^^ not found in this scope

error: aborting due to 7 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 4 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpyCDbEL/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut args = command_args () ; let mut program_name = args [0i32] ; let...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `command_args` in this scope
 --> /tmp/.tmpyCDbEL/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut args = command_args () ; let mut program_name = args [0i32] ; let...
  |                                                                                ^^^^^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 5 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmppZXgVv/main.rs:1:101
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Text Processor ===" . to_string ()) ; let mut filename = ...
  |                                                                                                     ^ expected `,`

error: argument never used
 --> /tmp/.tmppZXgVv/main.rs:1:103
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Text Processor ===" . to_string ()) ; let mut filename = ...
  |                                                                            ------------------------   ^^^^^^^^^^^^ argument never used
  |                                                                            |
  |                                                                            formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmppZXgVv/main.rs:1:448
  |
1 | ...nes = content . lines () ; println ! ("\nChoose operation:" . to_string ()) ; println ! ("1. Count lines" . to_string ()) ; println ! ...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmppZXgVv/main.rs:1:450
  |
1 | ...ines = content . lines () ; println ! ("\nChoose operation:" . to_string ()) ; println ! ("1. Count lines" . to_string ()) ; println !...
  |                                           ---------------------   ^^^^^^^^^^^^ argument never used
  |                                           |
  |                                           formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmppZXgVv/main.rs:1:494
  |
1 | ...e operation:" . to_string ()) ; println ! ("1. Count lines" . to_string ()) ; println ! ("2. Find and replace" . to_string ()) ; print...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmppZXgVv/main.rs:1:496
  |
1 | ...operation:" . to_string ()) ; println ! ("1. Count lines" . to_string ()) ; println ! ("2. Find and replace" . to_string ()) ; println...
  |                                             ----------------   ^^^^^^^^^^^^ argument never used
  |                                             |
  |                                             formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmppZXgVv/main.rs:1:545
  |
1 | ...t lines" . to_string ()) ; println ! ("2. Find and replace" . to_string ()) ; println ! ("3. Convert to uppercase" . to_string ()) ; p...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmppZXgVv/main.rs:1:547
  |
1 | ...nt lines" . to_string ()) ; println ! ("2. Find and replace" . to_string ()) ; println ! ("3. Convert to uppercase" . to_string ()) ; ...
  |                                           ---------------------   ^^^^^^^^^^^^ argument never used
  |                                           |
  |                                           formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmppZXgVv/main.rs:1:600
  |
1 | ...ace" . to_string ()) ; println ! ("3. Convert to uppercase" . to_string ()) ; println ! ("4. Remove empty lines" . to_string ()) ; let...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmppZXgVv/main.rs:1:602
  |
1 | ...eplace" . to_string ()) ; println ! ("3. Convert to uppercase" . to_string ()) ; println ! ("4. Remove empty lines" . to_string ()) ; ...
  |                                         -------------------------   ^^^^^^^^^^^^ argument never used
  |                                         |
  |                                         formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmppZXgVv/main.rs:1:653
  |
1 | ...rcase" . to_string ()) ; println ! ("4. Remove empty lines" . to_string ()) ; let mut choice = input ("Enter choice (1-4): " . to_stri...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmppZXgVv/main.rs:1:655
  |
1 | ...percase" . to_string ()) ; println ! ("4. Remove empty lines" . to_string ()) ; let mut choice = input ("Enter choice (1-4): " . to_st...
  |                                          -----------------------   ^^^^^^^^^^^^ argument never used
  |                                          |
  |                                          formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmppZXgVv/main.rs:1:1857
  |
1 | ..., output_file)) } } } , _ => { println ! ("Invalid choice!" . to_string ()) } , } } ; if let Some (s) = (& result as & dyn std :: any ...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmppZXgVv/main.rs:1:1859
  |
1 | ... output_file)) } } } , _ => { println ! ("Invalid choice!" . to_string ()) } , } } ; if let Some (s) = (& result as & dyn std :: any :...
  |                                             -----------------   ^^^^^^^^^^^^ argument never used
  |                                             |
  |                                             formatting specifier missing

error[E0425]: cannot find function `exit` in this scope
 --> /tmp/.tmppZXgVv/main.rs:1:319
  |
1 | ..." , "Error: File '" , filename) , "' not found!")) ; exit (1i32) } } ; let mut content = read_file (filename) ; let mut lines = conten...
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::process::exit;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmppZXgVv/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Text Processor ===" . to_string ()) ; let mut filename = ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmppZXgVv/main.rs:1:103
  |
1 | ... result = { println ! ("=== Text Processor ===" . to_string ()) ; let mut filename = input ("Enter filename: " . to_string ()) ; if ! ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmppZXgVv/main.rs:1:138
  |
1 | ...Processor ===" . to_string ()) ; let mut filename = input ("Enter filename: " . to_string ()) ; if ! file_exists (filename) { { printl...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmppZXgVv/main.rs:1:187
  |
1 | ...input ("Enter filename: " . to_string ()) ; if ! file_exists (filename) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "E...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmppZXgVv/main.rs:1:355
  |
1 | ...t found!")) ; exit (1i32) } } ; let mut content = read_file (filename) ; let mut lines = content . lines () ; println ! ("\nChoose ope...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmppZXgVv/main.rs:1:450
  |
1 | ...t . lines () ; println ! ("\nChoose operation:" . to_string ()) ; println ! ("1. Count lines" . to_string ()) ; println ! ("2. Find an...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmppZXgVv/main.rs:1:496
  |
1 | ..." . to_string ()) ; println ! ("1. Count lines" . to_string ()) ; println ! ("2. Find and replace" . to_string ()) ; println ! ("3. Co...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmppZXgVv/main.rs:1:547
  |
1 | ...o_string ()) ; println ! ("2. Find and replace" . to_string ()) ; println ! ("3. Convert to uppercase" . to_string ()) ; println ! ("4...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmppZXgVv/main.rs:1:602
  |
1 | ...ring ()) ; println ! ("3. Convert to uppercase" . to_string ()) ; println ! ("4. Remove empty lines" . to_string ()) ; let mut choice ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmppZXgVv/main.rs:1:655
  |
1 | ...string ()) ; println ! ("4. Remove empty lines" . to_string ()) ; let mut choice = input ("Enter choice (1-4): " . to_string ()) . to_...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmppZXgVv/main.rs:1:688
  |
1 | ...ove empty lines" . to_string ()) ; let mut choice = input ("Enter choice (1-4): " . to_string ()) . to_i () ; match choice { 1i32 => {...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmppZXgVv/main.rs:1:880
  |
1 | ...nes . len () . to_s ())) } , 2i32 => { { let find = input ("Find: " . to_string ()) ; { let mut replace = input ("Replace with: " . to...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmppZXgVv/main.rs:1:934
  |
1 | ...put ("Find: " . to_string ()) ; { let mut replace = input ("Replace with: " . to_string ()) ; let mut new_content = content . replace ...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmppZXgVv/main.rs:1:1105
  |
1 | ...= filename . replace (".txt" , "_modified.txt") ; write_file (output_file , new_content) ; println ! ("{}" , format ! ("{}{}" , "Saved...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmppZXgVv/main.rs:1:1349
  |
1 | ...le = filename . replace (".txt" , "_upper.txt") ; write_file (output_file , upper_content) ; println ! ("{}" , format ! ("{}{}" , "Sav...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmppZXgVv/main.rs:1:1704
  |
1 | ...le = filename . replace (".txt" , "_clean.txt") ; write_file (output_file , clean_content) ; println ! ("{}" , format ! ("{}{}" , "Sav...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmppZXgVv/main.rs:1:1859
  |
1 | ...e)) } } } , _ => { println ! ("Invalid choice!" . to_string ()) } , } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . do...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 31 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 6 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpiAzpEG/main.rs:1:99
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===" . to_string ()) ; let mut log_file = in...
  |                                                                                                   ^ expected `,`

error: argument never used
 --> /tmp/.tmpiAzpEG/main.rs:1:101
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===" . to_string ()) ; let mut log_file = in...
  |                                                                            ----------------------   ^^^^^^^^^^^^ argument never used
  |                                                                            |
  |                                                                            formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpiAzpEG/main.rs:1:827
  |
1 | ... / total_requests ; println ! ("\n=== Analysis Results ===" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "Total Requests: " ...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpiAzpEG/main.rs:1:829
  |
1 | ...0i32 / total_requests ; println ! ("\n=== Analysis Results ===" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "Total Requests...
  |                                       ----------------------------   ^^^^^^^^^^^^ argument never used
  |                                       |
  |                                       formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpiAzpEG/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===" . to_string ()) ; let mut log_file = in...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpiAzpEG/main.rs:1:380
  |
1 | ... { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ...
  |       ^^                                                                                                                                                                                                  ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===" . to_string ()) ; let mut log_file = input ("Enter log file path: " . to_string ()) ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===" . to_string ()) ; let mut log_file = input ("Enter log file path: " . to_string ()) ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpiAzpEG/main.rs:1:413
  |
1 | ... for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_co...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===" . to_string ()) ; let mut log_file = input ("Enter log file path: " . to_string ()) ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===" . to_string ()) ; let mut log_file = input ("Enter log file path: " . to_string ()) ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { success_count += 1i32 } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpiAzpEG/main.rs:1:479
  |
1 | ...nt += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count...
  |                                                         ^^                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===" . to_string ()) ; let mut log_file = input ("Enter log file path: " . to_string ()) ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===" . to_string ()) ; let mut log_file = input ("Enter log file path: " . to_string ()) ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { not_found_count += 1i32 } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpiAzpEG/main.rs:1:547
  |
1 | ...ount += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 1...
  |                                                           ^^                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===" . to_string ()) ; let mut log_file = input ("Enter log file path: " . to_string ()) ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===" . to_string ()) ; let mut log_file = input ("Enter log file path: " . to_string ()) ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { error_count += 1i32 } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpiAzpEG/main.rs:1:1487
  |
1 | ... lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let m...
  |             ^^                                                                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===" . to_string ()) ; let mut log_file = input ("Enter log file path: " . to_string ()) ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===" . to_string ()) ; let mut log_file = input ("Enter log file path: " . to_string ()) ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpiAzpEG/main.rs:1:101
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Log Analyzer ===" . to_string ()) ; let mut log_file = in...
  |                                                                                                     ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpiAzpEG/main.rs:1:136
  |
1 | ... Analyzer ===" . to_string ()) ; let mut log_file = input ("Enter log file path: " . to_string ()) ; let mut lines = read_lines (log_f...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `read_lines` in this scope
 --> /tmp/.tmpiAzpEG/main.rs:1:201
  |
1 | ...og file path: " . to_string ()) ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_co...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpiAzpEG/main.rs:1:829
  |
1 | ...uests ; println ! ("\n=== Analysis Results ===" . to_string ()) ; println ! ("{}" , format ! ("{}{}" , "Total Requests: " , total_requ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpiAzpEG/main.rs:1:1043
  |
1 | ...mat ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{}" , format !...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpiAzpEG/main.rs:1:1080
  |
1 | ...uccess_count . to_s ()) , " (") + success_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpiAzpEG/main.rs:1:1214
  |
1 | ...! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{}" , format...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpiAzpEG/main.rs:1:1253
  |
1 | ...ound_count . to_s ()) , " (") + not_found_percent . to_s () , "%)")) ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , format ...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpiAzpEG/main.rs:1:1386
  |
1 | ... ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; f...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpiAzpEG/main.rs:1:1421
  |
1 | ... , error_count . to_s ()) , " (") + error_percent . to_s () , "%)")) ; let mut hour_counts = () ; for line in lines { { { let timestam...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `extract_hour` in this scope
 --> /tmp/.tmpiAzpEG/main.rs:1:1507
  |
1 | ...s = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) ...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `get` found for unit type `()` in the current scope
    --> /tmp/.tmpiAzpEG/main.rs:1:1569
     |
1    | ... = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let mut busiest_hour = hour_cou...
     |                                                                     ^^^
     |
help: there is a method `ge` with a similar name, but with different arguments
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1438:5
     |
1438 |     fn ge(&self, other: &Rhs) -> bool {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `max_by_value` found for unit type `()` in the current scope
 --> /tmp/.tmpiAzpEG/main.rs:1:1644
  |
1 | ...32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Busie...
  |                                                    ^^^^^^^^^^^^ method not found in `()`

error: aborting due to 17 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0425, E0599.
For more information about an error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 7 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpBRTfsV/main.rs:1:105
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Batch File Renamer ===" . to_string ()) ; let mut directo...
  |                                                                                                         ^ expected `,`

error: argument never used
 --> /tmp/.tmpBRTfsV/main.rs:1:107
  |
1 | ...ain () { let result = { println ! ("=== Batch File Renamer ===" . to_string ()) ; let mut directory = input ("Enter directory path: " ...
  |                                       ----------------------------   ^^^^^^^^^^^^ argument never used
  |                                       |
  |                                       formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpBRTfsV/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Batch File Renamer ===" . to_string ()) ; let mut directo...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpBRTfsV/main.rs:1:423
  |
1 | ... { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") + new_name) ; renamed_count += 1i32 } } else { { println ! ("{}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Batch File Renamer ===" . to_string ()) ; let mut directory = input ("Enter directory path: " . to_string ()) ; let mut pattern = input ("Enter pattern to find: " . to_string ()) ; let mut replacement = input ("Enter replacement: " . to_string ()) ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") + new_name) ; renamed_count += 1i32 } } else { { println ! ("{}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Batch File Renamer ===" . to_string ()) ; let mut directory = input ("Enter directory path: " . to_string ()) ; let mut pattern = input ("Enter pattern to find: " . to_string ()) ; let mut replacement = input ("Enter replacement: " . to_string ()) ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") + new_name) ; renamed_count += 1i32 } } else { { println ! ("{}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpBRTfsV/main.rs:1:456
  |
1 | ... { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") + new_name) ; renamed_count += 1i32 } } else { { println ! ("{}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Batch File Renamer ===" . to_string ()) ; let mut directory = input ("Enter directory path: " . to_string ()) ; let mut pattern = input ("Enter pattern to find: " . to_string ()) ; let mut replacement = input ("Enter replacement: " . to_string ()) ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") + new_name) ; renamed_count += 1i32 } } else { { println ! ("{}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Batch File Renamer ===" . to_string ()) ; let mut directory = input ("Enter directory path: " . to_string ()) ; let mut pattern = input ("Enter pattern to find: " . to_string ()) ; let mut replacement = input ("Enter replacement: " . to_string ()) ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") + new_name) ; renamed_count += 1i32 } } else { { println ! ("{}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpBRTfsV/main.rs:1:796
  |
1 | ...enamed_count += 1i32 } } else { { println ! ("{}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ; println ! ("{}"...
  |                                    ^^                                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Batch File Renamer ===" . to_string ()) ; let mut directory = input ("Enter directory path: " . to_string ()) ; let mut pattern = input ("Enter pattern to find: " . to_string ()) ; let mut replacement = input ("Enter replacement: " . to_string ()) ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") + new_name) ; renamed_count += 1i32 } } else { { println ! ("{}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { println ! ("=== Batch File Renamer ===" . to_string ()) ; let mut directory = input ("Enter directory path: " . to_string ()) ; let mut pattern = input ("Enter pattern to find: " . to_string ()) ; let mut replacement = input ("Enter replacement: " . to_string ()) ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") + new_name) ; renamed_count += 1i32 } } else { println ! ("{}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpBRTfsV/main.rs:1:107
  |
1 | ...ult = { println ! ("=== Batch File Renamer ===" . to_string ()) ; let mut directory = input ("Enter directory path: " . to_string ()) ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpBRTfsV/main.rs:1:143
  |
1 | ... Renamer ===" . to_string ()) ; let mut directory = input ("Enter directory path: " . to_string ()) ; let mut pattern = input ("Enter ...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpBRTfsV/main.rs:1:211
  |
1 | ...rectory path: " . to_string ()) ; let mut pattern = input ("Enter pattern to find: " . to_string ()) ; let mut replacement = input ("E...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpBRTfsV/main.rs:1:284
  |
1 | ... to find: " . to_string ()) ; let mut replacement = input ("Enter replacement: " . to_string ()) ; let mut files = list_files (directo...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `list_files` in this scope
 --> /tmp/.tmpBRTfsV/main.rs:1:347
  |
1 | ... replacement: " . to_string ()) ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if fil...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpBRTfsV/main.rs:1:537
  |
1 | ...ce (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ;...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpBRTfsV/main.rs:1:587
  |
1 | ...y , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , format ! ...
  |                                   ^^^^^^^^^ help: a local variable with a similar name exists: `old_path`

error[E0425]: cannot find function `rename_file` in this scope
 --> /tmp/.tmpBRTfsV/main.rs:1:625
  |
1 | ...new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , format ! ("{}{}" , format ! (...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpBRTfsV/main.rs:1:970
  |
1 | ..., format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) ...
  |                                                        ^^^^ method not found in `i32`

error: aborting due to 11 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0425, E0599.
For more information about an error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 8 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpppMZXm/main.rs:1:1076
  |
1 | ...lename) { { println ! ("Processing completed successfully!" . to_string ()) } } else { { println ! ("Processing failed!" . to_string (...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpppMZXm/main.rs:1:1078
  |
1 | ...file (filename) { { println ! ("Processing completed successfully!" . to_string ()) } } else { { println ! ("Processing failed!" . to_...
  |                                   ------------------------------------   ^^^^^^^^^^^^ argument never used
  |                                   |
  |                                   formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpppMZXm/main.rs:1:1137
  |
1 | ... to_string ()) } } else { { println ! ("Processing failed!" . to_string ()) ; exit (1i32) } } ; }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpppMZXm/main.rs:1:1139
  |
1 | ... to_string ()) } } else { { println ! ("Processing failed!" . to_string ()) ; exit (1i32) } } ; }
  |                                           --------------------   ^^^^^^^^^^^^ argument never used
  |                                           |
  |                                           formatting specifier missing

error[E0423]: expected value, found macro `try`
 --> /tmp/.tmpppMZXm/main.rs:1:567
  |
1 | ...rmission denied?)")) ; return false } } ; { let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! ("{}" , for...
  |                                                              ^^^^^ not a value

error[E0425]: cannot find value `catch` in this scope
 --> /tmp/.tmpppMZXm/main.rs:1:604
  |
1 | ... let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! ("{}" , format ! ("{}{}" , "❌ Error reading file: " , e...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpppMZXm/main.rs:1:612
  |
1 | ...tent = r#try ; { { read_file (filename) } ; catch ; error ; { println ! ("{}" , format ! ("{}{}" , "❌ Error reading file: " , error . t...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpppMZXm/main.rs:1:686
  |
1 | ...{}" , format ! ("{}{}" , "❌ Error reading file: " , error . to_s ())) ; return false } ; let mut word_count = content . split_whitespac...
  |                                                         ^^^^^ not found in this scope

error[E0425]: cannot find function `exit` in this scope
 --> /tmp/.tmpppMZXm/main.rs:1:1155
  |
1 | ... { println ! ("Processing failed!" . to_string ()) ; exit (1i32) } } ; }
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::process::exit;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpppMZXm/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn process_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fm...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpppMZXm/main.rs:1:1026
  |
1 | ...) ; if process_file (filename) { { println ! ("Processing completed successfully!" . to_string ()) } } else { { println ! ("Processing...
  |                                     ^^                                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (filename : T) -> T { { if ! file_exists (filename) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Error: File '" , filename) , "' does not exist")) ; return false } } ; if ! file_readable (filename) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Error: Cannot read file '" , filename) , "' (permission denied?)")) ; return false } } ; { let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! ("{}" , format ! ("{}{}" , "❌ Error reading file: " , error . to_s ())) ; return false } ; let mut word_count = content . split_whitespace () . len () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "✅ File processed: " , word_count . to_s ()) , " words")) ; return true } } } } fn main () { let mut filename = input ("Enter filename: " . to_string ()) ; if process_file (filename) { { println ! ("Processing completed successfully!" . to_string ()) } } else { { println ! ("Processing failed!" . to_string ()) ; exit (1i32) } } ; }
1 + use std :: collections :: HashMap ; fn process_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (filename : T) -> T { { if ! file_exists (filename) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Error: File '" , filename) , "' does not exist")) ; return false } } ; if ! file_readable (filename) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Error: Cannot read file '" , filename) , "' (permission denied?)")) ; return false } } ; { let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! ("{}" , format ! ("{}{}" , "❌ Error reading file: " , error . to_s ())) ; return false } ; let mut word_count = content . split_whitespace () . len () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "✅ File processed: " , word_count . to_s ()) , " words")) ; return true } } } } fn main () { let mut filename = input ("Enter filename: " . to_string ()) ; if process_file (filename) { println ! ("Processing completed successfully!" . to_string ()) } else { { println ! ("Processing failed!" . to_string ()) ; exit (1i32) } } ; }
  |

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpppMZXm/main.rs:1:212
  |
1 | ... :: Debug + Clone > (filename : T) -> T { { if ! file_exists (filename) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpppMZXm/main.rs:1:357
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (filename : T) -> T { { if ! file_exists (filename) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌ Error: File '" , filename) , "' does not exist")) ; return false } }...
  |       - expected this type parameter                                                                                                                    - expected `T` because of return type                                                                                                                        ^^^^^ expected type parameter `T`, found `bool`
  |
  = note: expected type parameter `T`
                       found type `bool`
  = note: the caller chooses a type for `T` which can be different from `bool`

error[E0425]: cannot find function `file_readable` in this scope
 --> /tmp/.tmpppMZXm/main.rs:1:374
  |
1 | ... "' does not exist")) ; return false } } ; if ! file_readable (filename) { { println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "❌...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpppMZXm/main.rs:1:579
  |
1 | ... ; return false } } ; { let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! ("{}" , format ! ("{}{}" , "❌ Er...
  |                                                      ^^^^^^^^^ not found in this scope

warning: unreachable statement
 --> /tmp/.tmpppMZXm/main.rs:1:723
  |
1 | ...or . to_s ())) ; return false } ; let mut word_count = content . split_whitespace () . len () ; println ! ("{}" , format ! ("{}{}" , f...
  |                     ------------     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable statement
  |                     |
  |                     any code following this expression is unreachable
  |
  = note: `#[warn(unreachable_code)]` on by default

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpppMZXm/main.rs:1:953
  |
1 | ...return true } } } } fn main () { let mut filename = input ("Enter filename: " . to_string ()) ; if process_file (filename) { { println...
  |                                                        ^^^^^ not found in this scope

error[E0277]: cannot add `bool` to `bool`
 --> /tmp/.tmpppMZXm/main.rs:1:1014
  |
1 | ...nter filename: " . to_string ()) ; if process_file (filename) { { println ! ("Processing completed successfully!" . to_string ()) } } ...
  |                                          ------------  ^^^^^^^^ no implementation for `bool + bool`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `bool`
note: required by a bound in `process_file`
 --> /tmp/.tmpppMZXm/main.rs:1:59
  |
1 | use std :: collections :: HashMap ; fn process_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fm...
  |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `process_file`

error[E0277]: cannot multiply `bool` by `bool`
 --> /tmp/.tmpppMZXm/main.rs:1:1014
  |
1 | ...nter filename: " . to_string ()) ; if process_file (filename) { { println ! ("Processing completed successfully!" . to_string ()) } } ...
  |                                          ------------  ^^^^^^^^ no implementation for `bool * bool`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `bool`
note: required by a bound in `process_file`
 --> /tmp/.tmpppMZXm/main.rs:1:94
  |
1 | ...: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (filename : T) ...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `process_file`

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpppMZXm/main.rs:1:1078
  |
1 | ...println ! ("Processing completed successfully!" . to_string ()) } } else { { println ! ("Processing failed!" . to_string ()) ; exit (1...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpppMZXm/main.rs:1:1139
  |
1 | ...)) } } else { { println ! ("Processing failed!" . to_string ()) ; exit (1i32) } } ; }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 18 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0423, E0425.
For more information about an error, try `rustc --explain E0277`.



=== ch04-00-command-line-tools example 9 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpma1F6K/main.rs:1:96
  |
1 | use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0" . to_string ()) ; println ! ("" . to_strin...
  |                                                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpma1F6K/main.rs:1:98
  |
1 | use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0" . to_string ()) ; println ! ("" . to_strin...
  |                                                                    ---------------------------   ^^^^^^^^^^^^ argument never used
  |                                                                    |
  |                                                                    formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpma1F6K/main.rs:1:128
  |
1 | ..."File Statistics Tool v1.0" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Usage:" . to_string ()) ; println ! ("  ruch...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpma1F6K/main.rs:1:130
  |
1 | ...tistics Tool v1.0" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Usage:" . to_string ()) ; println ! ("  ruchy run fil...
  |                                                    --   ^^^^^^^^^^^^ argument never used
  |                                                    |
  |                                                    formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpma1F6K/main.rs:1:166
  |
1 | ...g ()) ; println ! ("" . to_string ()) ; println ! ("Usage:" . to_string ()) ; println ! ("  ruchy run file_stats.ruchy <filename>" . t...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpma1F6K/main.rs:1:168
  |
1 | ...; println ! ("" . to_string ()) ; println ! ("Usage:" . to_string ()) ; println ! ("  ruchy run file_stats.ruchy <filename>" . to_stri...
  |                                                 --------   ^^^^^^^^^^^^ argument never used
  |                                                 |
  |                                                 formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpma1F6K/main.rs:1:237
  |
1 | ... ()) ; println ! ("  ruchy run file_stats.ruchy <filename>" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Examples:" ....
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpma1F6K/main.rs:1:239
  |
1 | .... to_string ()) ; println ! ("  ruchy run file_stats.ruchy <filename>" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("E...
  |                                 -----------------------------------------   ^^^^^^^^^^^^ argument never used
  |                                 |
  |                                 formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpma1F6K/main.rs:1:269
  |
1 | ...ile_stats.ruchy <filename>" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Examples:" . to_string ()) ; println ! ("  r...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpma1F6K/main.rs:1:271
  |
1 | ....ruchy <filename>" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Examples:" . to_string ()) ; println ! ("  ruchy run ...
  |                                                    --   ^^^^^^^^^^^^ argument never used
  |                                                    |
  |                                                    formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpma1F6K/main.rs:1:310
  |
1 | ...)) ; println ! ("" . to_string ()) ; println ! ("Examples:" . to_string ()) ; println ! ("  ruchy run file_stats.ruchy document.txt" ....
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpma1F6K/main.rs:1:312
  |
1 | ... println ! ("" . to_string ()) ; println ! ("Examples:" . to_string ()) ; println ! ("  ruchy run file_stats.ruchy document.txt" . to_...
  |                                                -----------   ^^^^^^^^^^^^ argument never used
  |                                                |
  |                                                formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpma1F6K/main.rs:1:383
  |
1 | ...)) ; println ! ("  ruchy run file_stats.ruchy document.txt" . to_string ()) ; println ! ("  ruchy run file_stats.ruchy data/*.csv" . t...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpma1F6K/main.rs:1:385
  |
1 | ... to_string ()) ; println ! ("  ruchy run file_stats.ruchy document.txt" . to_string ()) ; println ! ("  ruchy run file_stats.ruchy dat...
  |                                -------------------------------------------   ^^^^^^^^^^^^ argument never used
  |                                |
  |                                formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpma1F6K/main.rs:1:454
  |
1 | ... ()) ; println ! ("  ruchy run file_stats.ruchy data/*.csv" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Options:" . ...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpma1F6K/main.rs:1:456
  |
1 | .... to_string ()) ; println ! ("  ruchy run file_stats.ruchy data/*.csv" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("O...
  |                                 -----------------------------------------   ^^^^^^^^^^^^ argument never used
  |                                 |
  |                                 formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpma1F6K/main.rs:1:486
  |
1 | ...ile_stats.ruchy data/*.csv" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Options:" . to_string ()) ; println ! ("  --...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpma1F6K/main.rs:1:488
  |
1 | ....ruchy data/*.csv" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Options:" . to_string ()) ; println ! ("  --help     ...
  |                                                    --   ^^^^^^^^^^^^ argument never used
  |                                                    |
  |                                                    formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpma1F6K/main.rs:1:526
  |
1 | ...()) ; println ! ("" . to_string ()) ; println ! ("Options:" . to_string ()) ; println ! ("  --help     Show this help message" . to_st...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpma1F6K/main.rs:1:528
  |
1 | ... println ! ("" . to_string ()) ; println ! ("Options:" . to_string ()) ; println ! ("  --help     Show this help message" . to_string ...
  |                                                ----------   ^^^^^^^^^^^^ argument never used
  |                                                |
  |                                                formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpma1F6K/main.rs:1:593
  |
1 | ...ring ()) ; println ! ("  --help     Show this help message" . to_string ()) ; println ! ("  --verbose  Show detailed output" . to_stri...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpma1F6K/main.rs:1:595
  |
1 | ..." . to_string ()) ; println ! ("  --help     Show this help message" . to_string ()) ; println ! ("  --verbose  Show detailed output" ...
  |                                   -------------------------------------   ^^^^^^^^^^^^ argument never used
  |                                   |
  |                                   formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpma1F6K/main.rs:1:658
  |
1 | ...string ()) ; println ! ("  --verbose  Show detailed output" . to_string ()) } } fn process_with_progress < T : std :: ops :: Add < Out...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpma1F6K/main.rs:1:660
  |
1 | ...e" . to_string ()) ; println ! ("  --verbose  Show detailed output" . to_string ()) } } fn process_with_progress < T : std :: ops :: A...
  |                                    -----------------------------------   ^^^^^^^^^^^^ argument never used
  |                                    |
  |                                    formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpma1F6K/main.rs:1:1215
  |
1 | ... = i + 1i32 } } } } ; println ! ("\n✅ All files processed!" . to_string ()) } } } } fn main () { }
  |                                                                 ^ expected `,`

error: argument never used
 --> /tmp/.tmpma1F6K/main.rs:1:1217
  |
1 | ...; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!" . to_string ()) } } } } fn main () { }
  |                                        ---------------------------   ^^^^^^^^^^^^ argument never used
  |                                        |
  |                                        formatting specifier missing

error[E0425]: cannot find function `sleep` in this scope
 --> /tmp/.tmpma1F6K/main.rs:1:1137
  |
1 | .... to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!" . to_...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::sleep;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpma1F6K/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0" . to_string ()) ; println ! ("" . to_strin...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpma1F6K/main.rs:1:852
  |
1 | ... { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!" . to_string ()) } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Usage:" . to_string ()) ; println ! ("  ruchy run file_stats.ruchy <filename>" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Examples:" . to_string ()) ; println ! ("  ruchy run file_stats.ruchy document.txt" . to_string ()) ; println ! ("  ruchy run file_stats.ruchy data/*.csv" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Options:" . to_string ()) ; println ! ("  --help     Show this help message" . to_string ()) ; println ! ("  --verbose  Show detailed output" . to_string ()) } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!" . to_string ()) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Usage:" . to_string ()) ; println ! ("  ruchy run file_stats.ruchy <filename>" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Examples:" . to_string ()) ; println ! ("  ruchy run file_stats.ruchy document.txt" . to_string ()) ; println ! ("  ruchy run file_stats.ruchy data/*.csv" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Options:" . to_string ()) ; println ! ("  --help     Show this help message" . to_string ()) ; println ! ("  --verbose  Show detailed output" . to_string ()) } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!" . to_string ()) } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpma1F6K/main.rs:1:924
  |
1 | ... { { { let file = files [i] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ...
  |       ^^                                                                                                                                                                                                                                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Usage:" . to_string ()) ; println ! ("  ruchy run file_stats.ruchy <filename>" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Examples:" . to_string ()) ; println ! ("  ruchy run file_stats.ruchy document.txt" . to_string ()) ; println ! ("  ruchy run file_stats.ruchy data/*.csv" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Options:" . to_string ()) ; println ! ("  --help     Show this help message" . to_string ()) ; println ! ("  --verbose  Show detailed output" . to_string ()) } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!" . to_string ()) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Usage:" . to_string ()) ; println ! ("  ruchy run file_stats.ruchy <filename>" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Examples:" . to_string ()) ; println ! ("  ruchy run file_stats.ruchy document.txt" . to_string ()) ; println ! ("  ruchy run file_stats.ruchy data/*.csv" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Options:" . to_string ()) ; println ! ("  --help     Show this help message" . to_string ()) ; println ! ("  --verbose  Show detailed output" . to_string ()) } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { let file = files [i] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } ; println ! ("\n✅ All files processed!" . to_string ()) } } } } fn main () { }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpma1F6K/main.rs:1:98
  |
1 | use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0" . to_string ()) ; println ! ("" . to_strin...
  |                                                                                                  ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpma1F6K/main.rs:1:130
  |
1 | ...tics Tool v1.0" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Usage:" . to_string ()) ; println ! ("  ruchy run file_s...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpma1F6K/main.rs:1:168
  |
1 | ...tln ! ("" . to_string ()) ; println ! ("Usage:" . to_string ()) ; println ! ("  ruchy run file_stats.ruchy <filename>" . to_string ())...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpma1F6K/main.rs:1:239
  |
1 | ...ln ! ("  ruchy run file_stats.ruchy <filename>" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Examples:" . to_string (...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpma1F6K/main.rs:1:271
  |
1 | ...chy <filename>" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Examples:" . to_string ()) ; println ! ("  ruchy run fil...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpma1F6K/main.rs:1:312
  |
1 | ... ! ("" . to_string ()) ; println ! ("Examples:" . to_string ()) ; println ! ("  ruchy run file_stats.ruchy document.txt" . to_string (...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpma1F6K/main.rs:1:385
  |
1 | ... ! ("  ruchy run file_stats.ruchy document.txt" . to_string ()) ; println ! ("  ruchy run file_stats.ruchy data/*.csv" . to_string ())...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpma1F6K/main.rs:1:456
  |
1 | ...ln ! ("  ruchy run file_stats.ruchy data/*.csv" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Options:" . to_string ()...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpma1F6K/main.rs:1:488
  |
1 | ...chy data/*.csv" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Options:" . to_string ()) ; println ! ("  --help     Sho...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpma1F6K/main.rs:1:528
  |
1 | ...n ! ("" . to_string ()) ; println ! ("Options:" . to_string ()) ; println ! ("  --help     Show this help message" . to_string ()) ; p...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpma1F6K/main.rs:1:595
  |
1 | ...rintln ! ("  --help     Show this help message" . to_string ()) ; println ! ("  --verbose  Show detailed output" . to_string ()) } } f...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpma1F6K/main.rs:1:660
  |
1 | ... println ! ("  --verbose  Show detailed output" . to_string ()) } } fn process_with_progress < T : std :: ops :: Add < Output = T > + ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpma1F6K/main.rs:1:876
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len ()...
  |       - method `len` not found for this type parameter                                                                                                                           ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Usage:" . to_string ()) ; println ! ("  ruchy run file_stats.ruchy <filename>" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Examples:" . to_string ()) ; println ! ("  ruchy run file_stats.ruchy document.txt" . to_string ()) ; println ! ("  ruchy run file_stats.ruchy data/*.csv" . to_string ()) ; println ! ("" . to_string ()) ; println ! ("Options:" . to_string ()) ; println ! ("  --help     Show this help message" . to_string ()) ; println ! ("  --verbose  Show detailed output" . to_string ()) } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!" . to_string ()) } } } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               +++++++++++++++++++

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpma1F6K/main.rs:1:945
  |
1 | ...() ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{}" ...
  |                                                                     ^^^

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpma1F6K/main.rs:1:1087
  |
1 | ...format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } ...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `process_file` in this scope
 --> /tmp/.tmpma1F6K/main.rs:1:1115
  |
1 | ...g... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All file...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpma1F6K/main.rs:1:1217
  |
1 | ...} } } } ; println ! ("\n✅ All files processed!" . to_string ()) } } } } fn main () { }
  |                                                       ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpma1F6K/main.rs:1:1177
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!" . to_string ()) } }...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 45 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0308, E0425, E0599, E0608.
For more information about an error, try `rustc --explain E0308`.



=== ch04-00-command-line-tools example 10 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpnaMoQV/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" ; { let mut lines = 1i32 ; let mut i = 0i32 ;...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpnaMoQV/main.rs:1:50
  |
1 | ... { { { let content = "line 1\nline 2\nline 3" ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {} {}" , "File has" . to_string () , lines , "lines" . to_string ()) } } } }
  |       ^^                                                                                                                                                                                                                                                                                      ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {} {}" , "File has" . to_string () , lines , "lines" . to_string ()) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let content = "line 1\nline 2\nline 3" ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {} {}" , "File has" . to_string () , lines , "lines" . to_string ()) } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpnaMoQV/main.rs:1:195
  |
1 | ...hile i < content . len () { { if content [i] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {} {}" , "File h...
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {} {}" , "File has" . to_string () , lines , "lines" . to_string ()) } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i] == '\n' { lines = lines + 1i32 } ; i = i + 1i32 } } ; println ! ("{} {} {}" , "File has" . to_string () , lines , "lines" . to_string ()) } } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpnaMoQV/main.rs:1:149
  |
1 | ...t lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 ...
  |                                              -   ^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                              |
  |                                              expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len ().try_into().unwrap() { { if content [i] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {} {}" , "File has" . to_string () , lines , "lines" . to_string ()) } } } }
  |                                                                                                                                                                     ++++++++++++++++++++

error[E0277]: the type `str` cannot be indexed by `i32`
 --> /tmp/.tmpnaMoQV/main.rs:1:182
  |
1 | ...32 ; while i < content . len () { { if content [i] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {} {}" , "...
  |                                                    ^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `i32`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `str` to implement `Index<i32>`

error: aborting due to 2 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.



=== ch04-00-command-line-tools example 11 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpcEBfWZ/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" ...
  |                                                                                             ^ expected `,`

error: argument never used
 --> /tmp/.tmpcEBfWZ/main.rs:1:95
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" ...
  |                                                                    ------------------------   ^^^^^^^^^^^^ argument never used
  |                                                                    |
  |                                                                    formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpcEBfWZ/main.rs:1:138
  |
1 | ...k Manager ===" . to_string ()) ; println ! ("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpcEBfWZ/main.rs:1:140
  |
1 | ...Manager ===" . to_string ()) ; println ! ("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. ...
  |                                              ---------------   ^^^^^^^^^^^^ argument never used
  |                                              |
  |                                              formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpcEBfWZ/main.rs:1:181
  |
1 | ...("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpcEBfWZ/main.rs:1:183
  |
1 | .... List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! (...
  |                                               -------------   ^^^^^^^^^^^^ argument never used
  |                                               |
  |                                               formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpcEBfWZ/main.rs:1:229
  |
1 | .... Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpcEBfWZ/main.rs:1:231
  |
1 | ... Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! (...
  |                                            ------------------   ^^^^^^^^^^^^ argument never used
  |                                            |
  |                                            formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpcEBfWZ/main.rs:1:275
  |
1 | ...omplete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks (...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpcEBfWZ/main.rs:1:277
  |
1 | ...plete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () ...
  |                                             ----------------   ^^^^^^^^^^^^ argument never used
  |                                             |
  |                                             formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpcEBfWZ/main.rs:1:314
  |
1 | ... ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { re...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpcEBfWZ/main.rs:1:316
  |
1 | ...4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return ...
  |                                                 ---------   ^^^^^^^^^^^^ argument never used
  |                                                 |
  |                                                 formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpcEBfWZ/main.rs:1:907
  |
1 | ...{ if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ...
  |                                                                 ^ expected `,`

error: argument never used
 --> /tmp/.tmpcEBfWZ/main.rs:1:909
  |
1 | ...{ if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ...
  |                                            --------------------   ^^^^^^^^^^^^ argument never used
  |                                            |
  |                                            formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpcEBfWZ/main.rs:1:1655
  |
1 | ...ew_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output =...
  |                                                                 ^ expected `,`

error: argument never used
 --> /tmp/.tmpcEBfWZ/main.rs:1:1657
  |
1 | ..._task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T...
  |                                              ----------------   ^^^^^^^^^^^^ argument never used
  |                                              |
  |                                              formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpcEBfWZ/main.rs:1:2116
  |
1 | ... "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string (...
  |                                                                  ^ expected `,`

error: argument never used
 --> /tmp/.tmpcEBfWZ/main.rs:1:2118
  |
1 | ... "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string (...
  |                                             --------------------   ^^^^^^^^^^^^ argument never used
  |                                             |
  |                                             formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpcEBfWZ/main.rs:1:2180
  |
1 | ..._string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } } fn main () { let mut TASK_FILE = "tasks.txt" ; le...
  |                                                                 ^ expected `,`

error: argument never used
 --> /tmp/.tmpcEBfWZ/main.rs:1:2182
  |
1 | ...to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } } fn main () { let mut TASK_FILE = "tasks.txt" ; ...
  |                                          ------------------------   ^^^^^^^^^^^^ argument never used
  |                                          |
  |                                          formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpcEBfWZ/main.rs:1:2721
  |
1 | ... save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpcEBfWZ/main.rs:1:2723
  |
1 | ...) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string (...
  |                                        --------------------------   ^^^^^^^^^^^^ argument never used
  |                                        |
  |                                        formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpcEBfWZ/main.rs:1:2780
  |
1 | ... . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string (...
  |                                                                 ^ expected `,`

error: argument never used
 --> /tmp/.tmpcEBfWZ/main.rs:1:2782
  |
1 | ...o_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) ,...
  |                                               -------------   ^^^^^^^^^^^^ argument never used
  |                                               |
  |                                               formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpcEBfWZ/main.rs:1:2843
  |
1 | ...o_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } } ; }
  |                                                                 ^ expected `,`

error: argument never used
 --> /tmp/.tmpcEBfWZ/main.rs:1:2845
  |
1 | ..._string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } } ; }
  |                                            -------------------   ^^^^^^^^^^^^ argument never used
  |                                            |
  |                                            formatting specifier missing

error[E0425]: cannot find value `TASK_FILE` in this scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:371
  |
1 | ...ring ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `TASK_FILE` in this scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:405
  |
1 | ...if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `TASK_FILE` in this scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:657
  |
1 | ...{ let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + st...
  |                                                      ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpcEBfWZ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpcEBfWZ/main.rs:1:384
  |
1 | ...fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std ::...
  |                                                      ^^                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } } fn main () { let mut TASK_FILE = "tasks.txt" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: " . to_string ()) ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { return read_lines (TASK_FILE) } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } } fn main () { let mut TASK_FILE = "tasks.txt" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: " . to_string ()) ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpcEBfWZ/main.rs:1:605
  |
1 | ...+ Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std ::...
  |                                 ^^                                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } } fn main () { let mut TASK_FILE = "tasks.txt" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: " . to_string ()) ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } } fn main () { let mut TASK_FILE = "tasks.txt" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: " . to_string ()) ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpcEBfWZ/main.rs:1:1104
  |
1 | ... { { { let task = tasks [i] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } }...
  |       ^^                                                                                                                                                                                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } } fn main () { let mut TASK_FILE = "tasks.txt" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: " . to_string ()) ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { let task = tasks [i] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } } fn main () { let mut TASK_FILE = "tasks.txt" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: " . to_string ()) ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpcEBfWZ/main.rs:1:1180
  |
1 | ... tasks [i] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" ...
  |                                                                   ^^      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } } fn main () { let mut TASK_FILE = "tasks.txt" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: " . to_string ()) ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with ("✅") { "DONE" } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } } fn main () { let mut TASK_FILE = "tasks.txt" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: " . to_string ()) ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpcEBfWZ/main.rs:1:1200
  |
1 | ... status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () ,...
  |                                                                 ^^         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } } fn main () { let mut TASK_FILE = "tasks.txt" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: " . to_string ()) ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { "PENDING" } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } } fn main () { let mut TASK_FILE = "tasks.txt" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: " . to_string ()) ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpcEBfWZ/main.rs:1:1478
  |
1 | ... { { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } } fn...
  |       ^^                                                                                                                                                                                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } } fn main () { let mut TASK_FILE = "tasks.txt" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: " . to_string ()) ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } } fn main () { let mut TASK_FILE = "tasks.txt" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: " . to_string ()) ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpcEBfWZ/main.rs:1:2143
  |
1 | ... completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } } fn main () { let mut TASK_FILE =...
  |                                            ^^                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } } fn main () { let mut TASK_FILE = "tasks.txt" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: " . to_string ()) ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { println ! ("❌ Invalid task number" . to_string ()) } } } } fn main () { let mut TASK_FILE = "tasks.txt" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: " . to_string ()) ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } } ; }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:95
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" ...
  |                                                                                               ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:140
  |
1 | ...=" . to_string ()) ; println ! ("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete t...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:183
  |
1 | ...sks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delet...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:231
  |
1 | .... to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" ....
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:277
  |
1 | ..." . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if fil...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:316
  |
1 | ...te task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_li...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:358
  |
1 | ...uit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } f...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_lines` in this scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:393
  |
1 | ...asks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: A...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0599]: no method named `join` found for type parameter `T` in the current scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:631
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("...
  |       - method `join` not found for this type parameter                                                                                                                            ^^^^ method not found in `T`

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:645
  |
1 | ...T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Outpu...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0599]: no method named `is_empty` found for type parameter `T` in the current scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:860
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty ()...
  |       - method `is_empty` not found for this type parameter                                                                                                           ^^^^^^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following traits define an item `is_empty`, perhaps you need to restrict type parameter `T` with one of them:
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } } fn main () { let mut TASK_FILE = "tasks.txt" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: " . to_string ()) ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++++++
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + RangeBounds</* T */> > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } } fn main () { let mut TASK_FILE = "tasks.txt" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: " . to_string ()) ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ++++++++++++++++++++++

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:909
  |
1 | ... is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , ...
  |                                                       ^^^^^^^^^ not found in this scope

error[E0069]: `return;` in a function whose return type is not `()`
 --> /tmp/.tmpcEBfWZ/main.rs:1:925
  |
1 | ...ks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("...
  |               - expected `T` because of this return type                                         ^^^^^^ return type is not `()`
  |
help: give the `return` a value of the expected type
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return /* value */ } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } } fn main () { let mut TASK_FILE = "tasks.txt" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: " . to_string ()) ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     +++++++++++

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:1023
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () ....
  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                                                                     ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } } fn main () { let mut TASK_FILE = "tasks.txt" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: " . to_string ()) ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++++++

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:1095
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () {...
  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                                                                                                                                             ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } } fn main () { let mut TASK_FILE = "tasks.txt" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: " . to_string ()) ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++++++

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpcEBfWZ/main.rs:1:1125
  |
1 | ...t mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } el...
  |                                                                     ^^^

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:1266
  |
1 | ...} ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops ::...
  |                                                        ^^^^ method not found in `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpcEBfWZ/main.rs:1:1077
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } f...
  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                                                                                                                                                                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: the caller chooses a type for `T` which can be different from `()`
  = note: `while` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } /* `T` value */ } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } } fn main () { let mut TASK_FILE = "tasks.txt" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: " . to_string ()) ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    +++++++++++++++

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:1497
  |
1 | ...bug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (format ! ("...
  |                                                        ^^^^^ not found in this scope

error[E0599]: no method named `push` found for type parameter `T` in the current scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:1562
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (f...
  |       - method `push` not found for this type parameter                                                                                                                                                                                      ^^^^ method not found in `T`

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:1657
  |
1 | ...save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :...
  |                                                       ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpcEBfWZ/main.rs:1:1628
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } ...
  |       - expected this type parameter                                                                                                                                                                                                                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:1882
  |
1 | ...ks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; i...
  |                                                        ^^^^^ not found in this scope

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:1999
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                                             ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===" . to_string ()) ; println ! ("1. List tasks" . to_string ()) ; println ! ("2. Add task" . to_string ()) ; println ! ("3. Complete task" . to_string ()) ; println ! ("4. Delete task" . to_string ()) ; println ! ("5. Quit" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!" . to_string ()) ; return } } ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? " . to_string ()) ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } } fn main () { let mut TASK_FILE = "tasks.txt" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: " . to_string ()) ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     +++++++++++++++++++

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:2118
  |
1 | ..._tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } ...
  |                                                       ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpcEBfWZ/main.rs:1:2085
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } e...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:2182
  |
1 | ...} } else { { println ! ("❌ Invalid task number" . to_string ()) } } } } } fn main () { let mut TASK_FILE = "tasks.txt" ; let mut tasks ...
  |                                                       ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpcEBfWZ/main.rs:1:2145
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): " . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!" . to_string ()) } } else { { println ! ("❌ Invalid task number" . to_string ()) } } } ...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:2324
  |
1 | ...d_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: " . to_string ()) ; match choice { "1" => list_tasks (tas...
  |                                                        ^^^^^ not found in this scope

error[E0277]: cannot add `()` to `()`
 --> /tmp/.tmpcEBfWZ/main.rs:1:2403
  |
1 | .... to_string ()) ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_ta...
  |                                            ----------  ^^^^^ no implementation for `() + ()`
  |                                            |
  |                                            required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `()`
note: required by a bound in `list_tasks`
 --> /tmp/.tmpcEBfWZ/main.rs:1:704
  |
1 | ...ent) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fm...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`

error[E0277]: cannot multiply `()` by `()`
 --> /tmp/.tmpcEBfWZ/main.rs:1:2403
  |
1 | .... to_string ()) ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_ta...
  |                                            ----------  ^^^^^ no implementation for `() * ()`
  |                                            |
  |                                            required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `()`
note: required by a bound in `list_tasks`
 --> /tmp/.tmpcEBfWZ/main.rs:1:739
  |
1 | ...:: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) ->...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpcEBfWZ/main.rs:1:2403
  |
1 | ... ()) ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks)...
  |                                 ----------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`
  |                                 |
  |                                 required by a bound introduced by this call
  |
note: required by a bound in `list_tasks`
 --> /tmp/.tmpcEBfWZ/main.rs:1:774
  |
1 | ...+ std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty ()...
  |                                         ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`

error[E0277]: cannot add `()` to `()`
 --> /tmp/.tmpcEBfWZ/main.rs:1:2429
  |
1 | ...ice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index =...
  |                                             --------  ^^^^^ no implementation for `() + ()`
  |                                             |
  |                                             required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `()`
note: required by a bound in `add_task`
 --> /tmp/.tmpcEBfWZ/main.rs:1:1335
  |
1 | ...2 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: f...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `add_task`

error[E0277]: cannot multiply `()` by `()`
 --> /tmp/.tmpcEBfWZ/main.rs:1:2429
  |
1 | ...ice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index =...
  |                                             --------  ^^^^^ no implementation for `() * ()`
  |                                             |
  |                                             required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `()`
note: required by a bound in `add_task`
 --> /tmp/.tmpcEBfWZ/main.rs:1:1370
  |
1 | ... :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `add_task`

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpcEBfWZ/main.rs:1:2429
  |
1 | ...> list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Wh...
  |                                  --------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`
  |                                  |
  |                                  required by a bound introduced by this call
  |
note: required by a bound in `add_task`
 --> /tmp/.tmpcEBfWZ/main.rs:1:1405
  |
1 | ... + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = inpu...
  |                                          ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `add_task`

error[E0277]: cannot add `()` to `()`
 --> /tmp/.tmpcEBfWZ/main.rs:1:2460
  |
1 | ...s) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete...
  |                                          -------------  ^^^^^ no implementation for `() + ()`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `()`
note: required by a bound in `complete_task`
 --> /tmp/.tmpcEBfWZ/main.rs:1:1702
  |
1 | ... } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `complete_task`

error[E0277]: cannot multiply `()` by `()`
 --> /tmp/.tmpcEBfWZ/main.rs:1:2460
  |
1 | ...s) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete...
  |                                          -------------  ^^^^^ no implementation for `() * ()`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `()`
note: required by a bound in `complete_task`
 --> /tmp/.tmpcEBfWZ/main.rs:1:1737
  |
1 | ...: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> ...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `complete_task`

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpcEBfWZ/main.rs:1:2460
  |
1 | ...> add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number)...
  |                                -------------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`
  |                                |
  |                                required by a bound introduced by this call
  |
note: required by a bound in `complete_task`
 --> /tmp/.tmpcEBfWZ/main.rs:1:1772
  |
1 | ...std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { l...
  |                                       ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `complete_task`

error[E0277]: cannot add `()` to `()`
 --> /tmp/.tmpcEBfWZ/main.rs:1:2490
  |
1 | ..."3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) ....
  |                                            ----------  ^^^^^ no implementation for `() + ()`
  |                                            |
  |                                            required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `()`
note: required by a bound in `list_tasks`
 --> /tmp/.tmpcEBfWZ/main.rs:1:704
  |
1 | ...ent) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fm...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`

error[E0277]: cannot multiply `()` by `()`
 --> /tmp/.tmpcEBfWZ/main.rs:1:2490
  |
1 | ..."3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) ....
  |                                            ----------  ^^^^^ no implementation for `() * ()`
  |                                            |
  |                                            required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `()`
note: required by a bound in `list_tasks`
 --> /tmp/.tmpcEBfWZ/main.rs:1:739
  |
1 | ...:: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) ->...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpcEBfWZ/main.rs:1:2490
  |
1 | ...lete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) . to_i () - ...
  |                                 ----------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`
  |                                 |
  |                                 required by a bound introduced by this call
  |
note: required by a bound in `list_tasks`
 --> /tmp/.tmpcEBfWZ/main.rs:1:774
  |
1 | ...+ std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty ()...
  |                                         ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:2513
  |
1 | ...asks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): " . to_string ()) . to_i () - 1i32 ; if in...
  |                                                        ^^^^^ not found in this scope

error[E0599]: no method named `len` found for unit type `()` in the current scope
    --> /tmp/.tmpcEBfWZ/main.rs:1:2626
     |
1    | ...tring ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("...
     |                                                                     ^^^
     |
help: there is a method `le` with a similar name, but with different arguments
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1402:5
     |
1402 |     fn le(&self, other: &Rhs) -> bool {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `remove` found for unit type `()` in the current scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:2645
  |
1 | ...ndex >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_st...
  |                                                       ^^^^^^ method not found in `()`

error[E0277]: cannot add `()` to `()`
 --> /tmp/.tmpcEBfWZ/main.rs:1:2674
  |
1 | ...s . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { ...
  |                                            ----------  ^^^^^ no implementation for `() + ()`
  |                                            |
  |                                            required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `()`
note: required by a bound in `save_tasks`
 --> /tmp/.tmpcEBfWZ/main.rs:1:462
  |
1 | ...c ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fm...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `save_tasks`

error[E0277]: cannot multiply `()` by `()`
 --> /tmp/.tmpcEBfWZ/main.rs:1:2674
  |
1 | ...s . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { ...
  |                                            ----------  ^^^^^ no implementation for `() * ()`
  |                                            |
  |                                            required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `()`
note: required by a bound in `save_tasks`
 --> /tmp/.tmpcEBfWZ/main.rs:1:497
  |
1 | ...:: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) ->...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `save_tasks`

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpcEBfWZ/main.rs:1:2674
  |
1 | ...{ { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("...
  |                                 ----------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`
  |                                 |
  |                                 required by a bound introduced by this call
  |
note: required by a bound in `save_tasks`
 --> /tmp/.tmpcEBfWZ/main.rs:1:532
  |
1 | ...+ std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks ...
  |                                         ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `save_tasks`

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:2723
  |
1 | ...(tasks) ; println ! ("🗑\u{fe0f}  Task deleted!" . to_string ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:2782
  |
1 | ... ()) } } } } , "5" => { println ! ("👋 Goodbye!" . to_string ()) ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } }...
  |                                                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpcEBfWZ/main.rs:1:2845
  |
1 | ... ; break } , _ => println ! ("❌ Invalid choice" . to_string ()) , } } } } ; }
  |                                                       ^^^^^^^^^ not found in this scope

error: aborting due to 79 previous errors; 8 warnings emitted

Some errors have detailed explanations: E0069, E0277, E0308, E0425, E0599, E0608.
For more information about an error, try `rustc --explain E0069`.



=== ch04-00-command-line-tools example 12 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpFLT6Gm/main.rs:1:97
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Example: Unsafe file operations" . to_string ()) ; println ! ("This patter...
  |                                                                                                 ^ expected `,`

error: argument never used
 --> /tmp/.tmpFLT6Gm/main.rs:1:99
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Example: Unsafe file operations" . to_string ()) ; println ! ("This patter...
  |                                                               ---------------------------------   ^^^^^^^^^^^^ argument never used
  |                                                               |
  |                                                               formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpFLT6Gm/main.rs:1:176
  |
1 | ...rintln ! ("This pattern would crash if file doesn't exist:" . to_string ()) ; println ! ("// let content = read_file(\"missing.txt\");...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpFLT6Gm/main.rs:1:178
  |
1 | ..._string ()) ; println ! ("This pattern would crash if file doesn't exist:" . to_string ()) ; println ! ("// let content = read_file(\"...
  |                             -------------------------------------------------   ^^^^^^^^^^^^ argument never used
  |                             |
  |                             formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpFLT6Gm/main.rs:1:252
  |
1 | ...; println ! ("// let content = read_file(\"missing.txt\");" . to_string ()) ; println ! ("Always check if operations can fail before u...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpFLT6Gm/main.rs:1:254
  |
1 | ...o_string ()) ; println ! ("// let content = read_file(\"missing.txt\");" . to_string ()) ; println ! ("Always check if operations can ...
  |                              ----------------------------------------------   ^^^^^^^^^^^^ argument never used
  |                              |
  |                              formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpFLT6Gm/main.rs:1:337
  |
1 | ... ! ("Always check if operations can fail before using them" . to_string ()) } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpFLT6Gm/main.rs:1:339
  |
1 | ...ring ()) ; println ! ("Always check if operations can fail before using them" . to_string ()) } }
  |                          -------------------------------------------------------   ^^^^^^^^^^^^ argument never used
  |                          |
  |                          formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpFLT6Gm/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Example: Unsafe file operations" . to_string ()) ; println ! ("This patter...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpFLT6Gm/main.rs:1:99
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Example: Unsafe file operations" . to_string ()) ; println ! ("This patter...
  |                                                                                                   ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpFLT6Gm/main.rs:1:178
  |
1 | ...his pattern would crash if file doesn't exist:" . to_string ()) ; println ! ("// let content = read_file(\"missing.txt\");" . to_strin...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpFLT6Gm/main.rs:1:254
  |
1 | ...("// let content = read_file(\"missing.txt\");" . to_string ()) ; println ! ("Always check if operations can fail before using them" ....
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpFLT6Gm/main.rs:1:339
  |
1 | ...check if operations can fail before using them" . to_string ()) } }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 12 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 13 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpB9dZYx/main.rs:1:134
  |
1 | ..._string ()) ; let mut thing = input () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error: expected `,`, found `.`
 --> /tmp/.tmpB9dZYx/main.rs:1:91
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("Enter thing:" . to_string ()) ; let mut thing = input () } ; ...
  |                                                                                           ^ expected `,`

error: argument never used
 --> /tmp/.tmpB9dZYx/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("Enter thing:" . to_string ()) ; let mut thing = input () } ; ...
  |                                                                            --------------   ^^^^^^^^^^^^ argument never used
  |                                                                            |
  |                                                                            formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpB9dZYx/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("Enter thing:" . to_string ()) ; let mut thing = input () } ; ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpB9dZYx/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("Enter thing:" . to_string ()) ; let mut thing = input () } ; ...
  |                                                                                             ^^^^^^^^^ not found in this scope

error: aborting due to 4 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 14 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found `let` statement
 --> /tmp/.tmpBs03FE/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let mut data = read_file ("/Users/noah/Desktop/data.txt" . to_string ()) ; ...
  |                                                               ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpBs03FE/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let mut data = read_file ("/Users/noah/Desktop/data.txt" . to_string ()) ; ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpBs03FE/main.rs:1:78
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let mut data = read_file ("/Users/noah/Desktop/data.txt" . to_string ()) ; ...
  |                                                                              ^^^^^^^^^ not found in this scope

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch12-00-traits-generics example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch03-00-functions-tdd example 1 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmp9pvGsv/main.rs:1:87
  |
1 | use std :: collections :: HashMap ; fn greet () { { println ! ("Hello from function!" . to_string ()) } } fn main () { { greet () } }
  |                                                                                       ^ expected `,`

error: argument never used
 --> /tmp/.tmp9pvGsv/main.rs:1:89
  |
1 | use std :: collections :: HashMap ; fn greet () { { println ! ("Hello from function!" . to_string ()) } } fn main () { { greet () } }
  |                                                                ----------------------   ^^^^^^^^^^^^ argument never used
  |                                                                |
  |                                                                formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp9pvGsv/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn greet () { { println ! ("Hello from function!" . to_string ()) } } fn main () { { greet () } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp9pvGsv/main.rs:1:51
  |
1 | use std :: collections :: HashMap ; fn greet () { { println ! ("Hello from function!" . to_string ()) } } fn main () { { greet () } }
  |                                                   ^^                                                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn greet () { { println ! ("Hello from function!" . to_string ()) } } fn main () { { greet () } }
1 + use std :: collections :: HashMap ; fn greet () { println ! ("Hello from function!" . to_string ()) } fn main () { { greet () } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp9pvGsv/main.rs:1:120
  |
1 | use std :: collections :: HashMap ; fn greet () { { println ! ("Hello from function!" . to_string ()) } } fn main () { { greet () } }
  |                                                                                                                        ^^        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn greet () { { println ! ("Hello from function!" . to_string ()) } } fn main () { { greet () } }
1 + use std :: collections :: HashMap ; fn greet () { { println ! ("Hello from function!" . to_string ()) } } fn main () { greet () }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmp9pvGsv/main.rs:1:89
  |
1 | use std :: collections :: HashMap ; fn greet () { { println ! ("Hello from function!" . to_string ()) } } fn main () { { greet () } }
  |                                                                                         ^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch03-00-functions-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `return_type` in this scope
 --> /tmp/.tmpk7UNiM/main.rs:1:204
  |
1 | ...td :: fmt :: Debug + Clone > (parameters : T) -> return_type { { return_expression } } fn main () { }
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `return_expression` in this scope
 --> /tmp/.tmpk7UNiM/main.rs:1:220
  |
1 | ...+ Clone > (parameters : T) -> return_type { { return_expression } } fn main () { }
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpk7UNiM/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn function_name < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: f...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpk7UNiM/main.rs:1:218
  |
1 | ...mt :: Debug + Clone > (parameters : T) -> return_type { { return_expression } } fn main () { }
  |                                                            ^^                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn function_name < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (parameters : T) -> return_type { { return_expression } } fn main () { }
1 + use std :: collections :: HashMap ; fn function_name < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (parameters : T) -> return_type { return_expression } fn main () { }
  |

error: aborting due to 2 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch11-00-file-operations-tdd example 1 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpSkR8Wi/main.rs:1:256
  |
1 | ... let config = read_config () ; { println ! ("Config value:" . to_string ()) ; println ! ("{}" , config) ; let mut success = write_stat...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpSkR8Wi/main.rs:1:258
  |
1 | ...et config = read_config () ; { println ! ("Config value:" . to_string ()) ; println ! ("{}" , config) ; let mut success = write_status...
  |                                              ---------------   ^^^^^^^^^^^^ argument never used
  |                                              |
  |                                              formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpSkR8Wi/main.rs:1:372
  |
1 | ...ccess = write_status (config) ; println ! ("Write success:" . to_string ()) ; println ! ("{}" , success) } } } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpSkR8Wi/main.rs:1:374
  |
1 | ...ess = write_status (config) ; println ! ("Write success:" . to_string ()) ; println ! ("{}" , success) } } } }
  |                                             ----------------   ^^^^^^^^^^^^ argument never used
  |                                             |
  |                                             formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpSkR8Wi/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn read_config () -> i32 { { return 42i32 } } fn write_status (value : i32) -> bool { { if value > 0i...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpSkR8Wi/main.rs:1:64
  |
1 | use std :: collections :: HashMap ; fn read_config () -> i32 { { return 42i32 } } fn write_status (value : i32) -> bool { { if value > 0i...
  |                                                                ^^            ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn read_config () -> i32 { { return 42i32 } } fn write_status (value : i32) -> bool { { if value > 0i32 { { return true } } ; return false } } fn main () { { { let config = read_config () ; { println ! ("Config value:" . to_string ()) ; println ! ("{}" , config) ; let mut success = write_status (config) ; println ! ("Write success:" . to_string ()) ; println ! ("{}" , success) } } } }
1 + use std :: collections :: HashMap ; fn read_config () -> i32 { return 42i32 } fn write_status (value : i32) -> bool { { if value > 0i32 { { return true } } ; return false } } fn main () { { { let config = read_config () ; { println ! ("Config value:" . to_string ()) ; println ! ("{}" , config) ; let mut success = write_status (config) ; println ! ("Write success:" . to_string ()) ; println ! ("{}" , success) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpSkR8Wi/main.rs:1:143
  |
1 | ...n write_status (value : i32) -> bool { { if value > 0i32 { { return true } } ; return false } } fn main () { { { let config = read_con...
  |                                                               ^^           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn read_config () -> i32 { { return 42i32 } } fn write_status (value : i32) -> bool { { if value > 0i32 { { return true } } ; return false } } fn main () { { { let config = read_config () ; { println ! ("Config value:" . to_string ()) ; println ! ("{}" , config) ; let mut success = write_status (config) ; println ! ("Write success:" . to_string ()) ; println ! ("{}" , success) } } } }
1 + use std :: collections :: HashMap ; fn read_config () -> i32 { { return 42i32 } } fn write_status (value : i32) -> bool { { if value > 0i32 { return true } ; return false } } fn main () { { { let config = read_config () ; { println ! ("Config value:" . to_string ()) ; println ! ("{}" , config) ; let mut success = write_status (config) ; println ! ("Write success:" . to_string ()) ; println ! ("{}" , success) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpSkR8Wi/main.rs:1:193
  |
1 | ... { { { let config = read_config () ; { println ! ("Config value:" . to_string ()) ; println ! ("{}" , config) ; let mut success = write_status (config) ; println ! ("Write success:" . to_string ()) ; println ! ("{}" , success) } } } }
  |       ^^                                                                                                                                                                                                                                 ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn read_config () -> i32 { { return 42i32 } } fn write_status (value : i32) -> bool { { if value > 0i32 { { return true } } ; return false } } fn main () { { { let config = read_config () ; { println ! ("Config value:" . to_string ()) ; println ! ("{}" , config) ; let mut success = write_status (config) ; println ! ("Write success:" . to_string ()) ; println ! ("{}" , success) } } } }
1 + use std :: collections :: HashMap ; fn read_config () -> i32 { { return 42i32 } } fn write_status (value : i32) -> bool { { if value > 0i32 { { return true } } ; return false } } fn main () { { let config = read_config () ; { println ! ("Config value:" . to_string ()) ; println ! ("{}" , config) ; let mut success = write_status (config) ; println ! ("Write success:" . to_string ()) ; println ! ("{}" , success) } } }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpSkR8Wi/main.rs:1:258
  |
1 | ...= read_config () ; { println ! ("Config value:" . to_string ()) ; println ! ("{}" , config) ; let mut success = write_status (config) ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpSkR8Wi/main.rs:1:374
  |
1 | ...e_status (config) ; println ! ("Write success:" . to_string ()) ; println ! ("{}" , success) } } } }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 6 previous errors; 4 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch11-00-file-operations-tdd example 2 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpaLDMJT/main.rs:1:122
  |
1 | ... : i32 , score : i32) { { println ! ("Saving game state..." . to_string ()) ; println ! ("Level:" . to_string ()) ; println ! ("{}" , ...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpaLDMJT/main.rs:1:124
  |
1 | ...l : i32 , score : i32) { { println ! ("Saving game state..." . to_string ()) ; println ! ("Level:" . to_string ()) ; println ! ("{}" ,...
  |                                          ----------------------   ^^^^^^^^^^^^ argument never used
  |                                          |
  |                                          formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpaLDMJT/main.rs:1:160
  |
1 | ...Saving game state..." . to_string ()) ; println ! ("Level:" . to_string ()) ; println ! ("{}" , level) ; println ! ("Score:" . to_stri...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpaLDMJT/main.rs:1:162
  |
1 | ... game state..." . to_string ()) ; println ! ("Level:" . to_string ()) ; println ! ("{}" , level) ; println ! ("Score:" . to_string ())...
  |                                                 --------   ^^^^^^^^^^^^ argument never used
  |                                                 |
  |                                                 formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpaLDMJT/main.rs:1:225
  |
1 | ...string ()) ; println ! ("{}" , level) ; println ! ("Score:" . to_string ()) ; println ! ("{}" , score) ; println ! ("State saved succe...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpaLDMJT/main.rs:1:227
  |
1 | ... ()) ; println ! ("{}" , level) ; println ! ("Score:" . to_string ()) ; println ! ("{}" , score) ; println ! ("State saved successfull...
  |                                                 --------   ^^^^^^^^^^^^ argument never used
  |                                                 |
  |                                                 formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpaLDMJT/main.rs:1:308
  |
1 | ...ln ! ("{}" , score) ; println ! ("State saved successfully" . to_string ()) } } fn load_game_state () { { println ! ("Loading game sta...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpaLDMJT/main.rs:1:310
  |
1 | ...intln ! ("{}" , score) ; println ! ("State saved successfully" . to_string ()) } } fn load_game_state () { { println ! ("Loading game ...
  |                                        --------------------------   ^^^^^^^^^^^^ argument never used
  |                                        |
  |                                        formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpaLDMJT/main.rs:1:389
  |
1 | ...n load_game_state () { { println ! ("Loading game state..." . to_string ()) ; println ! ("Level: 5" . to_string ()) ; println ! ("Scor...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpaLDMJT/main.rs:1:391
  |
1 | ... fn load_game_state () { { println ! ("Loading game state..." . to_string ()) ; println ! ("Level: 5" . to_string ()) ; println ! ("Sc...
  |                                          -----------------------   ^^^^^^^^^^^^ argument never used
  |                                          |
  |                                          formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpaLDMJT/main.rs:1:429
  |
1 | ...ding game state..." . to_string ()) ; println ! ("Level: 5" . to_string ()) ; println ! ("Score: 1000" . to_string ()) ; println ! ("S...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpaLDMJT/main.rs:1:431
  |
1 | ...game state..." . to_string ()) ; println ! ("Level: 5" . to_string ()) ; println ! ("Score: 1000" . to_string ()) ; println ! ("State ...
  |                                                ----------   ^^^^^^^^^^^^ argument never used
  |                                                |
  |                                                formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpaLDMJT/main.rs:1:472
  |
1 | ...ln ! ("Level: 5" . to_string ()) ; println ! ("Score: 1000" . to_string ()) ; println ! ("State loaded successfully" . to_string ()) }...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpaLDMJT/main.rs:1:474
  |
1 | ...! ("Level: 5" . to_string ()) ; println ! ("Score: 1000" . to_string ()) ; println ! ("State loaded successfully" . to_string ()) } } ...
  |                                               -------------   ^^^^^^^^^^^^ argument never used
  |                                               |
  |                                               formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpaLDMJT/main.rs:1:529
  |
1 | ...0" . to_string ()) ; println ! ("State loaded successfully" . to_string ()) } } fn main () { { save_game_state (5i32 , 1000i32) ; prin...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpaLDMJT/main.rs:1:531
  |
1 | ... 1000" . to_string ()) ; println ! ("State loaded successfully" . to_string ()) } } fn main () { { save_game_state (5i32 , 1000i32) ; ...
  |                                        ---------------------------   ^^^^^^^^^^^^ argument never used
  |                                        |
  |                                        formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpaLDMJT/main.rs:1:616
  |
1 | ... () { { save_game_state (5i32 , 1000i32) ; println ! ("---" . to_string ()) ; load_game_state () } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpaLDMJT/main.rs:1:618
  |
1 | ... save_game_state (5i32 , 1000i32) ; println ! ("---" . to_string ()) ; load_game_state () } }
  |                                                   -----   ^^^^^^^^^^^^ argument never used
  |                                                   |
  |                                                   formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpaLDMJT/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn save_game_state (level : i32 , score : i32) { { println ! ("Saving game state..." . to_string ()) ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpaLDMJT/main.rs:1:124
  |
1 | ...re : i32) { { println ! ("Saving game state..." . to_string ()) ; println ! ("Level:" . to_string ()) ; println ! ("{}" , level) ; pri...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpaLDMJT/main.rs:1:162
  |
1 | ...state..." . to_string ()) ; println ! ("Level:" . to_string ()) ; println ! ("{}" , level) ; println ! ("Score:" . to_string ()) ; pri...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpaLDMJT/main.rs:1:227
  |
1 | ... println ! ("{}" , level) ; println ! ("Score:" . to_string ()) ; println ! ("{}" , score) ; println ! ("State saved successfully" . t...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpaLDMJT/main.rs:1:310
  |
1 | ... score) ; println ! ("State saved successfully" . to_string ()) } } fn load_game_state () { { println ! ("Loading game state..." . to_...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpaLDMJT/main.rs:1:391
  |
1 | ...state () { { println ! ("Loading game state..." . to_string ()) ; println ! ("Level: 5" . to_string ()) ; println ! ("Score: 1000" . t...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpaLDMJT/main.rs:1:431
  |
1 | ...ate..." . to_string ()) ; println ! ("Level: 5" . to_string ()) ; println ! ("Score: 1000" . to_string ()) ; println ! ("State loaded ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpaLDMJT/main.rs:1:474
  |
1 | ...: 5" . to_string ()) ; println ! ("Score: 1000" . to_string ()) ; println ! ("State loaded successfully" . to_string ()) } } fn main (...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpaLDMJT/main.rs:1:531
  |
1 | ...ng ()) ; println ! ("State loaded successfully" . to_string ()) } } fn main () { { save_game_state (5i32 , 1000i32) ; println ! ("---"...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpaLDMJT/main.rs:1:618
  |
1 | ..._game_state (5i32 , 1000i32) ; println ! ("---" . to_string ()) ; load_game_state () } }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 27 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch11-00-file-operations-tdd example 3 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpmrOd45/main.rs:1:284
  |
1 | ...ig (value : i32) { { println ! ("Applying configuration..." . to_string ()) ; println ! ("Config value:" . to_string ()) ; println ! (...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpmrOd45/main.rs:1:286
  |
1 | ...config (value : i32) { { println ! ("Applying configuration..." . to_string ()) ; println ! ("Config value:" . to_string ()) ; println...
  |                                        ---------------------------   ^^^^^^^^^^^^ argument never used
  |                                        |
  |                                        formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpmrOd45/main.rs:1:329
  |
1 | ...figuration..." . to_string ()) ; println ! ("Config value:" . to_string ()) ; println ! ("{}" , value) ; if validate_config (value) { ...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpmrOd45/main.rs:1:331
  |
1 | ...guration..." . to_string ()) ; println ! ("Config value:" . to_string ()) ; println ! ("{}" , value) ; if validate_config (value) { { ...
  |                                              ---------------   ^^^^^^^^^^^^ argument never used
  |                                              |
  |                                              formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpmrOd45/main.rs:1:453
  |
1 | ...(value) { { println ! ("Configuration applied successfully" . to_string ()) } } else { { println ! ("Invalid configuration" . to_strin...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpmrOd45/main.rs:1:455
  |
1 | ..._config (value) { { println ! ("Configuration applied successfully" . to_string ()) } } else { { println ! ("Invalid configuration" . ...
  |                                   ------------------------------------   ^^^^^^^^^^^^ argument never used
  |                                   |
  |                                   formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpmrOd45/main.rs:1:517
  |
1 | ..._string ()) } } else { { println ! ("Invalid configuration" . to_string ()) } } } } fn main () { { { let config = get_default_config (...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpmrOd45/main.rs:1:519
  |
1 | ...to_string ()) } } else { { println ! ("Invalid configuration" . to_string ()) } } } } fn main () { { { let config = get_default_config...
  |                                          -----------------------   ^^^^^^^^^^^^ argument never used
  |                                          |
  |                                          formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpmrOd45/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpmrOd45/main.rs:1:71
  |
1 | use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if...
  |                                                                       ^^             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) { { println ! ("Applying configuration..." . to_string ()) ; println ! ("Config value:" . to_string ()) ; println ! ("{}" , value) ; if validate_config (value) { { println ! ("Configuration applied successfully" . to_string ()) } } else { { println ! ("Invalid configuration" . to_string ()) } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }
1 + use std :: collections :: HashMap ; fn get_default_config () -> i32 { return 100i32 } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) { { println ! ("Applying configuration..." . to_string ()) ; println ! ("Config value:" . to_string ()) ; println ! ("{}" , value) ; if validate_config (value) { { println ! ("Configuration applied successfully" . to_string ()) } } else { { println ! ("Invalid configuration" . to_string ()) } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpmrOd45/main.rs:1:174
  |
1 | ...e : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) { { prin...
  |                                                               ^^           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) { { println ! ("Applying configuration..." . to_string ()) ; println ! ("Config value:" . to_string ()) ; println ! ("{}" , value) ; if validate_config (value) { { println ! ("Configuration applied successfully" . to_string ()) } } else { { println ! ("Invalid configuration" . to_string ()) } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }
1 + use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { return true } ; return false } } fn apply_config (value : i32) { { println ! ("Applying configuration..." . to_string ()) ; println ! ("Config value:" . to_string ()) ; println ! ("{}" , value) ; if validate_config (value) { { println ! ("Configuration applied successfully" . to_string ()) } } else { { println ! ("Invalid configuration" . to_string ()) } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpmrOd45/main.rs:1:403
  |
1 | ...) ; if validate_config (value) { { println ! ("Configuration applied successfully" . to_string ()) } } else { { println ! ("Invalid co...
  |                                     ^^                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) { { println ! ("Applying configuration..." . to_string ()) ; println ! ("Config value:" . to_string ()) ; println ! ("{}" , value) ; if validate_config (value) { { println ! ("Configuration applied successfully" . to_string ()) } } else { { println ! ("Invalid configuration" . to_string ()) } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }
1 + use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) { { println ! ("Applying configuration..." . to_string ()) ; println ! ("Config value:" . to_string ()) ; println ! ("{}" , value) ; if validate_config (value) { println ! ("Configuration applied successfully" . to_string ()) } else { { println ! ("Invalid configuration" . to_string ()) } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpmrOd45/main.rs:1:480
  |
1 | ...uccessfully" . to_string ()) } } else { { println ! ("Invalid configuration" . to_string ()) } } } } fn main () { { { let config = get...
  |                                            ^^                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) { { println ! ("Applying configuration..." . to_string ()) ; println ! ("Config value:" . to_string ()) ; println ! ("{}" , value) ; if validate_config (value) { { println ! ("Configuration applied successfully" . to_string ()) } } else { { println ! ("Invalid configuration" . to_string ()) } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }
1 + use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) { { println ! ("Applying configuration..." . to_string ()) ; println ! ("Config value:" . to_string ()) ; println ! ("{}" , value) ; if validate_config (value) { { println ! ("Configuration applied successfully" . to_string ()) } } else { println ! ("Invalid configuration" . to_string ()) } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpmrOd45/main.rs:1:554
  |
1 | ...o_string ()) } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }
  |                                      ^^                                                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) { { println ! ("Applying configuration..." . to_string ()) ; println ! ("Config value:" . to_string ()) ; println ! ("{}" , value) ; if validate_config (value) { { println ! ("Configuration applied successfully" . to_string ()) } } else { { println ! ("Invalid configuration" . to_string ()) } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }
1 + use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) { { println ! ("Applying configuration..." . to_string ()) ; println ! ("Config value:" . to_string ()) ; println ! ("{}" , value) ; if validate_config (value) { { println ! ("Configuration applied successfully" . to_string ()) } } else { { println ! ("Invalid configuration" . to_string ()) } } } } fn main () { { let config = get_default_config () ; apply_config (config) } }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpmrOd45/main.rs:1:286
  |
1 | ...i32) { { println ! ("Applying configuration..." . to_string ()) ; println ! ("Config value:" . to_string ()) ; println ! ("{}" , value...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpmrOd45/main.rs:1:331
  |
1 | ...." . to_string ()) ; println ! ("Config value:" . to_string ()) ; println ! ("{}" , value) ; if validate_config (value) { { println ! ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpmrOd45/main.rs:1:455
  |
1 | ...println ! ("Configuration applied successfully" . to_string ()) } } else { { println ! ("Invalid configuration" . to_string ()) } } } ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpmrOd45/main.rs:1:519
  |
1 | ...} } else { { println ! ("Invalid configuration" . to_string ()) } } } } fn main () { { { let config = get_default_config () ; apply_co...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 12 previous errors; 6 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch11-00-file-operations-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `DataType` in this scope
 --> /tmp/.tmpKrvGIN/main.rs:1:56
  |
1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
  |                                                        ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `default_value` in this scope
 --> /tmp/.tmpKrvGIN/main.rs:1:76
  |
1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
  |                                                                            ^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpKrvGIN/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpKrvGIN/main.rs:1:67
  |
1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
  |                                                                   ^^                    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
1 + use std :: collections :: HashMap ; fn read_data () -> DataType { return default_value } fn main () { }
  |

error: aborting due to 2 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch11-00-file-operations-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `DataType` in this scope
 --> /tmp/.tmpff0YXm/main.rs:1:60
  |
1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...
  |                                                            ^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpff0YXm/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpff0YXm/main.rs:1:101
  |
1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...
  |                                                                                                     ^^           ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } fn main () { }
1 + use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { return true } ; return false } } fn main () { }
  |

error[E0425]: cannot find function `valid` in this scope
 --> /tmp/.tmpff0YXm/main.rs:1:85
  |
1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...
  |                                                                                     ^^^^^ not found in this scope

error: aborting due to 2 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch11-00-file-operations-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `ConfigType` in this scope
 --> /tmp/.tmpq3LaC3/main.rs:1:58
  |
1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...
  |                                                          ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `default_config` in this scope
 --> /tmp/.tmpq3LaC3/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...
  |                                                                                ^^^^^^^^^^^^^^ not found in this scope

error[E0412]: cannot find type `ConfigType` in this scope
 --> /tmp/.tmpq3LaC3/main.rs:1:124
  |
1 | ...eturn default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
  |                                                      ^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpq3LaC3/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpq3LaC3/main.rs:1:71
  |
1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...
  |                                                                       ^^                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
1 + use std :: collections :: HashMap ; fn load_config () -> ConfigType { return default_config } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpq3LaC3/main.rs:1:146
  |
1 | ...g } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
  |                                                         ^^                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
1 + use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { return validate (config) } fn main () { }
  |

error[E0425]: cannot find function `validate` in this scope
 --> /tmp/.tmpq3LaC3/main.rs:1:155
  |
1 | ...ve_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
  |                                                       ^^^^^^^^ not found in this scope

error: aborting due to 4 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch11-00-file-operations-tdd example 8 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpJ9gLO4/main.rs:1:118
  |
1 | use std :: collections :: HashMap ; fn save_progress (level : i32 , score : i32) { { println ! ("Saving progress..." . to_string ()) ; pr...
  |                                                                                                                      ^ expected `,`

error: argument never used
 --> /tmp/.tmpJ9gLO4/main.rs:1:120
  |
1 | ...el : i32 , score : i32) { { println ! ("Saving progress..." . to_string ()) ; println ! ("{}" , level) ; println ! ("{}" , score) } } ...
  |                                           --------------------   ^^^^^^^^^^^^ argument never used
  |                                           |
  |                                           formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpJ9gLO4/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn save_progress (level : i32 , score : i32) { { println ! ("Saving progress..." . to_string ()) ; pr...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpJ9gLO4/main.rs:1:120
  |
1 | ...core : i32) { { println ! ("Saving progress..." . to_string ()) ; println ! ("{}" , level) ; println ! ("{}" , score) } } fn main () { }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch11-00-file-operations-tdd example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-control-flow-tdd example 1 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpgEjcMk/main.rs:1:119
  |
1 | use std :: collections :: HashMap ; fn main () { { { let x = 10i32 ; if x > 5i32 { { println ! ("x is greater than 5" . to_string ()) } }...
  |                                                                                                                       ^ expected `,`

error: argument never used
 --> /tmp/.tmpgEjcMk/main.rs:1:121
  |
1 | ...x = 10i32 ; if x > 5i32 { { println ! ("x is greater than 5" . to_string ()) } } else { { println ! ("x is not greater than 5" . to_st...
  |                                           ---------------------   ^^^^^^^^^^^^ argument never used
  |                                           |
  |                                           formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpgEjcMk/main.rs:1:185
  |
1 | ...tring ()) } } else { { println ! ("x is not greater than 5" . to_string ()) } } } } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpgEjcMk/main.rs:1:187
  |
1 | ...o_string ()) } } else { { println ! ("x is not greater than 5" . to_string ()) } } } } }
  |                                         -------------------------   ^^^^^^^^^^^^ argument never used
  |                                         |
  |                                         formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpgEjcMk/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let x = 10i32 ; if x > 5i32 { { println ! ("x is greater than 5" . to_string ()) } }...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpgEjcMk/main.rs:1:50
  |
1 | ... { { { let x = 10i32 ; if x > 5i32 { { println ! ("x is greater than 5" . to_string ()) } } else { { println ! ("x is not greater than 5" . to_string ()) } } } } }
  |       ^^                                                                                                                                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let x = 10i32 ; if x > 5i32 { { println ! ("x is greater than 5" . to_string ()) } } else { { println ! ("x is not greater than 5" . to_string ()) } } } } }
1 + use std :: collections :: HashMap ; fn main () { { let x = 10i32 ; if x > 5i32 { { println ! ("x is greater than 5" . to_string ()) } } else { { println ! ("x is not greater than 5" . to_string ()) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpgEjcMk/main.rs:1:84
  |
1 | ...n () { { { let x = 10i32 ; if x > 5i32 { { println ! ("x is greater than 5" . to_string ()) } } else { { println ! ("x is not greater ...
  |                                             ^^                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let x = 10i32 ; if x > 5i32 { { println ! ("x is greater than 5" . to_string ()) } } else { { println ! ("x is not greater than 5" . to_string ()) } } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let x = 10i32 ; if x > 5i32 { println ! ("x is greater than 5" . to_string ()) } else { { println ! ("x is not greater than 5" . to_string ()) } } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpgEjcMk/main.rs:1:146
  |
1 | ...ter than 5" . to_string ()) } } else { { println ! ("x is not greater than 5" . to_string ()) } } } } }
  |                                           ^^                                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let x = 10i32 ; if x > 5i32 { { println ! ("x is greater than 5" . to_string ()) } } else { { println ! ("x is not greater than 5" . to_string ()) } } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let x = 10i32 ; if x > 5i32 { { println ! ("x is greater than 5" . to_string ()) } } else { println ! ("x is not greater than 5" . to_string ()) } } } }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpgEjcMk/main.rs:1:121
  |
1 | ...f x > 5i32 { { println ! ("x is greater than 5" . to_string ()) } } else { { println ! ("x is not greater than 5" . to_string ()) } } ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpgEjcMk/main.rs:1:187
  |
1 | ...} else { { println ! ("x is not greater than 5" . to_string ()) } } } } }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 6 previous errors; 4 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 2 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpDGTXGL/main.rs:1:122
  |
1 | ...e = 85i32 ; { if score >= 80i32 { { println ! ("Great job!" . to_string ()) } } ; println ! ("Score processed" . to_string ()) } } } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpDGTXGL/main.rs:1:124
  |
1 | ...85i32 ; { if score >= 80i32 { { println ! ("Great job!" . to_string ()) } } ; println ! ("Score processed" . to_string ()) } } } }
  |                                               ------------   ^^^^^^^^^^^^ argument never used
  |                                               |
  |                                               formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpDGTXGL/main.rs:1:173
  |
1 | ...at job!" . to_string ()) } } ; println ! ("Score processed" . to_string ()) } } } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpDGTXGL/main.rs:1:175
  |
1 | ...t job!" . to_string ()) } } ; println ! ("Score processed" . to_string ()) } } } }
  |                                             -----------------   ^^^^^^^^^^^^ argument never used
  |                                             |
  |                                             formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpDGTXGL/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let score = 85i32 ; { if score >= 80i32 { { println ! ("Great job!" . to_string ()) ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpDGTXGL/main.rs:1:50
  |
1 | ... { { { let score = 85i32 ; { if score >= 80i32 { { println ! ("Great job!" . to_string ()) } } ; println ! ("Score processed" . to_string ()) } } } }
  |       ^^                                                                                                                                            ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let score = 85i32 ; { if score >= 80i32 { { println ! ("Great job!" . to_string ()) } } ; println ! ("Score processed" . to_string ()) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let score = 85i32 ; { if score >= 80i32 { { println ! ("Great job!" . to_string ()) } } ; println ! ("Score processed" . to_string ()) } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpDGTXGL/main.rs:1:96
  |
1 | ... { let score = 85i32 ; { if score >= 80i32 { { println ! ("Great job!" . to_string ()) } } ; println ! ("Score processed" . to_string ...
  |                                                 ^^                                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let score = 85i32 ; { if score >= 80i32 { { println ! ("Great job!" . to_string ()) } } ; println ! ("Score processed" . to_string ()) } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let score = 85i32 ; { if score >= 80i32 { println ! ("Great job!" . to_string ()) } ; println ! ("Score processed" . to_string ()) } } } }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpDGTXGL/main.rs:1:124
  |
1 | ...{ if score >= 80i32 { { println ! ("Great job!" . to_string ()) } } ; println ! ("Score processed" . to_string ()) } } } }
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpDGTXGL/main.rs:1:175
  |
1 | ...o_string ()) } } ; println ! ("Score processed" . to_string ()) } } } }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 6 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 3 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpbFqMeD/main.rs:1:117
  |
1 | use std :: collections :: HashMap ; fn main () { { { let grade = 75i32 ; if grade >= 90i32 { { println ! ("A grade" . to_string ()) } } e...
  |                                                                                                                     ^ expected `,`

error: argument never used
 --> /tmp/.tmpbFqMeD/main.rs:1:119
  |
1 | ...e = 75i32 ; if grade >= 90i32 { { println ! ("A grade" . to_string ()) } } else { if grade >= 80i32 { { println ! ("B grade" . to_stri...
  |                                                 ---------   ^^^^^^^^^^^^ argument never used
  |                                                 |
  |                                                 formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpbFqMeD/main.rs:1:187
  |
1 | ...g ()) } } else { if grade >= 80i32 { { println ! ("B grade" . to_string ()) } } else { if grade >= 70i32 { { println ! ("C grade" . to...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpbFqMeD/main.rs:1:189
  |
1 | ... } } else { if grade >= 80i32 { { println ! ("B grade" . to_string ()) } } else { if grade >= 70i32 { { println ! ("C grade" . to_stri...
  |                                                 ---------   ^^^^^^^^^^^^ argument never used
  |                                                 |
  |                                                 formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpbFqMeD/main.rs:1:257
  |
1 | ...g ()) } } else { if grade >= 70i32 { { println ! ("C grade" . to_string ()) } } else { { println ! ("Below C" . to_string ()) } } } } ...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpbFqMeD/main.rs:1:259
  |
1 | ... } } else { if grade >= 70i32 { { println ! ("C grade" . to_string ()) } } else { { println ! ("Below C" . to_string ()) } } } } } } }
  |                                                 ---------   ^^^^^^^^^^^^ argument never used
  |                                                 |
  |                                                 formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpbFqMeD/main.rs:1:307
  |
1 | ..."C grade" . to_string ()) } } else { { println ! ("Below C" . to_string ()) } } } } } } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpbFqMeD/main.rs:1:309
  |
1 | ...ade" . to_string ()) } } else { { println ! ("Below C" . to_string ()) } } } } } } }
  |                                                 ---------   ^^^^^^^^^^^^ argument never used
  |                                                 |
  |                                                 formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpbFqMeD/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let grade = 75i32 ; if grade >= 90i32 { { println ! ("A grade" . to_string ()) } } e...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpbFqMeD/main.rs:1:50
  |
1 | ... { { { let grade = 75i32 ; if grade >= 90i32 { { println ! ("A grade" . to_string ()) } } else { if grade >= 80i32 { { println ! ("B grade" . to_string ()) } } else { if grade >= 70i32 { { println ! ("C grade" . to_string ()) } } else { { println ! ("Below C" . to_string ()) } } } } } } }
  |       ^^                                                                                                                                                                                                                                                                                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let grade = 75i32 ; if grade >= 90i32 { { println ! ("A grade" . to_string ()) } } else { if grade >= 80i32 { { println ! ("B grade" . to_string ()) } } else { if grade >= 70i32 { { println ! ("C grade" . to_string ()) } } else { { println ! ("Below C" . to_string ()) } } } } } } }
1 + use std :: collections :: HashMap ; fn main () { { let grade = 75i32 ; if grade >= 90i32 { { println ! ("A grade" . to_string ()) } } else { if grade >= 80i32 { { println ! ("B grade" . to_string ()) } } else { if grade >= 70i32 { { println ! ("C grade" . to_string ()) } } else { { println ! ("Below C" . to_string ()) } } } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpbFqMeD/main.rs:1:94
  |
1 | use std :: collections :: HashMap ; fn main () { { { let grade = 75i32 ; if grade >= 90i32 { { println ! ("A grade" . to_string ()) } } e...
  |                                                                                              ^^                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let grade = 75i32 ; if grade >= 90i32 { { println ! ("A grade" . to_string ()) } } else { if grade >= 80i32 { { println ! ("B grade" . to_string ()) } } else { if grade >= 70i32 { { println ! ("C grade" . to_string ()) } } else { { println ! ("Below C" . to_string ()) } } } } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let grade = 75i32 ; if grade >= 90i32 { println ! ("A grade" . to_string ()) } else { if grade >= 80i32 { { println ! ("B grade" . to_string ()) } } else { if grade >= 70i32 { { println ! ("C grade" . to_string ()) } } else { { println ! ("Below C" . to_string ()) } } } } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpbFqMeD/main.rs:1:164
  |
1 | .... to_string ()) } } else { if grade >= 80i32 { { println ! ("B grade" . to_string ()) } } else { if grade >= 70i32 { { println ! ("C g...
  |                                                   ^^                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let grade = 75i32 ; if grade >= 90i32 { { println ! ("A grade" . to_string ()) } } else { if grade >= 80i32 { { println ! ("B grade" . to_string ()) } } else { if grade >= 70i32 { { println ! ("C grade" . to_string ()) } } else { { println ! ("Below C" . to_string ()) } } } } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let grade = 75i32 ; if grade >= 90i32 { { println ! ("A grade" . to_string ()) } } else { if grade >= 80i32 { println ! ("B grade" . to_string ()) } else { if grade >= 70i32 { { println ! ("C grade" . to_string ()) } } else { { println ! ("Below C" . to_string ()) } } } } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpbFqMeD/main.rs:1:234
  |
1 | .... to_string ()) } } else { if grade >= 70i32 { { println ! ("C grade" . to_string ()) } } else { { println ! ("Below C" . to_string ()...
  |                                                   ^^                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let grade = 75i32 ; if grade >= 90i32 { { println ! ("A grade" . to_string ()) } } else { if grade >= 80i32 { { println ! ("B grade" . to_string ()) } } else { if grade >= 70i32 { { println ! ("C grade" . to_string ()) } } else { { println ! ("Below C" . to_string ()) } } } } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let grade = 75i32 ; if grade >= 90i32 { { println ! ("A grade" . to_string ()) } } else { if grade >= 80i32 { { println ! ("B grade" . to_string ()) } } else { if grade >= 70i32 { println ! ("C grade" . to_string ()) } else { { println ! ("Below C" . to_string ()) } } } } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpbFqMeD/main.rs:1:284
  |
1 | ...rintln ! ("C grade" . to_string ()) } } else { { println ! ("Below C" . to_string ()) } } } } } } }
  |                                                   ^^                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let grade = 75i32 ; if grade >= 90i32 { { println ! ("A grade" . to_string ()) } } else { if grade >= 80i32 { { println ! ("B grade" . to_string ()) } } else { if grade >= 70i32 { { println ! ("C grade" . to_string ()) } } else { { println ! ("Below C" . to_string ()) } } } } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let grade = 75i32 ; if grade >= 90i32 { { println ! ("A grade" . to_string ()) } } else { if grade >= 80i32 { { println ! ("B grade" . to_string ()) } } else { if grade >= 70i32 { { println ! ("C grade" . to_string ()) } } else { println ! ("Below C" . to_string ()) } } } } } }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpbFqMeD/main.rs:1:119
  |
1 | ...32 ; if grade >= 90i32 { { println ! ("A grade" . to_string ()) } } else { if grade >= 80i32 { { println ! ("B grade" . to_string ()) ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpbFqMeD/main.rs:1:189
  |
1 | ...se { if grade >= 80i32 { { println ! ("B grade" . to_string ()) } } else { if grade >= 70i32 { { println ! ("C grade" . to_string ()) ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpbFqMeD/main.rs:1:259
  |
1 | ...se { if grade >= 70i32 { { println ! ("C grade" . to_string ()) } } else { { println ! ("Below C" . to_string ()) } } } } } } }
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpbFqMeD/main.rs:1:309
  |
1 | ...to_string ()) } } else { { println ! ("Below C" . to_string ()) } } } } } } }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 12 previous errors; 6 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpDUdhgT/main.rs:1:150
  |
1 | ...println ! ("{}" , i) ; i = i + 1i32 } } ; println ! ("Done" . to_string ()) } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpDUdhgT/main.rs:1:152
  |
1 | ... ! ("{}" , i) ; i = i + 1i32 } } ; println ! ("Done" . to_string ()) } }
  |                                                  ------   ^^^^^^^^^^^^ argument never used
  |                                                  |
  |                                                  formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpDUdhgT/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { let mut i = 0i32 ; while i < 3i32 { { println ! ("{}" , i) ; i = i + 1i32 } } ; printl...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpDUdhgT/main.rs:1:152
  |
1 | ...{}" , i) ; i = i + 1i32 } } ; println ! ("Done" . to_string ()) } }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpDULVQK/main.rs:1:132
  |
1 | ...2 { { println ! ("{}" , i) } } ; println ! ("For loop done" . to_string ()) } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpDULVQK/main.rs:1:134
  |
1 | ...{ { println ! ("{}" , i) } } ; println ! ("For loop done" . to_string ()) } }
  |                                              ---------------   ^^^^^^^^^^^^ argument never used
  |                                              |
  |                                              formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpDULVQK/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { for i in 0i32 .. 3i32 { { println ! ("{}" , i) } } ; println ! ("For loop done" . to_s...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpDULVQK/main.rs:1:76
  |
1 | use std :: collections :: HashMap ; fn main () { { for i in 0i32 .. 3i32 { { println ! ("{}" , i) } } ; println ! ("For loop done" . to_s...
  |                                                                            ^^                    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { for i in 0i32 .. 3i32 { { println ! ("{}" , i) } } ; println ! ("For loop done" . to_string ()) } }
1 + use std :: collections :: HashMap ; fn main () { { for i in 0i32 .. 3i32 { println ! ("{}" , i) } ; println ! ("For loop done" . to_string ()) } }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpDULVQK/main.rs:1:134
  |
1 | ...n ! ("{}" , i) } } ; println ! ("For loop done" . to_string ()) } }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpxdWlgO/main.rs:1:114
  |
1 | use std :: collections :: HashMap ; fn main () { { { let number = 2i32 ; match number { 1i32 => println ! ("One" . to_string ()) , 2i32 =...
  |                                                                                                                  ^ expected `,`

error: argument never used
 --> /tmp/.tmpxdWlgO/main.rs:1:116
  |
1 | ...ber = 2i32 ; match number { 1i32 => println ! ("One" . to_string ()) , 2i32 => println ! ("Two" . to_string ()) , 3i32 => println ! ("...
  |                                                   -----   ^^^^^^^^^^^^ argument never used
  |                                                   |
  |                                                   formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpxdWlgO/main.rs:1:157
  |
1 | ...println ! ("One" . to_string ()) , 2i32 => println ! ("Two" . to_string ()) , 3i32 => println ! ("Three" . to_string ()) , _ => printl...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpxdWlgO/main.rs:1:159
  |
1 | ... ! ("One" . to_string ()) , 2i32 => println ! ("Two" . to_string ()) , 3i32 => println ! ("Three" . to_string ()) , _ => println ! ("O...
  |                                                   -----   ^^^^^^^^^^^^ argument never used
  |                                                   |
  |                                                   formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpxdWlgO/main.rs:1:202
  |
1 | ...intln ! ("Two" . to_string ()) , 3i32 => println ! ("Three" . to_string ()) , _ => println ! ("Other" . to_string ()) , } } } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpxdWlgO/main.rs:1:204
  |
1 | ...! ("Two" . to_string ()) , 3i32 => println ! ("Three" . to_string ()) , _ => println ! ("Other" . to_string ()) , } } } }
  |                                                  -------   ^^^^^^^^^^^^ argument never used
  |                                                  |
  |                                                  formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpxdWlgO/main.rs:1:244
  |
1 | ...rintln ! ("Three" . to_string ()) , _ => println ! ("Other" . to_string ()) , } } } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpxdWlgO/main.rs:1:246
  |
1 | ... ! ("Three" . to_string ()) , _ => println ! ("Other" . to_string ()) , } } } }
  |                                                  -------   ^^^^^^^^^^^^ argument never used
  |                                                  |
  |                                                  formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpxdWlgO/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let number = 2i32 ; match number { 1i32 => println ! ("One" . to_string ()) , 2i32 =...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpxdWlgO/main.rs:1:50
  |
1 | ... { { { let number = 2i32 ; match number { 1i32 => println ! ("One" . to_string ()) , 2i32 => println ! ("Two" . to_string ()) , 3i32 => println ! ("Three" . to_string ()) , _ => println ! ("Other" . to_string ()) , } } } }
  |       ^^                                                                                                                                                                                                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let number = 2i32 ; match number { 1i32 => println ! ("One" . to_string ()) , 2i32 => println ! ("Two" . to_string ()) , 3i32 => println ! ("Three" . to_string ()) , _ => println ! ("Other" . to_string ()) , } } } }
1 + use std :: collections :: HashMap ; fn main () { { let number = 2i32 ; match number { 1i32 => println ! ("One" . to_string ()) , 2i32 => println ! ("Two" . to_string ()) , 3i32 => println ! ("Three" . to_string ()) , _ => println ! ("Other" . to_string ()) , } } }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpxdWlgO/main.rs:1:116
  |
1 | ... 2i32 ; match number { 1i32 => println ! ("One" . to_string ()) , 2i32 => println ! ("Two" . to_string ()) , 3i32 => println ! ("Three...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpxdWlgO/main.rs:1:159
  |
1 | ...One" . to_string ()) , 2i32 => println ! ("Two" . to_string ()) , 3i32 => println ! ("Three" . to_string ()) , _ => println ! ("Other"...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpxdWlgO/main.rs:1:204
  |
1 | ...o" . to_string ()) , 3i32 => println ! ("Three" . to_string ()) , _ => println ! ("Other" . to_string ()) , } } } }
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpxdWlgO/main.rs:1:246
  |
1 | ...hree" . to_string ()) , _ => println ! ("Other" . to_string ()) , } } } }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 12 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 7 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpF5UlTq/main.rs:1:218
  |
1 | ...ak } } ; println ! ("{}" , i) } } ; println ! ("Loop ended" . to_string ()) } }
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpF5UlTq/main.rs:1:220
  |
1 | ... } ; println ! ("{}" , i) } } ; println ! ("Loop ended" . to_string ()) } }
  |                                               ------------   ^^^^^^^^^^^^ argument never used
  |                                               |
  |                                               formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpF5UlTq/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { let mut i = 0i32 ; while i < 10i32 { { i = i + 1i32 ; if i == 3i32 { { continue } } ; ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpF5UlTq/main.rs:1:121
  |
1 | use std :: collections :: HashMap ; fn main () { { let mut i = 0i32 ; while i < 10i32 { { i = i + 1i32 ; if i == 3i32 { { continue } } ; ...
  |                                                                                                                         ^^        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { let mut i = 0i32 ; while i < 10i32 { { i = i + 1i32 ; if i == 3i32 { { continue } } ; if i == 6i32 { { break } } ; println ! ("{}" , i) } } ; println ! ("Loop ended" . to_string ()) } }
1 + use std :: collections :: HashMap ; fn main () { { let mut i = 0i32 ; while i < 10i32 { { i = i + 1i32 ; if i == 3i32 { continue } ; if i == 6i32 { { break } } ; println ! ("{}" , i) } } ; println ! ("Loop ended" . to_string ()) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpF5UlTq/main.rs:1:153
  |
1 | ...i = i + 1i32 ; if i == 3i32 { { continue } } ; if i == 6i32 { { break } } ; println ! ("{}" , i) } } ; println ! ("Loop ended" . to_st...
  |                                                                  ^^     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { let mut i = 0i32 ; while i < 10i32 { { i = i + 1i32 ; if i == 3i32 { { continue } } ; if i == 6i32 { { break } } ; println ! ("{}" , i) } } ; println ! ("Loop ended" . to_string ()) } }
1 + use std :: collections :: HashMap ; fn main () { { let mut i = 0i32 ; while i < 10i32 { { i = i + 1i32 ; if i == 3i32 { { continue } } ; if i == 6i32 { break } ; println ! ("{}" , i) } } ; println ! ("Loop ended" . to_string ()) } }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpF5UlTq/main.rs:1:220
  |
1 | ...ntln ! ("{}" , i) } } ; println ! ("Loop ended" . to_string ()) } }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 8 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `condition` in this scope
 --> /tmp/.tmpH5Q0LF/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if condition { () } else { if other_condition { () } else { () } } ; if let...
  |                                                                  ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `other_condition` in this scope
 --> /tmp/.tmpH5Q0LF/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if condition { () } else { if other_condition { () } else { () } } ; if let...
  |                                                                                             ^^^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpH5Q0LF/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if condition { () } else { if other_condition { () } else { () } } ; if let...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 9 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `condition` in this scope
 --> /tmp/.tmpV3BGu3/main.rs:1:71
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start .. end { () } } ; if let S...
  |                                                                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `start` in this scope
 --> /tmp/.tmpV3BGu3/main.rs:1:106
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start .. end { () } } ; if let S...
  |                                                                                                          ^^^^^ not found in this scope

error[E0425]: cannot find value `end` in this scope
 --> /tmp/.tmpV3BGu3/main.rs:1:115
  |
1 | ... { while condition { () } ; for variable in start .. end { () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast...
  |                                                         ^^^ not found in this scope
  |
help: you might have meant to write `.` instead of `..`
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start .. end { () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start.end { () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpV3BGu3/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start .. end { () } } ; if let S...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 3 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 10 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `value` in this scope
 --> /tmp/.tmpsp6qt2/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match value { pattern1 => action1 , pattern2 => action2 , _ => default_acti...
  |                                                                     ^^^^^ not found in this scope

error[E0425]: cannot find value `action1` in this scope
 --> /tmp/.tmpsp6qt2/main.rs:1:89
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match value { pattern1 => action1 , pattern2 => action2 , _ => default_acti...
  |                                                                                         ^^^^^^^ not found in this scope

error[E0425]: cannot find value `action2` in this scope
 --> /tmp/.tmpsp6qt2/main.rs:1:111
  |
1 | ... = match value { pattern1 => action1 , pattern2 => action2 , _ => default_action , } ; if let Some (s) = (& result as & dyn std :: any...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `default_action` in this scope
 --> /tmp/.tmpsp6qt2/main.rs:1:126
  |
1 | ...attern1 => action1 , pattern2 => action2 , _ => default_action , } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcas...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpsp6qt2/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match value { pattern1 => action1 , pattern2 => action2 , _ => default_acti...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 4 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 11 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `user_input` in this scope
 --> /tmp/.tmpQWyksn/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...
  |                                                                  ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `threshold` in this scope
 --> /tmp/.tmpQWyksn/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...
  |                                                                               ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpQWyksn/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpQWyksn/main.rs:1:91
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...
  |                                                                                           ^^                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { process_high_value () } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpQWyksn/main.rs:1:126
  |
1 | ...put > threshold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :...
  |                                                         ^^                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { process_normal_value () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `process_high_value` in this scope
 --> /tmp/.tmpQWyksn/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...
  |                                                                                             ^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `process_normal_value` in this scope
 --> /tmp/.tmpQWyksn/main.rs:1:128
  |
1 | ...shold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . d...
  |                                                 ^^^^^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 4 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 12 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmptsp08z/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; while count < 10i32 { { do_something () ; count = ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `do_something` in this scope
 --> /tmp/.tmptsp08z/main.rs:1:112
  |
1 | ...{ let mut count = 0i32 ; while count < 10i32 { { do_something () ; count = count + 1i32 } } } ; if let Some (s) = (& result as & dyn s...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 14 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpCeo095/main.rs:1:114
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match status_code { 200i32 => println ! ("Success" . to_string ()) , 404i32...
  |                                                                                                                  ^ expected `,`

error: argument never used
 --> /tmp/.tmpCeo095/main.rs:1:116
  |
1 | ...t = match status_code { 200i32 => println ! ("Success" . to_string ()) , 404i32 => println ! ("Not Found" . to_string ()) , 500i32 => ...
  |                                                 ---------   ^^^^^^^^^^^^ argument never used
  |                                                 |
  |                                                 formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpCeo095/main.rs:1:165
  |
1 | ...Success" . to_string ()) , 404i32 => println ! ("Not Found" . to_string ()) , 500i32 => println ! ("Server Error" . to_string ()) , _ ...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpCeo095/main.rs:1:167
  |
1 | ...ess" . to_string ()) , 404i32 => println ! ("Not Found" . to_string ()) , 500i32 => println ! ("Server Error" . to_string ()) , _ => p...
  |                                                -----------   ^^^^^^^^^^^^ argument never used
  |                                                |
  |                                                formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpCeo095/main.rs:1:219
  |
1 | ...ound" . to_string ()) , 500i32 => println ! ("Server Error" . to_string ()) , _ => println ! ("Unknown Status" . to_string ()) , } ; i...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpCeo095/main.rs:1:221
  |
1 | ...d" . to_string ()) , 500i32 => println ! ("Server Error" . to_string ()) , _ => println ! ("Unknown Status" . to_string ()) , } ; if l...
  |                                              --------------   ^^^^^^^^^^^^ argument never used
  |                                              |
  |                                              formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpCeo095/main.rs:1:270
  |
1 | ...r Error" . to_string ()) , _ => println ! ("Unknown Status" . to_string ()) , } ; if let Some (s) = (& result as & dyn std :: any :: A...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpCeo095/main.rs:1:272
  |
1 | ...Error" . to_string ()) , _ => println ! ("Unknown Status" . to_string ()) , } ; if let Some (s) = (& result as & dyn std :: any :: Any...
  |                                             ----------------   ^^^^^^^^^^^^ argument never used
  |                                             |
  |                                             formatting specifier missing

error[E0425]: cannot find value `status_code` in this scope
 --> /tmp/.tmpCeo095/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match status_code { 200i32 => println ! ("Success" . to_string ()) , 404i32...
  |                                                                     ^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpCeo095/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match status_code { 200i32 => println ! ("Success" . to_string ()) , 404i32...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpCeo095/main.rs:1:116
  |
1 | ...ch status_code { 200i32 => println ! ("Success" . to_string ()) , 404i32 => println ! ("Not Found" . to_string ()) , 500i32 => println...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpCeo095/main.rs:1:167
  |
1 | ...o_string ()) , 404i32 => println ! ("Not Found" . to_string ()) , 500i32 => println ! ("Server Error" . to_string ()) , _ => println !...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpCeo095/main.rs:1:221
  |
1 | ...tring ()) , 500i32 => println ! ("Server Error" . to_string ()) , _ => println ! ("Unknown Status" . to_string ()) , } ; if let Some (...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpCeo095/main.rs:1:272
  |
1 | ...o_string ()) , _ => println ! ("Unknown Status" . to_string ()) , } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downca...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 13 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== appendix-c-troubleshooting example 1 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmphWCv33/main.rs:1:143
  |
1 | ... let mut x = 42i32 ; let mut y = 24i32 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmphWCv33/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut x = 42i32 ; let mut y = 24i32 ; let mut x = 42i32 ; let mut y = 2...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== appendix-c-troubleshooting example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 4 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmptOV3vr/main.rs:1:129
  |
1 | ...t mut x = 42i32 ; let mut x = "string" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmptOV3vr/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut x = "string" ; let mut x = 42i32 ; let mut x = "string" } ; if le...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== appendix-c-troubleshooting example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 6 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpLP5ERZ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut s = String :: from ("hello" . to_string ()) ; takes_ownership (s)...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `takes_ownership` in this scope
 --> /tmp/.tmpLP5ERZ/main.rs:1:119
  |
1 | ... s = String :: from ("hello" . to_string ()) ; takes_ownership (s) ; println ! ("{}" , s) ; let mut s = String :: from ("hello" . to_s...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `takes_ownership` in this scope
 --> /tmp/.tmpLP5ERZ/main.rs:1:218
  |
1 | ... s = String :: from ("hello" . to_string ()) ; takes_ownership (s . clone ()) ; println ! ("{}" , s) ; let mut s = String :: from ("he...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `borrows_value` in this scope
 --> /tmp/.tmpLP5ERZ/main.rs:1:328
  |
1 | ...t s = String :: from ("hello" . to_string ()) ; borrows_value (& s) ; println ! ("{}" , s) } ; if let Some (s) = (& result as & dyn st...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== appendix-c-troubleshooting example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 9 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpkUWZ8s/main.rs:1:307
  |
1 | ...: {{}}") , item) , None => println ! ("Index out of bounds" . to_string ()) , } ; if let Some (item) = v . get (5i32) { { println ! ("...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpkUWZ8s/main.rs:1:309
  |
1 | ...m: {{}}") , item) , None => println ! ("Index out of bounds" . to_string ()) , } ; if let Some (item) = v . get (5i32) { { println ! (...
  |                                           ---------------------   ^^^^^^^^^^^^ argument never used
  |                                           |
  |                                           formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpkUWZ8s/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut v = vec ! [1i32 , 2i32 , 3i32] ; let mut item = v [5i32] ; let mu...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpkUWZ8s/main.rs:1:367
  |
1 | ... if let Some (item) = v . get (5i32) { { println ! ("{} {}" , format ! ("Item: {{}}") , item) } } } ; if let Some (s) = (& result as &...
  |                                           ^^                                                    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { let mut v = vec ! [1i32 , 2i32 , 3i32] ; let mut item = v [5i32] ; let mut v = vec ! [1i32 , 2i32 , 3i32] ; match v . get (5i32) { Some (item) => println ! ("{} {}" , format ! ("Item: {{}}") , item) , None => println ! ("Index out of bounds" . to_string ()) , } ; if let Some (item) = v . get (5i32) { { println ! ("{} {}" , format ! ("Item: {{}}") , item) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { let mut v = vec ! [1i32 , 2i32 , 3i32] ; let mut item = v [5i32] ; let mut v = vec ! [1i32 , 2i32 , 3i32] ; match v . get (5i32) { Some (item) => println ! ("{} {}" , format ! ("Item: {{}}") , item) , None => println ! ("Index out of bounds" . to_string ()) , } ; if let Some (item) = v . get (5i32) { println ! ("{} {}" , format ! ("Item: {{}}") , item) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0277]: the type `[i32]` cannot be indexed by `i32`
 --> /tmp/.tmpkUWZ8s/main.rs:1:124
  |
1 | ...2 , 2i32 , 3i32] ; let mut item = v [5i32] ; let mut v = vec ! [1i32 , 2i32 , 3i32] ; match v . get (5i32) { Some (item) => println ! ...
  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`
  |
  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `Vec<i32>` to implement `Index<i32>`

error[E0277]: the type `[i32]` cannot be indexed by `i32`
   --> /tmp/.tmpkUWZ8s/main.rs:1:188
    |
1   | ...! [1i32 , 2i32 , 3i32] ; match v . get (5i32) { Some (item) => println ! ("{} {}" , format ! ("Item: {{}}") , item) , None => println ...
    |                                       ---  ^^^^ slice indices are of type `usize` or ranges of `usize`
    |                                       |
    |                                       required by a bound introduced by this call
    |
    = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
    = help: the following other types implement trait `SliceIndex<T>`:
              `usize` implements `SliceIndex<ByteStr>`
              `usize` implements `SliceIndex<[T]>`
note: required by a bound in `core::slice::<impl [T]>::get`
   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:573:12
    |
571 |     pub fn get<I>(&self, index: I) -> Option<&I::Output>
    |            --- required by a bound in this associated function
572 |     where
573 |         I: SliceIndex<Self>,
    |            ^^^^^^^^^^^^^^^^ required by this bound in `core::slice::<impl [T]>::get`

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpkUWZ8s/main.rs:1:309
  |
1 | ...tem) , None => println ! ("Index out of bounds" . to_string ()) , } ; if let Some (item) = v . get (5i32) { { println ! ("{} {}" , for...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0277]: the type `[i32]` cannot be indexed by `i32`
   --> /tmp/.tmpkUWZ8s/main.rs:1:359
    |
1   | ...()) , } ; if let Some (item) = v . get (5i32) { { println ! ("{} {}" , format ! ("Item: {{}}") , item) } } } ; if let Some (s) = (& re...
    |                                       ---  ^^^^ slice indices are of type `usize` or ranges of `usize`
    |                                       |
    |                                       required by a bound introduced by this call
    |
    = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
    = help: the following other types implement trait `SliceIndex<T>`:
              `usize` implements `SliceIndex<ByteStr>`
              `usize` implements `SliceIndex<[T]>`
note: required by a bound in `core::slice::<impl [T]>::get`
   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:573:12
    |
571 |     pub fn get<I>(&self, index: I) -> Option<&I::Output>
    |            --- required by a bound in this associated function
572 |     where
573 |         I: SliceIndex<Self>,
    |            ^^^^^^^^^^^^^^^^ required by this bound in `core::slice::<impl [T]>::get`

error: aborting due to 6 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0277, E0425.
For more information about an error, try `rustc --explain E0277`.



=== appendix-c-troubleshooting example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 13 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 14 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 15 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 16 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpaUfQCC/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpaUfQCC/main.rs:1:102
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for...
  |                                                                                                      ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpaUfQCC/main.rs:1:162
  |
1 | ...ut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i...
  |                                                         ^^                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { list . insert (0i32 , i) } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpaUfQCC/main.rs:1:259
  |
1 | ...que = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any...
  |                                                          ^^                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { deque . push_front (i) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0308]: mismatched types
    --> /tmp/.tmpaUfQCC/main.rs:1:179
     |
1    | ...ew () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { ...
     |                                                ------  ^^^^ expected `usize`, found `i32`
     |                                                |
     |                                                arguments to this method are incorrect
     |
note: method defined here
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2034:12
     |
2034 |     pub fn insert(&mut self, index: usize, element: T) {
     |            ^^^^^^
help: change the type of the numeric literal from `i32` to `usize`
     |
1    - use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1    + use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0usize , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
     |

error: aborting due to 1 previous error; 4 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== appendix-c-troubleshooting example 17 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmplhkvPR/main.rs:1:161
  |
1 | ...ut data = response . json () . await ? } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0425]: cannot find value `url` in this scope
 --> /tmp/.tmplhkvPR/main.rs:1:100
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut response = reqwest :: get (url) . await ? ; let mut data = respon...
  |                                                                                                    ^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmplhkvPR/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut response = reqwest :: get (url) . await ? ; let mut data = respon...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
 --> /tmp/.tmplhkvPR/main.rs:1:84
  |
1 | ... { let result = { let mut response = reqwest :: get (url) . await ? ; let mut data = response . json () . await ? } ; if let Some (s) ...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
  |
  = help: you might be missing a crate named `reqwest`

error: aborting due to 3 previous errors; 1 warning emitted

Some errors have detailed explanations: E0425, E0433.
For more information about an error, try `rustc --explain E0425`.



=== appendix-c-troubleshooting example 18 ===
✗ Compilation failed: Failed to transpile to Rust


=== appendix-c-troubleshooting example 19 ===
✗ Compilation failed: Failed to transpile to Rust


=== appendix-c-troubleshooting example 20 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 2 ===

thread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:
"alice@email.com" is not a valid Ident
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


=== ch05-00-data-processing example 3 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpTpKV4W/main.rs:1:451
  |
1 | ...return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut ...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpTpKV4W/main.rs:1:488
  |
1 | ...t mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut ...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpTpKV4W/main.rs:1:507
  |
1 | ...rs . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers ....
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpTpKV4W/main.rs:1:544
  |
1 | ...rs . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transa...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpTpKV4W/main.rs:1:581
  |
1 | ...mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t |...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `transactions` in this scope
 --> /tmp/.tmpTpKV4W/main.rs:1:621
  |
1 | ...inimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let m...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `transactions` in this scope
 --> /tmp/.tmpTpKV4W/main.rs:1:724
  |
1 | ... > 100i32) . collect () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let ...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `transactions` in this scope
 --> /tmp/.tmpTpKV4W/main.rs:1:828
  |
1 | ...lect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }
  |                                                     ^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpTpKV4W/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpTpKV4W/main.rs:1:218
  |
1 | ... { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } } } } ...
  |       ^^                                                                                                                                                                                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }
1 + use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTpKV4W/main.rs:1:266
  |
1 | ... { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ...
  |       ^^                                                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }
1 + use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTpKV4W/main.rs:1:329
  |
1 | ...y = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return gro...
  |                                                         ^^                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }
1 + use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { groups [key] = vec ! [] } ; groups [key] . push (record) } } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }
  |

error[E0277]: `T` is not an iterator
 --> /tmp/.tmpTpKV4W/main.rs:1:256
  |
1 | ...d : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups ...
  |                                                        ^^^^^^^ `T` is not an iterator
  |
  = note: required for `T` to implement `IntoIterator`
help: consider further restricting type parameter `T` with trait `Iterator`
  |
1 | use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }
  |                                                                                                                                                                                       +++++++++++++++++++++

error[E0599]: no method named `has_key` found for unit type `()` in the current scope
 --> /tmp/.tmpTpKV4W/main.rs:1:313
  |
1 | ...s { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } ...
  |                                                       ^^^^^^^ method not found in `()`

error[E0308]: mismatched types
 --> /tmp/.tmpTpKV4W/main.rs:1:407
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } ...
  |       - expected this type parameter                                                                                                                               - expected `T` because of return type                                                                                                                                                            ^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: the caller chooses a type for `T` which can be different from `()`

error: aborting due to 11 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0425, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch05-00-data-processing example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 8 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmpmF20kx/main.rs:1:685
  |
1 | ...monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart...
  |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") + bar , " ") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = { SomeStruct { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } } ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ++++++++++++                                                                                                       +

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpmF20kx/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpmF20kx/main.rs:1:432
  |
1 | ... { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") + bar , " ") + value . to_s ()) } } } } ...
  |       ^^                                                                                                                                                                                                         ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") + bar , " ") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
1 + use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . items () { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") + bar , " ") + value . to_s ()) } } } } } } } fn main () { let mut monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
  |

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpmF20kx/main.rs:1:303
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{}" , "=" * title . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                                                                      ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (data : T , title : T) -> T { { println ! ("{}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") + bar , " ") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
  |                                                                                                                                                                                       +++++++++++++++++++

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpmF20kx/main.rs:1:289
  |
1 | ..." , "\n" , title)) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width =...
  |                                     --    ^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                                     |
  |                                     required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `values` found for type parameter `T` in the current scope
 --> /tmp/.tmpmF20kx/main.rs:1:338
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values ()...
  |       - method `values` not found for this type parameter                                                                                                                                                                                                                                      ^^^^^^ method not found in `T`

error[E0599]: no method named `items` found for type parameter `T` in the current scope
 --> /tmp/.tmpmF20kx/main.rs:1:421
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . items ()...
  |       - method `items` not found for this type parameter                                                                                                                                                                                                                                                                                                                          ^^^^^ method not found in `T`

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpmF20kx/main.rs:1:494
  |
1 | ...value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" ...
  |                                              ^^^^^^^ doesn't have a size known at compile-time
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: all local variables must have a statically known size

error[E0308]: mismatched types
 --> /tmp/.tmpmF20kx/main.rs:1:602
  |
1 | ...ormat ! ("{}{}" , format ! ("{}{}" , key , " │") + bar , " ") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = ...
  |                                                       ^^^ expected `&str`, found `str`
  |
help: consider borrowing here
  |
1 | use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") + &bar , " ") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +

error[E0308]: mismatched types
 --> /tmp/.tmpmF20kx/main.rs:1:393
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") + bar , " ") + value . to_s ()) } } } } } ...
  |       - expected this type parameter                                                                                                                            - expected `T` because of return type                                                                                                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: the caller chooses a type for `T` which can be different from `()`
  = note: `for` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = "█" * bar_width . to_i () ; println ! ("{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") + bar , " ") + value . to_s ()) } } } } /* `T` value */ } } } } fn main () { let mut monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                +++++++++++++++

error: aborting due to 8 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch05-00-data-processing example 9 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp4suJNW/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut sales_data = load_csv ("sales.csv" . to_string ()) ; let mut tota...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `load_csv` in this scope
 --> /tmp/.tmp4suJNW/main.rs:1:86
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut sales_data = load_csv ("sales.csv" . to_string ()) ; let mut tota...
  |                                                                                      ^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-data-processing example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch01-02-hello-world example 1 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmphbmHjd/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |                                                                               ^ expected `,`

error: argument never used
 --> /tmp/.tmphbmHjd/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |                                                               ---------------   ^^^^^^^^^^^^ argument never used
  |                                                               |
  |                                                               formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmphbmHjd/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmphbmHjd/main.rs:1:50
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |                                                  ^^                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
1 + use std :: collections :: HashMap ; fn main () { println ! ("Hello, World!" . to_string ()) }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmphbmHjd/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |                                                                                 ^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-02-hello-world example 5 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmp13HP0j/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |                                                                               ^ expected `,`

error: argument never used
 --> /tmp/.tmp13HP0j/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |                                                               ---------------   ^^^^^^^^^^^^ argument never used
  |                                                               |
  |                                                               formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp13HP0j/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp13HP0j/main.rs:1:50
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |                                                  ^^                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
1 + use std :: collections :: HashMap ; fn main () { println ! ("Hello, World!" . to_string ()) }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmp13HP0j/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |                                                                                 ^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-02-hello-world example 6 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpjOjXvn/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |                                                                               ^ expected `,`

error: argument never used
 --> /tmp/.tmpjOjXvn/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |                                                               ---------------   ^^^^^^^^^^^^ argument never used
  |                                                               |
  |                                                               formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpjOjXvn/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpjOjXvn/main.rs:1:50
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |                                                  ^^                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
1 + use std :: collections :: HashMap ; fn main () { println ! ("Hello, World!" . to_string ()) }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpjOjXvn/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |                                                                                 ^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-02-hello-world example 7 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpmsH6p5/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |                                                                               ^ expected `,`

error: argument never used
 --> /tmp/.tmpmsH6p5/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |                                                               ---------------   ^^^^^^^^^^^^ argument never used
  |                                                               |
  |                                                               formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpmsH6p5/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpmsH6p5/main.rs:1:50
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |                                                  ^^                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
1 + use std :: collections :: HashMap ; fn main () { println ! ("Hello, World!" . to_string ()) }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpmsH6p5/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |                                                                                 ^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-02-hello-world example 8 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpa1XT8J/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |                                                                               ^ expected `,`

error: argument never used
 --> /tmp/.tmpa1XT8J/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |                                                               ---------------   ^^^^^^^^^^^^ argument never used
  |                                                               |
  |                                                               formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpa1XT8J/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpa1XT8J/main.rs:1:50
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |                                                  ^^                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
1 + use std :: collections :: HashMap ; fn main () { println ! ("Hello, World!" . to_string ()) }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpa1XT8J/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |                                                                                 ^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch02-00-variables-types example 4 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpNVv5iM/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let favorite_languages = vec ! ["Python" , "Rust" , "Ruchy"] ; { let mut daily_tempe...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpNVv5iM/main.rs:1:50
  |
1 | ... { { { let favorite_languages = vec ! ["Python" , "Rust" , "Ruchy"] ; { let mut daily_temperatures = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let mut task_completed = vec ! [true , false , true , true] ; println ! ("{} {}" , "First language:" . to_string () , favorite_languages [0i32]) ; println ! ("{} {} {}" , "Today's temp:" . to_string () , daily_temperatures [0i32] , "°C" . to_string ()) ; println ! ("{} {} {}" , "I know" . to_string () , favorite_languages . len () , "languages" . to_string ()) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let favorite_languages = vec ! ["Python" , "Rust" , "Ruchy"] ; { let mut daily_temperatures = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let mut task_completed = vec ! [true , false , true , true] ; println ! ("{} {}" , "First language:" . to_string () , favorite_languages [0i32]) ; println ! ("{} {} {}" , "Today's temp:" . to_string () , daily_temperatures [0i32] , "°C" . to_string ()) ; println ! ("{} {} {}" , "I know" . to_string () , favorite_languages . len () , "languages" . to_string ()) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let favorite_languages = vec ! ["Python" , "Rust" , "Ruchy"] ; { let mut daily_temperatures = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let mut task_completed = vec ! [true , false , true , true] ; println ! ("{} {}" , "First language:" . to_string () , favorite_languages [0i32]) ; println ! ("{} {} {}" , "Today's temp:" . to_string () , daily_temperatures [0i32] , "°C" . to_string ()) ; println ! ("{} {} {}" , "I know" . to_string () , favorite_languages . len () , "languages" . to_string ()) } } }
  |

error[E0277]: the type `[&str]` cannot be indexed by `i32`
 --> /tmp/.tmpNVv5iM/main.rs:1:332
  |
1 | .... to_string () , favorite_languages [0i32]) ; println ! ("{} {} {}" , "Today's temp:" . to_string () , daily_temperatures [0i32] , "°C...
  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`
  |
  = help: the trait `SliceIndex<[&str]>` is not implemented for `i32`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `Vec<&str>` to implement `Index<i32>`

error[E0277]: the type `[f64]` cannot be indexed by `i32`
 --> /tmp/.tmpNVv5iM/main.rs:1:418
  |
1 | .... to_string () , daily_temperatures [0i32] , "°C" . to_string ()) ; println ! ("{} {} {}" , "I know" . to_string () , favorite_languag...
  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`
  |
  = help: the trait `SliceIndex<[f64]>` is not implemented for `i32`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `Vec<f64>` to implement `Index<i32>`

error: aborting due to 2 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0277`.



=== ch02-00-variables-types example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `user_name` in this scope
 --> /tmp/.tmpVQcVC5/main.rs:1:52
  |
1 | use std :: collections :: HashMap ; fn main () { { user_name = "Alice" } }
  |                                                    ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpVQcVC5/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { user_name = "Alice" } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpVQcVC5/main.rs:1:50
  |
1 | use std :: collections :: HashMap ; fn main () { { user_name = "Alice" } }
  |                                                  ^^                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { user_name = "Alice" } }
1 + use std :: collections :: HashMap ; fn main () { user_name = "Alice" }
  |

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch02-00-variables-types example 6 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpvWmajy/main.rs:1:102
  |
1 | use std :: collections :: HashMap ; fn main () { { { let age = "25" ; let mut next_year = age + 1i32 } } }
  |                                                                                                      ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpvWmajy/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let age = "25" ; let mut next_year = age + 1i32 } } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpvWmajy/main.rs:1:50
  |
1 | use std :: collections :: HashMap ; fn main () { { { let age = "25" ; let mut next_year = age + 1i32 } } }
  |                                                  ^^                                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let age = "25" ; let mut next_year = age + 1i32 } } }
1 + use std :: collections :: HashMap ; fn main () { { let age = "25" ; let mut next_year = age + 1i32 } }
  |

error: aborting due to 1 previous error; 2 warnings emitted




=== ch06-00-data-structures-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpZlrp0a/main.rs:1:153
  |
1 | ..."Alice" ; let mut greeting = "Welcome" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpZlrp0a/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut message = "Hello World" ; let mut name = "Alice" ; let mut greeti...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch06-00-data-structures-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmp76xuV8/main.rs:1:136
  |
1 | ... number = 100i32 ; let mut flag = true } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp76xuV8/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut text = "Count" ; let mut number = 100i32 ; let mut flag = true } ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch06-00-data-structures-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpeA2ZAg/main.rs:1:145
  |
1 | ...t_name = "Doe" ; let mut title = "Mr." } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpeA2ZAg/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut first_name = "John" ; let mut last_name = "Doe" ; let mut title =...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch06-00-data-structures-tdd example 7 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpmLyYyf/main.rs:1:149
  |
1 | ... = 72i32 ; let mut unit = "Fahrenheit" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpmLyYyf/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut label = "Temperature" ; let mut value = 72i32 ; let mut unit = "F...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch06-00-data-structures-tdd example 8 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmp1sQ5pQ/main.rs:1:141
  |
1 | ...version = "1.0" ; let mut debug = true } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp1sQ5pQ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { let mut app_name = "MyApp" ; let mut version = "1.0" ; let mut debug = tr...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch03-00-functions example 1 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpVrgG3w/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let name = "Alice" ; { let mut a = 15i32 ; let mut b = 27i32 ; let mut greeting = fo...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpVrgG3w/main.rs:1:50
  |
1 | ... { { { let name = "Alice" ; { let mut a = 15i32 ; let mut b = 27i32 ; let mut greeting = format ! ("{}{}" , format ! ("{}{}" , "Hello, " , name) , "! Welcome to Ruchy!") ; let mut sum = a + b ; let mut result_message = format ! ("{}{}" , format ! ("{}{}" , a , " + ") + b , " = ") + sum ; println ! ("{}" , greeting) ; println ! ("{}" , result_message) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let name = "Alice" ; { let mut a = 15i32 ; let mut b = 27i32 ; let mut greeting = format ! ("{}{}" , format ! ("{}{}" , "Hello, " , name) , "! Welcome to Ruchy!") ; let mut sum = a + b ; let mut result_message = format ! ("{}{}" , format ! ("{}{}" , a , " + ") + b , " = ") + sum ; println ! ("{}" , greeting) ; println ! ("{}" , result_message) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let name = "Alice" ; { let mut a = 15i32 ; let mut b = 27i32 ; let mut greeting = format ! ("{}{}" , format ! ("{}{}" , "Hello, " , name) , "! Welcome to Ruchy!") ; let mut sum = a + b ; let mut result_message = format ! ("{}{}" , format ! ("{}{}" , a , " + ") + b , " = ") + sum ; println ! ("{}" , greeting) ; println ! ("{}" , result_message) } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpVrgG3w/main.rs:1:317
  |
1 | ... format ! ("{}{}" , format ! ("{}{}" , a , " + ") + b , " = ") + sum ; println ! ("{}" , greeting) ; println ! ("{}" , result_message)...
  |                                                        ^ expected `&str`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpVrgG3w/main.rs:1:330
  |
1 | ...{}" , format ! ("{}{}" , a , " + ") + b , " = ") + sum ; println ! ("{}" , greeting) ; println ! ("{}" , result_message) } } } }
  |                                                       ^^^ expected `&str`, found `i32`

error: aborting due to 2 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 2 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpbxsOJx/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let input1 = 10i32 ; { let mut input2 = 20i32 ; let mut sum = input1 + input2 ; let ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpbxsOJx/main.rs:1:50
  |
1 | ... { { { let input1 = 10i32 ; { let mut input2 = 20i32 ; let mut sum = input1 + input2 ; let mut product = input1 * input2 ; let mut average = sum / 2i32 ; let mut result = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Sum: " , sum) , ", Product: ") + product , ", Average: ") + average ; println ! ("{}" , result) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let input1 = 10i32 ; { let mut input2 = 20i32 ; let mut sum = input1 + input2 ; let mut product = input1 * input2 ; let mut average = sum / 2i32 ; let mut result = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Sum: " , sum) , ", Product: ") + product , ", Average: ") + average ; println ! ("{}" , result) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let input1 = 10i32 ; { let mut input2 = 20i32 ; let mut sum = input1 + input2 ; let mut product = input1 * input2 ; let mut average = sum / 2i32 ; let mut result = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Sum: " , sum) , ", Product: ") + product , ", Average: ") + average ; println ! ("{}" , result) } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpbxsOJx/main.rs:1:309
  |
1 | ...at ! ("{}{}" , "Sum: " , sum) , ", Product: ") + product , ", Average: ") + average ; println ! ("{}" , result) } } } }
  |                                                     ^^^^^^^ expected `&str`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpbxsOJx/main.rs:1:336
  |
1 | ...m) , ", Product: ") + product , ", Average: ") + average ; println ! ("{}" , result) } } } }
  |                                                     ^^^^^^^ expected `&str`, found `i32`

error: aborting due to 2 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 3 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp5CDMGl/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let user_name = "Alice" ; { let mut greeting_template = format ! ("{}{}" , format ! ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp5CDMGl/main.rs:1:50
  |
1 | ... { { { let user_name = "Alice" ; { let mut greeting_template = format ! ("{}{}" , format ! ("{}{}" , "Hello, " , user_name) , "! Welcome!") ; let mut num1 = 15i32 ; let mut num2 = 27i32 ; let mut operation = "addition" ; let mut calc_result = num1 + num2 ; let mut calc_display = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , operation , ": ") + num1 , " + ") + num2 , " = ") + calc_result ; println ! ("{}" , greeting_template) ; println ! ("{}" , calc_display) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let user_name = "Alice" ; { let mut greeting_template = format ! ("{}{}" , format ! ("{}{}" , "Hello, " , user_name) , "! Welcome!") ; let mut num1 = 15i32 ; let mut num2 = 27i32 ; let mut operation = "addition" ; let mut calc_result = num1 + num2 ; let mut calc_display = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , operation , ": ") + num1 , " + ") + num2 , " = ") + calc_result ; println ! ("{}" , greeting_template) ; println ! ("{}" , calc_display) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let user_name = "Alice" ; { let mut greeting_template = format ! ("{}{}" , format ! ("{}{}" , "Hello, " , user_name) , "! Welcome!") ; let mut num1 = 15i32 ; let mut num2 = 27i32 ; let mut operation = "addition" ; let mut calc_result = num1 + num2 ; let mut calc_display = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , operation , ": ") + num1 , " + ") + num2 , " = ") + calc_result ; println ! ("{}" , greeting_template) ; println ! ("{}" , calc_display) } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp5CDMGl/main.rs:1:404
  |
1 | ... ("{}{}" , format ! ("{}{}" , operation , ": ") + num1 , " + ") + num2 , " = ") + calc_result ; println ! ("{}" , greeting_template) ;...
  |                                                      ^^^^ expected `&str`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmp5CDMGl/main.rs:1:420
  |
1 | ...t ! ("{}{}" , operation , ": ") + num1 , " + ") + num2 , " = ") + calc_result ; println ! ("{}" , greeting_template) ; println ! ("{}"...
  |                                                      ^^^^ expected `&str`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmp5CDMGl/main.rs:1:436
  |
1 | ...tion , ": ") + num1 , " + ") + num2 , " = ") + calc_result ; println ! ("{}" , greeting_template) ; println ! ("{}" , calc_display) } ...
  |                                                   ^^^^^^^^^^^ expected `&str`, found `i32`

error: aborting due to 3 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 4 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpXOxC2b/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = "San Francisco" ; let mut temp...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpXOxC2b/main.rs:1:50
  |
1 | ... { { { let temperature_f = 68i32 ; { let mut user_location = "San Francisco" ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Weather in " , user_location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{}" , weather_report) ; println ! ("{}" , comfort_message) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = "San Francisco" ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Weather in " , user_location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{}" , weather_report) ; println ! ("{}" , comfort_message) } } } }
1 + use std :: collections :: HashMap ; fn main () { { let temperature_f = 68i32 ; { let mut user_location = "San Francisco" ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Weather in " , user_location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{}" , weather_report) ; println ! ("{}" , comfort_message) } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXOxC2b/main.rs:1:501
  |
1 | ... "°C)") ; let mut comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{}" , ...
  |                                                            ^^                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = "San Francisco" ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Weather in " , user_location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{}" , weather_report) ; println ! ("{}" , comfort_message) } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = "San Francisco" ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Weather in " , user_location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfortable { "Perfect weather!" } else { { "Dress accordingly" } } ; println ! ("{}" , weather_report) ; println ! ("{}" , comfort_message) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXOxC2b/main.rs:1:533
  |
1 | ... = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{}" , weather_report) ; println ! ("{}"...
  |                                                           ^^                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = "San Francisco" ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Weather in " , user_location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{}" , weather_report) ; println ! ("{}" , comfort_message) } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = "San Francisco" ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Weather in " , user_location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfortable { { "Perfect weather!" } } else { "Dress accordingly" } ; println ! ("{}" , weather_report) ; println ! ("{}" , comfort_message) } } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpXOxC2b/main.rs:1:404
  |
1 | ...}" , "Weather in " , user_location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfo...
  |                                                  ^^^^^^^^^^^^^ expected `&str`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpXOxC2b/main.rs:1:430
  |
1 | ...location) , ": ") + temperature_f , "°F (") + temperature_c , "°C)") ; let mut comfort_message = if is_comfortable { { "Perfect weathe...
  |                                                  ^^^^^^^^^^^^^ expected `&str`, found `i32`

error: aborting due to 2 previous errors; 4 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 5 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpkH0a0e/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: D...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpkH0a0e/main.rs:1:192
  |
1 | ...fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std ...
  |                                                                  ^^     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("{} {}" , "Circle area:" . to_string () , area) ; println ! ("{} {}" , "Username:" . to_string () , username) ; println ! ("{}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { x * x } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("{} {}" , "Circle area:" . to_string () , area) ; println ! ("{} {}" , "Username:" . to_string () , username) ; println ! ("{}" , excited) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpkH0a0e/main.rs:1:369
  |
1 | ...mt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Ad...
  |                                              ^^                                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("{} {}" , "Circle area:" . to_string () , area) ; println ! ("{} {}" , "Username:" . to_string () , username) ; println ! ("{}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { let pi = 3.14159f64 ; pi * square (radius) } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("{} {}" , "Circle area:" . to_string () , area) ; println ! ("{} {}" , "Username:" . to_string () , username) ; println ! ("{}" , excited) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpkH0a0e/main.rs:1:609
  |
1 | ... (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Out...
  |                                             ^^                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("{} {}" , "Circle area:" . to_string () , area) ; println ! ("{} {}" , "Username:" . to_string () , username) ; println ! ("{}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { format ! ("{}{}" , first_name , "_") + last_name } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("{} {}" , "Circle area:" . to_string () , area) ; println ! ("{} {}" , "Username:" . to_string () , username) ; println ! ("{}" , excited) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpkH0a0e/main.rs:1:824
  |
1 | ...:: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32...
  |                                                   ^^                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("{} {}" , "Circle area:" . to_string () , area) ; println ! ("{} {}" , "Username:" . to_string () , username) ; println ! ("{}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { format ! ("{}{}" , message , "!!!") } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("{} {}" , "Circle area:" . to_string () , area) ; println ! ("{} {}" , "Username:" . to_string () , username) ; println ! ("{}" , excited) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpkH0a0e/main.rs:1:879
  |
1 | ... { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("{} {}" , "Circle area:" . to_string () , area) ; println ! ("{} {}" , "Username:" . to_string () , username) ; println ! ("{}" , excited) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("{} {}" , "Circle area:" . to_string () , area) ; println ! ("{} {}" , "Username:" . to_string () , username) ; println ! ("{}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("{} {}" , "Circle area:" . to_string () , area) ; println ! ("{} {}" , "Username:" . to_string () , username) ; println ! ("{}" , excited) } } }
  |

error[E0277]: cannot multiply `f64` by `T`
 --> /tmp/.tmpkH0a0e/main.rs:1:398
  |
1 | ... (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + st...
  |                                                      ^ no implementation for `f64 * T`
  |
  = help: the trait `Mul<T>` is not implemented for `f64`
help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement
  |
1 | use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T where f64: Mul<T> { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("{} {}" , "Circle area:" . to_string () , area) ; println ! ("{} {}" , "Username:" . to_string () , username) ; println ! ("{}" , excited) } } } }
  |                                                                                                                                                                                                                                                                                                                                                                               +++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpkH0a0e/main.rs:1:650
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } ...
  |       - found this type parameter                                                                                                                                                                                      ^^^^^^^^^ expected `&str`, found type parameter `T`
  |
  = note:   expected reference `&str`
          found type parameter `T`

error[E0308]: mismatched types
 --> /tmp/.tmpkH0a0e/main.rs:1:611
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } ...
  |       -                                                                                                                                                                   -     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `String`
  |       |                                                                                                                                                                   |
  |       expected this type parameter                                                                                                                                        expected `T` because of return type
  |
  = note: expected type parameter `T`
                     found struct `String`
  = note: the caller chooses a type for `T` which can be different from `String`

error[E0308]: mismatched types
 --> /tmp/.tmpkH0a0e/main.rs:1:826
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } ...
  |       -                                                                                                                                                -     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `String`
  |       |                                                                                                                                                |
  |       expected this type parameter                                                                                                                     expected `T` because of return type
  |
  = note: expected type parameter `T`
                     found struct `String`
  = note: the caller chooses a type for `T` which can be different from `String`
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: cannot add `String` to `String`
 --> /tmp/.tmpkH0a0e/main.rs:1:936
  |
1 | ...rcle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("...
  |                                            ^^^^^^^^^^^^^ no implementation for `String + String`
  |
  = help: the trait `Add<String>` is not implemented for `String`
          but trait `Add<&str>` is implemented for it
  = help: for that trait implementation, expected `&str`, found `String`
note: required by a bound in `make_username`
 --> /tmp/.tmpkH0a0e/main.rs:1:445
  |
1 | ... } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `make_username`

error[E0277]: cannot multiply `String` by `String`
 --> /tmp/.tmpkH0a0e/main.rs:1:936
  |
1 | ...rcle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("...
  |                                            ^^^^^^^^^^^^^ no implementation for `String * String`
  |
  = help: the trait `Mul` is not implemented for `String`
note: required by a bound in `make_username`
 --> /tmp/.tmpkH0a0e/main.rs:1:480
  |
1 | ...: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `make_username`

error[E0277]: cannot add `String` to `String`
 --> /tmp/.tmpkH0a0e/main.rs:1:1029
  |
1 | ...ng ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("{} {}" , "Circle area:" . to_string () , area) ; pr...
  |                               -----  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String + String`
  |                               |
  |                               required by a bound introduced by this call
  |
  = help: the trait `Add<String>` is not implemented for `String`
          but trait `Add<&str>` is implemented for it
  = help: for that trait implementation, expected `&str`, found `String`
note: required by a bound in `shout`
 --> /tmp/.tmpkH0a0e/main.rs:1:679
  |
1 | ...") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std ::...
  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `shout`

error[E0277]: cannot multiply `String` by `String`
 --> /tmp/.tmpkH0a0e/main.rs:1:1029
  |
1 | ...ng ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("{} {}" , "Circle area:" . to_string () , area) ; pr...
  |                               -----  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String * String`
  |                               |
  |                               required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `String`
note: required by a bound in `shout`
 --> /tmp/.tmpkH0a0e/main.rs:1:714
  |
1 | ...td :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : ...
  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `shout`

error[E0382]: use of moved value: `x`
   --> /tmp/.tmpkH0a0e/main.rs:1:198
    |
1   | ...: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output...
    |                              -               ----^
    |                              |               |   |
    |                              |               |   value used here after move
    |                              |               `x` moved due to usage in operator
    |                              move occurs because `x` has type `T`, which does not implement the `Copy` trait
    |
note: calling this operator moves the left-hand side
   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/arith.rs:333:12
    |
333 |     fn mul(self, rhs: Rhs) -> Self::Output;
    |            ^^^^
help: consider cloning the value if the performance cost is acceptable
    |
1   | use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x.clone() * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("{} {}" , "Circle area:" . to_string () , area) ; println ! ("{} {}" , "Username:" . to_string () , username) ; println ! ("{}" , excited) } } } }
    |                                                                                                                                                                                                   ++++++++
help: consider further restricting type parameter `T` with trait `Copy`
    |
1   | use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + Copy > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! ("{}{}" , first_name , "_") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; let mut excited = shout ("I love functions" . to_string ()) ; println ! ("{} {}" , "Circle area:" . to_string () , area) ; println ! ("{} {}" , "Username:" . to_string () , username) ; println ! ("{}" , excited) } } } }
    |                                                                                                                                                                               ++++++

error: aborting due to 9 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0382.
For more information about an error, try `rustc --explain E0277`.



=== ch03-00-functions example 6 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpWGC9HN/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpWGC9HN/main.rs:1:198
  |
1 | ...y + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T...
  |                                                          ^^                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { number % 2i32 == 0i32 } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpWGC9HN/main.rs:1:391
  |
1 | ... { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } ...
  |       ^^                                                                                                                                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpWGC9HN/main.rs:1:413
  |
1 | ...mt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { "A" } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpWGC9HN/main.rs:1:450
  |
1 | ...T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { "B" } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpWGC9HN/main.rs:1:487
  |
1 | ...lse { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } }...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { "C" } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpWGC9HN/main.rs:1:524
  |
1 | ...lse { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: op...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { "D" } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpWGC9HN/main.rs:1:541
  |
1 | ... 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { "F" } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpWGC9HN/main.rs:1:725
  |
1 | ... { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } ...
  |       ^^                                                                                                                                                                                                                                                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpWGC9HN/main.rs:1:761
  |
1 | ... + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "la...
  |                                                                  ^^      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { "even" } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpWGC9HN/main.rs:1:781
  |
1 | ...> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "s...
  |                                                                  ^^     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { "odd" } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpWGC9HN/main.rs:1:828
  |
1 | ...n" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" ...
  |                                                                 ^^       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { "large" } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpWGC9HN/main.rs:1:849
  |
1 | ... } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , ...
  |                                                                 ^^       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { "small" } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

error[E0369]: cannot calculate the remainder of `T` divided by `i32`
 --> /tmp/.tmpWGC9HN/main.rs:1:207
  |
1 | ...lay + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output =...
  |                                                              ------ ^ ---- i32
  |                                                              |
  |                                                              T
  |
help: consider further restricting type parameter `T` with trait `Rem`
  |
1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Rem<i32> > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |                                                                                                                                                                                ++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpWGC9HN/main.rs:1:200
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } ...
  |       -                                                                                                                                               -     ^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `bool`
  |       |                                                                                                                                               |
  |       expected this type parameter                                                                                                                    expected `T` because of return type
  |
  = note: expected type parameter `T`
                       found type `bool`
  = note: the caller chooses a type for `T` which can be different from `bool`

error[E0369]: binary operation `>=` cannot be applied to type `T`
 --> /tmp/.tmpWGC9HN/main.rs:1:402
  |
1 | ...y + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if sc...
  |                                                              ----- ^^ ----- i32
  |                                                              |
  |                                                              T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                  +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpWGC9HN/main.rs:1:415
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } ...
  |       -                                                                                                                                              -                           ^^^ expected type parameter `T`, found `&str`
  |       |                                                                                                                                              |
  |       expected this type parameter                                                                                                                   expected `T` because of return type
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0369]: binary operation `>=` cannot be applied to type `T`
 --> /tmp/.tmpWGC9HN/main.rs:1:439
  |
1 | ...ore : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if sc...
  |                                                              ----- ^^ ----- i32
  |                                                              |
  |                                                              T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                  +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpWGC9HN/main.rs:1:452
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } ...
  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                            ^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0369]: binary operation `>=` cannot be applied to type `T`
 --> /tmp/.tmpWGC9HN/main.rs:1:476
  |
1 | ... { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F"...
  |                                                              ----- ^^ ----- i32
  |                                                              |
  |                                                              T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                  +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpWGC9HN/main.rs:1:489
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } ...
  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                                                                 ^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0369]: binary operation `>=` cannot be applied to type `T`
 --> /tmp/.tmpWGC9HN/main.rs:1:513
  |
1 | ... { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T...
  |                                                              ----- ^^ ----- i32
  |                                                              |
  |                                                              T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                  +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpWGC9HN/main.rs:1:526
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } ...
  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                                                                                                      ^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0308]: mismatched types
 --> /tmp/.tmpWGC9HN/main.rs:1:543
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } ...
  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                                                                                                                       ^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0308]: mismatched types
 --> /tmp/.tmpWGC9HN/main.rs:1:756
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) {...
  |       -                                                                                                                                                                    -------  ^ expected `bool`, found type parameter `T`
  |       |                                                                                                                                                                    |
  |       found this type parameter                                                                                                                                            arguments to this function are incorrect
  |
  = note:        expected type `bool`
          found type parameter `T`
help: the return type of this call is `T` due to the type of the argument passed
 --> /tmp/.tmpWGC9HN/main.rs:1:747
  |
1 | ... : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else...
  |                                       ^^^^^^^^^-^
  |                                                |
  |                                                this argument influences the return type of `is_even`
note: function defined here
 --> /tmp/.tmpWGC9HN/main.rs:1:40
  |
1 | ...fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -...
  |       ^^^^^^^                                                                                                                                    ----------

error[E0277]: cannot add `bool` to `bool`
 --> /tmp/.tmpWGC9HN/main.rs:1:756
  |
1 | ...e > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } ...
  |                                             -------  ^ no implementation for `bool + bool`
  |                                             |
  |                                             required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `bool`
note: required by a bound in `is_even`
 --> /tmp/.tmpWGC9HN/main.rs:1:54
  |
1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: ...
  |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_even`

error[E0277]: cannot multiply `bool` by `bool`
 --> /tmp/.tmpWGC9HN/main.rs:1:756
  |
1 | ...e > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } ...
  |                                             -------  ^ no implementation for `bool * bool`
  |                                             |
  |                                             required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `bool`
note: required by a bound in `is_even`
 --> /tmp/.tmpWGC9HN/main.rs:1:89
  |
1 | ...d :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T)...
  |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_even`

error[E0369]: binary operation `>` cannot be applied to type `T`
 --> /tmp/.tmpWGC9HN/main.rs:1:817
  |
1 | ...(n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , forma...
  |                                                                - ^ ------ i32
  |                                                                |
  |                                                                T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpWGC9HN/main.rs:1:865
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let mut size = if n > 100i32 { { "large" } } else { { "small" } } ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") + size , " ") + even_odd , " number") } ...
  |       - expected this type parameter                                                                                                             - expected `T` because of return type                                                                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `String`
  |
  = note: expected type parameter `T`
                     found struct `String`
  = note: the caller chooses a type for `T` which can be different from `String`
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 16 previous errors; 13 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0369.
For more information about an error, try `rustc --explain E0277`.



=== ch03-00-functions example 7 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpi3fHcZ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std ::...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpi3fHcZ/main.rs:1:615
  |
1 | ...e i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T ...
  |                                                          ^^                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" ; println ! ("{} {}" , "Total cost: $" . to_string () , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" . to_string () , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" . to_string () , count_words (essay)) } } } }
1 + use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { max_val = numbers [i] } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" ; println ! ("{} {}" , "Total cost: $" . to_string () , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" . to_string () , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" . to_string () , count_words (essay)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpi3fHcZ/main.rs:1:839
  |
1 | ...t :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = ...
  |                                           ^^                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" ; println ! ("{} {}" , "Total cost: $" . to_string () , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" . to_string () , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" . to_string () , count_words (essay)) } } } }
1 + use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { let words = text . split (" ") ; words . len () } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" ; println ! ("{} {}" , "Total cost: $" . to_string () , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" . to_string () , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" . to_string () , count_words (essay)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpi3fHcZ/main.rs:1:910
  |
1 | ... { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" ; println ! ("{} {}" , "Total cost: $" . to_string () , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" . to_string () , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" . to_string () , count_words (essay)) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" ; println ! ("{} {}" , "Total cost: $" . to_string () , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" . to_string () , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" . to_string () , count_words (essay)) } } } }
1 + use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" ; println ! ("{} {}" , "Total cost: $" . to_string () , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" . to_string () , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" . to_string () , count_words (essay)) } } }
  |

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpi3fHcZ/main.rs:1:269
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                                   ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" ; println ! ("{} {}" , "Total cost: $" . to_string () , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" . to_string () , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" . to_string () , count_words (essay)) } } } }
  |                                                                                                                                                                                        +++++++++++++++++++

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpi3fHcZ/main.rs:1:303
  |
1 | ... i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Ad...
  |                                                                     ^^^

error[E0308]: mismatched types
 --> /tmp/.tmpi3fHcZ/main.rs:1:328
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } ...
  |       - expected this type parameter                                                                                                                  - expected `T` because of return type                                                                                         ^^^^^ expected type parameter `T`, found `f64`
  |
  = note: expected type parameter `T`
                       found type `f64`
  = note: the caller chooses a type for `T` which can be different from `f64`

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpi3fHcZ/main.rs:1:529
  |
1 | ...ebug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers ...
  |                                                                    ^^^^^^

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpi3fHcZ/main.rs:1:577
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                                                 ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" ; println ! ("{} {}" , "Total cost: $" . to_string () , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" . to_string () , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" . to_string () , count_words (essay)) } } } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              +++++++++++++++++++

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpi3fHcZ/main.rs:1:599
  |
1 | ...] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_...
  |                                                                     ^^^

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpi3fHcZ/main.rs:1:635
  |
1 | ...bers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ...
  |                                                                     ^^^

error[E0599]: no method named `split` found for type parameter `T` in the current scope
 --> /tmp/.tmpi3fHcZ/main.rs:1:862
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split ("...
  |       - method `split` not found for this type parameter                                                                                                                       ^^^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `split`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + BufRead > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = "Functions make code reusable and testable" ; println ! ("{} {}" , "Total cost: $" . to_string () , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" . to_string () , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" . to_string () , count_words (essay)) } } } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   +++++++++

error[E0277]: cannot add `Vec<f64>` to `Vec<f64>`
 --> /tmp/.tmpi3fHcZ/main.rs:1:1185
  |
1 | ...tal cost: $" . to_string () , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" . to_string () , find_max (test...
  |                                  ---------------  ^^^^^^^^^^^^^ no implementation for `Vec<f64> + Vec<f64>`
  |                                  |
  |                                  required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `Vec<f64>`
note: required by a bound in `calculate_total`
 --> /tmp/.tmpi3fHcZ/main.rs:1:62
  |
1 | ...p ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt ...
  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `calculate_total`

error[E0277]: cannot multiply `Vec<f64>` by `Vec<f64>`
 --> /tmp/.tmpi3fHcZ/main.rs:1:1185
  |
1 | ...tal cost: $" . to_string () , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" . to_string () , find_max (test...
  |                                  ---------------  ^^^^^^^^^^^^^ no implementation for `Vec<f64> * Vec<f64>`
  |                                  |
  |                                  required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `Vec<f64>`
note: required by a bound in `calculate_total`
 --> /tmp/.tmpi3fHcZ/main.rs:1:97
  |
1 | ... ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> ...
  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `calculate_total`

error[E0277]: `Vec<f64>` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpi3fHcZ/main.rs:1:1185
  |
1 | ...$" . to_string () , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" . to_string () , find_max (test_scores)) ...
  |                        ---------------  ^^^^^^^^^^^^^ the trait `std::fmt::Display` is not implemented for `Vec<f64>`
  |                        |
  |                        required by a bound introduced by this call
  |
note: required by a bound in `calculate_total`
 --> /tmp/.tmpi3fHcZ/main.rs:1:132
  |
1 | ...td :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; l...
  |                                      ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `calculate_total`

error[E0277]: `Vec<f64>` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpi3fHcZ/main.rs:1:1168
  |
1 | ...{} {}" , "Total cost: $" . to_string () , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" . to_string () , fi...
  |       --                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `Vec<f64>` cannot be formatted with the default formatter
  |       |
  |       required by this formatting parameter
  |
  = help: the trait `std::fmt::Display` is not implemented for `Vec<f64>`
  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: cannot add `Vec<i32>` to `Vec<i32>`
 --> /tmp/.tmpi3fHcZ/main.rs:1:1268
  |
1 | ..."Highest score:" . to_string () , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" . to_string () , count_words (essay)) }...
  |                                      --------  ^^^^^^^^^^^ no implementation for `Vec<i32> + Vec<i32>`
  |                                      |
  |                                      required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `Vec<i32>`
note: required by a bound in `find_max`
 --> /tmp/.tmpi3fHcZ/main.rs:1:356
  |
1 | ...} ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: f...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`

error[E0277]: cannot multiply `Vec<i32>` by `Vec<i32>`
 --> /tmp/.tmpi3fHcZ/main.rs:1:1268
  |
1 | ..."Highest score:" . to_string () , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" . to_string () , count_words (essay)) }...
  |                                      --------  ^^^^^^^^^^^ no implementation for `Vec<i32> * Vec<i32>`
  |                                      |
  |                                      required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `Vec<i32>`
note: required by a bound in `find_max`
 --> /tmp/.tmpi3fHcZ/main.rs:1:391
  |
1 | ... :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T)...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`

error[E0277]: `Vec<i32>` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpi3fHcZ/main.rs:1:1268
  |
1 | ...core:" . to_string () , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" . to_string () , count_words (essay)) } } } }
  |                            --------  ^^^^^^^^^^^ the trait `std::fmt::Display` is not implemented for `Vec<i32>`
  |                            |
  |                            required by a bound introduced by this call
  |
note: required by a bound in `find_max`
 --> /tmp/.tmpi3fHcZ/main.rs:1:426
  |
1 | ... + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = n...
  |                                          ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`

error[E0277]: `Vec<i32>` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpi3fHcZ/main.rs:1:1258
  |
1 | ...! ("{} {}" , "Highest score:" . to_string () , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" . to_string () , count_wor...
  |           --                                      ^^^^^^^^^^^^^^^^^^^^^^ `Vec<i32>` cannot be formatted with the default formatter
  |           |
  |           required by this formatting parameter
  |
  = help: the trait `std::fmt::Display` is not implemented for `Vec<i32>`
  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: cannot add `&str` to `&str`
 --> /tmp/.tmpi3fHcZ/main.rs:1:1349
  |
1 | ...} {}" , "Word count:" . to_string () , count_words (essay)) } } } }
  |                                           -----------  ^^^^^ no implementation for `&str + &str`
  |                                           |
  |                                           required by a bound introduced by this call
  |
  = help: the trait `Add<&str>` is not implemented for `&str`
          but it is implemented for `String`
  = help: for that trait implementation, expected `String`, found `&str`
note: required by a bound in `count_words`
 --> /tmp/.tmpi3fHcZ/main.rs:1:697
  |
1 | ...x_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fm...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `count_words`

error[E0277]: cannot multiply `&str` by `&str`
 --> /tmp/.tmpi3fHcZ/main.rs:1:1349
  |
1 | ...} {}" , "Word count:" . to_string () , count_words (essay)) } } } }
  |                                           -----------  ^^^^^ no implementation for `&str * &str`
  |                                           |
  |                                           required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `&str`
note: required by a bound in `count_words`
 --> /tmp/.tmpi3fHcZ/main.rs:1:732
  |
1 | ...:: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> ...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `count_words`

error: aborting due to 18 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0599, E0608.
For more information about an error, try `rustc --explain E0277`.



=== ch03-00-functions example 9 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpJykFf3/main.rs:1:374
  |
1 | ...t msg = greet ("Alice" . to_string ()) } }
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpJykFf3/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn greet < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Di...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpJykFf3/main.rs:1:204
  |
1 | ... T) -> T { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") + age , " years old") } } fn main (...
  |               ^^                                                                                                           ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn greet < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , age : T) -> T { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") + age , " years old") } } fn main () { { let msg = greet ("Alice" . to_string ()) } }
1 + use std :: collections :: HashMap ; fn greet < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , age : T) -> T { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") + age , " years old") } fn main () { { let msg = greet ("Alice" . to_string ()) } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpJykFf3/main.rs:1:294
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , age : T) -> T { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") + age , ...
  |       - found this type parameter                                                                                                                                                                                                                           ^^^ expected `&str`, found type parameter `T`
  |
  = note:   expected reference `&str`
          found type parameter `T`

error[E0308]: mismatched types
 --> /tmp/.tmpJykFf3/main.rs:1:206
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , age : T) -> T { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") + age , " years old") } ...
  |       -                                                                                                                                                       -     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `String`
  |       |                                                                                                                                                       |
  |       expected this type parameter                                                                                                                            expected `T` because of return type
  |
  = note: expected type parameter `T`
                     found struct `String`
  = note: the caller chooses a type for `T` which can be different from `String`
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 3 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 10 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpfuU0nL/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn bad_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fm...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpfuU0nL/main.rs:1:383
  |
1 | ... + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; result } } } fn main () { { println ! ("{}" , good_functio...
  |                                                    ^^                                  ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn bad_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; x } } fn good_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; result } } } fn main () { { println ! ("{}" , good_function (5i32)) } }
1 + use std :: collections :: HashMap ; fn bad_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; x } } fn good_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { let result = x + 1i32 ; result } } fn main () { { println ! ("{}" , good_function (5i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpfuU0nL/main.rs:1:437
  |
1 | ...esult = x + 1i32 ; result } } } fn main () { { println ! ("{}" , good_function (5i32)) } }
  |                                                 ^^                                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn bad_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; x } } fn good_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; result } } } fn main () { { println ! ("{}" , good_function (5i32)) } }
1 + use std :: collections :: HashMap ; fn bad_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; x } } fn good_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; result } } } fn main () { println ! ("{}" , good_function (5i32)) }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpfuU0nL/main.rs:1:208
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; ...
  |       -                                                                                                                                                    -   ^^^^ expected type parameter `T`, found `i32`
  |       |                                                                                                                                                    |
  |       expected this type parameter                                                                                                                         expected because this is `T`
  |
  = note: expected type parameter `T`
                       found type `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpfuU0nL/main.rs:1:404
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; ...
  |       -                                                                                                                                                               -   ^^^^ expected type parameter `T`, found `i32`
  |       |                                                                                                                                                               |
  |       expected this type parameter                                                                                                                                    expected because this is `T`
  |
  = note: expected type parameter `T`
                       found type `i32`

error: aborting due to 2 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 12 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpTmUwAU/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpTmUwAU/main.rs:1:213
  |
1 | ...td :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Outpu...
  |                                                      ^^                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { celsius * 9i32 / 5i32 + 32i32 } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTmUwAU/main.rs:1:434
  |
1 | ... + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Out...
  |                                                     ^^                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { weight_kg / height_m * height_m } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTmUwAU/main.rs:1:662
  |
1 | ...discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ...
  |                                 ^^                                                                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { let discount = price * discount_percent / 100i32 ; price - discount } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTmUwAU/main.rs:1:902
  |
1 | ...t :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: A...
  |                                           ^^                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { let words = text . split (" ") ; words . len () } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTmUwAU/main.rs:1:1129
  |
1 | ... { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } ...
  |       ^^                                                                                                                                                                                                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTmUwAU/main.rs:1:1243
  |
1 | ...ile i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn r...
  |                             ^^                                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTmUwAU/main.rs:1:1547
  |
1 | ... { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } ...
  |       ^^                                                                                                                                                                                                                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTmUwAU/main.rs:1:1600
  |
1 | ...f energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time...
  |                                                      ^^                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { "Go for a run or hit the gym!" } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTmUwAU/main.rs:1:1695
  |
1 | ... if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn ...
  |                                                        ^^                         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { "Perfect time for a walk" } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTmUwAU/main.rs:1:1734
  |
1 | ...e > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to...
  |                                                       ^^                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { "Maybe just relax and read" } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpTmUwAU/main.rs:1:225
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / ...
  |       -                                                                                                                                                      -------   ^^^^ expected type parameter `T`, found `i32`
  |       |                                                                                                                                                      |
  |       expected this type parameter                                                                                                                           expected because this is `T`
  |
  = note: expected type parameter `T`
                       found type `i32`

error[E0369]: cannot divide `T` by `i32`
 --> /tmp/.tmpTmUwAU/main.rs:1:230
  |
1 | ... std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Out...
  |                                                          -------------- ^ ---- i32
  |                                                          |
  |                                                          T
  |
help: consider further restricting type parameter `T` with trait `Div`
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Div<i32> > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                              ++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpTmUwAU/main.rs:1:239
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } ...
  |       - expected this type parameter                                                                                                                                                 ^^^^^ expected type parameter `T`, found `i32`
  |
  = note: expected type parameter `T`
                       found type `i32`

error[E0369]: cannot divide `T` by `T`
 --> /tmp/.tmpTmUwAU/main.rs:1:446
  |
1 | ...Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add ...
  |                                                            --------- ^ -------- T
  |                                                            |
  |                                                            T
  |
help: consider further restricting type parameter `T` with trait `Div`
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Div > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++

error[E0369]: cannot divide `T` by `i32`
 --> /tmp/.tmpTmUwAU/main.rs:1:706
  |
1 | ...discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ...
  |                                                    ------------------------ ^ ------ i32
  |                                                    |
  |                                                    T
  |
help: consider further restricting type parameter `T` with trait `Div`
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Div<i32> > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ++++++++++++++++++++

error[E0599]: no method named `split` found for type parameter `T` in the current scope
 --> /tmp/.tmpTmUwAU/main.rs:1:925
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split ("...
  |       - method `split` not found for this type parameter                                                                                                                       ^^^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `split`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + BufRead > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  +++++++++

error[E0599]: no method named `split` found for type parameter `T` in the current scope
 --> /tmp/.tmpTmUwAU/main.rs:1:1157
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split ("...
  |       - method `split` not found for this type parameter                                                                                                                                 ^^^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `split`, perhaps you need to restrict type parameter `T` with it:
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + BufRead > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                +++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpTmUwAU/main.rs:1:1283
  |
1 | ...itials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1...
  |             -- expected due to this value                                                              ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `str`
  |
help: consider borrowing here
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = &(initials + word [0i32]) ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ++                      +

error[E0308]: mismatched types
 --> /tmp/.tmpTmUwAU/main.rs:1:1331
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } ...
  |       - expected this type parameter                                                                                                                     - expected `T` because of return type                                                                                                                                                                         ^^^^^^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&str`
  = note: the caller chooses a type for `T` which can be different from `&str`

error[E0369]: binary operation `>` cannot be applied to type `T`
 --> /tmp/.tmpTmUwAU/main.rs:1:1565
  |
1 | ... > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!...
  |                                                           ------------ ^ ---- i32
  |                                                           |
  |                                                           T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++++++++++++++

error[E0369]: binary operation `>` cannot be applied to type `T`
 --> /tmp/.tmpTmUwAU/main.rs:1:1590
  |
1 | ...vailable_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_l...
  |                                                          -------------- ^ ----- i32
  |                                                          |
  |                                                          T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpTmUwAU/main.rs:1:1602
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } ...
  |       - expected this type parameter                                                                                                                                             - expected `T` because of return type                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0369]: binary operation `>` cannot be applied to type `T`
 --> /tmp/.tmpTmUwAU/main.rs:1:1660
  |
1 | ...60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } }...
  |                                                           ------------ ^ ---- i32
  |                                                           |
  |                                                           T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++++++++++++++

error[E0369]: binary operation `>` cannot be applied to type `T`
 --> /tmp/.tmpTmUwAU/main.rs:1:1685
  |
1 | ...or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just re...
  |                                                          -------------- ^ ----- i32
  |                                                          |
  |                                                          T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpTmUwAU/main.rs:1:1697
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } ...
  |       - expected this type parameter                                                                                                                                             - expected `T` because of return type                                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0308]: mismatched types
 --> /tmp/.tmpTmUwAU/main.rs:1:1736
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } ...
  |       - expected this type parameter                                                                                                                                             - expected `T` because of return type                                                                                                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0308]: mismatched types
 --> /tmp/.tmpTmUwAU/main.rs:1:1881
  |
1 | ..."{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recomme...
  |           -------------  -----   ^^^^^^^ expected `i32`, found `f64`
  |           |              |
  |           |              expected all arguments to be this `i32` type because they need to match the type of this parameter
  |           arguments to this function are incorrect
  |
help: the return type of this call is `f64` due to the type of the argument passed
 --> /tmp/.tmpTmUwAU/main.rs:1:1858
  |
1 | ...) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ...
  |                          ^^^^^^^^^^^^^^^^^^^^^^^-------^
  |                                                 |
  |                                                 this argument influences the return type of `calculate_bmi`
note: function defined here
 --> /tmp/.tmpTmUwAU/main.rs:1:252
  |
1 | ...fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -...
  |       ^^^^^^^^^^^^^   -                                                                                                                                -------------   ------------ this parameter needs to match the `i32` type of `weight_kg`
  |                       |                                                                                                                                |
  |                       `weight_kg` and `height_m` both reference this parameter `T`                                                                     `height_m` needs to match the `i32` type of this parameter
help: change the type of the numeric literal from `f64` to `i32`
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1i32)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

error[E0277]: cannot add `String` to `String`
 --> /tmp/.tmpTmUwAU/main.rs:1:1925
  |
1 | ...64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                             ------------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String + String`
  |                             |
  |                             required by a bound introduced by this call
  |
  = help: the trait `Add<String>` is not implemented for `String`
          but trait `Add<&str>` is implemented for it
  = help: for that trait implementation, expected `&str`, found `String`
note: required by a bound in `get_initials`
 --> /tmp/.tmpTmUwAU/main.rs:1:982
  |
1 | ...) } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `get_initials`

error[E0277]: cannot multiply `String` by `String`
 --> /tmp/.tmpTmUwAU/main.rs:1:1925
  |
1 | ...64)) ; println ! ("{}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                             ------------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String * String`
  |                             |
  |                             required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `String`
note: required by a bound in `get_initials`
 --> /tmp/.tmpTmUwAU/main.rs:1:1017
  |
1 | ...: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T)...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `get_initials`

error: aborting due to 19 previous errors; 11 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0369, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch01-02-hello-world-tdd example 1 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpFKj0KY/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |                                                                               ^ expected `,`

error: argument never used
 --> /tmp/.tmpFKj0KY/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |                                                               ---------------   ^^^^^^^^^^^^ argument never used
  |                                                               |
  |                                                               formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpFKj0KY/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpFKj0KY/main.rs:1:50
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |                                                  ^^                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
1 + use std :: collections :: HashMap ; fn main () { println ! ("Hello, World!" . to_string ()) }
  |

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpFKj0KY/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello, World!" . to_string ()) } }
  |                                                                                 ^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-02-hello-world-tdd example 2 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpzACjCY/main.rs:1:72
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello," . to_string ()) ; println ! ("World!" . to_string ()) } }
  |                                                                        ^ expected `,`

error: argument never used
 --> /tmp/.tmpzACjCY/main.rs:1:74
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello," . to_string ()) ; println ! ("World!" . to_string ()) } }
  |                                                               --------   ^^^^^^^^^^^^ argument never used
  |                                                               |
  |                                                               formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpzACjCY/main.rs:1:110
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello," . to_string ()) ; println ! ("World!" . to_string ()) } }
  |                                                                                                              ^ expected `,`

error: argument never used
 --> /tmp/.tmpzACjCY/main.rs:1:112
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello," . to_string ()) ; println ! ("World!" . to_string ()) } }
  |                                                                                                     --------   ^^^^^^^^^^^^ argument never used
  |                                                                                                     |
  |                                                                                                     formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpzACjCY/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello," . to_string ()) ; println ! ("World!" . to_string ()) } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpzACjCY/main.rs:1:74
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello," . to_string ()) ; println ! ("World!" . to_string ()) } }
  |                                                                          ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpzACjCY/main.rs:1:112
  |
1 | use std :: collections :: HashMap ; fn main () { { println ! ("Hello," . to_string ()) ; println ! ("World!" . to_string ()) } }
  |                                                                                                                ^^^^^^^^^ not found in this scope

error: aborting due to 6 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-02-hello-world-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpPIPMOV/main.rs:1:94
  |
1 | use std :: collections :: HashMap ; fn main () { let result = println ! ("Your message here" . to_string ()) ; if let Some (s) = (& resul...
  |                                                                                              ^ expected `,`

error: argument never used
 --> /tmp/.tmpPIPMOV/main.rs:1:96
  |
1 | use std :: collections :: HashMap ; fn main () { let result = println ! ("Your message here" . to_string ()) ; if let Some (s) = (& resul...
  |                                                                          -------------------   ^^^^^^^^^^^^ argument never used
  |                                                                          |
  |                                                                          formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpPIPMOV/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = println ! ("Your message here" . to_string ()) ; if let Some (s) = (& resul...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpPIPMOV/main.rs:1:96
  |
1 | use std :: collections :: HashMap ; fn main () { let result = println ! ("Your message here" . to_string ()) ; if let Some (s) = (& resul...
  |                                                                                                ^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-02-hello-world-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error: expected `,`, found `.`
 --> /tmp/.tmpK5F8Za/main.rs:1:89
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("First line" . to_string ()) ; println ! ("Second line" . to_s...
  |                                                                                         ^ expected `,`

error: argument never used
 --> /tmp/.tmpK5F8Za/main.rs:1:91
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("First line" . to_string ()) ; println ! ("Second line" . to_s...
  |                                                                            ------------   ^^^^^^^^^^^^ argument never used
  |                                                                            |
  |                                                                            formatting specifier missing

error: expected `,`, found `.`
 --> /tmp/.tmpK5F8Za/main.rs:1:132
  |
1 | ... ! ("First line" . to_string ()) ; println ! ("Second line" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any...
  |                                                                ^ expected `,`

error: argument never used
 --> /tmp/.tmpK5F8Za/main.rs:1:134
  |
1 | ...("First line" . to_string ()) ; println ! ("Second line" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) ....
  |                                               -------------   ^^^^^^^^^^^^ argument never used
  |                                               |
  |                                               formatting specifier missing

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpK5F8Za/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("First line" . to_string ()) ; println ! ("Second line" . to_s...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpK5F8Za/main.rs:1:91
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { println ! ("First line" . to_string ()) ; println ! ("Second line" . to_s...
  |                                                                                           ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
 --> /tmp/.tmpK5F8Za/main.rs:1:134
  |
1 | ...ine" . to_string ()) ; println ! ("Second line" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 6 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.


