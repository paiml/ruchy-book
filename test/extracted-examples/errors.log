=== ch02-00-variables-types-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found `let` statement
 --> /tmp/.tmpRRSIIe/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let result = value1 + value2 ; ; if let Some (s) = (& result as & dyn std :...
  |                                                               ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

error[E0425]: cannot find value `value1` in this scope
 --> /tmp/.tmpRRSIIe/main.rs:1:76
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let result = value1 + value2 ; ; if let Some (s) = (& result as & dyn std :...
  |                                                                            ^^^^^^ not found in this scope

error[E0425]: cannot find value `value2` in this scope
 --> /tmp/.tmpRRSIIe/main.rs:1:85
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let result = value1 + value2 ; ; if let Some (s) = (& result as & dyn std :...
  |                                                                                     ^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpRRSIIe/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let result = value1 + value2 ; ; if let Some (s) = (& result as & dyn std :...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpRRSIIe/main.rs:1:94
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let result = value1 + value2 ; ; if let Some (s) = (& result as & dyn std :...
  |                                                                                              ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error: aborting due to 3 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch02-00-variables-types-tdd example 7 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `initial_value` in this scope
 --> /tmp/.tmpw0eAz6/main.rs:1:62
  |
1 | use std :: collections :: HashMap ; fn main () { let step1 = initial_value * factor ; ; let step2 = step1 + adjustment ; ; let final_resu...
  |                                                              ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `factor` in this scope
 --> /tmp/.tmpw0eAz6/main.rs:1:78
  |
1 | use std :: collections :: HashMap ; fn main () { let step1 = initial_value * factor ; ; let step2 = step1 + adjustment ; ; let final_resu...
  |                                                                              ^^^^^^ not found in this scope

error[E0425]: cannot find value `adjustment` in this scope
 --> /tmp/.tmpw0eAz6/main.rs:1:109
  |
1 | ... = initial_value * factor ; ; let step2 = step1 + adjustment ; ; let final_result = step2 / divisor ; ; }
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `divisor` in this scope
 --> /tmp/.tmpw0eAz6/main.rs:1:151
  |
1 | ... step1 + adjustment ; ; let final_result = step2 / divisor ; ; }
  |                                                       ^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpw0eAz6/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let step1 = initial_value * factor ; ; let step2 = step1 + adjustment ; ; let final_resu...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpw0eAz6/main.rs:1:87
  |
1 | use std :: collections :: HashMap ; fn main () { let step1 = initial_value * factor ; ; let step2 = step1 + adjustment ; ; let final_resu...
  |                                                                                       ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpw0eAz6/main.rs:1:122
  |
1 | ...value * factor ; ; let step2 = step1 + adjustment ; ; let final_result = step2 / divisor ; ; }
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpw0eAz6/main.rs:1:161
  |
1 | ...adjustment ; ; let final_result = step2 / divisor ; ; }
  |                                                        ^ help: remove this semicolon

error: aborting due to 4 previous errors; 4 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch04-00-modules-tdd example 3 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found keyword `mod`
 --> /tmp/.tmpOonDno/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod module_name { { pub fn public_function () { () } ; fn private_function ...
  |                                                               ^^^ expected expression

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpOonDno/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod module_name { { pub fn public_function () { () } ; fn private_function ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch04-00-modules-tdd example 4 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpL22HhU/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpL22HhU/main.rs:1:50
  |
1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }
  |                                                  ^^                                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }
1 + use std :: collections :: HashMap ; fn main () { module_name :: public_function () }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `module_name`
 --> /tmp/.tmpL22HhU/main.rs:1:52
  |
1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }
  |                                                    ^^^^^^^^^^^ use of unresolved module or unlinked crate `module_name`
  |
  = help: you might be missing a crate named `module_name`

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0433`.



=== ch04-00-modules-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found keyword `mod`
 --> /tmp/.tmpBGWtUA/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod math { { pub fn add (a : i32 , b : i32) -> i32 { { a + b } } ; pub fn s...
  |                                                               ^^^ expected expression

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpBGWtUA/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod math { { pub fn add (a : i32 , b : i32) -> i32 { { a + b } } ; pub fn s...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch04-00-modules-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found keyword `mod`
 --> /tmp/.tmpD2v69Y/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod strings { { pub fn greet () { { println ! ("Hello!") } } ; pub fn farew...
  |                                                               ^^^ expected expression

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpD2v69Y/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod strings { { pub fn greet () { { println ! ("Hello!") } } ; pub fn farew...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch09-00-collections-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `start` in this scope
 --> /tmp/.tmp3IItyR/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{:?}" , variable) } } ; if let...
  |                                                                               ^^^^^ not found in this scope

error[E0425]: cannot find value `end` in this scope
 --> /tmp/.tmp3IItyR/main.rs:1:88
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{:?}" , variable) } } ; if let...
  |                                                                                        ^^^ not found in this scope
  |
help: you might have meant to write `.` instead of `..`
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{:?}" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for variable in start.end { { println ! ("{:?}" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp3IItyR/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{:?}" , variable) } } ; if let...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp3IItyR/main.rs:1:94
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{:?}" , variable) } } ; if let...
  |                                                                                              ^^                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{:?}" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { println ! ("{:?}" , variable) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error: aborting due to 2 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `initial_value` in this scope
 --> /tmp/.tmpN7lJNA/main.rs:1:72
  |
1 | use std :: collections :: HashMap ; fn main () { let mut accumulator = initial_value ; ; let mut counter = start ; ; while counter <= end...
  |                                                                        ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `start` in this scope
 --> /tmp/.tmpN7lJNA/main.rs:1:108
  |
1 | ...t accumulator = initial_value ; ; let mut counter = start ; ; while counter <= end { { accumulator = update (accumulator , counter) ; ...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `end` in this scope
 --> /tmp/.tmpN7lJNA/main.rs:1:135
  |
1 | ...lue ; ; let mut counter = start ; ; while counter <= end { { accumulator = update (accumulator , counter) ; counter = counter + 1i32 }...
  |                                                         ^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpN7lJNA/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let mut accumulator = initial_value ; ; let mut counter = start ; ; while counter <= end...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpN7lJNA/main.rs:1:88
  |
1 | use std :: collections :: HashMap ; fn main () { let mut accumulator = initial_value ; ; let mut counter = start ; ; while counter <= end...
  |                                                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpN7lJNA/main.rs:1:116
  |
1 | ...lator = initial_value ; ; let mut counter = start ; ; while counter <= end { { accumulator = update (accumulator , counter) ; counter ...
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `update` in this scope
 --> /tmp/.tmpN7lJNA/main.rs:1:157
  |
1 | ... = start ; ; while counter <= end { { accumulator = update (accumulator , counter) ; counter = counter + 1i32 } } ; }
  |                                                        ^^^^^^ not found in this scope

error: aborting due to 4 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `height` in this scope
 --> /tmp/.tmpEwQDxn/main.rs:1:84
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (out...
  |                                                                                    ^^^^^^ not found in this scope

error[E0425]: cannot find value `width` in this scope
 --> /tmp/.tmpEwQDxn/main.rs:1:116
  |
1 | ...or outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn s...
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpEwQDxn/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (out...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpEwQDxn/main.rs:1:93
  |
1 | ...ult = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as ...
  |                                        ^^                                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { for inner in 0i32 .. width { { process (outer , inner) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpEwQDxn/main.rs:1:124
  |
1 | ...r in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: a...
  |                                                         ^^                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { process (outer , inner) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `process` in this scope
 --> /tmp/.tmpEwQDxn/main.rs:1:126
  |
1 | ... 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :...
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 7 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpIuptBg/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! ("{:?}" ,...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpIuptBg/main.rs:1:88
  |
1 | ...t result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! ("{:?}" , result) } } } ; if let Some (s) = (& result as ...
  |                                        ^^                                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! ("{:?}" , result) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { let result = process (i) ; println ! ("{:?}" , result) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `process` in this scope
 --> /tmp/.tmpIuptBg/main.rs:1:105
  |
1 | ...result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! ("{:?}" , result) } } } ; if let Some (s) = (& result as & ...
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 9 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `height` in this scope
 --> /tmp/.tmpi13Npe/main.rs:1:82
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = ca...
  |                                                                                  ^^^^^^ not found in this scope

error[E0425]: cannot find value `width` in this scope
 --> /tmp/.tmpi13Npe/main.rs:1:112
  |
1 | ... = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let...
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpi13Npe/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = ca...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpi13Npe/main.rs:1:91
  |
1 | ... in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) ...
  |                         ^^                                                                                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpi13Npe/main.rs:1:120
  |
1 | ...eight { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result a...
  |                                         ^^                                                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { let value = calculate (row , col) ; display (value) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `calculate` in this scope
 --> /tmp/.tmpi13Npe/main.rs:1:136
  |
1 | ...ht { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as &...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `display` in this scope
 --> /tmp/.tmpi13Npe/main.rs:1:160
  |
1 | ..... width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any)...
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 4 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 10 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpjSHmRr/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let mut count = 0i32 ; ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpjSHmRr/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn main () { let mut count = 0i32 ; ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count ...
  |                                                                         ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpjSHmRr/main.rs:1:101
  |
1 | ...ount = 0i32 ; ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } ; }
  |                                              ^^                                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let mut count = 0i32 ; ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } ; }
1 + use std :: collections :: HashMap ; fn main () { let mut count = 0i32 ; ; for i in 1i32 .. 100i32 { if condition (i) { { count = count + 1i32 } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpjSHmRr/main.rs:1:122
  |
1 | ...i32 ; ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } ; }
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let mut count = 0i32 ; ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } ; }
1 + use std :: collections :: HashMap ; fn main () { let mut count = 0i32 ; ; for i in 1i32 .. 100i32 { { if condition (i) { count = count + 1i32 } } } ; }
  |

error[E0425]: cannot find function `condition` in this scope
 --> /tmp/.tmpjSHmRr/main.rs:1:106
  |
1 | ...t count = 0i32 ; ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } ; }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 4 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== conclusion example 2 ===
✗ Compilation failed: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`
 --> /tmp/.tmpIwsYml/main.rs:1:455
  |
1 | .... pop () ; } } input } ; ; let contents = fs :: read_to_string ("file.txt" . to_string ()) ; ; let add_one = | x | x + 1i32 ; ; }
  |                                              ^^ use of unresolved module or unlinked crate `fs`
  |
  = help: you might be missing a crate named `fs`
help: consider importing this module
  |
1 + use std::fs;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpIwsYml/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let arr = vec ! [1i32 , 2i32 , 3i32] ; ; let name = { print ! ("{}" , "Enter name: ") ; ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpIwsYml/main.rs:1:89
  |
1 | use std :: collections :: HashMap ; fn main () { let arr = vec ! [1i32 , 2i32 , 3i32] ; ; let name = { print ! ("{}" , "Enter name: ") ; ...
  |                                                                                         ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpIwsYml/main.rs:1:438
  |
1 | .... ends_with ('\r') { input . pop () ; } } input } ; ; let contents = fs :: read_to_string ("file.txt" . to_string ()) ; ; let add_one ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpIwsYml/main.rs:1:506
  |
1 | ... fs :: read_to_string ("file.txt" . to_string ()) ; ; let add_one = | x | x + 1i32 ; ; }
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpIwsYml/main.rs:1:539
  |
1 | ... . to_string ()) ; ; let add_one = | x | x + 1i32 ; ; }
  |                                                        ^ help: remove this semicolon

error: aborting due to 1 previous error; 5 warnings emitted

For more information about this error, try `rustc --explain E0433`.



=== ch10-00-input-output-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `variable` in this scope
 --> /tmp/.tmputXKTi/main.rs:1:99
  |
1 | use std :: collections :: HashMap ; fn main () { println ! ("text message") ; println ! ("{:?}" , variable) ; println ! ("{:?}" , 42i32) ...
  |                                                                                                   ^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmputXKTi/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { println ! ("text message") ; println ! ("{:?}" , variable) ; println ! ("{:?}" , 42i32) ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch10-00-input-output-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `value` in this scope
 --> /tmp/.tmpzrwVYe/main.rs:1:61
  |
1 | use std :: collections :: HashMap ; fn main () { let data = value ; ; println ! ("Label:") ; println ! ("{:?}" , data) ; }
  |                                                             ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpzrwVYe/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let data = value ; ; println ! ("Label:") ; println ! ("{:?}" , data) ; }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpzrwVYe/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let data = value ; ; println ! ("Label:") ; println ! ("{:?}" , data) ; }
  |                                                                     ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch10-00-input-output-tdd example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch01-03-interpreter-scripting example 1 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `ruchy` in this scope
 --> /tmp/.tmpKzAIqx/main.rs:1:65
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "2 + 2" } ; if let Some (s) = (& result as & dyn std :: any :...
  |                                                                 ^^^^^ not found in this scope

error[E0425]: cannot find value `e` in this scope
 --> /tmp/.tmpKzAIqx/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "2 + 2" } ; if let Some (s) = (& result as & dyn std :: any :...
  |                                                                         ^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpKzAIqx/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "2 + 2" } ; if let Some (s) = (& result as & dyn std :: any :...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 2 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `ruchy` in this scope
 --> /tmp/.tmp6jTcrZ/main.rs:1:65
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let name = \"World\"; \"Hello \" + name + \"!\"" } ; if let ...
  |                                                                 ^^^^^ not found in this scope

error[E0425]: cannot find value `e` in this scope
 --> /tmp/.tmp6jTcrZ/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let name = \"World\"; \"Hello \" + name + \"!\"" } ; if let ...
  |                                                                         ^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp6jTcrZ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let name = \"World\"; \"Hello \" + name + \"!\"" } ; if let ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 3 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `ruchy` in this scope
 --> /tmp/.tmpVYihbB/main.rs:1:65
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let nums = [1, 2, 3]; nums[1]" } ; if let Some (s) = (& resu...
  |                                                                 ^^^^^ not found in this scope

error[E0425]: cannot find value `e` in this scope
 --> /tmp/.tmpVYihbB/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let nums = [1, 2, 3]; nums[1]" } ; if let Some (s) = (& resu...
  |                                                                         ^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpVYihbB/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let nums = [1, 2, 3]; nums[1]" } ; if let Some (s) = (& resu...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 7 ===
✗ Compilation failed: Compilation failed:
error[E0434]: can't capture dynamic environment in a fn item
 --> /tmp/.tmpUZw7BI/main.rs:1:259
  |
1 | ... () { { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ...
  |                                                                  ^^^^^^^^^
  |
  = help: use the `|| { ... }` closure form instead

error[E0425]: cannot find value `global_var` in this scope
 --> /tmp/.tmpUZw7BI/main.rs:1:141
  |
1 | ...ng () ; { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; fn nested () { { println ! ("{:?}" , global_var) ; printl...
  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `local_var`

error[E0425]: cannot find value `global_var` in this scope
 --> /tmp/.tmpUZw7BI/main.rs:1:225
  |
1 | ...ed () { { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ...
  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `local_var`

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpUZw7BI/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { { let local_var = "I'm local" . to_string () ; { println ! ("{:?}"...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpUZw7BI/main.rs:1:70
  |
1 | ... { { { let local_var = "I'm local" . to_string () ; { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; fn nested () { { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ("{:?}" , nested_var) } } } ; nested () } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { { let local_var = "I'm local" . to_string () ; { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; fn nested () { { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ("{:?}" , nested_var) } } } ; nested () } } } } fn main () { let global_var = "I'm global" . to_string () ; ; { demonstrate_scope () } }
1 + use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { let local_var = "I'm local" . to_string () ; { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; fn nested () { { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ("{:?}" , nested_var) } } } ; nested () } } } fn main () { let global_var = "I'm global" . to_string () ; ; { demonstrate_scope () } }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpUZw7BI/main.rs:1:359
  |
1 | ...o_string () ; println ! ("{:?}" , nested_var) } } } ; nested () } } } } fn main () { let global_var = "I'm global" . to_string () ; ; ...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpUZw7BI/main.rs:1:439
  |
1 | ...() { let global_var = "I'm global" . to_string () ; ; { demonstrate_scope () } }
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpUZw7BI/main.rs:1:441
  |
1 | ... () { let global_var = "I'm global" . to_string () ; ; { demonstrate_scope () } }
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { { let local_var = "I'm local" . to_string () ; { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; fn nested () { { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ("{:?}" , nested_var) } } } ; nested () } } } } fn main () { let global_var = "I'm global" . to_string () ; ; { demonstrate_scope () } }
1 + use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { { let local_var = "I'm local" . to_string () ; { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; fn nested () { { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ("{:?}" , nested_var) } } } ; nested () } } } } fn main () { let global_var = "I'm global" . to_string () ; ; demonstrate_scope () }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpUZw7BI/main.rs:1:361
  |
1 | ...-> i32 { { { let local_var = "I'm local" . to_string () ; { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; fn nested () { { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ("{:?}" , nested_var) } } } ; nested () } ...
  |       --- expected `i32` because of return type                                                                                                                                                                                                                                                                ^^^^^^^^^ expected `i32`, found `()`

error[E0308]: mismatched types
 --> /tmp/.tmpUZw7BI/main.rs:1:443
  |
1 | ... main () { let global_var = "I'm global" . to_string () ; ; { demonstrate_scope () } }
  |            -                                                     ^^^^^^^^^^^^^^^^^^^^- help: consider using a semicolon here: `;`
  |            |                                                     |
  |            expected `()` because of default return type          expected `()`, found `i32`

error: aborting due to 5 previous errors; 5 warnings emitted

Some errors have detailed explanations: E0308, E0425, E0434.
For more information about an error, try `rustc --explain E0308`.



=== ch01-03-interpreter-scripting example 8 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpbx9UMo/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpbx9UMo/main.rs:1:50
  |
1 | ... { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } } }
  |       ^^                                                                                                                                                                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } } }
1 + use std :: collections :: HashMap ; fn main () { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpbx9UMo/main.rs:1:118
  |
1 | ...32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds")...
  |                                                 ^^                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { println ! ("{:?}" , arr [5i32 as usize]) } else { { println ! ("Index out of bounds") } } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpbx9UMo/main.rs:1:172
  |
1 | ...tln ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } } }
  |                                                    ^^                                 ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" , arr [5i32 as usize]) } } else { println ! ("Index out of bounds") } } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpbx9UMo/main.rs:1:103
  |
1 | ...let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("In...
  |                                              ----   ^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                              |
  |                                              expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len ().try_into().unwrap() { { println ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } } }
  |                                                                                                                   ++++++++++++++++++++

error: aborting due to 1 previous error; 4 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch01-03-interpreter-scripting example 12 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `items` in this scope
 --> /tmp/.tmpgalo48/main.rs:1:112
  |
1 | ...ount = 42i32 ; ; let total_price = calculate_price (items) ; ; let x = 42i32 ; ; let y = calc (z) ; ; }
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `z` in this scope
 --> /tmp/.tmpgalo48/main.rs:1:155
  |
1 | ...s) ; ; let x = 42i32 ; ; let y = calc (z) ; ; }
  |                                           ^ help: a local variable with a similar name exists: `x`

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpgalo48/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let user_count = 42i32 ; ; let total_price = calculate_price (items) ; ; let x = 42i32 ;...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpgalo48/main.rs:1:75
  |
1 | use std :: collections :: HashMap ; fn main () { let user_count = 42i32 ; ; let total_price = calculate_price (items) ; ; let x = 42i32 ;...
  |                                                                           ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpgalo48/main.rs:1:121
  |
1 | ...i32 ; ; let total_price = calculate_price (items) ; ; let x = 42i32 ; ; let y = calc (z) ; ; }
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpgalo48/main.rs:1:139
  |
1 | ...price = calculate_price (items) ; ; let x = 42i32 ; ; let y = calc (z) ; ; }
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpgalo48/main.rs:1:160
  |
1 | ...ce (items) ; ; let x = 42i32 ; ; let y = calc (z) ; ; }
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `calculate_price` in this scope
 --> /tmp/.tmpgalo48/main.rs:1:95
  |
1 | use std :: collections :: HashMap ; fn main () { let user_count = 42i32 ; ; let total_price = calculate_price (items) ; ; let x = 42i32 ;...
  |                                                                                               ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `calc` in this scope
 --> /tmp/.tmpgalo48/main.rs:1:149
  |
1 | ...alculate_price (items) ; ; let x = 42i32 ; ; let y = calc (z) ; ; }
  |                                                         ^^^^ not found in this scope

error: aborting due to 4 previous errors; 5 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-building-applications example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch07-00-building-applications example 2 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `User` in this scope
 --> /tmp/.tmpyr3xbI/main.rs:1:109
  |
1 | ...e : String , email : String) -> i32 { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . ema...
  |                                                         ^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpyr3xbI/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn create_user (name : String , email : String) -> i32 { { { let user = User . copy () ; { user . id ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpyr3xbI/main.rs:1:94
  |
1 | ... { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } ...
  |       ^^                                                                                                                                                                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn create_user (name : String , email : String) -> i32 { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user (user : String) { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{:?}" , format ! ("{}{}" , "Member since: " , user . created)) } } fn main () { let APP = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("name" . to_string () , ("MyApp") . to_string ()) ; map . insert ("version" . to_string () , ("1.0.0") . to_string ()) ; map . insert ("config_dir" . to_string () , ("~/.config/myapp") . to_string ()) ; map . insert ("data_dir" . to_string () , ("~/.local/share/myapp") . to_string ()) ; map . insert ("cache_dir" . to_string () , ("~/.cache/myapp") . to_string ()) ; map } ; ; let User = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("id" . to_string () , (None) . to_string ()) ; map . insert ("name" . to_string () , ("") . to_string ()) ; map . insert ("email" . to_string () , ("") . to_string ()) ; map . insert ("created" . to_string () , (None) . to_string ()) ; map } ; ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
1 + use std :: collections :: HashMap ; fn create_user (name : String , email : String) -> i32 { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } fn display_user (user : String) { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{:?}" , format ! ("{}{}" , "Member since: " , user . created)) } } fn main () { let APP = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("name" . to_string () , ("MyApp") . to_string ()) ; map . insert ("version" . to_string () , ("1.0.0") . to_string ()) ; map . insert ("config_dir" . to_string () , ("~/.config/myapp") . to_string ()) ; map . insert ("data_dir" . to_string () , ("~/.local/share/myapp") . to_string ()) ; map . insert ("cache_dir" . to_string () , ("~/.cache/myapp") . to_string ()) ; map } ; ; let User = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("id" . to_string () , (None) . to_string ()) ; map . insert ("name" . to_string () , ("") . to_string ()) ; map . insert ("email" . to_string () , ("") . to_string ()) ; map . insert ("created" . to_string () , (None) . to_string ()) ; map } ; ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpyr3xbI/main.rs:1:959
  |
1 | ...g () , ("~/.cache/myapp") . to_string ()) ; map } ; ; let User = { let mut map : std :: collections :: HashMap < String , String > = s...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpyr3xbI/main.rs:1:1340
  |
1 | ..." . to_string () , (None) . to_string ()) ; map } ; ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `generate_uuid` in this scope
 --> /tmp/.tmpyr3xbI/main.rs:1:140
  |
1 | ...{ { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = curren...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `current_datetime` in this scope
 --> /tmp/.tmpyr3xbI/main.rs:1:220
  |
1 | ...name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user (user : String) { { println !...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0609]: no field `name` on type `String`
 --> /tmp/.tmpyr3xbI/main.rs:1:334
  |
1 | ...r (user : String) { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{:?}" , format ! ("{}{}" , "Member since:...
  |                                                              ^^^^ unknown field

error[E0609]: no field `email` on type `String`
 --> /tmp/.tmpyr3xbI/main.rs:1:348
  |
1 | ...g) { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{:?}" , format ! ("{}{}" , "Member since: " , user . cre...
  |                                                             ^^^^^ unknown field

error[E0609]: no field `created` on type `String`
 --> /tmp/.tmpyr3xbI/main.rs:1:422
  |
1 | ... ("{:?}" , format ! ("{}{}" , "Member since: " , user . created)) } } fn main () { let APP = { let mut map : std :: collections :: Has...
  |                                                            ^^^^^^^ unknown field

error[E0599]: the method `to_string` exists for enum `Option<_>`, but its trait bounds were not satisfied
   --> /tmp/.tmpyr3xbI/main.rs:1:1127
    |
1   | ... . to_string () , (None) . to_string ()) ; map . insert ("name" . to_string () , ("") . to_string ()) ; map . insert ("email" . to_str...
    |                               ^^^^^^^^^ method cannot be called on `Option<_>` due to unsatisfied trait bounds
    |
   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:591:1
    |
591 | pub enum Option<T> {
    | ------------------ doesn't satisfy `Option<_>: ToString` or `Option<_>: std::fmt::Display`
    |
    = note: the following trait bounds were not satisfied:
            `Option<_>: std::fmt::Display`
            which is required by `Option<_>: ToString`

error[E0599]: the method `to_string` exists for enum `Option<_>`, but its trait bounds were not satisfied
   --> /tmp/.tmpyr3xbI/main.rs:1:1316
    |
1   | ... . to_string () , (None) . to_string ()) ; map } ; ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
    |                               ^^^^^^^^^ method cannot be called on `Option<_>` due to unsatisfied trait bounds
    |
   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:591:1
    |
591 | pub enum Option<T> {
    | ------------------ doesn't satisfy `Option<_>: ToString` or `Option<_>: std::fmt::Display`
    |
    = note: the following trait bounds were not satisfied:
            `Option<_>: std::fmt::Display`
            which is required by `Option<_>: ToString`

error[E0425]: cannot find function `init_app` in this scope
 --> /tmp/.tmpyr3xbI/main.rs:1:1344
  |
1 | ...o_string () , (None) . to_string ()) ; map } ; ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `load_config` in this scope
 --> /tmp/.tmpyr3xbI/main.rs:1:1358
  |
1 | ...one) . to_string ()) ; map } ; ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `run_event_loop` in this scope
 --> /tmp/.tmpyr3xbI/main.rs:1:1375
  |
1 | ...)) ; map } ; ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `cleanup` in this scope
 --> /tmp/.tmpyr3xbI/main.rs:1:1395
  |
1 | ...init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 12 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0425, E0599, E0609.
For more information about an error, try `rustc --explain E0425`.



=== ch07-00-building-applications example 3 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpchvUJx/main.rs:1:96
  |
1 | use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dir...
  |                                                                                                ^^^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpchvUJx/main.rs:1:127
  |
1 | ...: String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty {...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpchvUJx/main.rs:1:194
  |
1 | ... true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `APP` in this scope
 --> /tmp/.tmpchvUJx/main.rs:1:242
  |
1 | ...{ if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_jso...
  |                                                         ^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpchvUJx/main.rs:1:326
  |
1 | ...to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file ...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpchvUJx/main.rs:1:336
  |
1 | ...()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_pat...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `APP` in this scope
 --> /tmp/.tmpchvUJx/main.rs:1:421
  |
1 | ...} fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { S...
  |                                                         ^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpchvUJx/main.rs:1:501
  |
1 | ..." . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { l...
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpchvUJx/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dir...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpchvUJx/main.rs:1:189
  |
1 | ... { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } ...
  |       ^^                                                                                                                                                                              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("users" . to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (None) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; ; }
1 + use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("users" . to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (None) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpchvUJx/main.rs:1:210
  |
1 | ... { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } ...
  |       ^^                                                                                                                                                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("users" . to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (None) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; ; }
1 + use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("users" . to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (None) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpchvUJx/main.rs:1:389
  |
1 | ... { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } ...
  |       ^^                                                                                                                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("users" . to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (None) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; ; }
1 + use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } fn main () { let STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("users" . to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (None) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpchvUJx/main.rs:1:499
  |
1 | ...string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut ...
  |                                               ^^                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("users" . to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (None) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; ; }
1 + use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { STATE = parse_json (read_file (state_file)) } } } } fn main () { let STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("users" . to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (None) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpchvUJx/main.rs:1:1029
  |
1 | ... . to_string () , (false) . to_string ()) ; map } ; ; }
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error[E0425]: cannot find function `trigger_save` in this scope
 --> /tmp/.tmpchvUJx/main.rs:1:150
  |
1 | ... [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0605]: non-primitive cast: `String` as `usize`
 --> /tmp/.tmpchvUJx/main.rs:1:103
  |
1 | ...ATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = j...
  |         ^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpchvUJx/main.rs:1:231
  |
1 | ...te () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_json` in this scope
 --> /tmp/.tmpchvUJx/main.rs:1:317
  |
1 | ...json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let sta...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpchvUJx/main.rs:1:292
  |
1 | ...ate.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let...
  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `state_file`

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpchvUJx/main.rs:1:410
  |
1 | ...} } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_fil...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpchvUJx/main.rs:1:472
  |
1 | ...P . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpchvUJx/main.rs:1:521
  |
1 | ... file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut map : std :: co...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `parse_json` in this scope
 --> /tmp/.tmpchvUJx/main.rs:1:509
  |
1 | ...ing ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut map...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0599]: the method `to_string` exists for struct `Vec<_>`, but its trait bounds were not satisfied
   --> /tmp/.tmpchvUJx/main.rs:1:742
    |
1   | ...to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (None) . to_string ()) ; map . insert ("sett...
    |                                ^^^^^^^^^ method cannot be called on `Vec<_>` due to unsatisfied trait bounds
    |
   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1
    |
414 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<_>: ToString` or `Vec<_>: std::fmt::Display`
    |
    = note: the following trait bounds were not satisfied:
            `Vec<_>: std::fmt::Display`
            which is required by `Vec<_>: ToString`
            `[_]: std::fmt::Display`
            which is required by `[_]: ToString`

error[E0599]: the method `to_string` exists for enum `Option<_>`, but its trait bounds were not satisfied
   --> /tmp/.tmpchvUJx/main.rs:1:813
    |
1   | ... . to_string () , (None) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to...
    |                               ^^^^^^^^^ method cannot be called on `Option<_>` due to unsatisfied trait bounds
    |
   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:591:1
    |
591 | pub enum Option<T> {
    | ------------------ doesn't satisfy `Option<_>: ToString` or `Option<_>: std::fmt::Display`
    |
    = note: the following trait bounds were not satisfied:
            `Option<_>: std::fmt::Display`
            which is required by `Option<_>: ToString`

error[E0599]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpchvUJx/main.rs:1:878
  |
1 | ...ings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to...
  |                                  ^^^^^^^^^ method cannot be called on `()` due to unsatisfied trait bounds
  |
  = note: the following trait bounds were not satisfied:
          `(): std::fmt::Display`
          which is required by `(): ToString`

error[E0599]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpchvUJx/main.rs:1:940
  |
1 | ...ache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; ; }
  |                                  ^^^^^^^^^ method cannot be called on `()` due to unsatisfied trait bounds
  |
  = note: the following trait bounds were not satisfied:
          `(): std::fmt::Display`
          which is required by `(): ToString`

error: aborting due to 21 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0425, E0599, E0605.
For more information about an error, try `rustc --explain E0425`.



=== ch07-00-building-applications example 4 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch07-00-building-applications example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `MASTER_KEY` in this scope
 --> /tmp/.tmpmr1vwH/main.rs:1:1055
  |
1 | ...("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_dat...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `MASTER_KEY` in this scope
 --> /tmp/.tmpmr1vwH/main.rs:1:1412
  |
1 | ...e] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipb...
  |                                                      ^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpmr1vwH/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpmr1vwH/main.rs:1:88
  |
1 | ... { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } ...
  |       ^^                                                                                                                                                                                                                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpmr1vwH/main.rs:1:172
  |
1 | ...erate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return ...
  |               ^^                                                                                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpmr1vwH/main.rs:1:382
  |
1 | ... { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } ...
  |       ^^                                                                                                                                                                                                                                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpmr1vwH/main.rs:1:455
  |
1 | ...4_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len (...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpmr1vwH/main.rs:1:498
  |
1 | ...te () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; ret...
  |            ^^                                                                                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpmr1vwH/main.rs:1:741
  |
1 | ... { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpmr1vwH/main.rs:1:1251
  |
1 | ... { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpmr1vwH/main.rs:1:1323
  |
1 | ... { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } e...
  |       ^^                                                                                                                                                                                                                                         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpmr1vwH/main.rs:1:1426
  |
1 | ...assword = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; sp...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpmr1vwH/main.rs:1:1569
  |
1 | ...lipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MAS...
  |                                ^^                                                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpmr1vwH/main.rs:1:1693
  |
1 | ...te)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpmr1vwH/main.rs:1:1752
  |
1 | ...ASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
  |                                                        ^ help: remove this semicolon

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpmr1vwH/main.rs:1:196
  |
1 | ...merate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return...
  |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0599]: no method named `code` found for type `char` in the current scope
 --> /tmp/.tmpmr1vwH/main.rs:1:250
  |
1 | ... key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn d...
  |                                                       ^^^^ method not found in `char`

error[E0425]: cannot find function `base64_encode` in this scope
 --> /tmp/.tmpmr1vwH/main.rs:1:295
  |
1 | ... . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 {...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `base64_decode` in this scope
 --> /tmp/.tmpmr1vwH/main.rs:1:398
  |
1 | ... : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . e...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `char_from_code` in this scope
 --> /tmp/.tmpmr1vwH/main.rs:1:569
  |
1 | ...[i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } }...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `load_passwords` in this scope
 --> /tmp/.tmpmr1vwH/main.rs:1:761
  |
1 | ...password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `current_datetime` in this scope
 --> /tmp/.tmpmr1vwH/main.rs:1:1128
  |
1 | ...)) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn ge...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `save_passwords` in this scope
 --> /tmp/.tmpmr1vwH/main.rs:1:1175
  |
1 | ...(current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let pa...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0605]: non-primitive cast: `String` as `usize`
 --> /tmp/.tmpmr1vwH/main.rs:1:794
  |
1 | ...rds [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; ma...
  |         ^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0425]: cannot find function `load_passwords` in this scope
 --> /tmp/.tmpmr1vwH/main.rs:1:1271
  |
1 | ... } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords ()...
  |       ------------------------------------------------------------------------------ similarly named function `add_password` defined here                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^^^^^^^^^^^^^ help: a function with a similar name exists: `add_password`

error[E0425]: cannot find function `copy_to_clipboard` in this scope
 --> /tmp/.tmpmr1vwH/main.rs:1:1428
  |
1 | ...= decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_afte...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `clear_clipboard` in this scope
 --> /tmp/.tmpmr1vwH/main.rs:1:1534
  |
1 | ...d to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No passwo...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `spawn_after` in this scope
 --> /tmp/.tmpmr1vwH/main.rs:1:1507
  |
1 | ... println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , fo...
  |                                                      ^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpmr1vwH/main.rs:1:1571
  |
1 | ... } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None...
  |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0605]: non-primitive cast: `String` as `usize`
 --> /tmp/.tmpmr1vwH/main.rs:1:1350
  |
1 | ...rds [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Passwor...
  |         ^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0282]: type annotations needed for `Option<_>`
 --> /tmp/.tmpmr1vwH/main.rs:1:1673
  |
1 | ...for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
  |                                              ^^^^^^^^^^   ---- type must be known at this point
  |
help: consider giving `MASTER_KEY` an explicit type, where the type for type parameter `T` is specified
  |
1 | use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY: Option<T> = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     +++++++++++

error: aborting due to 18 previous errors; 13 warnings emitted

Some errors have detailed explanations: E0277, E0282, E0308, E0425, E0599, E0605.
For more information about an error, try `rustc --explain E0277`.



=== ch07-00-building-applications example 6 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `TRANSACTIONS_FILE` in this scope
 --> /tmp/.tmpcJ8I9g/main.rs:1:559
  |
1 | ...tion) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; ...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `report_data` in this scope
 --> /tmp/.tmpcJ8I9g/main.rs:1:1998
  |
1 | ...{}.pdf" , month) ; ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_...
  |                                                     ^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpcJ8I9g/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) { { { let transaction = ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpcJ8I9g/main.rs:1:116
  |
1 | ... { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") , monthly_spent . to_s ()) , "/$") , budget_limit . to_s ())) } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") , monthly_spent . to_s ()) , "/$") , budget_limit . to_s ())) } } } } } } fn generate_report (month : i32) { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category" . to_string ()) ; ; println ! ("{:?}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") , category_total . to_s ()) , " ") , bar)) } } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; ; }
1 + use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") , monthly_spent . to_s ()) , "/$") , budget_limit . to_s ())) } } } } } fn generate_report (month : i32) { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category" . to_string ()) ; ; println ! ("{:?}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") , category_total . to_s ()) , " ") , bar)) } } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpcJ8I9g/main.rs:1:645
  |
1 | ... let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_lim...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpcJ8I9g/main.rs:1:696
  |
1 | ... ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpcJ8I9g/main.rs:1:1078
  |
1 | ... { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category" . to_string ()) ; ; println ! ("{:?}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") , category_total . to_s ()) , " ") , bar)) } } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") , monthly_spent . to_s ()) , "/$") , budget_limit . to_s ())) } } } } } } fn generate_report (month : i32) { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category" . to_string ()) ; ; println ! ("{:?}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") , category_total . to_s ()) , " ") , bar)) } } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; ; }
1 + use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") , monthly_spent . to_s ()) , "/$") , budget_limit . to_s ())) } } } } } } fn generate_report (month : i32) { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category" . to_string ()) ; ; println ! ("{:?}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") , category_total . to_s ()) , " ") , bar)) } } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } fn main () { let TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpcJ8I9g/main.rs:1:1203
  |
1 | ...oup_by (transactions , "category" . to_string ()) ; ; println ! ("{:?}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; print...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpcJ8I9g/main.rs:1:1335
  |
1 | ...intln ! ("{:?}" , "=" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . iter () . map (| (k , v) | (k . clone ()...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpcJ8I9g/main.rs:1:1968
  |
1 | ..._file = format ! ("budget_report_{}.pdf" , month) ; ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpcJ8I9g/main.rs:1:1437
  |
1 | ... { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") , category_total . to_s ()) , " ") , bar)) } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") , monthly_spent . to_s ()) , "/$") , budget_limit . to_s ())) } } } } } } fn generate_report (month : i32) { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category" . to_string ()) ; ; println ! ("{:?}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") , category_total . to_s ()) , " ") , bar)) } } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; ; }
1 + use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") , monthly_spent . to_s ()) , "/$") , budget_limit . to_s ())) } } } } } } fn generate_report (month : i32) { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category" . to_string ()) ; ; println ! ("{:?}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") , category_total . to_s ()) , " ") , bar)) } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpcJ8I9g/main.rs:1:1622
  |
1 | ... let bar = "█" * category_total / 50i32 . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , for...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpcJ8I9g/main.rs:1:2182
  |
1 | ...ILE = "~/.budget/transactions.csv" . to_string () ; ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Othe...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpcJ8I9g/main.rs:1:2270
  |
1 | ...Transport" , "Bills" , "Entertainment" , "Other"] ; ; }
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `current_date` in this scope
 --> /tmp/.tmpcJ8I9g/main.rs:1:287
  |
1 | ... new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) ....
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `append_csv` in this scope
 --> /tmp/.tmpcJ8I9g/main.rs:1:547
  |
1 | ...ng () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `get_monthly_total` in this scope
 --> /tmp/.tmpcJ8I9g/main.rs:1:614
  |
1 | ...ONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if m...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `get_budget_limit` in this scope
 --> /tmp/.tmpcJ8I9g/main.rs:1:666
  |
1 | ...onthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `send_notification` in this scope
 --> /tmp/.tmpcJ8I9g/main.rs:1:734
  |
1 | ...gory) ; ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `load_transactions` in this scope
 --> /tmp/.tmpcJ8I9g/main.rs:1:1101
  |
1 | ... ; fn add_transaction (amount : String , category : i32 , description : String) { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") , monthly_spent . to_s ()) , "/$") , budget_limit . to_s ())) } } } } } } fn generate_report (month : i32) { { { let transactions = load_transactions (m...
  |       ---------------------------------------------------------------------------- similarly named function `add_transaction` defined here                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^^^^^^^^^^^^^^^^^ help: a function with a similar name exists: `add_transaction`

error[E0425]: cannot find function `group_by` in this scope
 --> /tmp/.tmpcJ8I9g/main.rs:1:1149
  |
1 | ... = load_transactions (month) ; { let by_category = group_by (transactions , "category" . to_string ()) ; ; println ! ("{:?}" , format ...
  |                                                       ^^^^^^^^ not found in this scope

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmpcJ8I9g/main.rs:1:1305
  |
1 | ..., "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . ...
  |                                                                --- ^ ----- i32
  |                                                                |
  |                                                                &str

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmpcJ8I9g/main.rs:1:1612
  |
1 | ...ry_total ; let bar = "█" * category_total / 50i32 . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{...
  |                                                        ^^^^ method not found in `i32`

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpcJ8I9g/main.rs:1:1575
  |
1 | ... . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , fo...
  |                                                ^^^ doesn't have a size known at compile-time
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: all local variables must have a statically known size

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpcJ8I9g/main.rs:1:1774
  |
1 | ... ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") , category_total . to_s ()) , " ") , bar)) } } } ...
  |         -- required by this formatting parameter                                                                             ^^^ doesn't have a size known at compile-time
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmpcJ8I9g/main.rs:1:1814
  |
1 | ...al . to_s ()) , " ") , bar)) } } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" ,...
  |                                                               --- ^ ----- i32
  |                                                               |
  |                                                               &str

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpcJ8I9g/main.rs:1:1894
  |
1 | ... , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; ; genera...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `generate_pdf` in this scope
 --> /tmp/.tmpcJ8I9g/main.rs:1:1970
  |
1 | ... = format ! ("budget_report_{}.pdf" , month) ; ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄...
  |                                                     ^^^^^^^^^^^^ not found in this scope

warning: unused variable: `TRANSACTIONS_FILE`
 --> /tmp/.tmpcJ8I9g/main.rs:1:2116
  |
1 | ... fn main () { let TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; ; let CATEGORIES = vec ! ["Food" , "Transport" , "...
  |                      ^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_TRANSACTIONS_FILE`
  |
  = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `CATEGORIES`
 --> /tmp/.tmpcJ8I9g/main.rs:1:2188
  |
1 | ..." . to_string () ; ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; ; }
  |                             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_CATEGORIES`

error: aborting due to 16 previous errors; 14 warnings emitted

Some errors have detailed explanations: E0277, E0369, E0425, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch07-00-building-applications example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch07-00-building-applications example 8 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `remove_file` in this scope
 --> /tmp/.tmpLEdVl4/main.rs:1:921
  |
1 | ...est == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_...
  |                                                     ^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_file;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpLEdVl4/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" ....
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpLEdVl4/main.rs:1:64
  |
1 | ... { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert ! (user . name == "Alice" , "{}" , "Name should be set") ; assert ! (user . email == "alice@example.com" , "{}" , "Email should be set") ; assert ! (user . id != None , "{}" , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                            ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert ! (user . name == "Alice" , "{}" , "Name should be set") ; assert ! (user . email == "alice@example.com" , "{}" , "Email should be set") ; assert ! (user . id != None , "{}" , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } fn test_data_persistence () { { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("test" . to_string () , ("value") . to_string ()) ; map } ; { let test_file = "test_data.json" . to_string () ; ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let loaded = load_json (test_file) ; ; assert ! (loaded . test == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_user_creation () { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert ! (user . name == "Alice" , "{}" , "Name should be set") ; assert ! (user . email == "alice@example.com" , "{}" , "Email should be set") ; assert ! (user . id != None , "{}" , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } fn test_data_persistence () { { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("test" . to_string () , ("value") . to_string ()) ; map } ; { let test_file = "test_data.json" . to_string () ; ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let loaded = load_json (test_file) ; ; assert ! (loaded . test == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpLEdVl4/main.rs:1:448
  |
1 | ... { { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("test" . to_string () , ("value") . to_string ()) ; map } ; { let test_file = "test_data.json" . to_string () ; ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let loaded = load_json (test_file) ; ; assert ! (loaded . test == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert ! (user . name == "Alice" , "{}" , "Name should be set") ; assert ! (user . email == "alice@example.com" , "{}" , "Email should be set") ; assert ! (user . id != None , "{}" , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } fn test_data_persistence () { { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("test" . to_string () , ("value") . to_string ()) ; map } ; { let test_file = "test_data.json" . to_string () ; ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let loaded = load_json (test_file) ; ; assert ! (loaded . test == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert ! (user . name == "Alice" , "{}" , "Name should be set") ; assert ! (user . email == "alice@example.com" , "{}" , "Email should be set") ; assert ! (user . id != None , "{}" , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } fn test_data_persistence () { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("test" . to_string () , ("value") . to_string ()) ; map } ; { let test_file = "test_data.json" . to_string () ; ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let loaded = load_json (test_file) ; ; assert ! (loaded . test == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpLEdVl4/main.rs:1:704
  |
1 | ...{ let test_file = "test_data.json" . to_string () ; ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpLEdVl4/main.rs:1:850
  |
1 | ...be created") ; let loaded = load_json (test_file) ; ; assert ! (loaded . test == "value" , "{}" , "Data should persist") ; remove_file...
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `create_user` in this scope
 --> /tmp/.tmpLEdVl4/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" ....
  |                                                                               ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `save_json` in this scope
 --> /tmp/.tmpLEdVl4/main.rs:1:706
  |
1 | ...t test_file = "test_data.json" . to_string () ; ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpLEdVl4/main.rs:1:752
  |
1 | ... ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let loaded = load_json (...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `load_json` in this scope
 --> /tmp/.tmpLEdVl4/main.rs:1:826
  |
1 | ..., "{}" , "File should be created") ; let loaded = load_json (test_file) ; ; assert ! (loaded . test == "value" , "{}" , "Data should p...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `test_error_handling` in this scope
 --> /tmp/.tmpLEdVl4/main.rs:1:1122
  |
1 | ...ser_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn ...
  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `test_performance` in this scope
 --> /tmp/.tmpLEdVl4/main.rs:1:1147
  |
1 | ...data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 7 previous errors; 5 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-building-applications example 9 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `VERSION` in this scope
 --> /tmp/.tmpQn7b2a/main.rs:1:174
  |
1 | ... let release_dir = format ! ("{}{}" , "release_" , VERSION) ; { create_dir_all (release_dir) ; copy_file ("main.ruchy" . to_string () ...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find function `create_dir_all` in this scope
 --> /tmp/.tmpQn7b2a/main.rs:1:187
  |
1 | ... = format ! ("{}{}" , "release_" , VERSION) ; { create_dir_all (release_dir) ; copy_file ("main.ruchy" . to_string () , join_path (rel...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::create_dir_all;
  |

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmpQn7b2a/main.rs:1:284
  |
1 | ...n.ruchy" . to_string () , join_path (release_dir , APP_NAME)) ; copy_dir ("resources" . to_string () , join_path (release_dir , "resou...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmpQn7b2a/main.rs:1:646
  |
1 | ...cho 'Installation complete! Run {} to start.'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; ; write_file (join_path (rel...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `VERSION` in this scope
 --> /tmp/.tmpQn7b2a/main.rs:1:657
  |
1 | ...lation complete! Run {} to start.'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; ; write_file (join_path (release_dir , ...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmpQn7b2a/main.rs:1:667
  |
1 | ...plete! Run {} to start.'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; ; write_file (join_path (release_dir , "install.s...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmpQn7b2a/main.rs:1:678
  |
1 | ...{} to start.'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; ; write_file (join_path (release_dir , "install.sh" . to_str...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmpQn7b2a/main.rs:1:689
  |
1 | ....'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; ; write_file (join_path (release_dir , "install.sh" . to_string ()) , i...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmpQn7b2a/main.rs:1:827
  |
1 | ...ller) ; create_archive (format ! ("{}-{}.tar.gz" , APP_NAME , VERSION) , release_dir) ; println ! ("✅ Release built: {}-{}.tar.gz" , AP...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `VERSION` in this scope
 --> /tmp/.tmpQn7b2a/main.rs:1:838
  |
1 | ...ate_archive (format ! ("{}-{}.tar.gz" , APP_NAME , VERSION) , release_dir) ; println ! ("✅ Release built: {}-{}.tar.gz" , APP_NAME , VE...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmpQn7b2a/main.rs:1:909
  |
1 | ...ir) ; println ! ("✅ Release built: {}-{}.tar.gz" , APP_NAME , VERSION) } } } } fn main () { }
  |                                                        ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `VERSION` in this scope
 --> /tmp/.tmpQn7b2a/main.rs:1:920
  |
1 | ...ln ! ("✅ Release built: {}-{}.tar.gz" , APP_NAME , VERSION) } } } } fn main () { }
  |                                                        ^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpQn7b2a/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn build_release () { { println ! ("🔨 Building release version...") ; run_tests () ; { let release_dir...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpQn7b2a/main.rs:1:701
  |
1 | ..._NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; ; write_file (join_path (release_dir , "install.sh" . to_string ()) , installer) ;...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error[E0425]: cannot find function `run_tests` in this scope
 --> /tmp/.tmpQn7b2a/main.rs:1:107
  |
1 | ...{ { println ! ("🔨 Building release version...") ; run_tests () ; { let release_dir = format ! ("{}{}" , "release_" , VERSION) ; { creat...
  |                                                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpQn7b2a/main.rs:1:259
  |
1 | ...e_dir) ; copy_file ("main.ruchy" . to_string () , join_path (release_dir , APP_NAME)) ; copy_dir ("resources" . to_string () , join_pa...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `copy_file` in this scope
 --> /tmp/.tmpQn7b2a/main.rs:1:218
  |
1 | ...e_" , VERSION) ; { create_dir_all (release_dir) ; copy_file ("main.ruchy" . to_string () , join_path (release_dir , APP_NAME)) ; copy_...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpQn7b2a/main.rs:1:336
  |
1 | ...P_NAME)) ; copy_dir ("resources" . to_string () , join_path (release_dir , "resources" . to_string ())) ; generate_docs (join_path (re...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `copy_dir` in this scope
 --> /tmp/.tmpQn7b2a/main.rs:1:297
  |
1 | ..._string () , join_path (release_dir , APP_NAME)) ; copy_dir ("resources" . to_string () , join_path (release_dir , "resources" . to_st...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpQn7b2a/main.rs:1:407
  |
1 | ...r , "resources" . to_string ())) ; generate_docs (join_path (release_dir , "docs" . to_string ())) ; let installer = format ! ("#!/bin...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `generate_docs` in this scope
 --> /tmp/.tmpQn7b2a/main.rs:1:392
  |
1 | ...h (release_dir , "resources" . to_string ())) ; generate_docs (join_path (release_dir , "docs" . to_string ())) ; let installer = form...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpQn7b2a/main.rs:1:715
  |
1 | ..., APP_NAME , APP_NAME , APP_NAME) ; ; write_file (join_path (release_dir , "install.sh" . to_string ()) , installer) ; create_archive ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpQn7b2a/main.rs:1:703
  |
1 | ...E , VERSION , APP_NAME , APP_NAME , APP_NAME) ; ; write_file (join_path (release_dir , "install.sh" . to_string ()) , installer) ; cre...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `create_archive` in this scope
 --> /tmp/.tmpQn7b2a/main.rs:1:784
  |
1 | ...r , "install.sh" . to_string ()) , installer) ; create_archive (format ! ("{}-{}.tar.gz" , APP_NAME , VERSION) , release_dir) ; printl...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 22 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch15-00-macros-metaprogramming example 2 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `User` in this scope
 --> /tmp/.tmpJmurY6/main.rs:1:59
  |
1 | use std :: collections :: HashMap ; fn debug_user (user : User) -> String { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , fo...
  |                                                           ^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpJmurY6/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn debug_user (user : User) -> String { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , fo...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpJmurY6/main.rs:1:77
  |
1 | ... { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "User { name: " , user . name) , ", age: ") , user . age . to_string ()) , " }") } } ...
  |       ^^                                                                                                                                                            ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn debug_user (user : User) -> String { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "User { name: " , user . name) , ", age: ") , user . age . to_string ()) , " }") } } fn main () { struct User { name : String , age : i32 , } ; }
1 + use std :: collections :: HashMap ; fn debug_user (user : User) -> String { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "User { name: " , user . name) , ", age: ") , user . age . to_string ()) , " }") } fn main () { struct User { name : String , age : i32 , } ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpJmurY6/main.rs:1:297
  |
1 | ...in () { struct User { name : String , age : i32 , } ; }
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error: aborting due to 1 previous error; 3 warnings emitted

For more information about this error, try `rustc --explain E0412`.



=== ch07-00-error-handling-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `value` in this scope
 --> /tmp/.tmp3KNQZ6/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid") } } else { { println ! ("Invalid") ...
  |                                                                  ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp3KNQZ6/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid") } } else { { println ! ("Invalid") ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp3KNQZ6/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid") } } else { { println ! ("Invalid") ...
  |                                                                                 ^^                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid") } } else { { println ! ("Invalid") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { println ! ("Valid") } else { { println ! ("Invalid") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp3KNQZ6/main.rs:1:114
  |
1 | ... = if value > 0i32 { { println ! ("Valid") } } else { { println ! ("Invalid") } } ; if let Some (s) = (& result as & dyn std :: any ::...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid") } } else { { println ! ("Invalid") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid") } } else { println ! ("Invalid") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error: aborting due to 1 previous error; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `status` in this scope
 --> /tmp/.tmpl7ROlO/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match status { 0i32 => println ! ("Error") , 1i32 => println ! ("Warning") ...
  |                                                                     ^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpl7ROlO/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match status { 0i32 => println ! ("Error") , 1i32 => println ! ("Warning") ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `age` in this scope
 --> /tmp/.tmpllgxQM/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match age { 0i32 => println ! ("Invalid age") , 1i32 ..= 17i32 => println !...
  |                                                                     ^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpllgxQM/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match age { 0i32 => println ! ("Invalid age") , 1i32 ..= 17i32 => println !...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 7 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `input` in this scope
 --> /tmp/.tmpvQiePi/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed") } } els...
  |                                                                  ^^^^^ not found in this scope

error[E0425]: cannot find value `input` in this scope
 --> /tmp/.tmpvQiePi/main.rs:1:159
  |
1 | ...ive input not allowed") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_re...
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpvQiePi/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed") } } els...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpvQiePi/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed") } } els...
  |                                                                                 ^^                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { println ! ("Error: Negative input not allowed") } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpvQiePi/main.rs:1:142
  |
1 | ...ln ! ("Error: Negative input not allowed") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any ::...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed") } } else { process_input (input) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `process_input` in this scope
 --> /tmp/.tmpvQiePi/main.rs:1:144
  |
1 | ...rror: Negative input not allowed") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . ...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 8 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `score` in this scope
 --> /tmp/.tmpJS97Jk/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match score { 0i32 ..= 59i32 => println ! ("Fail") , 60i32 ..= 79i32 => pri...
  |                                                                     ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpJS97Jk/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match score { 0i32 ..= 59i32 => println ! ("Fail") , 60i32 ..= 79i32 => pri...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 9 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `system_ready` in this scope
 --> /tmp/.tmpBtmbvp/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational") } } else { { println !...
  |                                                                  ^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpBtmbvp/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational") } } else { { println !...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpBtmbvp/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational") } } else { { println !...
  |                                                                                 ^^                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational") } } else { { println ! ("System not ready") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if system_ready { println ! ("System operational") } else { { println ! ("System not ready") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpBtmbvp/main.rs:1:127
  |
1 | ...y { { println ! ("System operational") } } else { { println ! ("System not ready") } } ; if let Some (s) = (& result as & dyn std :: a...
  |                                                      ^^                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational") } } else { { println ! ("System not ready") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational") } } else { println ! ("System not ready") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error: aborting due to 1 previous error; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch08-00-advanced-functions-tdd example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-advanced-functions-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `Type` in this scope
 --> /tmp/.tmpTHTbsD/main.rs:1:60
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |                                                            ^^^^ not found in this scope

error[E0412]: cannot find type `ResultType` in this scope
 --> /tmp/.tmpTHTbsD/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |                                                                     ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `condition1` in this scope
 --> /tmp/.tmpTHTbsD/main.rs:1:87
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |                                                                                       ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `result1` in this scope
 --> /tmp/.tmpTHTbsD/main.rs:1:109
  |
1 | ...: Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn m...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `condition2` in this scope
 --> /tmp/.tmpTHTbsD/main.rs:1:126
  |
1 | ...ype { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `result2` in this scope
 --> /tmp/.tmpTHTbsD/main.rs:1:148
  |
1 | ... { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `default_result` in this scope
 --> /tmp/.tmpTHTbsD/main.rs:1:169
  |
1 | ...; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpTHTbsD/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpTHTbsD/main.rs:1:100
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |                                                                                                    ^^              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
1 + use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { return result1 } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTHTbsD/main.rs:1:139
  |
1 | ... { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |                                                              ^^              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
1 + use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { return result2 } ; return default_result } } fn main () { }
  |

error: aborting due to 7 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch08-00-advanced-functions-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `Type` in this scope
 --> /tmp/.tmpODki6e/main.rs:1:60
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |                                                            ^^^^ not found in this scope

error[E0412]: cannot find type `Type` in this scope
 --> /tmp/.tmpODki6e/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |                                                                     ^^^^ not found in this scope

error[E0425]: cannot find value `base_condition` in this scope
 --> /tmp/.tmpODki6e/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |                                                                                 ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `base_value` in this scope
 --> /tmp/.tmpODki6e/main.rs:1:107
  |
1 | ... : Type) -> Type { { if base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
  |                                                      ^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpODki6e/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpODki6e/main.rs:1:98
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |                                                                                                  ^^                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
1 + use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { return base_value } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
  |

error[E0425]: cannot find function `reduce` in this scope
 --> /tmp/.tmpODki6e/main.rs:1:160
  |
1 | ...ase_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
  |                                                        ^^^^^^ not found in this scope

error[E0425]: cannot find function `combine` in this scope
 --> /tmp/.tmpODki6e/main.rs:1:131
  |
1 | ... base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 6 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch08-00-advanced-functions-tdd example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch04-00-command-line-tools example 1 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpNoLjmo/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { println ! ("Word Counter Tool") ; print ! ("Enter filename: ") ; let filename = { let mu...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpNoLjmo/main.rs:1:359
  |
1 | .... ends_with ('\r') { input . pop () ; } } input } ; ; let content = read_file (filename) ; ; let words = content . split_whitespace ()...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpNoLjmo/main.rs:1:398
  |
1 | ... } input } ; ; let content = read_file (filename) ; ; let words = content . split_whitespace () ; ; let word_count = words . len () ; ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpNoLjmo/main.rs:1:444
  |
1 | ...me) ; ; let words = content . split_whitespace () ; ; let word_count = words . len () ; ; let char_count = content . len () ; ; let li...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpNoLjmo/main.rs:1:480
  |
1 | ...whitespace () ; ; let word_count = words . len () ; ; let char_count = content . len () ; ; let line_count = content . lines () . len ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpNoLjmo/main.rs:1:518
  |
1 | ...ds . len () ; ; let char_count = content . len () ; ; let line_count = content . lines () . len () ; ; println ! ("{:?}" , format ! ("...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpNoLjmo/main.rs:1:567
  |
1 | ... ; ; let line_count = content . lines () . len () ; ; println ! ("{:?}" , format ! ("{}{}" , "\nFile Analysis: " , filename)) ; printl...
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpNoLjmo/main.rs:1:375
  |
1 | ... { input . pop () ; } } input } ; ; let content = read_file (filename) ; ; let words = content . split_whitespace () ; ; let word_coun...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 7 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 2 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpwcYlAF/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let name = { print ! ("{}" , "What's your name? ") ; std :: io :: Write :: flush (& mut ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpwcYlAF/main.rs:1:403
  |
1 | .... ends_with ('\r') { input . pop () ; } } input } ; ; let age = { print ! ("{}" , "How old are you? ") ; std :: io :: Write :: flush (...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpwcYlAF/main.rs:1:766
  |
1 | ...h ('\r') { input . pop () ; } } input } . to_i () ; ; let is_student = { print ! ("{}" , "Are you a student? (y/n) ") ; std :: io :: W...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpwcYlAF/main.rs:1:1141
  |
1 | ...with ('\r') { input . pop () ; } } input } == "y" ; ; }
  |                                                        ^ help: remove this semicolon

error[E0599]: no method named `to_i` found for struct `String` in the current scope
 --> /tmp/.tmpwcYlAF/main.rs:1:756
  |
1 | ...ends_with ('\r') { input . pop () ; } } input } . to_i () ; ; let is_student = { print ! ("{}" , "Are you a student? (y/n) ") ; std ::...
  |                                                      ^^^^ method not found in `String`

error: aborting due to 1 previous error; 4 warnings emitted

For more information about this error, try `rustc --explain E0599`.



=== ch04-00-command-line-tools example 3 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmps3Sknt/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let content = read_file ("data.txt" . to_string ()) ; ; let lines = read_lines ("data.tx...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmps3Sknt/main.rs:1:104
  |
1 | use std :: collections :: HashMap ; fn main () { let content = read_file ("data.txt" . to_string ()) ; ; let lines = read_lines ("data.tx...
  |                                                                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmps3Sknt/main.rs:1:159
  |
1 | ...et lines = read_lines ("data.txt" . to_string ()) ; ; write_file ("output.txt" . to_string () , "Hello, World!" . to_string ()) ; appe...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmps3Sknt/main.rs:1:386
  |
1 | ...xists = file_exists ("config.txt" . to_string ()) ; ; let size = file_size ("data.txt" . to_string ()) ; ; }
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmps3Sknt/main.rs:1:439
  |
1 | ... let size = file_size ("data.txt" . to_string ()) ; ; }
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmps3Sknt/main.rs:1:64
  |
1 | use std :: collections :: HashMap ; fn main () { let content = read_file ("data.txt" . to_string ()) ; ; let lines = read_lines ("data.tx...
  |                                                                ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_lines` in this scope
 --> /tmp/.tmps3Sknt/main.rs:1:118
  |
1 | ..._file ("data.txt" . to_string ()) ; ; let lines = read_lines ("data.txt" . to_string ()) ; ; write_file ("output.txt" . to_string () ,...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmps3Sknt/main.rs:1:161
  |
1 | ...ines = read_lines ("data.txt" . to_string ()) ; ; write_file ("output.txt" . to_string () , "Hello, World!" . to_string ()) ; append_f...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `timestamp` in this scope
 --> /tmp/.tmps3Sknt/main.rs:1:312
  |
1 | ...to_string () , format ! ("{}{}" , "New entry: " , timestamp ())) ; let exists = file_exists ("config.txt" . to_string ()) ; ; let size...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `append_file` in this scope
 --> /tmp/.tmps3Sknt/main.rs:1:237
  |
1 | ...to_string () , "Hello, World!" . to_string ()) ; append_file ("log.txt" . to_string () , format ! ("{}{}" , "New entry: " , timestamp ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmps3Sknt/main.rs:1:342
  |
1 | ... , "New entry: " , timestamp ())) ; let exists = file_exists ("config.txt" . to_string ()) ; ; let size = file_size ("data.txt" . to_s...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_size` in this scope
 --> /tmp/.tmps3Sknt/main.rs:1:399
  |
1 | ...ists ("config.txt" . to_string ()) ; ; let size = file_size ("data.txt" . to_string ()) ; ; }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 7 previous errors; 5 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 4 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpU4OaBk/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let args = command_args () ; ; let program_name = args [0i32 as usize] ; ; let first_fil...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpU4OaBk/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn main () { let args = command_args () ; ; let program_name = args [0i32 as usize] ; ; let first_fil...
  |                                                                               ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpU4OaBk/main.rs:1:123
  |
1 | ...gs () ; ; let program_name = args [0i32 as usize] ; ; let first_file = args [1i32 as usize] ; ; let second_file = args [2i32 as usize]...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpU4OaBk/main.rs:1:165
  |
1 | ... usize] ; ; let first_file = args [1i32 as usize] ; ; let second_file = args [2i32 as usize] ; ; println ! ("{:?}" , format ! ("{}{}" ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpU4OaBk/main.rs:1:208
  |
1 | ...usize] ; ; let second_file = args [2i32 as usize] ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Pr...
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `command_args` in this scope
 --> /tmp/.tmpU4OaBk/main.rs:1:61
  |
1 | use std :: collections :: HashMap ; fn main () { let args = command_args () ; ; let program_name = args [0i32 as usize] ; ; let first_fil...
  |                                                             ^^^^^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 5 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `exit` in this scope
 --> /tmp/.tmpOfKqZF/main.rs:1:585
  |
1 | ..." , "Error: File '" , filename) , "' not found!")) ; exit (1i32) } } ; let content = read_file (filename) ; ; let lines = content . li...
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::process::exit;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpOfKqZF/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { println ! ("=== Text Processor ===") ; let filename = { print ! ("{}" , "Enter filename:...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpOfKqZF/main.rs:1:444
  |
1 | .... ends_with ('\r') { input . pop () ; } } input } ; ; if ! file_exists (filename) { { println ! ("{:?}" , format ! ("{}{}" , format ! ...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpOfKqZF/main.rs:1:640
  |
1 | ...t (1i32) } } ; let content = read_file (filename) ; ; let lines = content . lines () ; ; println ! ("\nChoose operation:") ; println !...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpOfKqZF/main.rs:1:675
  |
1 | ...ile (filename) ; ; let lines = content . lines () ; ; println ! ("\nChoose operation:") ; println ! ("1. Count lines") ; println ! ("2...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpOfKqZF/main.rs:1:1225
  |
1 | ...h ('\r') { input . pop () ; } } input } . to_i () ; ; let result = match choice { 1i32 => { println ! ("{:?}" , format ! ("{}{}" , "To...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpOfKqZF/main.rs:1:2060
  |
1 | .... ends_with ('\r') { input . pop () ; } } input } ; ; let new_content = content . replace (find , replace) ; ; let output_file = filen...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpOfKqZF/main.rs:1:2117
  |
1 | ... new_content = content . replace (find , replace) ; ; let output_file = filename . replace (".txt" , "_modified.txt") ; ; write_file (...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpOfKqZF/main.rs:1:2185
  |
1 | ...e = filename . replace (".txt" , "_modified.txt") ; ; write_file (output_file , new_content) ; println ! ("{:?}" , format ! ("{}{}" , ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpOfKqZF/main.rs:1:2429
  |
1 | ...file = filename . replace (".txt" , "_upper.txt") ; ; write_file (output_file , upper_content) ; println ! ("{:?}" , format ! ("{}{}" ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpOfKqZF/main.rs:1:2735
  |
1 | ...{ let clean_content = clean_lines . join (& "\n") ; ; let output_file = filename . replace (".txt" , "_clean.txt") ; ; write_file (out...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpOfKqZF/main.rs:1:2800
  |
1 | ...file = filename . replace (".txt" , "_clean.txt") ; ; write_file (output_file , clean_content) ; println ! ("{:?}" , format ! ("{}{}" ...
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpOfKqZF/main.rs:1:451
  |
1 | ...h ('\r') { input . pop () ; } } input } ; ; if ! file_exists (filename) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpOfKqZF/main.rs:1:617
  |
1 | ...' not found!")) ; exit (1i32) } } ; let content = read_file (filename) ; ; let lines = content . lines () ; ; println ! ("\nChoose ope...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0599]: no method named `to_i` found for struct `String` in the current scope
 --> /tmp/.tmpOfKqZF/main.rs:1:1215
  |
1 | ...ends_with ('\r') { input . pop () ; } } input } . to_i () ; ; let result = match choice { 1i32 => { println ! ("{:?}" , format ! ("{}{...
  |                                                      ^^^^ method not found in `String`

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpOfKqZF/main.rs:1:2187
  |
1 | ...filename . replace (".txt" , "_modified.txt") ; ; write_file (output_file , new_content) ; println ! ("{:?}" , format ! ("{}{}" , "Sav...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpOfKqZF/main.rs:1:2431
  |
1 | ... = filename . replace (".txt" , "_upper.txt") ; ; write_file (output_file , upper_content) ; println ! ("{:?}" , format ! ("{}{}" , "S...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpOfKqZF/main.rs:1:2802
  |
1 | ... = filename . replace (".txt" , "_clean.txt") ; ; write_file (output_file , clean_content) ; println ! ("{:?}" , format ! ("{}{}" , "S...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpOfKqZF/main.rs:1:3100
  |
1 | .... contains ("&str") => println ! ("{}" , result) , _ => println ! ("{:?}" , result) } }
  |                                       --    ^^^^^^ `()` cannot be formatted with the default formatter
  |                                       |
  |                                       required by this formatting parameter
  |
  = help: the trait `std::fmt::Display` is not implemented for `()`
  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 8 previous errors; 11 warnings emitted

Some errors have detailed explanations: E0277, E0425, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch04-00-command-line-tools example 6 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpsIhChT/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { println ! ("=== Log Analyzer ===") ; let log_file = { print ! ("{}" , "Enter log file pa...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpsIhChT/main.rs:1:447
  |
1 | .... ends_with ('\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; le...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpsIhChT/main.rs:1:485
  |
1 | ...} } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_c...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpsIhChT/main.rs:1:525
  |
1 | ...log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpsIhChT/main.rs:1:554
  |
1 | ...sts = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpsIhChT/main.rs:1:581
  |
1 | ...t success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (" 200 "...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpsIhChT/main.rs:1:612
  |
1 | ...error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } }...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpsIhChT/main.rs:1:901
  |
1 | ...percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_perc...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpsIhChT/main.rs:1:963
  |
1 | ...r_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpsIhChT/main.rs:1:1033
  |
1 | ...rcent = not_found_count * 100i32 / total_requests ; ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpsIhChT/main.rs:1:1764
  |
1 | ...ercent . to_s ()) , "%)")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [times...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpsIhChT/main.rs:1:1984
  |
1 | ...usiest_hour = hour_counts . max_by_value () . key ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , bus...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpsIhChT/main.rs:1:634
  |
1 | ... { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ...
  |       ^^                                                                                                                                                                                                  ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { println ! ("=== Log Analyzer ===") ; let log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") , success_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") , not_found_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") , error_percent . to_s ()) , "%)")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) ; }
1 + use std :: collections :: HashMap ; fn main () { println ! ("=== Log Analyzer ===") ; let log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") , success_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") , not_found_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") , error_percent . to_s ()) , "%)")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpsIhChT/main.rs:1:667
  |
1 | ... for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_co...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { println ! ("=== Log Analyzer ===") ; let log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") , success_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") , not_found_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") , error_percent . to_s ()) , "%)")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) ; }
1 + use std :: collections :: HashMap ; fn main () { println ! ("=== Log Analyzer ===") ; let log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (" 200 ") { success_count += 1i32 } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") , success_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") , not_found_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") , error_percent . to_s ()) , "%)")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpsIhChT/main.rs:1:733
  |
1 | ...nt += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count...
  |                                                         ^^                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { println ! ("=== Log Analyzer ===") ; let log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") , success_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") , not_found_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") , error_percent . to_s ()) , "%)")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) ; }
1 + use std :: collections :: HashMap ; fn main () { println ! ("=== Log Analyzer ===") ; let log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { not_found_count += 1i32 } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") , success_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") , not_found_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") , error_percent . to_s ()) , "%)")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpsIhChT/main.rs:1:801
  |
1 | ...ount += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i3...
  |                                                           ^^                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { println ! ("=== Log Analyzer ===") ; let log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") , success_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") , not_found_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") , error_percent . to_s ()) , "%)")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) ; }
1 + use std :: collections :: HashMap ; fn main () { println ! ("=== Log Analyzer ===") ; let log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { error_count += 1i32 } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") , success_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") , not_found_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") , error_percent . to_s ()) , "%)")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpsIhChT/main.rs:1:1786
  |
1 | ... { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ...
  |       ^^                                                                                                                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { println ! ("=== Log Analyzer ===") ; let log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") , success_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") , not_found_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") , error_percent . to_s ()) , "%)")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) ; }
1 + use std :: collections :: HashMap ; fn main () { println ! ("=== Log Analyzer ===") ; let log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") , success_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") , not_found_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") , error_percent . to_s ()) , "%)")) ; let hour_counts = () ; ; for line in lines { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) ; }
  |

error[E0425]: cannot find function `read_lines` in this scope
 --> /tmp/.tmpsIhChT/main.rs:1:461
  |
1 | ...') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count ...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpsIhChT/main.rs:1:1299
  |
1 | ...mat ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") , success_percent . to_s ()) , "%)")) ; println ! ("{:?}" , forma...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpsIhChT/main.rs:1:1336
  |
1 | ...uccess_count . to_s ()) , " (") , success_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , form...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpsIhChT/main.rs:1:1492
  |
1 | ...! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") , not_found_percent . to_s ()) , "%)")) ; println ! ("{:?}" , for...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpsIhChT/main.rs:1:1531
  |
1 | ...ound_count . to_s ()) , " (") , not_found_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , form...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpsIhChT/main.rs:1:1686
  |
1 | ... ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") , error_percent . to_s ()) , "%)")) ; let hour_counts = () ; ; fo...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpsIhChT/main.rs:1:1721
  |
1 | ... , error_count . to_s ()) , " (") , error_percent . to_s ()) , "%)")) ; let hour_counts = () ; ; for line in lines { { { let timestamp...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `extract_hour` in this scope
 --> /tmp/.tmpsIhChT/main.rs:1:1806
  |
1 | ...= () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `get` found for unit type `()` in the current scope
    --> /tmp/.tmpsIhChT/main.rs:1:1877
     |
1    | ...t_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = ...
     |                                                                     ^^^
     |
help: there is a method `ge` with a similar name, but with different arguments
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1438:5
     |
1438 |     fn ge(&self, other: &Rhs) -> bool {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `max_by_value` found for unit type `()` in the current scope
 --> /tmp/.tmpsIhChT/main.rs:1:1960
  |
1 | ...+ 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "B...
  |                                                    ^^^^^^^^^^^^ method not found in `()`

error: aborting due to 10 previous errors; 17 warnings emitted

Some errors have detailed explanations: E0425, E0599.
For more information about an error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 7 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmplpky4e/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { println ! ("=== Batch File Renamer ===") ; let directory = { print ! ("{}" , "Enter dire...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmplpky4e/main.rs:1:455
  |
1 | .... ends_with ('\r') { input . pop () ; } } input } ; ; let pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write ...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmplpky4e/main.rs:1:818
  |
1 | .... ends_with ('\r') { input . pop () ; } } input } ; ; let replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmplpky4e/main.rs:1:1181
  |
1 | .... ends_with ('\r') { input . pop () ; } } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmplpky4e/main.rs:1:1220
  |
1 | ... } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { { if file . contains (pattern) ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmplpky4e/main.rs:1:1249
  |
1 | ...st_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { { if file . contains (pattern) { { { let new_name = file . r...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmplpky4e/main.rs:1:1271
  |
1 | ... { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") , new_name)) ; renamed_count += 1i32 } } else { { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { println ! ("=== Batch File Renamer ===") ; let directory = { print ! ("{}" , "Enter directory path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") , new_name)) ; renamed_count += 1i32 } } else { { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) ; }
1 + use std :: collections :: HashMap ; fn main () { println ! ("=== Batch File Renamer ===") ; let directory = { print ! ("{}" , "Enter directory path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") , new_name)) ; renamed_count += 1i32 } } else { { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmplpky4e/main.rs:1:1304
  |
1 | ... { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") , new_name)) ; renamed_count += 1i32 } } else { { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { println ! ("=== Batch File Renamer ===") ; let directory = { print ! ("{}" , "Enter directory path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") , new_name)) ; renamed_count += 1i32 } } else { { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) ; }
1 + use std :: collections :: HashMap ; fn main () { println ! ("=== Batch File Renamer ===") ; let directory = { print ! ("{}" , "Enter directory path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { { if file . contains (pattern) { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") , new_name)) ; renamed_count += 1i32 } } else { { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmplpky4e/main.rs:1:1412
  |
1 | ...) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , n...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmplpky4e/main.rs:1:1464
  |
1 | ...; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmplpky4e/main.rs:1:1662
  |
1 | ...named_count += 1i32 } } else { { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ; println ! ("{:...
  |                                   ^^                                                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { println ! ("=== Batch File Renamer ===") ; let directory = { print ! ("{}" , "Enter directory path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") , new_name)) ; renamed_count += 1i32 } } else { { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) ; }
1 + use std :: collections :: HashMap ; fn main () { println ! ("=== Batch File Renamer ===") ; let directory = { print ! ("{}" , "Enter directory path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") , new_name)) ; renamed_count += 1i32 } } else { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) ; }
  |

error[E0425]: cannot find function `list_files` in this scope
 --> /tmp/.tmplpky4e/main.rs:1:1195
  |
1 | ...') { input . pop () ; } } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { { if fil...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmplpky4e/main.rs:1:1381
  |
1 | ...eplace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ;...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmplpky4e/main.rs:1:1429
  |
1 | ...ory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! ("{:?}" , forma...
  |                                   ^^^^^^^^^ help: a local variable with a similar name exists: `old_path`

error[E0425]: cannot find function `rename_file` in this scope
 --> /tmp/.tmplpky4e/main.rs:1:1469
  |
1 | ...w_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format !...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmplpky4e/main.rs:1:1840
  |
1 | ..., format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) ; }
  |                                                        ^^^^ method not found in `i32`

error: aborting due to 5 previous errors; 11 warnings emitted

Some errors have detailed explanations: E0425, E0599.
For more information about an error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 8 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch04-00-command-line-tools example 9 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `sleep` in this scope
 --> /tmp/.tmpFD0oN9/main.rs:1:860
  |
1 | ... to_s ()) , "%] ") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } ...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::sleep;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpFD0oN9/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ;...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpFD0oN9/main.rs:1:542
  |
1 | ... { { { let total = files . len () ; { let mut i = 0i32 ; ; while i < total { { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress (files : String) { { { let total = files . len () ; { let mut i = 0i32 ; ; while i < total { { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress (files : String) { { let total = files . len () ; { let mut i = 0i32 ; ; while i < total { { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } fn main () { }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpFD0oN9/main.rs:1:596
  |
1 | ...{ let total = files . len () ; { let mut i = 0i32 ; ; while i < total { { { let file = files [i as usize] ; { let progress = (i + 1i32...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpFD0oN9/main.rs:1:616
  |
1 | ... { { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress (files : String) { { { let total = files . len () ; { let mut i = 0i32 ; ; while i < total { { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress (files : String) { { { let total = files . len () ; { let mut i = 0i32 ; ; while i < total { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } ; println ! ("\n✅ All files processed!") } } } } fn main () { }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpFD0oN9/main.rs:1:699
  |
1 | ...e] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "\rPr...
  |                                                        ^ help: remove this semicolon

error[E0308]: mismatched types
 --> /tmp/.tmpFD0oN9/main.rs:1:608
  |
1 | ... files . len () ; { let mut i = 0i32 ; ; while i < total { { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / ...
  |                                                   -   ^^^^^ expected `i32`, found `usize`
  |                                                   |
  |                                                   expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress (files : String) { { { let total = files . len () ; { let mut i = 0i32 ; ; while i < total.try_into().unwrap() { { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ++++++++++++++++++++

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpFD0oN9/main.rs:1:638
  |
1 | ... ; while i < total { { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! ("{:?}" , format ! (...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0308]: mismatched types
 --> /tmp/.tmpFD0oN9/main.rs:1:691
  |
1 | ... usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , ...
  |                                                     ^^^^^ expected `i32`, found `usize`

error[E0277]: cannot divide `i32` by `usize`
 --> /tmp/.tmpFD0oN9/main.rs:1:689
  |
1 | ...s usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" ,...
  |                                                    ^ no implementation for `i32 / usize`
  |
  = help: the trait `Div<usize>` is not implemented for `i32`
  = help: the following other types implement trait `Div<Rhs>`:
            `&i32` implements `Div<i32>`
            `&i32` implements `Div`
            `i32` implements `Div<&i32>`
            `i32` implements `Div`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpFD0oN9/main.rs:1:809
  |
1 | ...format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 }...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `process_file` in this scope
 --> /tmp/.tmpFD0oN9/main.rs:1:838
  |
1 | ...... [" , progress . to_s ()) , "%] ") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All file...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error: aborting due to 7 previous errors; 5 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0425, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch04-00-command-line-tools example 10 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp8bGPDG/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; ; l...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp8bGPDG/main.rs:1:50
  |
1 | ... { { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {:?} {}" , "File has" , lines , "lines") } } } }
  |       ^^                                                                                                                                                                                                                                                                                      ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {:?} {}" , "File has" , lines , "lines") } } } }
1 + use std :: collections :: HashMap ; fn main () { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {:?} {}" , "File has" , lines , "lines") } } }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmp8bGPDG/main.rs:1:135
  |
1 | ...\nline 3" . to_string () ; { let mut lines = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len () { { if content [i as usize] == '...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmp8bGPDG/main.rs:1:156
  |
1 | ... () ; { let mut lines = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len () { { if content [i as usize] == '\n' { { lines = lines...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmp8bGPDG/main.rs:1:223
  |
1 | ...content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {:?} {}" , "File...
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {:?} {}" , "File has" , lines , "lines") } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len () { { if content [i as usize] == '\n' { lines = lines + 1i32 } ; i = i + 1i32 } } ; println ! ("{} {:?} {}" , "File has" , lines , "lines") } } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp8bGPDG/main.rs:1:168
  |
1 | ...nes = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = ...
  |                                              -   ^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                              |
  |                                              expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len ().try_into().unwrap() { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {:?} {}" , "File has" , lines , "lines") } } } }
  |                                                                                                                                                                                        ++++++++++++++++++++

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmp8bGPDG/main.rs:1:201
  |
1 | ...while i < content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {:?} {...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error: aborting due to 2 previous errors; 5 warnings emitted

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.



=== ch04-00-command-line-tools example 11 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `TASK_FILE` in this scope
 --> /tmp/.tmpphnukZ/main.rs:1:288
  |
1 | ...) } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `TASK_FILE` in this scope
 --> /tmp/.tmpphnukZ/main.rs:1:322
  |
1 | ...if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `TASK_FILE` in this scope
 --> /tmp/.tmpphnukZ/main.rs:1:453
  |
1 | ...let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty ()...
  |                                                      ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpphnukZ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpphnukZ/main.rs:1:301
  |
1 | ..._tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : Str...
  |                                                      ^^                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { return read_lines (TASK_FILE) } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpphnukZ/main.rs:1:399
  |
1 | ...s (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : St...
  |                                ^^                                                                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpphnukZ/main.rs:1:730
  |
1 | ...n () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpphnukZ/main.rs:1:759
  |
1 | ... { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } }...
  |       ^^                                                                                                                                                                                                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpphnukZ/main.rs:1:878
  |
1 | ..._with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , "....
  |                                                         ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpphnukZ/main.rs:1:840
  |
1 | ...s [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}...
  |                                                                   ^^      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { "DONE" } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpphnukZ/main.rs:1:860
  |
1 | ... status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}"...
  |                                                                 ^^         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { "PENDING" } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpphnukZ/main.rs:1:1029
  |
1 | ... { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpphnukZ/main.rs:1:2141
  |
1 | ...) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" ...
  |                                                    ^^                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { println ! ("❌ Invalid task number") } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpphnukZ/main.rs:1:2247
  |
1 | ...n () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! (...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpphnukZ/main.rs:1:2277
  |
1 | ...txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; ...
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpphnukZ/main.rs:1:275
  |
1 | ...! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } f...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_lines` in this scope
 --> /tmp/.tmpphnukZ/main.rs:1:310
  |
1 | ... -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0599]: no method named `join` found for struct `String` in the current scope
 --> /tmp/.tmpphnukZ/main.rs:1:425
  |
1 | ...asks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String...
  |                                                      ^^^^ method not found in `String`

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpphnukZ/main.rs:1:441
  |
1 | ...> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks ....
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0599]: no method named `to_s` found for type `usize` in the current scope
 --> /tmp/.tmpphnukZ/main.rs:1:685
  |
1 | ... ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let ta...
  |                                                        ^^^^ method not found in `usize`

error[E0308]: mismatched types
 --> /tmp/.tmpphnukZ/main.rs:1:742
  |
1 | ... " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_wi...
  |                                               -   ^^^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                               |
  |                                               expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len ().try_into().unwrap() { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ++++++++++++++++++++

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpphnukZ/main.rs:1:781
  |
1 | ...i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" }...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpphnukZ/main.rs:1:949
  |
1 | ... , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { ...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `push` found for type `i32` in the current scope
 --> /tmp/.tmpphnukZ/main.rs:1:1409
  |
1 | ...h ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task...
  |                                                        ^^^^ method not found in `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpphnukZ/main.rs:1:1466
  |
1 | ...! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (...
  |                                     ----------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                     |           |
  |                                     |           expected `String`, found `i32`
  |                                     arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpphnukZ/main.rs:1:362
  |
1 | ... read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; wr...
  |                                                         ^^^^^^^^^^  --------------

error[E0308]: mismatched types
 --> /tmp/.tmpphnukZ/main.rs:1:1558
  |
1 | ...complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: ...
  |                                    ----------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                    |           |
  |                                    |           expected `String`, found `i32`
  |                                    arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpphnukZ/main.rs:1:483
  |
1 | ...(& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No task...
  |                                                         ^^^^^^^^^^  --------------

error[E0599]: no method named `to_i` found for struct `String` in the current scope
 --> /tmp/.tmpphnukZ/main.rs:1:1941
  |
1 | ...ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usiz...
  |                                                      ^^^^ method not found in `String`

error[E0599]: no method named `len` found for type `i32` in the current scope
    --> /tmp/.tmpphnukZ/main.rs:1:1994
     |
1    | ...} input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (...
     |                                                                     ^^^
     |
help: there is a method `le` with a similar name, but with different arguments
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1402:5
     |
1402 |     fn le(&self, other: &Rhs) -> bool {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
 --> /tmp/.tmpphnukZ/main.rs:1:2089
  |
1 | ... usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } ...
  |                                      ----------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                      |           |
  |                                      |           expected `String`, found `i32`
  |                                      arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpphnukZ/main.rs:1:362
  |
1 | ... read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; wr...
  |                                                         ^^^^^^^^^^  --------------

error[E0308]: mismatched types
 --> /tmp/.tmpphnukZ/main.rs:1:2674
  |
1 | ...'\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (task...
  |                                                 ------   ^^^ expected `String`, found `&str`
  |                                                 |
  |                                                 this expression has type `String`

error[E0308]: mismatched types
 --> /tmp/.tmpphnukZ/main.rs:1:2702
  |
1 | .... pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { ...
  |                                   ------                               ^^^ expected `String`, found `&str`
  |                                   |
  |                                   this expression has type `String`

error[E0308]: mismatched types
 --> /tmp/.tmpphnukZ/main.rs:1:2728
  |
1 | ...} input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (t...
  |                      ------ this expression has type `String`                       ^^^ expected `String`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpphnukZ/main.rs:1:2759
  |
1 | ...nput } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (task...
  |                   ------ this expression has type `String`                                                      ^^^ expected `String`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpphnukZ/main.rs:1:3318
  |
1 | ...ch choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" =>...
  |       ------ this expression has type `String`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^^^ expected `String`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpphnukZ/main.rs:1:2693
  |
1 | ...input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tas...
  |                                    ----------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                    |           |
  |                                    |           expected `String`, found `i32`
  |                                    arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpphnukZ/main.rs:1:483
  |
1 | ...(& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No task...
  |                                                         ^^^^^^^^^^  --------------

error[E0308]: mismatched types
 --> /tmp/.tmpphnukZ/main.rs:1:2780
  |
1 | ...omplete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :...
  |                                    ----------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                    |           |
  |                                    |           expected `String`, found `i32`
  |                                    arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpphnukZ/main.rs:1:483
  |
1 | ...(& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No task...
  |                                                         ^^^^^^^^^^  --------------

error[E0599]: no method named `to_i` found for struct `String` in the current scope
 --> /tmp/.tmpphnukZ/main.rs:1:3159
  |
1 | ...ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (inde...
  |                                                      ^^^^ method not found in `String`

error[E0599]: no method named `len` found for type `i32` in the current scope
    --> /tmp/.tmpphnukZ/main.rs:1:3212
     |
1    | ...} input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("...
     |                                                                     ^^^
     |
help: there is a method `le` with a similar name, but with different arguments
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1402:5
     |
1402 |     fn le(&self, other: &Rhs) -> bool {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `remove` found for type `i32` in the current scope
 --> /tmp/.tmpphnukZ/main.rs:1:3231
  |
1 | ...- 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task dele...
  |                                                                    ^^^^^^
  |
help: there is a method `rem` with a similar name
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . rem (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpphnukZ/main.rs:1:3260
  |
1 | ...() { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!")...
  |                                    ----------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                    |           |
  |                                    |           expected `String`, found `i32`
  |                                    arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpphnukZ/main.rs:1:362
  |
1 | ... read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; wr...
  |                                                         ^^^^^^^^^^  --------------

error: aborting due to 28 previous errors; 12 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0425, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch04-00-command-line-tools example 14 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found `let` statement
 --> /tmp/.tmpF1pOyp/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let data = read_file ("/Users/noah/Desktop/data.txt" . to_string ()) ; ; if...
  |                                                               ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpF1pOyp/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let data = read_file ("/Users/noah/Desktop/data.txt" . to_string ()) ; ; if...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpF1pOyp/main.rs:1:134
  |
1 | ...e ("/Users/noah/Desktop/data.txt" . to_string ()) ; ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < Stri...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpF1pOyp/main.rs:1:74
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let data = read_file ("/Users/noah/Desktop/data.txt" . to_string ()) ; ; if...
  |                                                                          ^^^^^^^^^ not found in this scope

error: aborting due to 2 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch03-00-functions-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `return_type` in this scope
 --> /tmp/.tmpe3khe3/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }
  |                                                                               ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `return_expression` in this scope
 --> /tmp/.tmpe3khe3/main.rs:1:95
  |
1 | use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }
  |                                                                                               ^^^^^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpe3khe3/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpe3khe3/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }
  |                                                                                             ^^                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }
1 + use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { return_expression } fn main () { }
  |

error: aborting due to 2 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch11-00-file-operations-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `DataType` in this scope
 --> /tmp/.tmpGg82ck/main.rs:1:56
  |
1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
  |                                                        ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `default_value` in this scope
 --> /tmp/.tmpGg82ck/main.rs:1:76
  |
1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
  |                                                                            ^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpGg82ck/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpGg82ck/main.rs:1:67
  |
1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
  |                                                                   ^^                    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
1 + use std :: collections :: HashMap ; fn read_data () -> DataType { return default_value } fn main () { }
  |

error: aborting due to 2 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch11-00-file-operations-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `DataType` in this scope
 --> /tmp/.tmpoSttq3/main.rs:1:60
  |
1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...
  |                                                            ^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpoSttq3/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpoSttq3/main.rs:1:101
  |
1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...
  |                                                                                                     ^^           ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } fn main () { }
1 + use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { return true } ; return false } } fn main () { }
  |

error[E0425]: cannot find function `valid` in this scope
 --> /tmp/.tmpoSttq3/main.rs:1:85
  |
1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...
  |                                                                                     ^^^^^ not found in this scope

error: aborting due to 2 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch11-00-file-operations-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `ConfigType` in this scope
 --> /tmp/.tmpTN9DT5/main.rs:1:58
  |
1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...
  |                                                          ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `default_config` in this scope
 --> /tmp/.tmpTN9DT5/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...
  |                                                                                ^^^^^^^^^^^^^^ not found in this scope

error[E0412]: cannot find type `ConfigType` in this scope
 --> /tmp/.tmpTN9DT5/main.rs:1:124
  |
1 | ...eturn default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
  |                                                      ^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpTN9DT5/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpTN9DT5/main.rs:1:71
  |
1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...
  |                                                                       ^^                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
1 + use std :: collections :: HashMap ; fn load_config () -> ConfigType { return default_config } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpTN9DT5/main.rs:1:146
  |
1 | ...g } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
  |                                                         ^^                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
1 + use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { return validate (config) } fn main () { }
  |

error[E0425]: cannot find function `validate` in this scope
 --> /tmp/.tmpTN9DT5/main.rs:1:155
  |
1 | ...ve_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
  |                                                       ^^^^^^^^ not found in this scope

error: aborting due to 4 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch11-00-file-operations-tdd example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-control-flow-tdd example 8 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpXAE3Lx/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let x = 10i32 ; ; let y = 5i32 ; ; let result = if x > y { { println ! ("x is greater") ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpXAE3Lx/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let x = 10i32 ; ; let y = 5i32 ; ; let result = if x > y { { println ! ("x is greater") ...
  |                                                                  ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpXAE3Lx/main.rs:1:83
  |
1 | use std :: collections :: HashMap ; fn main () { let x = 10i32 ; ; let y = 5i32 ; ; let result = if x > y { { println ! ("x is greater") ...
  |                                                                                   ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpXAE3Lx/main.rs:1:109
  |
1 | ... 10i32 ; ; let y = 5i32 ; ; let result = if x > y { { println ! ("x is greater") } } else { if x < y { { println ! ("y is greater") } ...
  |                                                        ^^                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let x = 10i32 ; ; let y = 5i32 ; ; let result = if x > y { { println ! ("x is greater") } } else { if x < y { { println ! ("y is greater") } } else { { println ! ("they are equal") } } } ; match std :: any :: type_name_of_val (& result) { name if name . contains ("String") || name . contains ("&str") => println ! ("{}" , result) , _ => println ! ("{:?}" , result) } }
1 + use std :: collections :: HashMap ; fn main () { let x = 10i32 ; ; let y = 5i32 ; ; let result = if x > y { println ! ("x is greater") } else { if x < y { { println ! ("y is greater") } } else { { println ! ("they are equal") } } } ; match std :: any :: type_name_of_val (& result) { name if name . contains ("String") || name . contains ("&str") => println ! ("{}" , result) , _ => println ! ("{:?}" , result) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXAE3Lx/main.rs:1:160
  |
1 | ... { println ! ("x is greater") } } else { if x < y { { println ! ("y is greater") } } else { { println ! ("they are equal") } } } ; mat...
  |                                                        ^^                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let x = 10i32 ; ; let y = 5i32 ; ; let result = if x > y { { println ! ("x is greater") } } else { if x < y { { println ! ("y is greater") } } else { { println ! ("they are equal") } } } ; match std :: any :: type_name_of_val (& result) { name if name . contains ("String") || name . contains ("&str") => println ! ("{}" , result) , _ => println ! ("{:?}" , result) } }
1 + use std :: collections :: HashMap ; fn main () { let x = 10i32 ; ; let y = 5i32 ; ; let result = if x > y { { println ! ("x is greater") } } else { if x < y { println ! ("y is greater") } else { { println ! ("they are equal") } } } ; match std :: any :: type_name_of_val (& result) { name if name . contains ("String") || name . contains ("&str") => println ! ("{}" , result) , _ => println ! ("{:?}" , result) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXAE3Lx/main.rs:1:200
  |
1 | ...if x < y { { println ! ("y is greater") } } else { { println ! ("they are equal") } } } ; match std :: any :: type_name_of_val (& resu...
  |                                                       ^^                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let x = 10i32 ; ; let y = 5i32 ; ; let result = if x > y { { println ! ("x is greater") } } else { if x < y { { println ! ("y is greater") } } else { { println ! ("they are equal") } } } ; match std :: any :: type_name_of_val (& result) { name if name . contains ("String") || name . contains ("&str") => println ! ("{}" , result) , _ => println ! ("{:?}" , result) } }
1 + use std :: collections :: HashMap ; fn main () { let x = 10i32 ; ; let y = 5i32 ; ; let result = if x > y { { println ! ("x is greater") } } else { if x < y { { println ! ("y is greater") } } else { println ! ("they are equal") } } ; match std :: any :: type_name_of_val (& result) { name if name . contains ("String") || name . contains ("&str") => println ! ("{}" , result) , _ => println ! ("{:?}" , result) } }
  |

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpXAE3Lx/main.rs:1:373
  |
1 | .... contains ("&str") => println ! ("{}" , result) , _ => println ! ("{:?}" , result) } }
  |                                       --    ^^^^^^ `()` cannot be formatted with the default formatter
  |                                       |
  |                                       required by this formatting parameter
  |
  = help: the trait `std::fmt::Display` is not implemented for `()`
  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 1 previous error; 6 warnings emitted

For more information about this error, try `rustc --explain E0277`.



=== ch05-00-control-flow-tdd example 10 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpEeLCBe/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let number = 2i32 ; ; let result = match number { 1i32 => println ! ("One") , 2i32 => pr...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpEeLCBe/main.rs:1:70
  |
1 | use std :: collections :: HashMap ; fn main () { let number = 2i32 ; ; let result = match number { 1i32 => println ! ("One") , 2i32 => pr...
  |                                                                      ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpEeLCBe/main.rs:1:351
  |
1 | .... contains ("&str") => println ! ("{}" , result) , _ => println ! ("{:?}" , result) } }
  |                                       --    ^^^^^^ `()` cannot be formatted with the default formatter
  |                                       |
  |                                       required by this formatting parameter
  |
  = help: the trait `std::fmt::Display` is not implemented for `()`
  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0277`.



=== ch05-00-control-flow-tdd example 11 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpjgX1MU/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let user_input = 75i32 ; ; let threshold = 50i32 ; ; let result = if user_input > thresh...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpjgX1MU/main.rs:1:75
  |
1 | use std :: collections :: HashMap ; fn main () { let user_input = 75i32 ; ; let threshold = 50i32 ; ; let result = if user_input > thresh...
  |                                                                           ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpjgX1MU/main.rs:1:101
  |
1 | use std :: collections :: HashMap ; fn main () { let user_input = 75i32 ; ; let threshold = 50i32 ; ; let result = if user_input > thresh...
  |                                                                                                     ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpjgX1MU/main.rs:1:144
  |
1 | ... = if user_input > threshold { { println ! ("{:?}" , format ! ("{}{}" , "High value: " , user_input)) } } else { { println ! ("{:?}" ,...
  |                                   ^^                                                                    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let user_input = 75i32 ; ; let threshold = 50i32 ; ; let result = if user_input > threshold { { println ! ("{:?}" , format ! ("{}{}" , "High value: " , user_input)) } } else { { println ! ("{:?}" , format ! ("{}{}" , "Normal value: " , user_input)) } } ; match std :: any :: type_name_of_val (& result) { name if name . contains ("String") || name . contains ("&str") => println ! ("{}" , result) , _ => println ! ("{:?}" , result) } }
1 + use std :: collections :: HashMap ; fn main () { let user_input = 75i32 ; ; let threshold = 50i32 ; ; let result = if user_input > threshold { println ! ("{:?}" , format ! ("{}{}" , "High value: " , user_input)) } else { { println ! ("{:?}" , format ! ("{}{}" , "Normal value: " , user_input)) } } ; match std :: any :: type_name_of_val (& result) { name if name . contains ("String") || name . contains ("&str") => println ! ("{}" , result) , _ => println ! ("{:?}" , result) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpjgX1MU/main.rs:1:226
  |
1 | ...: " , user_input)) } } else { { println ! ("{:?}" , format ! ("{}{}" , "Normal value: " , user_input)) } } ; match std :: any :: type_...
  |                                  ^^                                                                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let user_input = 75i32 ; ; let threshold = 50i32 ; ; let result = if user_input > threshold { { println ! ("{:?}" , format ! ("{}{}" , "High value: " , user_input)) } } else { { println ! ("{:?}" , format ! ("{}{}" , "Normal value: " , user_input)) } } ; match std :: any :: type_name_of_val (& result) { name if name . contains ("String") || name . contains ("&str") => println ! ("{}" , result) , _ => println ! ("{:?}" , result) } }
1 + use std :: collections :: HashMap ; fn main () { let user_input = 75i32 ; ; let threshold = 50i32 ; ; let result = if user_input > threshold { { println ! ("{:?}" , format ! ("{}{}" , "High value: " , user_input)) } } else { println ! ("{:?}" , format ! ("{}{}" , "Normal value: " , user_input)) } ; match std :: any :: type_name_of_val (& result) { name if name . contains ("String") || name . contains ("&str") => println ! ("{}" , result) , _ => println ! ("{:?}" , result) } }
  |

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpjgX1MU/main.rs:1:439
  |
1 | .... contains ("&str") => println ! ("{}" , result) , _ => println ! ("{:?}" , result) } }
  |                                       --    ^^^^^^ `()` cannot be formatted with the default formatter
  |                                       |
  |                                       required by this formatting parameter
  |
  = help: the trait `std::fmt::Display` is not implemented for `()`
  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 1 previous error; 5 warnings emitted

For more information about this error, try `rustc --explain E0277`.



=== ch05-00-control-flow-tdd example 14 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpd6j3ca/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let status_code = 200i32 ; ; let result = match status_code { 200i32 => println ! ("Succ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpd6j3ca/main.rs:1:77
  |
1 | use std :: collections :: HashMap ; fn main () { let status_code = 200i32 ; ; let result = match status_code { 200i32 => println ! ("Succ...
  |                                                                             ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpd6j3ca/main.rs:1:395
  |
1 | .... contains ("&str") => println ! ("{}" , result) , _ => println ! ("{:?}" , result) } }
  |                                       --    ^^^^^^ `()` cannot be formatted with the default formatter
  |                                       |
  |                                       required by this formatting parameter
  |
  = help: the trait `std::fmt::Display` is not implemented for `()`
  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0277`.



=== appendix-c-troubleshooting example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 6 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpzwfJcf/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let s = String :: from ("hello" . to_string ()) ; ; takes_ownership (s) ; println ! ("{:...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpzwfJcf/main.rs:1:100
  |
1 | use std :: collections :: HashMap ; fn main () { let s = String :: from ("hello" . to_string ()) ; ; takes_ownership (s) ; println ! ("{:...
  |                                                                                                    ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpzwfJcf/main.rs:1:199
  |
1 | ...; let s = String :: from ("hello" . to_string ()) ; ; takes_ownership (s . clone ()) ; println ! ("{:?}" , s) ; let s = String :: from...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpzwfJcf/main.rs:1:309
  |
1 | ...; let s = String :: from ("hello" . to_string ()) ; ; borrows_value (& s) ; println ! ("{:?}" , s) ; }
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `takes_ownership` in this scope
 --> /tmp/.tmpzwfJcf/main.rs:1:102
  |
1 | ... = String :: from ("hello" . to_string ()) ; ; takes_ownership (s) ; println ! ("{:?}" , s) ; let s = String :: from ("hello" . to_str...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `takes_ownership` in this scope
 --> /tmp/.tmpzwfJcf/main.rs:1:201
  |
1 | ... = String :: from ("hello" . to_string ()) ; ; takes_ownership (s . clone ()) ; println ! ("{:?}" , s) ; let s = String :: from ("hell...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `borrows_value` in this scope
 --> /tmp/.tmpzwfJcf/main.rs:1:311
  |
1 | ...s = String :: from ("hello" . to_string ()) ; ; borrows_value (& s) ; println ! ("{:?}" , s) ; }
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 4 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== appendix-c-troubleshooting example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 9 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpXqxhbI/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let v = vec ! [1i32 , 2i32 , 3i32] ; ; let item = v [5i32 as usize] ; ; let v = vec ! [1...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpXqxhbI/main.rs:1:87
  |
1 | use std :: collections :: HashMap ; fn main () { let v = vec ! [1i32 , 2i32 , 3i32] ; ; let item = v [5i32 as usize] ; ; let v = vec ! [1...
  |                                                                                       ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpXqxhbI/main.rs:1:120
  |
1 | ...2 , 2i32 , 3i32] ; ; let item = v [5i32 as usize] ; ; let v = vec ! [1i32 , 2i32 , 3i32] ; ; match v . get (5i32) . cloned () { Some (...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpXqxhbI/main.rs:1:159
  |
1 | ... as usize] ; ; let v = vec ! [1i32 , 2i32 , 3i32] ; ; match v . get (5i32) . cloned () { Some (item) => println ! ("{:?} {:?}" , forma...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpXqxhbI/main.rs:1:381
  |
1 | ...item) = v . get (5i32) . cloned () { { println ! ("{:?} {:?}" , format ! ("Item: {{}}") , item) } } ; match std :: any :: type_name_of...
  |                                         ^^                                                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let v = vec ! [1i32 , 2i32 , 3i32] ; ; let item = v [5i32 as usize] ; ; let v = vec ! [1i32 , 2i32 , 3i32] ; ; match v . get (5i32) . cloned () { Some (item) => println ! ("{:?} {:?}" , format ! ("Item: {{}}") , item) , None => println ! ("Index out of bounds") , } ; let result = if let Some (item) = v . get (5i32) . cloned () { { println ! ("{:?} {:?}" , format ! ("Item: {{}}") , item) } } ; match std :: any :: type_name_of_val (& result) { name if name . contains ("String") || name . contains ("&str") => println ! ("{}" , result) , _ => println ! ("{:?}" , result) } }
1 + use std :: collections :: HashMap ; fn main () { let v = vec ! [1i32 , 2i32 , 3i32] ; ; let item = v [5i32 as usize] ; ; let v = vec ! [1i32 , 2i32 , 3i32] ; ; match v . get (5i32) . cloned () { Some (item) => println ! ("{:?} {:?}" , format ! ("Item: {{}}") , item) , None => println ! ("Index out of bounds") , } ; let result = if let Some (item) = v . get (5i32) . cloned () { println ! ("{:?} {:?}" , format ! ("Item: {{}}") , item) } ; match std :: any :: type_name_of_val (& result) { name if name . contains ("String") || name . contains ("&str") => println ! ("{}" , result) , _ => println ! ("{:?}" , result) } }
  |

error[E0277]: the type `[i32]` cannot be indexed by `i32`
   --> /tmp/.tmpXqxhbI/main.rs:1:176
    |
1   | ...[1i32 , 2i32 , 3i32] ; ; match v . get (5i32) . cloned () { Some (item) => println ! ("{:?} {:?}" , format ! ("Item: {{}}") , item) , ...
    |                                       ---  ^^^^ slice indices are of type `usize` or ranges of `usize`
    |                                       |
    |                                       required by a bound introduced by this call
    |
    = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
    = help: the following other types implement trait `SliceIndex<T>`:
              `usize` implements `SliceIndex<ByteStr>`
              `usize` implements `SliceIndex<[T]>`
note: required by a bound in `core::slice::<impl [T]>::get`
   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:573:12
    |
571 |     pub fn get<I>(&self, index: I) -> Option<&I::Output>
    |            --- required by a bound in this associated function
572 |     where
573 |         I: SliceIndex<Self>,
    |            ^^^^^^^^^^^^^^^^ required by this bound in `core::slice::<impl [T]>::get`

error[E0277]: the type `[i32]` cannot be indexed by `i32`
   --> /tmp/.tmpXqxhbI/main.rs:1:361
    |
1   | ... result = if let Some (item) = v . get (5i32) . cloned () { { println ! ("{:?} {:?}" , format ! ("Item: {{}}") , item) } } ; match std...
    |                                       ---  ^^^^ slice indices are of type `usize` or ranges of `usize`
    |                                       |
    |                                       required by a bound introduced by this call
    |
    = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
    = help: the following other types implement trait `SliceIndex<T>`:
              `usize` implements `SliceIndex<ByteStr>`
              `usize` implements `SliceIndex<[T]>`
note: required by a bound in `core::slice::<impl [T]>::get`
   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:573:12
    |
571 |     pub fn get<I>(&self, index: I) -> Option<&I::Output>
    |            --- required by a bound in this associated function
572 |     where
573 |         I: SliceIndex<Self>,
    |            ^^^^^^^^^^^^^^^^ required by this bound in `core::slice::<impl [T]>::get`

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpXqxhbI/main.rs:1:580
  |
1 | .... contains ("&str") => println ! ("{}" , result) , _ => println ! ("{:?}" , result) } }
  |                                       --    ^^^^^^ `()` cannot be formatted with the default formatter
  |                                       |
  |                                       required by this formatting parameter
  |
  = help: the trait `std::fmt::Display` is not implemented for `()`
  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 3 previous errors; 5 warnings emitted

For more information about this error, try `rustc --explain E0277`.



=== appendix-c-troubleshooting example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 13 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 14 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 15 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 16 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpXNiccP/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .....
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpXNiccP/main.rs:1:87
  |
1 | use std :: collections :: HashMap ; fn main () { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .....
  |                                                                                       ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpXNiccP/main.rs:1:120
  |
1 | ...ions :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecD...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpXNiccP/main.rs:1:219
  |
1 | ...i32 , i) } } ; let mut deque = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } ; }
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpXNiccP/main.rs:1:149
  |
1 | ... list = Vec :: new () ; ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; ; for i in ...
  |                                                         ^^                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } ; }
1 + use std :: collections :: HashMap ; fn main () { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .. 1000i32 { list . insert (0i32 , i) } ; let mut deque = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXNiccP/main.rs:1:248
  |
1 | ...e = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } ; }
  |                                                          ^^                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } ; }
1 + use std :: collections :: HashMap ; fn main () { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { deque . push_front (i) } ; }
  |

error[E0308]: mismatched types
    --> /tmp/.tmpXNiccP/main.rs:1:166
     |
1    | ... () ; ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { ...
     |                                                ------  ^^^^ expected `usize`, found `i32`
     |                                                |
     |                                                arguments to this method are incorrect
     |
note: method defined here
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2034:12
     |
2034 |     pub fn insert(&mut self, index: usize, element: T) {
     |            ^^^^^^
help: change the type of the numeric literal from `i32` to `usize`
     |
1    - use std :: collections :: HashMap ; fn main () { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } ; }
1    + use std :: collections :: HashMap ; fn main () { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .. 1000i32 { { list . insert (0usize , i) } } ; let mut deque = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } ; }
     |

error: aborting due to 1 previous error; 6 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== appendix-c-troubleshooting example 17 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `url` in this scope
 --> /tmp/.tmpdWMKtu/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { let response = reqwest :: get (url) . await ? ; ; let data = response . json () . await ...
  |                                                                                 ^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpdWMKtu/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let response = reqwest :: get (url) . await ? ; ; let data = response . json () . await ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpdWMKtu/main.rs:1:98
  |
1 | use std :: collections :: HashMap ; fn main () { let response = reqwest :: get (url) . await ? ; ; let data = response . json () . await ...
  |                                                                                                  ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpdWMKtu/main.rs:1:142
  |
1 | ...ait ? ; ; let data = response . json () . await ? ; ; }
  |                                                        ^ help: remove this semicolon

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
 --> /tmp/.tmpdWMKtu/main.rs:1:65
  |
1 | use std :: collections :: HashMap ; fn main () { let response = reqwest :: get (url) . await ? ; ; let data = response . json () . await ...
  |                                                                 ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
  |
  = help: you might be missing a crate named `reqwest`

error: aborting due to 2 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0425, E0433.
For more information about an error, try `rustc --explain E0425`.



=== appendix-c-troubleshooting example 18 ===
✗ Compilation failed: Failed to transpile to Rust


=== appendix-c-troubleshooting example 19 ===
✗ Compilation failed: Failed to transpile to Rust


=== appendix-c-troubleshooting example 20 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 3 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpWe47o9/main.rs:1:356
  |
1 | ...} ; return groups } } } } fn main () { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maxi...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpWe47o9/main.rs:1:391
  |
1 | ...) { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let mini...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpWe47o9/main.rs:1:410
  |
1 | ...bers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpWe47o9/main.rs:1:445
  |
1 | ...bers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactio...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpWe47o9/main.rs:1:480
  |
1 | ...; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `transactions` in this scope
 --> /tmp/.tmpWe47o9/main.rs:1:518
  |
1 | ... minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec <...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `transactions` in this scope
 --> /tmp/.tmpWe47o9/main.rs:1:635
  |
1 | ...ollect :: < Vec < _ >> () ; ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; ; le...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `transactions` in this scope
 --> /tmp/.tmpWe47o9/main.rs:1:737
  |
1 | ...ollect :: < Vec < _ >> () ; ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; ; }
  |                                                     ^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpWe47o9/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpWe47o9/main.rs:1:100
  |
1 | ... { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } ...
  |       ^^                                                                                                                                                                                                                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; ; }
1 + use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } fn main () { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpWe47o9/main.rs:1:148
  |
1 | ... { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ...
  |       ^^                                                                                                                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; ; }
1 + use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } ; return groups } } } } fn main () { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpWe47o9/main.rs:1:220
  |
1 | ...ield as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } ...
  |                                                     ^^                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; ; }
1 + use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { groups [key as usize] = vec ! [] } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpWe47o9/main.rs:1:375
  |
1 | ...} } } } fn main () { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . ma...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpWe47o9/main.rs:1:429
  |
1 | ...let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_v...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpWe47o9/main.rs:1:464
  |
1 | ...mbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpWe47o9/main.rs:1:499
  |
1 | ...mbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpWe47o9/main.rs:1:614
  |
1 | ...t . amount > 100i32) . collect :: < Vec < _ >> () ; ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpWe47o9/main.rs:1:716
  |
1 | ...(| t | t . customer) . collect :: < Vec < _ >> () ; ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpWe47o9/main.rs:1:816
  |
1 | ...p (| t | t . amount) . collect :: < Vec < _ >> () ; ; }
  |                                                        ^ help: remove this semicolon

error[E0277]: `String` is not an iterator
 --> /tmp/.tmpWe47o9/main.rs:1:138
  |
1 | ...groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize...
  |                                  ^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`
  |
  = help: the trait `Iterator` is not implemented for `String`
  = note: required for `String` to implement `IntoIterator`

error[E0599]: no method named `has_key` found for unit type `()` in the current scope
 --> /tmp/.tmpWe47o9/main.rs:1:204
  |
1 | ...et key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . pu...
  |                                                       ^^^^^^^ method not found in `()`

error[E0308]: mismatched types
 --> /tmp/.tmpWe47o9/main.rs:1:316
  |
1 | ...-> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } ...
  |       --- expected `i32` because of return type                                                                                                                                                                                     ^^^^^^ expected `i32`, found `()`

error[E0605]: non-primitive cast: `String` as `usize`
 --> /tmp/.tmpWe47o9/main.rs:1:170
  |
1 | ...rd [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) }...
  |        ^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error: aborting due to 12 previous errors; 11 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0425, E0599, E0605.
For more information about an error, try `rustc --explain E0277`.



=== ch05-00-data-processing example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 8 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpJhRLRv/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) { { println ! ("{:?}" , format ! ("{}{}" , "\n" , ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpJhRLRv/main.rs:1:268
  |
1 | ... values () . max () ; { let max_bar_width = 50i32 ; ; for (key , value) in data . iter () . map (| (k , v) | (k . clone () , v . clone...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpJhRLRv/main.rs:1:358
  |
1 | ... { { { let bar_width = value * max_bar_width / max_value ; { let bar = "█" * bar_width . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") , bar) , " ") , value . to_s ())) } } } } ...
  |       ^^                                                                                                                                                                                                                                                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) { { println ! ("{:?}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{:?}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; ; for (key , value) in data . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let bar_width = value * max_bar_width / max_value ; { let bar = "█" * bar_width . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") , bar) , " ") , value . to_s ())) } } } } } } } } fn main () { let monthly_sales = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("January" . to_string () , (45000i32) . to_string ()) ; map . insert ("February" . to_string () , (52000i32) . to_string ()) ; map . insert ("March" . to_string () , (48000i32) . to_string ()) ; map . insert ("April" . to_string () , (61000i32) . to_string ()) ; map . insert ("May" . to_string () , (58000i32) . to_string ()) ; map } ; ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
1 + use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) { { println ! ("{:?}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{:?}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; ; for (key , value) in data . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { let bar_width = value * max_bar_width / max_value ; { let bar = "█" * bar_width . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") , bar) , " ") , value . to_s ())) } } } } } } } fn main () { let monthly_sales = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("January" . to_string () , (45000i32) . to_string ()) ; map . insert ("February" . to_string () , (52000i32) . to_string ()) ; map . insert ("March" . to_string () , (48000i32) . to_string ()) ; map . insert ("April" . to_string () , (61000i32) . to_string ()) ; map . insert ("May" . to_string () , (58000i32) . to_string ()) ; map } ; ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpJhRLRv/main.rs:1:454
  |
1 | ...max_value ; { let bar = "█" * bar_width . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , for...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpJhRLRv/main.rs:1:1108
  |
1 | ...to_string () , (58000i32) . to_string ()) ; map } ; ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
  |                                                        ^ help: remove this semicolon

error[E0369]: cannot multiply `&str` by `usize`
 --> /tmp/.tmpJhRLRv/main.rs:1:172
  |
1 | ...rmat ! ("{}{}" , "\n" , title)) ; println ! ("{:?}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let max_...
  |                                                          --- ^ -------------- usize
  |                                                          |
  |                                                          &str

error[E0599]: no method named `values` found for struct `String` in the current scope
 --> /tmp/.tmpJhRLRv/main.rs:1:217
  |
1 | ..."=" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; ; for (key , value) in data . iter...
  |                                                     ^^^^^^ method not found in `String`

error[E0599]: no method named `iter` found for struct `String` in the current scope
 --> /tmp/.tmpJhRLRv/main.rs:1:298
  |
1 | ...bar_width = 50i32 ; ; for (key , value) in data . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let bar_width = valu...
  |                                                      ^^^^ method not found in `String`
  |
help: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`
  |
1 - use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) { { println ! ("{:?}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{:?}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; ; for (key , value) in data . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let bar_width = value * max_bar_width / max_value ; { let bar = "█" * bar_width . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") , bar) , " ") , value . to_s ())) } } } } } } } } fn main () { let monthly_sales = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("January" . to_string () , (45000i32) . to_string ()) ; map . insert ("February" . to_string () , (52000i32) . to_string ()) ; map . insert ("March" . to_string () , (48000i32) . to_string ()) ; map . insert ("April" . to_string () , (61000i32) . to_string ()) ; map . insert ("May" . to_string () , (58000i32) . to_string ()) ; map } ; ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
1 + use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) { { println ! ("{:?}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{:?}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; ; for (key , value) in data . chars () . map (| (k , v) | (k . clone () , v . clone ())) { { { let bar_width = value * max_bar_width / max_value ; { let bar = "█" * bar_width . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") , bar) , " ") , value . to_s ())) } } } } } } } } fn main () { let monthly_sales = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("January" . to_string () , (45000i32) . to_string ()) ; map . insert ("February" . to_string () , (52000i32) . to_string ()) ; map . insert ("March" . to_string () , (48000i32) . to_string ()) ; map . insert ("April" . to_string () , (61000i32) . to_string ()) ; map . insert ("May" . to_string () , (58000i32) . to_string ()) ; map } ; ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
  |

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpJhRLRv/main.rs:1:420
  |
1 | ...= value * max_bar_width / max_value ; { let bar = "█" * bar_width . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}...
  |                                                ^^^ doesn't have a size known at compile-time
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: all local variables must have a statically known size

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpJhRLRv/main.rs:1:566
  |
1 | ...! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") , bar) , " ") , value . to_s ())) } } } } } } } } fn main () { let month...
  |                             --                                     ^^^ doesn't have a size known at compile-time
  |                             |
  |                             required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
 --> /tmp/.tmpJhRLRv/main.rs:1:1126
  |
1 | ... to_string ()) ; map } ; ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
  |                               --------------  ^^^^^^^^^^^^^ expected `String`, found `HashMap<String, String>`
  |                               |
  |                               arguments to this function are incorrect
  |
  = note: expected struct `String`
             found struct `HashMap<String, String>`
note: function defined here
 --> /tmp/.tmpJhRLRv/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) { { println ! ("{:?}" , format ! ("{}{}" , "\n" , ...
  |                                        ^^^^^^^^^^^^^^  -------------

error: aborting due to 6 previous errors; 5 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0369, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch05-00-data-processing example 9 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpU0dR8s/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let sales_data = load_csv ("sales.csv" . to_string ()) ; ; let total = sales_data . iter...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpU0dR8s/main.rs:1:107
  |
1 | ...ales_data = load_csv ("sales.csv" . to_string ()) ; ; let total = sales_data . iter () . map (| row | row . amount . to_f ()) . collec...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpU0dR8s/main.rs:1:221
  |
1 | ... . to_f ()) . collect :: < Vec < _ >> () . sum () ; ; let average = total / sales_data . len () ; ; println ! ("{:?}" , format ! ("{}{...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpU0dR8s/main.rs:1:267
  |
1 | ... () ; ; let average = total / sales_data . len () ; ; println ! ("{:?}" , format ! ("{}{}" , "Average sale: $" , average . to_s ())) ; }
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `load_csv` in this scope
 --> /tmp/.tmpU0dR8s/main.rs:1:67
  |
1 | use std :: collections :: HashMap ; fn main () { let sales_data = load_csv ("sales.csv" . to_string ()) ; ; let total = sales_data . iter...
  |                                                                   ^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 4 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-data-processing example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch02-00-variables-types example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `user_name` in this scope
 --> /tmp/.tmptsYjb9/main.rs:1:52
  |
1 | use std :: collections :: HashMap ; fn main () { { user_name = "Alice" } }
  |                                                    ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmptsYjb9/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { user_name = "Alice" } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmptsYjb9/main.rs:1:50
  |
1 | use std :: collections :: HashMap ; fn main () { { user_name = "Alice" } }
  |                                                  ^^                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { user_name = "Alice" } }
1 + use std :: collections :: HashMap ; fn main () { user_name = "Alice" }
  |

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch02-00-variables-types example 6 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpytDf3h/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let age = "25" . to_string () ; let next_year = age + 1i32 ; } } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpytDf3h/main.rs:1:50
  |
1 | use std :: collections :: HashMap ; fn main () { { { let age = "25" . to_string () ; let next_year = age + 1i32 ; } } }
  |                                                  ^^                                                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let age = "25" . to_string () ; let next_year = age + 1i32 ; } } }
1 + use std :: collections :: HashMap ; fn main () { { let age = "25" . to_string () ; let next_year = age + 1i32 ; } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpytDf3h/main.rs:1:108
  |
1 | use std :: collections :: HashMap ; fn main () { { { let age = "25" . to_string () ; let next_year = age + 1i32 ; } } }
  |                                                                                                            ^^^^ expected `&str`, found `i32`

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 5 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpu4NilF/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpu4NilF/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f...
  |                                                                  ^^     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , first_name , "_") , last_name) } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}" , "Circle area:" , area) ; println ! ("{} {:?}" , "Username:" , username) ; println ! ("{:?}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { x * x } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , first_name , "_") , last_name) } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}" , "Circle area:" , area) ; println ! ("{} {:?}" , "Username:" , username) ; println ! ("{:?}" , excited) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpu4NilF/main.rs:1:117
  |
1 | ... } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , la...
  |                                              ^^                                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , first_name , "_") , last_name) } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}" , "Circle area:" , area) ; println ! ("{} {:?}" , "Username:" , username) ; println ! ("{:?}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { let pi = 3.14159f64 ; pi * square (radius) } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , first_name , "_") , last_name) } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}" , "Circle area:" , area) ; println ! ("{} {:?}" , "Username:" , username) ; println ! ("{:?}" , excited) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpu4NilF/main.rs:1:233
  |
1 | ...32 , last_name : i32) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , first_name , "_") , last_name) } } fn shout (message : String) ...
  |                                   ^^                                                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , first_name , "_") , last_name) } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}" , "Circle area:" , area) ; println ! ("{} {:?}" , "Username:" , username) ; println ! ("{:?}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { format ! ("{}{}" , format ! ("{}{}" , first_name , "_") , last_name) } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}" , "Circle area:" , area) ; println ! ("{} {:?}" , "Username:" , username) ; println ! ("{:?}" , excited) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpu4NilF/main.rs:1:345
  |
1 | ...name) } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32...
  |                                                   ^^                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , first_name , "_") , last_name) } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}" , "Circle area:" , area) ; println ! ("{} {:?}" , "Username:" , username) ; println ! ("{:?}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , first_name , "_") , last_name) } } fn shout (message : String) -> i32 { format ! ("{}{}" , message , "!!!") } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}" , "Circle area:" , area) ; println ! ("{} {:?}" , "Username:" , username) ; println ! ("{:?}" , excited) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpu4NilF/main.rs:1:400
  |
1 | ... { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}" , "Circle area:" , area) ; println ! ("{} {:?}" , "Username:" , username) ; println ! ("{:?}" , excited) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , first_name , "_") , last_name) } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}" , "Circle area:" , area) ; println ! ("{} {:?}" , "Username:" , username) ; println ! ("{:?}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , first_name , "_") , last_name) } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { let area = circle_area (5i32) ; { let username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}" , "Circle area:" , area) ; println ! ("{} {:?}" , "Username:" , username) ; println ! ("{:?}" , excited) } } }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpu4NilF/main.rs:1:521
  |
1 | ...Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}"...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpu4NilF/main.rs:1:581
  |
1 | ...cited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}" , "Circle area:" , area) ; println ! ("{} {:?}" , "Username...
  |                                                        ^ help: remove this semicolon

error[E0277]: cannot multiply `f64` by `i32`
 --> /tmp/.tmpu4NilF/main.rs:1:146
  |
1 | ...ius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 ...
  |                                                     ^ no implementation for `f64 * i32`
  |
  = help: the trait `Mul<i32>` is not implemented for `f64`
  = help: the following other types implement trait `Mul<Rhs>`:
            `&f64` implements `Mul<f64>`
            `&f64` implements `Mul`
            `f64` implements `Mul<&f64>`
            `f64` implements `Mul`

error[E0308]: mismatched types
 --> /tmp/.tmpu4NilF/main.rs:1:235
  |
1 | ...me : i32) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , first_name , "_") , last_name) } } fn shout (message : String) -> i32 { { f...
  |                 ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`
  |                 |
  |                 expected `i32` because of return type
  |
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
 --> /tmp/.tmpu4NilF/main.rs:1:347
  |
1 | ...n shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let u...
  |                                  ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`
  |                                  |
  |                                  expected `i32` because of return type
  |
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpu4NilF/main.rs:1:453
  |
1 | ...; { let username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_...
  |                       ^^^^^^^^^^^^^  ----------------------   ------------------------ expected `i32`, found `String`
  |                                      |
  |                                      expected `i32`, found `String`
  |
note: function defined here
 --> /tmp/.tmpu4NilF/main.rs:1:173
  |
1 | ....14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , format ! ("...
  |                                              ^^^^^^^^^^^^^  ----------------   ---------------

error: aborting due to 4 previous errors; 8 warnings emitted

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.



=== ch03-00-functions example 6 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpr7ca4r/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i3...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpr7ca4r/main.rs:1:72
  |
1 | use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i3...
  |                                                                        ^^                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { number % 2i32 == 0i32 } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpr7ca4r/main.rs:1:142
  |
1 | ... { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } ...
  |       ^^                                                                                                                                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpr7ca4r/main.rs:1:164
  |
1 | ...n grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { "A" } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpr7ca4r/main.rs:1:201
  |
1 | ...2 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { "B" } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpr7ca4r/main.rs:1:238
  |
1 | ...lse { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } }...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { "C" } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpr7ca4r/main.rs:1:275
  |
1 | ...lse { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i3...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { "D" } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpr7ca4r/main.rs:1:292
  |
1 | ... 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { "F" } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpr7ca4r/main.rs:1:350
  |
1 | ... { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpr7ca4r/main.rs:1:386
  |
1 | ...number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large"...
  |                                                                  ^^      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { "even" } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpr7ca4r/main.rs:1:406
  |
1 | ...i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small...
  |                                                                  ^^     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { "odd" } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpr7ca4r/main.rs:1:486
  |
1 | ...f n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , form...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpr7ca4r/main.rs:1:449
  |
1 | ..."even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}...
  |                                                                 ^^       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { "large" } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpr7ca4r/main.rs:1:470
  |
1 | ...odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" ...
  |                                                                 ^^       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { "small" } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpr7ca4r/main.rs:1:74
  |
1 | use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i3...
  |                                                                  ---     ^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `bool`
  |                                                                  |
  |                                                                  expected `i32` because of return type

error[E0308]: mismatched types
 --> /tmp/.tmpr7ca4r/main.rs:1:156
  |
1 | ...er (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } }...
  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`
  |                                      |        |
  |                                      |        expected `String`, found `i32`
  |                                      expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmpr7ca4r/main.rs:1:166
  |
1 | ...fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i3...
  |                                        ---                           ^^^ expected `i32`, found `&str`
  |                                        |
  |                                        expected `i32` because of return type

error[E0308]: mismatched types
 --> /tmp/.tmpr7ca4r/main.rs:1:193
  |
1 | ...re >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } }...
  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`
  |                                      |        |
  |                                      |        expected `String`, found `i32`
  |                                      expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmpr7ca4r/main.rs:1:203
  |
1 | ...ore : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else ...
  |                     --- expected `i32` because of return type                          ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpr7ca4r/main.rs:1:230
  |
1 | ...re >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn descri...
  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`
  |                                      |        |
  |                                      |        expected `String`, found `i32`
  |                                      expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmpr7ca4r/main.rs:1:240
  |
1 | ...String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if s...
  |               --- expected `i32` because of return type                                                               ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpr7ca4r/main.rs:1:267
  |
1 | ...re >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let ...
  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`
  |                                      |        |
  |                                      |        expected `String`, found `i32`
  |                                      expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmpr7ca4r/main.rs:1:277
  |
1 | ...-> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } ...
  |       --- expected `i32` because of return type                                                                                                    ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpr7ca4r/main.rs:1:294
  |
1 | ...-> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } ...
  |       --- expected `i32` because of return type                                                                                                                     ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpr7ca4r/main.rs:1:372
  |
1 | ...umber (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" ...
  |                                                   ^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpr7ca4r/main.rs:1:488
  |
1 | ...-> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } ...
  |       --- expected `i32` because of return type                                                                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`
  |
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
 --> /tmp/.tmpr7ca4r/main.rs:1:789
  |
1 | ...150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |                                   ------------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                   |             |
  |                                   |             expected `String`, found `i32`
  |                                   arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpr7ca4r/main.rs:1:103
  |
1 | use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i3...
  |                                                                                                       ^^^^^^^^^^^^  --------------

error: aborting due to 13 previous errors; 14 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 7 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpX6TJTX/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpX6TJTX/main.rs:1:108
  |
1 | ...(prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as ...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpX6TJTX/main.rs:1:129
  |
1 | ...i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpX6TJTX/main.rs:1:314
  |
1 | ...i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > ma...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpX6TJTX/main.rs:1:335
  |
1 | ...al = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = n...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpX6TJTX/main.rs:1:404
  |
1 | ... . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words...
  |                                                      ^^                              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = "Functions make code reusable and testable" . to_string () ; ; println ! ("{} {:?}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {:?}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {:?}" , "Word count:" , count_words (essay)) } } } }
1 + use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { max_val = numbers [i as usize] } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = "Functions make code reusable and testable" . to_string () ; ; println ! ("{} {:?}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {:?}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {:?}" , "Word count:" , count_words (essay)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpX6TJTX/main.rs:1:514
  |
1 | ...n count_words (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = ...
  |                                           ^^                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = "Functions make code reusable and testable" . to_string () ; ; println ! ("{} {:?}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {:?}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {:?}" , "Word count:" , count_words (essay)) } } } }
1 + use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { let words = text . split (" ") ; words . len () } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = "Functions make code reusable and testable" . to_string () ; ; println ! ("{} {:?}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {:?}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {:?}" , "Word count:" , count_words (essay)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpX6TJTX/main.rs:1:585
  |
1 | ... { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = "Functions make code reusable and testable" . to_string () ; ; println ! ("{} {:?}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {:?}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {:?}" , "Word count:" , count_words (essay)) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = "Functions make code reusable and testable" . to_string () ; ; println ! ("{} {:?}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {:?}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {:?}" , "Word count:" , count_words (essay)) } } } }
1 + use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = "Functions make code reusable and testable" . to_string () ; ; println ! ("{} {:?}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {:?}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {:?}" , "Word count:" , count_words (essay)) } } }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpX6TJTX/main.rs:1:723
  |
1 | ...s = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = "Functions make code reusable and testable" . to_string () ; ; print...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpX6TJTX/main.rs:1:798
  |
1 | ...s make code reusable and testable" . to_string () ; ; println ! ("{} {:?}" , "Total cost: $" , calculate_total (shopping_cart)) ; prin...
  |                                                        ^ help: remove this semicolon

error[E0308]: mismatched types
 --> /tmp/.tmpX6TJTX/main.rs:1:141
  |
1 | ...tal = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } f...
  |                                              -   ^^^^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                              |
  |                                              expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len ().try_into().unwrap() { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = "Functions make code reusable and testable" . to_string () ; ; println ! ("{} {:?}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {:?}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {:?}" , "Word count:" , count_words (essay)) } } } }
  |                                                                                                                                                            ++++++++++++++++++++

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpX6TJTX/main.rs:1:185
  |
1 | ...rices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mu...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0308]: mismatched types
 --> /tmp/.tmpX6TJTX/main.rs:1:218
  |
1 | ...-> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } ...
  |       --- expected `i32` because of return type                                                                                                    ^^^^^ expected `i32`, found `f64`

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpX6TJTX/main.rs:1:297
  |
1 | ...ng) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usiz...
  |                                              ^^^^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0308]: mismatched types
 --> /tmp/.tmpX6TJTX/main.rs:1:347
  |
1 | ... as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize...
  |                                              -   ^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                              |
  |                                              expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len ().try_into().unwrap() { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = "Functions make code reusable and testable" . to_string () ; ; println ! ("{} {:?}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {:?}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {:?}" , "Word count:" , count_words (essay)) } } } }
  |                                                                                                                                                                                                                                                                                                                                                                           ++++++++++++++++++++

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpX6TJTX/main.rs:1:380
  |
1 | ...while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val }...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpX6TJTX/main.rs:1:425
  |
1 | ...as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { ...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0599]: no method named `len` found for struct `std::str::Split` in the current scope
    --> /tmp/.tmpX6TJTX/main.rs:1:559
     |
1    | ... : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5...
     |                                                                     ^^^
     |
help: there is a method `le` with a similar name, but with different arguments
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:3877:5
     |
3877 | /     fn le<I>(self, other: I) -> bool
3878 | |     where
3879 | |         I: IntoIterator,
3880 | |         Self::Item: PartialOrd<I::Item>,
3881 | |         Self: Sized,
     | |____________________^

error[E0308]: mismatched types
 --> /tmp/.tmpX6TJTX/main.rs:1:858
  |
1 | ... ! ("{} {:?}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {:?}" , "Highest score:" , find_max (test_scores))...
  |                                      ---------------  ^^^^^^^^^^^^^ expected `String`, found `Vec<f64>`
  |                                      |
  |                                      arguments to this function are incorrect
  |
  = note: expected struct `String`
             found struct `Vec<f64>`
note: function defined here
 --> /tmp/.tmpX6TJTX/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i...
  |                                        ^^^^^^^^^^^^^^^  ---------------

error[E0308]: mismatched types
 --> /tmp/.tmpX6TJTX/main.rs:1:928
  |
1 | ...tln ! ("{} {:?}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {:?}" , "Word count:" , count_words (essay)) } } } }
  |                                          --------  ^^^^^^^^^^^ expected `String`, found `Vec<i32>`
  |                                          |
  |                                          arguments to this function are incorrect
  |
  = note: expected struct `String`
             found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmpX6TJTX/main.rs:1:231
  |
1 | ...rices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ...
  |                                                         ^^^^^^^^  ----------------

error: aborting due to 10 previous errors; 10 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch03-00-functions example 9 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpAMEyiP/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn greet (name : String , age : String) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpAMEyiP/main.rs:1:86
  |
1 | ... { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") , age) , " years old") } } ...
  |       ^^                                                                                                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn greet (name : String , age : String) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") , age) , " years old") } } fn main () { { let msg = greet ("Alice" . to_string ()) ; } }
1 + use std :: collections :: HashMap ; fn greet (name : String , age : String) -> i32 { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") , age) , " years old") } fn main () { { let msg = greet ("Alice" . to_string ()) ; } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpAMEyiP/main.rs:1:88
  |
1 | ...-> i32 { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") , age) , " years old") } ...
  |       ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`
  |       |
  |       expected `i32` because of return type
  |
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0061]: this function takes 2 arguments but 1 argument was supplied
 --> /tmp/.tmpAMEyiP/main.rs:1:245
  |
1 | ...") } } fn main () { { let msg = greet ("Alice" . to_string ()) ; } }
  |                                    ^^^^^------------------------- argument #2 of type `String` is missing
  |
note: function defined here
 --> /tmp/.tmpAMEyiP/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn greet (name : String , age : String) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{...
  |                                        ^^^^^                  ------------
help: provide the argument
  |
1 | use std :: collections :: HashMap ; fn greet (name : String , age : String) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") , age) , " years old") } } fn main () { { let msg = greet("Alice" . to_string (), /* String */) ; } }
  |                                                                                                                                                                                                                                                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

error: aborting due to 2 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0061, E0308.
For more information about an error, try `rustc --explain E0061`.



=== ch03-00-functions example 10 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpvful02/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpvful02/main.rs:1:134
  |
1 | ...i32 ; x } } fn good_function (x : i32) -> i32 { { { let result = x + 1i32 ; result } } } fn main () { { println ! ("{:?}" , good_funct...
  |                                                    ^^                                  ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { let result = x + 1i32 ; result } } } fn main () { { println ! ("{:?}" , good_function (5i32)) } }
1 + use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { let result = x + 1i32 ; result } } fn main () { { println ! ("{:?}" , good_function (5i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpvful02/main.rs:1:188
  |
1 | ...sult = x + 1i32 ; result } } } fn main () { { println ! ("{:?}" , good_function (5i32)) } }
  |                                                ^^                                         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { let result = x + 1i32 ; result } } } fn main () { { println ! ("{:?}" , good_function (5i32)) } }
1 + use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { let result = x + 1i32 ; result } } } fn main () { println ! ("{:?}" , good_function (5i32)) }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpvful02/main.rs:1:85
  |
1 | use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { ...
  |                                                                                     ^^^^ expected `&str`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpvful02/main.rs:1:92
  |
1 | use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { ...
  |                                                                     ---                    ^ expected `i32`, found `String`
  |                                                                     |
  |                                                                     expected `i32` because of return type

error: aborting due to 2 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 12 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp1IcUiL/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bm...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp1IcUiL/main.rs:1:87
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bm...
  |                                                                                       ^^                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { celsius * 9i32 / 5i32 + 32i32 } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp1IcUiL/main.rs:1:184
  |
1 | ..._bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_perce...
  |                                                     ^^                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { weight_kg / height_m * height_m } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp1IcUiL/main.rs:1:288
  |
1 | ...ount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : Strin...
  |                                 ^^                                                                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { let discount = price * discount_percent / 100i32 ; price - discount } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp1IcUiL/main.rs:1:405
  |
1 | ...fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) ...
  |                                           ^^                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { let words = text . split (" ") ; words . len () } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp1IcUiL/main.rs:1:509
  |
1 | ... { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } ...
  |       ^^                                                                                                                                                                                                                                                         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmp1IcUiL/main.rs:1:592
  |
1 | ...it (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmp1IcUiL/main.rs:1:613
  |
1 | ...initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = init...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmp1IcUiL/main.rs:1:642
  |
1 | ...ords . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } }...
  |                    ^^                                                                                                 ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp1IcUiL/main.rs:1:846
  |
1 | ... { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } ...
  |       ^^                                                                                                                                                                                                                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp1IcUiL/main.rs:1:899
  |
1 | ...f energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time...
  |                                                      ^^                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { "Go for a run or hit the gym!" } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp1IcUiL/main.rs:1:994
  |
1 | ... if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn ...
  |                                                        ^^                         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { "Perfect time for a walk" } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp1IcUiL/main.rs:1:1033
  |
1 | ...e > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_...
  |                                                       ^^                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { "Maybe just relax and read" } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

error[E0599]: no method named `len` found for struct `std::str::Split` in the current scope
    --> /tmp/.tmp1IcUiL/main.rs:1:450
     |
1    | ... : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let wo...
     |                                                                     ^^^
     |
help: there is a method `le` with a similar name, but with different arguments
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:3877:5
     |
3877 | /     fn le<I>(self, other: I) -> bool
3878 | |     where
3879 | |         I: IntoIterator,
3880 | |         Self::Item: PartialOrd<I::Item>,
3881 | |         Self: Sized,
     | |____________________^

error[E0599]: no method named `len` found for struct `std::str::Split` in the current scope
    --> /tmp/.tmp1IcUiL/main.rs:1:633
     |
1    | ...s = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + ...
     |                                                                     ^^^
     |
help: there is a method `le` with a similar name, but with different arguments
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:3877:5
     |
3877 | /     fn le<I>(self, other: I) -> bool
3878 | |     where
3879 | |         I: IntoIterator,
3880 | |         Self::Item: PartialOrd<I::Item>,
3881 | |         Self: Sized,
     | |____________________^

error[E0608]: cannot index into a value of type `std::str::Split<'_, &str>`
 --> /tmp/.tmp1IcUiL/main.rs:1:663
  |
1 | ...i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i3...
  |                                                                 ^^^^^^^^^^^^

error[E0308]: mismatched types
 --> /tmp/.tmp1IcUiL/main.rs:1:748
  |
1 | ...-> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } ...
  |       --- expected `i32` because of return type                                                                                                                                                                                                            ^^^^^^^^ expected `i32`, found `String`

error[E0308]: mismatched types
 --> /tmp/.tmp1IcUiL/main.rs:1:866
  |
1 | ...e_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_l...
  |                                   ------------   ^^^^- help: try using a conversion method: `.to_string()`
  |                                   |              |
  |                                   |              expected `String`, found `i32`
  |                                   expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmp1IcUiL/main.rs:1:891
  |
1 | ...{ { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available...
  |                                  --------------   ^^^^^- help: try using a conversion method: `.to_string()`
  |                                  |                |
  |                                  |                expected `String`, found `i32`
  |                                  expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmp1IcUiL/main.rs:1:901
  |
1 | ...ng) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 &...
  |           --- expected `i32` because of return type                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmp1IcUiL/main.rs:1:961
  |
1 | ...or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just re...
  |                                   ------------   ^^^^- help: try using a conversion method: `.to_string()`
  |                                   |              |
  |                                   |              expected `String`, found `i32`
  |                                   expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmp1IcUiL/main.rs:1:986
  |
1 | ...e { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } ...
  |                                  --------------   ^^^^^- help: try using a conversion method: `.to_string()`
  |                                  |                |
  |                                  |                expected `String`, found `i32`
  |                                  expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmp1IcUiL/main.rs:1:996
  |
1 | ...-> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } ...
  |       --- expected `i32` because of return type                                                                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmp1IcUiL/main.rs:1:1035
  |
1 | ...-> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } ...
  |       --- expected `i32` because of return type                                                                                                                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmp1IcUiL/main.rs:1:1184
  |
1 | ...enheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string...
  |                                          -------------          ^^^^^^^ expected `i32`, found `f64`
  |                                          |
  |                                          arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmp1IcUiL/main.rs:1:126
  |
1 | ...2 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m...
  |                                               ^^^^^^^^^^^^^                    --------------
help: change the type of the numeric literal from `f64` to `i32`
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1i32)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmp1IcUiL/main.rs:1:1285
  |
1 | ..._string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |                                       ^^^^^^^^^^^^^^^^^^  ----   ----- expected `String`, found `i32`
  |                                                           |
  |                                                           expected `String`, found `i32`
  |
note: function defined here
 --> /tmp/.tmp1IcUiL/main.rs:1:768
  |
1 | ...32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i3...
  |                                     ^^^^^^^^^^^^^^^^^^  ---------------------   -----------------------
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32.to_string() , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ++++++++++++
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32.to_string())) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ++++++++++++

error: aborting due to 13 previous errors; 13 warnings emitted

Some errors have detailed explanations: E0308, E0599, E0608.
For more information about an error, try `rustc --explain E0308`.


