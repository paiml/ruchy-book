=== ch16-00-testing-quality-assurance example 5 ===
DEBUG: About to call transpile_to_program
DEBUG: transpile_to_program completed
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `add` in this scope
 --> /tmp/.tmpz6gzOF/main.rs:1:36
  |
1 | fn test_addition () { assert_eq ! (add (2i32 , 3i32) , 5i32 , "{}" , "Basic addition") ; assert_eq ! (add (- 1i32 , 1i32) , 0i32 , "{}" ,...
  |                                    ^^^ not found in this scope
  |
help: use the `.` operator to call the method `Add::add` on `i32`
  |
1 - fn test_addition () { assert_eq ! (add (2i32 , 3i32) , 5i32 , "{}" , "Basic addition") ; assert_eq ! (add (- 1i32 , 1i32) , 0i32 , "{}" , "Adding negative numbers") ; assert_eq ! (add (0i32 , 0i32) , 0i32 , "{}" , "Adding zeros") ; println ! ("✅ Addition tests pass") ; } fn test_multiplication () { assert_eq ! (multiply (3i32 , 4i32) , 12i32 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32 , "{}" , "Negative multiplication") ; assert_eq ! (multiply (0i32 , 100i32) , 0i32 , "{}" , "Multiply by zero") ; println ! ("✅ Multiplication tests pass") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! ("🎉 Calculator test suite complete!") ; } fn main () { run_all_tests () }
1 + fn test_addition () { assert_eq ! (2i32.add(3i32) , 5i32 , "{}" , "Basic addition") ; assert_eq ! (add (- 1i32 , 1i32) , 0i32 , "{}" , "Adding negative numbers") ; assert_eq ! (add (0i32 , 0i32) , 0i32 , "{}" , "Adding zeros") ; println ! ("✅ Addition tests pass") ; } fn test_multiplication () { assert_eq ! (multiply (3i32 , 4i32) , 12i32 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32 , "{}" , "Negative multiplication") ; assert_eq ! (multiply (0i32 , 100i32) , 0i32 , "{}" , "Multiply by zero") ; println ! ("✅ Multiplication tests pass") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! ("🎉 Calculator test suite complete!") ; } fn main () { run_all_tests () }
  |

error[E0425]: cannot find function `add` in this scope
 --> /tmp/.tmpz6gzOF/main.rs:1:103
  |
1 | fn test_addition () { assert_eq ! (add (2i32 , 3i32) , 5i32 , "{}" , "Basic addition") ; assert_eq ! (add (- 1i32 , 1i32) , 0i32 , "{}" ,...
  |                                                                                                       ^^^ not found in this scope
  |
help: use the `.` operator to call the method `Add::add` on `i32`
  |
1 - fn test_addition () { assert_eq ! (add (2i32 , 3i32) , 5i32 , "{}" , "Basic addition") ; assert_eq ! (add (- 1i32 , 1i32) , 0i32 , "{}" , "Adding negative numbers") ; assert_eq ! (add (0i32 , 0i32) , 0i32 , "{}" , "Adding zeros") ; println ! ("✅ Addition tests pass") ; } fn test_multiplication () { assert_eq ! (multiply (3i32 , 4i32) , 12i32 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32 , "{}" , "Negative multiplication") ; assert_eq ! (multiply (0i32 , 100i32) , 0i32 , "{}" , "Multiply by zero") ; println ! ("✅ Multiplication tests pass") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! ("🎉 Calculator test suite complete!") ; } fn main () { run_all_tests () }
1 + fn test_addition () { assert_eq ! (add (2i32 , 3i32) , 5i32 , "{}" , "Basic addition") ; assert_eq ! ((- 1i32).add(1i32) , 0i32 , "{}" , "Adding negative numbers") ; assert_eq ! (add (0i32 , 0i32) , 0i32 , "{}" , "Adding zeros") ; println ! ("✅ Addition tests pass") ; } fn test_multiplication () { assert_eq ! (multiply (3i32 , 4i32) , 12i32 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32 , "{}" , "Negative multiplication") ; assert_eq ! (multiply (0i32 , 100i32) , 0i32 , "{}" , "Multiply by zero") ; println ! ("✅ Multiplication tests pass") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! ("🎉 Calculator test suite complete!") ; } fn main () { run_all_tests () }
  |

error[E0425]: cannot find function `add` in this scope
 --> /tmp/.tmpz6gzOF/main.rs:1:181
  |
1 | ...2 , "{}" , "Adding negative numbers") ; assert_eq ! (add (0i32 , 0i32) , 0i32 , "{}" , "Adding zeros") ; println ! ("✅ Addition tests p...
  |                                                         ^^^ not found in this scope
  |
help: use the `.` operator to call the method `Add::add` on `i32`
  |
1 - fn test_addition () { assert_eq ! (add (2i32 , 3i32) , 5i32 , "{}" , "Basic addition") ; assert_eq ! (add (- 1i32 , 1i32) , 0i32 , "{}" , "Adding negative numbers") ; assert_eq ! (add (0i32 , 0i32) , 0i32 , "{}" , "Adding zeros") ; println ! ("✅ Addition tests pass") ; } fn test_multiplication () { assert_eq ! (multiply (3i32 , 4i32) , 12i32 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32 , "{}" , "Negative multiplication") ; assert_eq ! (multiply (0i32 , 100i32) , 0i32 , "{}" , "Multiply by zero") ; println ! ("✅ Multiplication tests pass") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! ("🎉 Calculator test suite complete!") ; } fn main () { run_all_tests () }
1 + fn test_addition () { assert_eq ! (add (2i32 , 3i32) , 5i32 , "{}" , "Basic addition") ; assert_eq ! (add (- 1i32 , 1i32) , 0i32 , "{}" , "Adding negative numbers") ; assert_eq ! (0i32.add(0i32) , 0i32 , "{}" , "Adding zeros") ; println ! ("✅ Addition tests pass") ; } fn test_multiplication () { assert_eq ! (multiply (3i32 , 4i32) , 12i32 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32 , "{}" , "Negative multiplication") ; assert_eq ! (multiply (0i32 , 100i32) , 0i32 , "{}" , "Multiply by zero") ; println ! ("✅ Multiplication tests pass") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! ("🎉 Calculator test suite complete!") ; } fn main () { run_all_tests () }
  |

error[E0425]: cannot find function `multiply` in this scope
 --> /tmp/.tmpz6gzOF/main.rs:1:314
  |
1 | ...ass") ; } fn test_multiplication () { assert_eq ! (multiply (3i32 , 4i32) , 12i32 , "{}" , "Basic multiplication") ; assert_eq ! (mult...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `multiply` in this scope
 --> /tmp/.tmpz6gzOF/main.rs:1:393
  |
1 | ...32 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32 , "{}" , "Negative multiplication") ; assert_eq !...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `multiply` in this scope
 --> /tmp/.tmpz6gzOF/main.rs:1:478
  |
1 | ..., "{}" , "Negative multiplication") ; assert_eq ! (multiply (0i32 , 100i32) , 0i32 , "{}" , "Multiply by zero") ; println ! ("✅ Multipl...
  |                                                       ^^^^^^^^ not found in this scope

error: aborting due to 6 previous errors

For more information about this error, try `rustc --explain E0425`.

Error: Compilation failed:
error[E0425]: cannot find function `add` in this scope
 --> /tmp/.tmpz6gzOF/main.rs:1:36
  |
1 | fn test_addition () { assert_eq ! (add (2i32 , 3i32) , 5i32 , "{}" , "Basic addition") ; assert_eq ! (add (- 1i32 , 1i32) , 0i32 , "{}" ,...
  |                                    ^^^ not found in this scope
  |
help: use the `.` operator to call the method `Add::add` on `i32`
  |
1 - fn test_addition () { assert_eq ! (add (2i32 , 3i32) , 5i32 , "{}" , "Basic addition") ; assert_eq ! (add (- 1i32 , 1i32) , 0i32 , "{}" , "Adding negative numbers") ; assert_eq ! (add (0i32 , 0i32) , 0i32 , "{}" , "Adding zeros") ; println ! ("✅ Addition tests pass") ; } fn test_multiplication () { assert_eq ! (multiply (3i32 , 4i32) , 12i32 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32 , "{}" , "Negative multiplication") ; assert_eq ! (multiply (0i32 , 100i32) , 0i32 , "{}" , "Multiply by zero") ; println ! ("✅ Multiplication tests pass") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! ("🎉 Calculator test suite complete!") ; } fn main () { run_all_tests () }
1 + fn test_addition () { assert_eq ! (2i32.add(3i32) , 5i32 , "{}" , "Basic addition") ; assert_eq ! (add (- 1i32 , 1i32) , 0i32 , "{}" , "Adding negative numbers") ; assert_eq ! (add (0i32 , 0i32) , 0i32 , "{}" , "Adding zeros") ; println ! ("✅ Addition tests pass") ; } fn test_multiplication () { assert_eq ! (multiply (3i32 , 4i32) , 12i32 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32 , "{}" , "Negative multiplication") ; assert_eq ! (multiply (0i32 , 100i32) , 0i32 , "{}" , "Multiply by zero") ; println ! ("✅ Multiplication tests pass") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! ("🎉 Calculator test suite complete!") ; } fn main () { run_all_tests () }
  |

error[E0425]: cannot find function `add` in this scope
 --> /tmp/.tmpz6gzOF/main.rs:1:103
  |
1 | fn test_addition () { assert_eq ! (add (2i32 , 3i32) , 5i32 , "{}" , "Basic addition") ; assert_eq ! (add (- 1i32 , 1i32) , 0i32 , "{}" ,...
  |                                                                                                       ^^^ not found in this scope
  |
help: use the `.` operator to call the method `Add::add` on `i32`
  |
1 - fn test_addition () { assert_eq ! (add (2i32 , 3i32) , 5i32 , "{}" , "Basic addition") ; assert_eq ! (add (- 1i32 , 1i32) , 0i32 , "{}" , "Adding negative numbers") ; assert_eq ! (add (0i32 , 0i32) , 0i32 , "{}" , "Adding zeros") ; println ! ("✅ Addition tests pass") ; } fn test_multiplication () { assert_eq ! (multiply (3i32 , 4i32) , 12i32 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32 , "{}" , "Negative multiplication") ; assert_eq ! (multiply (0i32 , 100i32) , 0i32 , "{}" , "Multiply by zero") ; println ! ("✅ Multiplication tests pass") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! ("🎉 Calculator test suite complete!") ; } fn main () { run_all_tests () }
1 + fn test_addition () { assert_eq ! (add (2i32 , 3i32) , 5i32 , "{}" , "Basic addition") ; assert_eq ! ((- 1i32).add(1i32) , 0i32 , "{}" , "Adding negative numbers") ; assert_eq ! (add (0i32 , 0i32) , 0i32 , "{}" , "Adding zeros") ; println ! ("✅ Addition tests pass") ; } fn test_multiplication () { assert_eq ! (multiply (3i32 , 4i32) , 12i32 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32 , "{}" , "Negative multiplication") ; assert_eq ! (multiply (0i32 , 100i32) , 0i32 , "{}" , "Multiply by zero") ; println ! ("✅ Multiplication tests pass") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! ("🎉 Calculator test suite complete!") ; } fn main () { run_all_tests () }
  |

error[E0425]: cannot find function `add` in this scope
 --> /tmp/.tmpz6gzOF/main.rs:1:181
  |
1 | ...2 , "{}" , "Adding negative numbers") ; assert_eq ! (add (0i32 , 0i32) , 0i32 , "{}" , "Adding zeros") ; println ! ("✅ Addition tests p...
  |                                                         ^^^ not found in this scope
  |
help: use the `.` operator to call the method `Add::add` on `i32`
  |
1 - fn test_addition () { assert_eq ! (add (2i32 , 3i32) , 5i32 , "{}" , "Basic addition") ; assert_eq ! (add (- 1i32 , 1i32) , 0i32 , "{}" , "Adding negative numbers") ; assert_eq ! (add (0i32 , 0i32) , 0i32 , "{}" , "Adding zeros") ; println ! ("✅ Addition tests pass") ; } fn test_multiplication () { assert_eq ! (multiply (3i32 , 4i32) , 12i32 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32 , "{}" , "Negative multiplication") ; assert_eq ! (multiply (0i32 , 100i32) , 0i32 , "{}" , "Multiply by zero") ; println ! ("✅ Multiplication tests pass") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! ("🎉 Calculator test suite complete!") ; } fn main () { run_all_tests () }
1 + fn test_addition () { assert_eq ! (add (2i32 , 3i32) , 5i32 , "{}" , "Basic addition") ; assert_eq ! (add (- 1i32 , 1i32) , 0i32 , "{}" , "Adding negative numbers") ; assert_eq ! (0i32.add(0i32) , 0i32 , "{}" , "Adding zeros") ; println ! ("✅ Addition tests pass") ; } fn test_multiplication () { assert_eq ! (multiply (3i32 , 4i32) , 12i32 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32 , "{}" , "Negative multiplication") ; assert_eq ! (multiply (0i32 , 100i32) , 0i32 , "{}" , "Multiply by zero") ; println ! ("✅ Multiplication tests pass") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! ("🎉 Calculator test suite complete!") ; } fn main () { run_all_tests () }
  |

error[E0425]: cannot find function `multiply` in this scope
 --> /tmp/.tmpz6gzOF/main.rs:1:314
  |
1 | ...ass") ; } fn test_multiplication () { assert_eq ! (multiply (3i32 , 4i32) , 12i32 , "{}" , "Basic multiplication") ; assert_eq ! (mult...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `multiply` in this scope
 --> /tmp/.tmpz6gzOF/main.rs:1:393
  |
1 | ...32 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32 , "{}" , "Negative multiplication") ; assert_eq !...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `multiply` in this scope
 --> /tmp/.tmpz6gzOF/main.rs:1:478
  |
1 | ..., "{}" , "Negative multiplication") ; assert_eq ! (multiply (0i32 , 100i32) , 0i32 , "{}" , "Multiply by zero") ; println ! ("✅ Multipl...
  |                                                       ^^^^^^^^ not found in this scope

error: aborting due to 6 previous errors

For more information about this error, try `rustc --explain E0425`.



=== ch16-00-testing-quality-assurance example 6 ===
DEBUG: About to call transpile_to_program
DEBUG: transpile_to_program completed
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmphLrSMU/main.rs:1:48
  |
1 | fn fibonacci (n : i32) -> i32 { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn test_fibonacci_perfo...
  |                                                ^^ ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn fibonacci (n : i32) -> i32 { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn test_fibonacci_performance () { let start_time = get_time_ms () ; let result = fibonacci (20i32) ; let end_time = get_time_ms () ; assert_eq ! (result , 6765i32 , "{}" , "Fibonacci(20) should equal 6765") ; let duration = end_time - start_time ; assert ! (duration < 1000i32 , "{}" , "Fibonacci(20) should complete within 1 second") ; println ! ("✅ Performance test passes") ; } fn main () { test_fibonacci_performance () }
1 + fn fibonacci (n : i32) -> i32 { if n <= 1i32 { n } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn test_fibonacci_performance () { let start_time = get_time_ms () ; let result = fibonacci (20i32) ; let end_time = get_time_ms () ; assert_eq ! (result , 6765i32 , "{}" , "Fibonacci(20) should equal 6765") ; let duration = end_time - start_time ; assert ! (duration < 1000i32 , "{}" , "Fibonacci(20) should complete within 1 second") ; println ! ("✅ Performance test passes") ; } fn main () { test_fibonacci_performance () }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmphLrSMU/main.rs:1:63
  |
1 | fn fibonacci (n : i32) -> i32 { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn test_fibonacci_perfo...
  |                                                               ^^                                           ^^
  |
help: remove these braces
  |
1 - fn fibonacci (n : i32) -> i32 { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn test_fibonacci_performance () { let start_time = get_time_ms () ; let result = fibonacci (20i32) ; let end_time = get_time_ms () ; assert_eq ! (result , 6765i32 , "{}" , "Fibonacci(20) should equal 6765") ; let duration = end_time - start_time ; assert ! (duration < 1000i32 , "{}" , "Fibonacci(20) should complete within 1 second") ; println ! ("✅ Performance test passes") ; } fn main () { test_fibonacci_performance () }
1 + fn fibonacci (n : i32) -> i32 { if n <= 1i32 { { n } } else { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } fn test_fibonacci_performance () { let start_time = get_time_ms () ; let result = fibonacci (20i32) ; let end_time = get_time_ms () ; assert_eq ! (result , 6765i32 , "{}" , "Fibonacci(20) should equal 6765") ; let duration = end_time - start_time ; assert ! (duration < 1000i32 , "{}" , "Fibonacci(20) should complete within 1 second") ; println ! ("✅ Performance test passes") ; } fn main () { test_fibonacci_performance () }
  |

error[E0425]: cannot find function `get_time_ms` in this scope
 --> /tmp/.tmphLrSMU/main.rs:1:167
  |
1 | ...test_fibonacci_performance () { let start_time = get_time_ms () ; let result = fibonacci (20i32) ; let end_time = get_time_ms () ; ass...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `get_time_ms` in this scope
 --> /tmp/.tmphLrSMU/main.rs:1:232
  |
1 | ... let result = fibonacci (20i32) ; let end_time = get_time_ms () ; assert_eq ! (result , 6765i32 , "{}" , "Fibonacci(20) should equal 6...
  |                                                     ^^^^^^^^^^^ not found in this scope

error: aborting due to 2 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.

Error: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmphLrSMU/main.rs:1:48
  |
1 | fn fibonacci (n : i32) -> i32 { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn test_fibonacci_perfo...
  |                                                ^^ ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn fibonacci (n : i32) -> i32 { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn test_fibonacci_performance () { let start_time = get_time_ms () ; let result = fibonacci (20i32) ; let end_time = get_time_ms () ; assert_eq ! (result , 6765i32 , "{}" , "Fibonacci(20) should equal 6765") ; let duration = end_time - start_time ; assert ! (duration < 1000i32 , "{}" , "Fibonacci(20) should complete within 1 second") ; println ! ("✅ Performance test passes") ; } fn main () { test_fibonacci_performance () }
1 + fn fibonacci (n : i32) -> i32 { if n <= 1i32 { n } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn test_fibonacci_performance () { let start_time = get_time_ms () ; let result = fibonacci (20i32) ; let end_time = get_time_ms () ; assert_eq ! (result , 6765i32 , "{}" , "Fibonacci(20) should equal 6765") ; let duration = end_time - start_time ; assert ! (duration < 1000i32 , "{}" , "Fibonacci(20) should complete within 1 second") ; println ! ("✅ Performance test passes") ; } fn main () { test_fibonacci_performance () }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmphLrSMU/main.rs:1:63
  |
1 | fn fibonacci (n : i32) -> i32 { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn test_fibonacci_perfo...
  |                                                               ^^                                           ^^
  |
help: remove these braces
  |
1 - fn fibonacci (n : i32) -> i32 { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn test_fibonacci_performance () { let start_time = get_time_ms () ; let result = fibonacci (20i32) ; let end_time = get_time_ms () ; assert_eq ! (result , 6765i32 , "{}" , "Fibonacci(20) should equal 6765") ; let duration = end_time - start_time ; assert ! (duration < 1000i32 , "{}" , "Fibonacci(20) should complete within 1 second") ; println ! ("✅ Performance test passes") ; } fn main () { test_fibonacci_performance () }
1 + fn fibonacci (n : i32) -> i32 { if n <= 1i32 { { n } } else { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } fn test_fibonacci_performance () { let start_time = get_time_ms () ; let result = fibonacci (20i32) ; let end_time = get_time_ms () ; assert_eq ! (result , 6765i32 , "{}" , "Fibonacci(20) should equal 6765") ; let duration = end_time - start_time ; assert ! (duration < 1000i32 , "{}" , "Fibonacci(20) should complete within 1 second") ; println ! ("✅ Performance test passes") ; } fn main () { test_fibonacci_performance () }
  |

error[E0425]: cannot find function `get_time_ms` in this scope
 --> /tmp/.tmphLrSMU/main.rs:1:167
  |
1 | ...test_fibonacci_performance () { let start_time = get_time_ms () ; let result = fibonacci (20i32) ; let end_time = get_time_ms () ; ass...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `get_time_ms` in this scope
 --> /tmp/.tmphLrSMU/main.rs:1:232
  |
1 | ... let result = fibonacci (20i32) ; let end_time = get_time_ms () ; assert_eq ! (result , 6765i32 , "{}" , "Fibonacci(20) should equal 6...
  |                                                     ^^^^^^^^^^^ not found in this scope

error: aborting due to 2 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch16-00-testing-quality-assurance example 7 ===
DEBUG: About to call transpile_to_program
DEBUG: transpile_to_program completed
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `actual` in this scope
 --> /tmp/.tmpMUBPhs/main.rs:1:340
  |
1 | ...element should be 4") ; } fn main () { assert_eq ! (actual , expected , "{}" , "Descriptive failure message") ; assert ! (condition , ...
  |                                                        ^^^^^^ not found in this scope

error[E0425]: cannot find value `expected` in this scope
 --> /tmp/.tmpMUBPhs/main.rs:1:349
  |
1 | ...ould be 4") ; } fn main () { assert_eq ! (actual , expected , "{}" , "Descriptive failure message") ; assert ! (condition , "{}" , "Ex...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `condition` in this scope
 --> /tmp/.tmpMUBPhs/main.rs:1:410
  |
1 | ..."{}" , "Descriptive failure message") ; assert ! (condition , "{}" , "Explain why this should be true") ; }
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `create_range` in this scope
 --> /tmp/.tmpMUBPhs/main.rs:1:42
  |
1 | fn test_range_function () { let result = create_range (1i32 , 5i32) ; assert_eq ! (len (result) , 4i32 , "{}" , "Range should have 4 elem...
  |                                          ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `len` in this scope
 --> /tmp/.tmpMUBPhs/main.rs:1:84
  |
1 | fn test_range_function () { let result = create_range (1i32 , 5i32) ; assert_eq ! (len (result) , 4i32 , "{}" , "Range should have 4 elem...
  |                                                                                    ^^^ not found in this scope

error: aborting due to 5 previous errors

For more information about this error, try `rustc --explain E0425`.

Error: Compilation failed:
error[E0425]: cannot find value `actual` in this scope
 --> /tmp/.tmpMUBPhs/main.rs:1:340
  |
1 | ...element should be 4") ; } fn main () { assert_eq ! (actual , expected , "{}" , "Descriptive failure message") ; assert ! (condition , ...
  |                                                        ^^^^^^ not found in this scope

error[E0425]: cannot find value `expected` in this scope
 --> /tmp/.tmpMUBPhs/main.rs:1:349
  |
1 | ...ould be 4") ; } fn main () { assert_eq ! (actual , expected , "{}" , "Descriptive failure message") ; assert ! (condition , "{}" , "Ex...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `condition` in this scope
 --> /tmp/.tmpMUBPhs/main.rs:1:410
  |
1 | ..."{}" , "Descriptive failure message") ; assert ! (condition , "{}" , "Explain why this should be true") ; }
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `create_range` in this scope
 --> /tmp/.tmpMUBPhs/main.rs:1:42
  |
1 | fn test_range_function () { let result = create_range (1i32 , 5i32) ; assert_eq ! (len (result) , 4i32 , "{}" , "Range should have 4 elem...
  |                                          ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `len` in this scope
 --> /tmp/.tmpMUBPhs/main.rs:1:84
  |
1 | fn test_range_function () { let result = create_range (1i32 , 5i32) ; assert_eq ! (len (result) , 4i32 , "{}" , "Range should have 4 elem...
  |                                                                                    ^^^ not found in this scope

error: aborting due to 5 previous errors

For more information about this error, try `rustc --explain E0425`.



=== ch15-00-binary-compilation-deployment example 2 ===
DEBUG: About to call transpile_to_program
✗ Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Expected body after if condition, typically { ... }: Unexpected token: ColonColon


=== ch15-00-binary-compilation-deployment example 3 ===
DEBUG: About to call transpile_to_program
✗ Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Expected RightBracket, found Comma


=== ch15-00-binary-compilation-deployment example 4 ===
DEBUG: About to call transpile_to_program
DEBUG: transpile_to_program completed
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpG96yJg/main.rs:1:48
  |
1 | fn factorial (n : i32) -> i64 { if n <= 1i32 { { 1i32 } } else { { (n as i64) * factorial (n - 1i32) } } } fn integer_sqrt (n : i32) -> i...
  |                                                ^^    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn factorial (n : i32) -> i64 { if n <= 1i32 { { 1i32 } } else { { (n as i64) * factorial (n - 1i32) } } } fn integer_sqrt (n : i32) -> i32 { if n < 2i32 { { return n } } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2i32 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0i32 { { let temp = b ; b = a % b ; a = temp ; } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; let n = 10i32 ; println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25i32 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48i32 ; let mut b = 18i32 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) ; ; }
1 + fn factorial (n : i32) -> i64 { if n <= 1i32 { 1i32 } else { { (n as i64) * factorial (n - 1i32) } } } fn integer_sqrt (n : i32) -> i32 { if n < 2i32 { { return n } } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2i32 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0i32 { { let temp = b ; b = a % b ; a = temp ; } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; let n = 10i32 ; println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25i32 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48i32 ; let mut b = 18i32 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpG96yJg/main.rs:1:66
  |
1 | fn factorial (n : i32) -> i64 { if n <= 1i32 { { 1i32 } } else { { (n as i64) * factorial (n - 1i32) } } } fn integer_sqrt (n : i32) -> i...
  |                                                                  ^^                                 ^^
  |
help: remove these braces
  |
1 - fn factorial (n : i32) -> i64 { if n <= 1i32 { { 1i32 } } else { { (n as i64) * factorial (n - 1i32) } } } fn integer_sqrt (n : i32) -> i32 { if n < 2i32 { { return n } } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2i32 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0i32 { { let temp = b ; b = a % b ; a = temp ; } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; let n = 10i32 ; println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25i32 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48i32 ; let mut b = 18i32 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) ; ; }
1 + fn factorial (n : i32) -> i64 { if n <= 1i32 { { 1i32 } } else { (n as i64) * factorial (n - 1i32) } } fn integer_sqrt (n : i32) -> i32 { if n < 2i32 { { return n } } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2i32 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0i32 { { let temp = b ; b = a % b ; a = temp ; } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; let n = 10i32 ; println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25i32 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48i32 ; let mut b = 18i32 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpG96yJg/main.rs:1:197
  |
1 | ... n < 2i32 { { return n } } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2i32 } ...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpG96yJg/main.rs:1:221
  |
1 | ... } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2i32 } } ; x } fn gcd (a : i32 ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpG96yJg/main.rs:1:157
  |
1 | ...1i32) } } } fn integer_sqrt (n : i32) -> i32 { if n < 2i32 { { return n } } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x...
  |                                                                 ^^        ^^
  |
help: remove these braces
  |
1 - fn factorial (n : i32) -> i64 { if n <= 1i32 { { 1i32 } } else { { (n as i64) * factorial (n - 1i32) } } } fn integer_sqrt (n : i32) -> i32 { if n < 2i32 { { return n } } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2i32 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0i32 { { let temp = b ; b = a % b ; a = temp ; } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; let n = 10i32 ; println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25i32 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48i32 ; let mut b = 18i32 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) ; ; }
1 + fn factorial (n : i32) -> i64 { if n <= 1i32 { { 1i32 } } else { { (n as i64) * factorial (n - 1i32) } } } fn integer_sqrt (n : i32) -> i32 { if n < 2i32 { return n } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2i32 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0i32 { { let temp = b ; b = a % b ; a = temp ; } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; let n = 10i32 ; println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25i32 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48i32 ; let mut b = 18i32 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpG96yJg/main.rs:1:700
  |
1 | ... ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) ; ; }
  |                                                        ^ help: remove this semicolon

error[E0308]: mismatched types
 --> /tmp/.tmpG96yJg/main.rs:1:50
  |
1 | fn factorial (n : i32) -> i64 { if n <= 1i32 { { 1i32 } } else { { (n as i64) * factorial (n - 1i32) } } } fn integer_sqrt (n : i32) -> i...
  |                           ---                    ^^^^ expected `i64`, found `i32`
  |                           |
  |                           expected `i64` because of return type
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - fn factorial (n : i32) -> i64 { if n <= 1i32 { { 1i32 } } else { { (n as i64) * factorial (n - 1i32) } } } fn integer_sqrt (n : i32) -> i32 { if n < 2i32 { { return n } } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2i32 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0i32 { { let temp = b ; b = a % b ; a = temp ; } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; let n = 10i32 ; println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25i32 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48i32 ; let mut b = 18i32 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) ; ; }
1 + fn factorial (n : i32) -> i64 { if n <= 1i32 { { 1i64 } } else { { (n as i64) * factorial (n - 1i32) } } } fn integer_sqrt (n : i32) -> i32 { if n < 2i32 { { return n } } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2i32 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0i32 { { let temp = b ; b = a % b ; a = temp ; } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; let n = 10i32 ; println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25i32 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48i32 ; let mut b = 18i32 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) ; ; }
  |

error[E0384]: cannot assign to immutable argument `b`
 --> /tmp/.tmpG96yJg/main.rs:1:358
  |
1 | ...-> i32 { while b != 0i32 { { let temp = b ; b = a % b ; a = temp ; } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; ...
  |                                                ^^^^^^^^^ cannot assign to immutable argument
  |
help: consider making this binding mutable
  |
1 | fn factorial (n : i32) -> i64 { if n <= 1i32 { { 1i32 } } else { { (n as i64) * factorial (n - 1i32) } } } fn integer_sqrt (n : i32) -> i32 { if n < 2i32 { { return n } } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2i32 } } ; x } fn gcd (a : i32 , mut b : i32) -> i32 { while b != 0i32 { { let temp = b ; b = a % b ; a = temp ; } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; let n = 10i32 ; println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25i32 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48i32 ; let mut b = 18i32 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) ; ; }
  |                                                                                                                                                                                                                                                                                                                 +++

error[E0384]: cannot assign to immutable argument `a`
 --> /tmp/.tmpG96yJg/main.rs:1:370
  |
1 | ...ile b != 0i32 { { let temp = b ; b = a % b ; a = temp ; } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; let n = 10i...
  |                                                 ^^^^^^^^ cannot assign to immutable argument
  |
help: consider making this binding mutable
  |
1 | fn factorial (n : i32) -> i64 { if n <= 1i32 { { 1i32 } } else { { (n as i64) * factorial (n - 1i32) } } } fn integer_sqrt (n : i32) -> i32 { if n < 2i32 { { return n } } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2i32 } } ; x } fn gcd (mut a : i32 , b : i32) -> i32 { while b != 0i32 { { let temp = b ; b = a % b ; a = temp ; } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; let n = 10i32 ; println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25i32 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48i32 ; let mut b = 18i32 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) ; ; }
  |                                                                                                                                                                                                                                                                                                       +++

warning: variable does not need to be mutable
 --> /tmp/.tmpG96yJg/main.rs:1:524
  |
1 | ... ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25i32 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let ...
  |                                                         ----^
  |                                                         |
  |                                                         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

warning: variable does not need to be mutable
 --> /tmp/.tmpG96yJg/main.rs:1:605
  |
1 | ...Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48i32 ; let mut b = 18i32 ; println ! ("GCD of {} and {}: {}" , a , b , g...
  |                                                         ----^
  |                                                         |
  |                                                         help: remove this `mut`

warning: variable does not need to be mutable
 --> /tmp/.tmpG96yJg/main.rs:1:625
  |
1 | ...}" , x , integer_sqrt (x)) ; let mut a = 48i32 ; let mut b = 18i32 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) ; ; }
  |                                                         ----^
  |                                                         |
  |                                                         help: remove this `mut`

error: aborting due to 3 previous errors; 9 warnings emitted

Some errors have detailed explanations: E0308, E0384.
For more information about an error, try `rustc --explain E0308`.

Error: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpG96yJg/main.rs:1:48
  |
1 | fn factorial (n : i32) -> i64 { if n <= 1i32 { { 1i32 } } else { { (n as i64) * factorial (n - 1i32) } } } fn integer_sqrt (n : i32) -> i...
  |                                                ^^    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn factorial (n : i32) -> i64 { if n <= 1i32 { { 1i32 } } else { { (n as i64) * factorial (n - 1i32) } } } fn integer_sqrt (n : i32) -> i32 { if n < 2i32 { { return n } } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2i32 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0i32 { { let temp = b ; b = a % b ; a = temp ; } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; let n = 10i32 ; println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25i32 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48i32 ; let mut b = 18i32 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) ; ; }
1 + fn factorial (n : i32) -> i64 { if n <= 1i32 { 1i32 } else { { (n as i64) * factorial (n - 1i32) } } } fn integer_sqrt (n : i32) -> i32 { if n < 2i32 { { return n } } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2i32 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0i32 { { let temp = b ; b = a % b ; a = temp ; } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; let n = 10i32 ; println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25i32 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48i32 ; let mut b = 18i32 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpG96yJg/main.rs:1:66
  |
1 | fn factorial (n : i32) -> i64 { if n <= 1i32 { { 1i32 } } else { { (n as i64) * factorial (n - 1i32) } } } fn integer_sqrt (n : i32) -> i...
  |                                                                  ^^                                 ^^
  |
help: remove these braces
  |
1 - fn factorial (n : i32) -> i64 { if n <= 1i32 { { 1i32 } } else { { (n as i64) * factorial (n - 1i32) } } } fn integer_sqrt (n : i32) -> i32 { if n < 2i32 { { return n } } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2i32 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0i32 { { let temp = b ; b = a % b ; a = temp ; } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; let n = 10i32 ; println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25i32 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48i32 ; let mut b = 18i32 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) ; ; }
1 + fn factorial (n : i32) -> i64 { if n <= 1i32 { { 1i32 } } else { (n as i64) * factorial (n - 1i32) } } fn integer_sqrt (n : i32) -> i32 { if n < 2i32 { { return n } } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2i32 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0i32 { { let temp = b ; b = a % b ; a = temp ; } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; let n = 10i32 ; println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25i32 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48i32 ; let mut b = 18i32 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpG96yJg/main.rs:1:197
  |
1 | ... n < 2i32 { { return n } } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2i32 } ...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpG96yJg/main.rs:1:221
  |
1 | ... } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2i32 } } ; x } fn gcd (a : i32 ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpG96yJg/main.rs:1:157
  |
1 | ...1i32) } } } fn integer_sqrt (n : i32) -> i32 { if n < 2i32 { { return n } } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x...
  |                                                                 ^^        ^^
  |
help: remove these braces
  |
1 - fn factorial (n : i32) -> i64 { if n <= 1i32 { { 1i32 } } else { { (n as i64) * factorial (n - 1i32) } } } fn integer_sqrt (n : i32) -> i32 { if n < 2i32 { { return n } } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2i32 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0i32 { { let temp = b ; b = a % b ; a = temp ; } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; let n = 10i32 ; println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25i32 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48i32 ; let mut b = 18i32 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) ; ; }
1 + fn factorial (n : i32) -> i64 { if n <= 1i32 { { 1i32 } } else { { (n as i64) * factorial (n - 1i32) } } } fn integer_sqrt (n : i32) -> i32 { if n < 2i32 { return n } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2i32 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0i32 { { let temp = b ; b = a % b ; a = temp ; } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; let n = 10i32 ; println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25i32 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48i32 ; let mut b = 18i32 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpG96yJg/main.rs:1:700
  |
1 | ... ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) ; ; }
  |                                                        ^ help: remove this semicolon

error[E0308]: mismatched types
 --> /tmp/.tmpG96yJg/main.rs:1:50
  |
1 | fn factorial (n : i32) -> i64 { if n <= 1i32 { { 1i32 } } else { { (n as i64) * factorial (n - 1i32) } } } fn integer_sqrt (n : i32) -> i...
  |                           ---                    ^^^^ expected `i64`, found `i32`
  |                           |
  |                           expected `i64` because of return type
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - fn factorial (n : i32) -> i64 { if n <= 1i32 { { 1i32 } } else { { (n as i64) * factorial (n - 1i32) } } } fn integer_sqrt (n : i32) -> i32 { if n < 2i32 { { return n } } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2i32 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0i32 { { let temp = b ; b = a % b ; a = temp ; } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; let n = 10i32 ; println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25i32 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48i32 ; let mut b = 18i32 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) ; ; }
1 + fn factorial (n : i32) -> i64 { if n <= 1i32 { { 1i64 } } else { { (n as i64) * factorial (n - 1i32) } } } fn integer_sqrt (n : i32) -> i32 { if n < 2i32 { { return n } } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2i32 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0i32 { { let temp = b ; b = a % b ; a = temp ; } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; let n = 10i32 ; println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25i32 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48i32 ; let mut b = 18i32 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) ; ; }
  |

error[E0384]: cannot assign to immutable argument `b`
 --> /tmp/.tmpG96yJg/main.rs:1:358
  |
1 | ...-> i32 { while b != 0i32 { { let temp = b ; b = a % b ; a = temp ; } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; ...
  |                                                ^^^^^^^^^ cannot assign to immutable argument
  |
help: consider making this binding mutable
  |
1 | fn factorial (n : i32) -> i64 { if n <= 1i32 { { 1i32 } } else { { (n as i64) * factorial (n - 1i32) } } } fn integer_sqrt (n : i32) -> i32 { if n < 2i32 { { return n } } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2i32 } } ; x } fn gcd (a : i32 , mut b : i32) -> i32 { while b != 0i32 { { let temp = b ; b = a % b ; a = temp ; } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; let n = 10i32 ; println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25i32 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48i32 ; let mut b = 18i32 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) ; ; }
  |                                                                                                                                                                                                                                                                                                                 +++

error[E0384]: cannot assign to immutable argument `a`
 --> /tmp/.tmpG96yJg/main.rs:1:370
  |
1 | ...ile b != 0i32 { { let temp = b ; b = a % b ; a = temp ; } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; let n = 10i...
  |                                                 ^^^^^^^^ cannot assign to immutable argument
  |
help: consider making this binding mutable
  |
1 | fn factorial (n : i32) -> i64 { if n <= 1i32 { { 1i32 } } else { { (n as i64) * factorial (n - 1i32) } } } fn integer_sqrt (n : i32) -> i32 { if n < 2i32 { { return n } } ; let mut x = n / 2i32 ; ; let mut prev = 0i32 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2i32 } } ; x } fn gcd (mut a : i32 , b : i32) -> i32 { while b != 0i32 { { let temp = b ; b = a % b ; a = temp ; } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; let n = 10i32 ; println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25i32 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48i32 ; let mut b = 18i32 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) ; ; }
  |                                                                                                                                                                                                                                                                                                       +++

warning: variable does not need to be mutable
 --> /tmp/.tmpG96yJg/main.rs:1:524
  |
1 | ... ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25i32 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let ...
  |                                                         ----^
  |                                                         |
  |                                                         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

warning: variable does not need to be mutable
 --> /tmp/.tmpG96yJg/main.rs:1:605
  |
1 | ...Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48i32 ; let mut b = 18i32 ; println ! ("GCD of {} and {}: {}" , a , b , g...
  |                                                         ----^
  |                                                         |
  |                                                         help: remove this `mut`

warning: variable does not need to be mutable
 --> /tmp/.tmpG96yJg/main.rs:1:625
  |
1 | ...}" , x , integer_sqrt (x)) ; let mut a = 48i32 ; let mut b = 18i32 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) ; ; }
  |                                                         ----^
  |                                                         |
  |                                                         help: remove this `mut`

error: aborting due to 3 previous errors; 9 warnings emitted

Some errors have detailed explanations: E0308, E0384.
For more information about an error, try `rustc --explain E0308`.



=== ch03-00-functions-tdd example 10 ===
DEBUG: About to call transpile_to_program
✗ Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Expected RightParen, found Colon


=== ch03-00-functions-tdd example 11 ===
DEBUG: About to call transpile_to_program
DEBUG: transpile_to_program completed
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `DataFrame` in this scope
 --> /tmp/.tmpLdg2yf/main.rs:1:28
  |
1 | fn add_profit_margin (df : DataFrame) -> DataFrame { df . with_column ("margin" , | row | { (row . get ("revenue") . cloned () . unwrap_o...
  |                            ^^^^^^^^^ not found in this scope

error[E0412]: cannot find type `DataFrame` in this scope
 --> /tmp/.tmpLdg2yf/main.rs:1:42
  |
1 | fn add_profit_margin (df : DataFrame) -> DataFrame { df . with_column ("margin" , | row | { (row . get ("revenue") . cloned () . unwrap_o...
  |                                          ^^^^^^^^^ not found in this scope

error[E0412]: cannot find type `DataFrame` in this scope
 --> /tmp/.tmpLdg2yf/main.rs:1:387
  |
1 | ...d")) * 100f64 }) } fn summarize_by_category (df : DataFrame) -> DataFrame { df . groupby (& []) . expect ("Failed to group DataFrame")...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0412]: cannot find type `DataFrame` in this scope
 --> /tmp/.tmpLdg2yf/main.rs:1:401
  |
1 | ...}) } fn summarize_by_category (df : DataFrame) -> DataFrame { df . groupby (& []) . expect ("Failed to group DataFrame") . agg ("quant...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 4 previous errors

For more information about this error, try `rustc --explain E0412`.

Error: Compilation failed:
error[E0412]: cannot find type `DataFrame` in this scope
 --> /tmp/.tmpLdg2yf/main.rs:1:28
  |
1 | fn add_profit_margin (df : DataFrame) -> DataFrame { df . with_column ("margin" , | row | { (row . get ("revenue") . cloned () . unwrap_o...
  |                            ^^^^^^^^^ not found in this scope

error[E0412]: cannot find type `DataFrame` in this scope
 --> /tmp/.tmpLdg2yf/main.rs:1:42
  |
1 | fn add_profit_margin (df : DataFrame) -> DataFrame { df . with_column ("margin" , | row | { (row . get ("revenue") . cloned () . unwrap_o...
  |                                          ^^^^^^^^^ not found in this scope

error[E0412]: cannot find type `DataFrame` in this scope
 --> /tmp/.tmpLdg2yf/main.rs:1:387
  |
1 | ...d")) * 100f64 }) } fn summarize_by_category (df : DataFrame) -> DataFrame { df . groupby (& []) . expect ("Failed to group DataFrame")...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0412]: cannot find type `DataFrame` in this scope
 --> /tmp/.tmpLdg2yf/main.rs:1:401
  |
1 | ...}) } fn summarize_by_category (df : DataFrame) -> DataFrame { df . groupby (& []) . expect ("Failed to group DataFrame") . agg ("quant...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 4 previous errors

For more information about this error, try `rustc --explain E0412`.



=== ch17-00-error-handling-robustness example 3 ===
DEBUG: About to call transpile_to_program
DEBUG: transpile_to_program completed
✗ Compilation failed: Compilation failed:
warning: unnecessary trailing semicolon
 --> /tmp/.tmpHalmzH/main.rs:1:163
  |
1 | ...er") ; return 0f64 } } ; let mut guess = x / 2f64 ; ; let mut i = 0i32 ; ; while i < 10i32 { { if guess * guess > x - 0.01f64 && guess...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpHalmzH/main.rs:1:184
  |
1 | ...} ; let mut guess = x / 2f64 ; ; let mut i = 0i32 ; ; while i < 10i32 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f6...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpHalmzH/main.rs:1:270
  |
1 | ...ess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { { return guess } } ; guess = (guess + x / guess) / 2f64 ; i = i + 1i32 } } ...
  |                                                               ^^            ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn safe_sqrt (x : f64) -> f64 { if x < 0f64 { { println ! ("Error: Cannot compute square root of negative number") ; return 0f64 } } ; let mut guess = x / 2f64 ; ; let mut i = 0i32 ; ; while i < 10i32 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { { return guess } } ; guess = (guess + x / guess) / 2f64 ; i = i + 1i32 } } ; guess } fn safe_factorial (n : i32) -> i64 { if n < 0i32 { { println ! ("Error: Factorial undefined for negative numbers") ; return 0i32 } } ; if n > 20i32 { { println ! ("Error: Factorial too large, computing factorial(20)") ; return safe_factorial (20i32) } } ; if n <= 1i32 { { return 1i32 } ((n as i64)) * safe_factorial (n - 1i32) } } fn main () { let sqrt1 = safe_sqrt (16f64) ; let sqrt2 = safe_sqrt (- 4f64) ; let fact1 = safe_factorial (5i32) ; let fact2 = safe_factorial (- 3i32) ; let fact3 = safe_factorial (25i32) ; println ! ("{} {:?} {:?}" , "Square roots: {:.2}, {:.2}" , sqrt1 , sqrt2) ; println ! ("Factorials: {}, {}, {}" , fact1 , fact2 , fact3) ; }
1 + fn safe_sqrt (x : f64) -> f64 { if x < 0f64 { { println ! ("Error: Cannot compute square root of negative number") ; return 0f64 } } ; let mut guess = x / 2f64 ; ; let mut i = 0i32 ; ; while i < 10i32 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { return guess } ; guess = (guess + x / guess) / 2f64 ; i = i + 1i32 } } ; guess } fn safe_factorial (n : i32) -> i64 { if n < 0i32 { { println ! ("Error: Factorial undefined for negative numbers") ; return 0i32 } } ; if n > 20i32 { { println ! ("Error: Factorial too large, computing factorial(20)") ; return safe_factorial (20i32) } } ; if n <= 1i32 { { return 1i32 } ((n as i64)) * safe_factorial (n - 1i32) } } fn main () { let sqrt1 = safe_sqrt (16f64) ; let sqrt2 = safe_sqrt (- 4f64) ; let fact1 = safe_factorial (5i32) ; let fact2 = safe_factorial (- 3i32) ; let fact3 = safe_factorial (25i32) ; println ! ("{} {:?} {:?}" , "Square roots: {:.2}, {:.2}" , sqrt1 , sqrt2) ; println ! ("Factorials: {}, {}, {}" , fact1 , fact2 , fact3) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpHalmzH/main.rs:1:626
  |
1 | ...20)") ; return safe_factorial (20i32) } } ; if n <= 1i32 { { return 1i32 } ((n as i64)) * safe_factorial (n - 1i32) } } fn main () { l...
  |                                                               ^^           ^^
  |
help: remove these braces
  |
1 - fn safe_sqrt (x : f64) -> f64 { if x < 0f64 { { println ! ("Error: Cannot compute square root of negative number") ; return 0f64 } } ; let mut guess = x / 2f64 ; ; let mut i = 0i32 ; ; while i < 10i32 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { { return guess } } ; guess = (guess + x / guess) / 2f64 ; i = i + 1i32 } } ; guess } fn safe_factorial (n : i32) -> i64 { if n < 0i32 { { println ! ("Error: Factorial undefined for negative numbers") ; return 0i32 } } ; if n > 20i32 { { println ! ("Error: Factorial too large, computing factorial(20)") ; return safe_factorial (20i32) } } ; if n <= 1i32 { { return 1i32 } ((n as i64)) * safe_factorial (n - 1i32) } } fn main () { let sqrt1 = safe_sqrt (16f64) ; let sqrt2 = safe_sqrt (- 4f64) ; let fact1 = safe_factorial (5i32) ; let fact2 = safe_factorial (- 3i32) ; let fact3 = safe_factorial (25i32) ; println ! ("{} {:?} {:?}" , "Square roots: {:.2}, {:.2}" , sqrt1 , sqrt2) ; println ! ("Factorials: {}, {}, {}" , fact1 , fact2 , fact3) ; }
1 + fn safe_sqrt (x : f64) -> f64 { if x < 0f64 { { println ! ("Error: Cannot compute square root of negative number") ; return 0f64 } } ; let mut guess = x / 2f64 ; ; let mut i = 0i32 ; ; while i < 10i32 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { { return guess } } ; guess = (guess + x / guess) / 2f64 ; i = i + 1i32 } } ; guess } fn safe_factorial (n : i32) -> i64 { if n < 0i32 { { println ! ("Error: Factorial undefined for negative numbers") ; return 0i32 } } ; if n > 20i32 { { println ! ("Error: Factorial too large, computing factorial(20)") ; return safe_factorial (20i32) } } ; if n <= 1i32 { return 1i32 ((n as i64)) * safe_factorial (n - 1i32) } } fn main () { let sqrt1 = safe_sqrt (16f64) ; let sqrt2 = safe_sqrt (- 4f64) ; let fact1 = safe_factorial (5i32) ; let fact2 = safe_factorial (- 3i32) ; let fact3 = safe_factorial (25i32) ; println ! ("{} {:?} {:?}" , "Square roots: {:.2}, {:.2}" , sqrt1 , sqrt2) ; println ! ("Factorials: {}, {}, {}" , fact1 , fact2 , fact3) ; }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpHalmzH/main.rs:1:479
  |
1 | ... -> i64 { if n < 0i32 { { println ! ("Error: Factorial undefined for negative numbers") ; return 0i32 } } ; if n > 20i32 { { println !...
  |        --- expected `i64` because of return type                                                    ^^^^ expected `i64`, found `i32`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - fn safe_sqrt (x : f64) -> f64 { if x < 0f64 { { println ! ("Error: Cannot compute square root of negative number") ; return 0f64 } } ; let mut guess = x / 2f64 ; ; let mut i = 0i32 ; ; while i < 10i32 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { { return guess } } ; guess = (guess + x / guess) / 2f64 ; i = i + 1i32 } } ; guess } fn safe_factorial (n : i32) -> i64 { if n < 0i32 { { println ! ("Error: Factorial undefined for negative numbers") ; return 0i32 } } ; if n > 20i32 { { println ! ("Error: Factorial too large, computing factorial(20)") ; return safe_factorial (20i32) } } ; if n <= 1i32 { { return 1i32 } ((n as i64)) * safe_factorial (n - 1i32) } } fn main () { let sqrt1 = safe_sqrt (16f64) ; let sqrt2 = safe_sqrt (- 4f64) ; let fact1 = safe_factorial (5i32) ; let fact2 = safe_factorial (- 3i32) ; let fact3 = safe_factorial (25i32) ; println ! ("{} {:?} {:?}" , "Square roots: {:.2}, {:.2}" , sqrt1 , sqrt2) ; println ! ("Factorials: {}, {}, {}" , fact1 , fact2 , fact3) ; }
1 + fn safe_sqrt (x : f64) -> f64 { if x < 0f64 { { println ! ("Error: Cannot compute square root of negative number") ; return 0f64 } } ; let mut guess = x / 2f64 ; ; let mut i = 0i32 ; ; while i < 10i32 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { { return guess } } ; guess = (guess + x / guess) / 2f64 ; i = i + 1i32 } } ; guess } fn safe_factorial (n : i32) -> i64 { if n < 0i32 { { println ! ("Error: Factorial undefined for negative numbers") ; return 0i64 } } ; if n > 20i32 { { println ! ("Error: Factorial too large, computing factorial(20)") ; return safe_factorial (20i32) } } ; if n <= 1i32 { { return 1i32 } ((n as i64)) * safe_factorial (n - 1i32) } } fn main () { let sqrt1 = safe_sqrt (16f64) ; let sqrt2 = safe_sqrt (- 4f64) ; let fact1 = safe_factorial (5i32) ; let fact2 = safe_factorial (- 3i32) ; let fact3 = safe_factorial (25i32) ; println ! ("{} {:?} {:?}" , "Square roots: {:.2}, {:.2}" , sqrt1 , sqrt2) ; println ! ("Factorials: {}, {}, {}" , fact1 , fact2 , fact3) ; }
  |

warning: unreachable expression
 --> /tmp/.tmpHalmzH/main.rs:1:642
  |
1 | ...i32) } } ; if n <= 1i32 { { return 1i32 } ((n as i64)) * safe_factorial (n - 1i32) } } fn main () { let sqrt1 = safe_sqrt (16f64) ; le...
  |                                -----------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression
  |                                |
  |                                any code following this expression is unreachable
  |
  = note: `#[warn(unreachable_code)]` on by default

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpHalmzH/main.rs:1:611
  |
1 | ...-> i64 { if n < 0i32 { { println ! ("Error: Factorial undefined for negative numbers") ; return 0i32 } } ; if n > 20i32 { { println ! ("Error: Factorial too large, computing factorial(20)") ; return safe_factorial (20i32) } } ; if n <= 1i32 { { return 1i32 } ((n as i64)) * safe_factorial (n - 1i32) } } ...
  |       --- expected `i64` because of this return type                                                                                                                                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type

error: aborting due to 2 previous errors; 5 warnings emitted

Some errors have detailed explanations: E0308, E0317.
For more information about an error, try `rustc --explain E0308`.

Error: Compilation failed:
warning: unnecessary trailing semicolon
 --> /tmp/.tmpHalmzH/main.rs:1:163
  |
1 | ...er") ; return 0f64 } } ; let mut guess = x / 2f64 ; ; let mut i = 0i32 ; ; while i < 10i32 { { if guess * guess > x - 0.01f64 && guess...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpHalmzH/main.rs:1:184
  |
1 | ...} ; let mut guess = x / 2f64 ; ; let mut i = 0i32 ; ; while i < 10i32 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f6...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpHalmzH/main.rs:1:270
  |
1 | ...ess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { { return guess } } ; guess = (guess + x / guess) / 2f64 ; i = i + 1i32 } } ...
  |                                                               ^^            ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn safe_sqrt (x : f64) -> f64 { if x < 0f64 { { println ! ("Error: Cannot compute square root of negative number") ; return 0f64 } } ; let mut guess = x / 2f64 ; ; let mut i = 0i32 ; ; while i < 10i32 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { { return guess } } ; guess = (guess + x / guess) / 2f64 ; i = i + 1i32 } } ; guess } fn safe_factorial (n : i32) -> i64 { if n < 0i32 { { println ! ("Error: Factorial undefined for negative numbers") ; return 0i32 } } ; if n > 20i32 { { println ! ("Error: Factorial too large, computing factorial(20)") ; return safe_factorial (20i32) } } ; if n <= 1i32 { { return 1i32 } ((n as i64)) * safe_factorial (n - 1i32) } } fn main () { let sqrt1 = safe_sqrt (16f64) ; let sqrt2 = safe_sqrt (- 4f64) ; let fact1 = safe_factorial (5i32) ; let fact2 = safe_factorial (- 3i32) ; let fact3 = safe_factorial (25i32) ; println ! ("{} {:?} {:?}" , "Square roots: {:.2}, {:.2}" , sqrt1 , sqrt2) ; println ! ("Factorials: {}, {}, {}" , fact1 , fact2 , fact3) ; }
1 + fn safe_sqrt (x : f64) -> f64 { if x < 0f64 { { println ! ("Error: Cannot compute square root of negative number") ; return 0f64 } } ; let mut guess = x / 2f64 ; ; let mut i = 0i32 ; ; while i < 10i32 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { return guess } ; guess = (guess + x / guess) / 2f64 ; i = i + 1i32 } } ; guess } fn safe_factorial (n : i32) -> i64 { if n < 0i32 { { println ! ("Error: Factorial undefined for negative numbers") ; return 0i32 } } ; if n > 20i32 { { println ! ("Error: Factorial too large, computing factorial(20)") ; return safe_factorial (20i32) } } ; if n <= 1i32 { { return 1i32 } ((n as i64)) * safe_factorial (n - 1i32) } } fn main () { let sqrt1 = safe_sqrt (16f64) ; let sqrt2 = safe_sqrt (- 4f64) ; let fact1 = safe_factorial (5i32) ; let fact2 = safe_factorial (- 3i32) ; let fact3 = safe_factorial (25i32) ; println ! ("{} {:?} {:?}" , "Square roots: {:.2}, {:.2}" , sqrt1 , sqrt2) ; println ! ("Factorials: {}, {}, {}" , fact1 , fact2 , fact3) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpHalmzH/main.rs:1:626
  |
1 | ...20)") ; return safe_factorial (20i32) } } ; if n <= 1i32 { { return 1i32 } ((n as i64)) * safe_factorial (n - 1i32) } } fn main () { l...
  |                                                               ^^           ^^
  |
help: remove these braces
  |
1 - fn safe_sqrt (x : f64) -> f64 { if x < 0f64 { { println ! ("Error: Cannot compute square root of negative number") ; return 0f64 } } ; let mut guess = x / 2f64 ; ; let mut i = 0i32 ; ; while i < 10i32 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { { return guess } } ; guess = (guess + x / guess) / 2f64 ; i = i + 1i32 } } ; guess } fn safe_factorial (n : i32) -> i64 { if n < 0i32 { { println ! ("Error: Factorial undefined for negative numbers") ; return 0i32 } } ; if n > 20i32 { { println ! ("Error: Factorial too large, computing factorial(20)") ; return safe_factorial (20i32) } } ; if n <= 1i32 { { return 1i32 } ((n as i64)) * safe_factorial (n - 1i32) } } fn main () { let sqrt1 = safe_sqrt (16f64) ; let sqrt2 = safe_sqrt (- 4f64) ; let fact1 = safe_factorial (5i32) ; let fact2 = safe_factorial (- 3i32) ; let fact3 = safe_factorial (25i32) ; println ! ("{} {:?} {:?}" , "Square roots: {:.2}, {:.2}" , sqrt1 , sqrt2) ; println ! ("Factorials: {}, {}, {}" , fact1 , fact2 , fact3) ; }
1 + fn safe_sqrt (x : f64) -> f64 { if x < 0f64 { { println ! ("Error: Cannot compute square root of negative number") ; return 0f64 } } ; let mut guess = x / 2f64 ; ; let mut i = 0i32 ; ; while i < 10i32 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { { return guess } } ; guess = (guess + x / guess) / 2f64 ; i = i + 1i32 } } ; guess } fn safe_factorial (n : i32) -> i64 { if n < 0i32 { { println ! ("Error: Factorial undefined for negative numbers") ; return 0i32 } } ; if n > 20i32 { { println ! ("Error: Factorial too large, computing factorial(20)") ; return safe_factorial (20i32) } } ; if n <= 1i32 { return 1i32 ((n as i64)) * safe_factorial (n - 1i32) } } fn main () { let sqrt1 = safe_sqrt (16f64) ; let sqrt2 = safe_sqrt (- 4f64) ; let fact1 = safe_factorial (5i32) ; let fact2 = safe_factorial (- 3i32) ; let fact3 = safe_factorial (25i32) ; println ! ("{} {:?} {:?}" , "Square roots: {:.2}, {:.2}" , sqrt1 , sqrt2) ; println ! ("Factorials: {}, {}, {}" , fact1 , fact2 , fact3) ; }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpHalmzH/main.rs:1:479
  |
1 | ... -> i64 { if n < 0i32 { { println ! ("Error: Factorial undefined for negative numbers") ; return 0i32 } } ; if n > 20i32 { { println !...
  |        --- expected `i64` because of return type                                                    ^^^^ expected `i64`, found `i32`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - fn safe_sqrt (x : f64) -> f64 { if x < 0f64 { { println ! ("Error: Cannot compute square root of negative number") ; return 0f64 } } ; let mut guess = x / 2f64 ; ; let mut i = 0i32 ; ; while i < 10i32 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { { return guess } } ; guess = (guess + x / guess) / 2f64 ; i = i + 1i32 } } ; guess } fn safe_factorial (n : i32) -> i64 { if n < 0i32 { { println ! ("Error: Factorial undefined for negative numbers") ; return 0i32 } } ; if n > 20i32 { { println ! ("Error: Factorial too large, computing factorial(20)") ; return safe_factorial (20i32) } } ; if n <= 1i32 { { return 1i32 } ((n as i64)) * safe_factorial (n - 1i32) } } fn main () { let sqrt1 = safe_sqrt (16f64) ; let sqrt2 = safe_sqrt (- 4f64) ; let fact1 = safe_factorial (5i32) ; let fact2 = safe_factorial (- 3i32) ; let fact3 = safe_factorial (25i32) ; println ! ("{} {:?} {:?}" , "Square roots: {:.2}, {:.2}" , sqrt1 , sqrt2) ; println ! ("Factorials: {}, {}, {}" , fact1 , fact2 , fact3) ; }
1 + fn safe_sqrt (x : f64) -> f64 { if x < 0f64 { { println ! ("Error: Cannot compute square root of negative number") ; return 0f64 } } ; let mut guess = x / 2f64 ; ; let mut i = 0i32 ; ; while i < 10i32 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { { return guess } } ; guess = (guess + x / guess) / 2f64 ; i = i + 1i32 } } ; guess } fn safe_factorial (n : i32) -> i64 { if n < 0i32 { { println ! ("Error: Factorial undefined for negative numbers") ; return 0i64 } } ; if n > 20i32 { { println ! ("Error: Factorial too large, computing factorial(20)") ; return safe_factorial (20i32) } } ; if n <= 1i32 { { return 1i32 } ((n as i64)) * safe_factorial (n - 1i32) } } fn main () { let sqrt1 = safe_sqrt (16f64) ; let sqrt2 = safe_sqrt (- 4f64) ; let fact1 = safe_factorial (5i32) ; let fact2 = safe_factorial (- 3i32) ; let fact3 = safe_factorial (25i32) ; println ! ("{} {:?} {:?}" , "Square roots: {:.2}, {:.2}" , sqrt1 , sqrt2) ; println ! ("Factorials: {}, {}, {}" , fact1 , fact2 , fact3) ; }
  |

warning: unreachable expression
 --> /tmp/.tmpHalmzH/main.rs:1:642
  |
1 | ...i32) } } ; if n <= 1i32 { { return 1i32 } ((n as i64)) * safe_factorial (n - 1i32) } } fn main () { let sqrt1 = safe_sqrt (16f64) ; le...
  |                                -----------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression
  |                                |
  |                                any code following this expression is unreachable
  |
  = note: `#[warn(unreachable_code)]` on by default

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpHalmzH/main.rs:1:611
  |
1 | ...-> i64 { if n < 0i32 { { println ! ("Error: Factorial undefined for negative numbers") ; return 0i32 } } ; if n > 20i32 { { println ! ("Error: Factorial too large, computing factorial(20)") ; return safe_factorial (20i32) } } ; if n <= 1i32 { { return 1i32 } ((n as i64)) * safe_factorial (n - 1i32) } } ...
  |       --- expected `i64` because of this return type                                                                                                                                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type

error: aborting due to 2 previous errors; 5 warnings emitted

Some errors have detailed explanations: E0308, E0317.
For more information about an error, try `rustc --explain E0308`.



=== ch17-00-error-handling-robustness example 4 ===
DEBUG: About to call transpile_to_program
DEBUG: transpile_to_program completed
✗ Compilation failed: Compilation failed:
warning: unnecessary trailing semicolon
 --> /tmp/.tmpFn8b6B/main.rs:1:399
  |
1 | ...]) -> i32 { let mut max = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < 5i32 { { if numbers [i as usize] > max { { max = ...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpFn8b6B/main.rs:1:420
  |
1 | ...ax = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < 5i32 { { if numbers [i as usize] > max { { max = numbers [i as usize] ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpFn8b6B/main.rs:1:473
  |
1 | ... while i < 5i32 { { if numbers [i as usize] > max { { max = numbers [i as usize] } } ; i = i + 1i32 } } ; max } fn main () { let data ...
  |                                                        ^^                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn safe_array_access (arr : [i32 ; 5] , index : i32) -> i32 { if index < 0i32 { { println ! ("Error: Array index cannot be negative") ; return arr [0i32 as usize] } } ; if index >= 5i32 { { println ! ("Error: Array index {} out of bounds" , index) ; return arr [4i32 as usize] } } ; arr [index as usize] } fn find_maximum_safe (numbers : [i32 ; 5]) -> i32 { let mut max = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < 5i32 { { if numbers [i as usize] > max { { max = numbers [i as usize] } } ; i = i + 1i32 } } ; max } fn main () { let data = vec ! [10i32 , 25i32 , 5i32 , 30i32 , 15i32] ; let val1 = safe_array_access (data , 2i32) ; let val2 = safe_array_access (data , - 1i32) ; let val3 = safe_array_access (data , 10i32) ; let maximum = find_maximum_safe (data) ; println ! ("Values: {}, {}, {}" , val1 , val2 , val3) ; println ! ("Maximum: {}" , maximum) ; }
1 + fn safe_array_access (arr : [i32 ; 5] , index : i32) -> i32 { if index < 0i32 { { println ! ("Error: Array index cannot be negative") ; return arr [0i32 as usize] } } ; if index >= 5i32 { { println ! ("Error: Array index {} out of bounds" , index) ; return arr [4i32 as usize] } } ; arr [index as usize] } fn find_maximum_safe (numbers : [i32 ; 5]) -> i32 { let mut max = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < 5i32 { { if numbers [i as usize] > max { max = numbers [i as usize] } ; i = i + 1i32 } } ; max } fn main () { let data = vec ! [10i32 , 25i32 , 5i32 , 30i32 , 15i32] ; let val1 = safe_array_access (data , 2i32) ; let val2 = safe_array_access (data , - 1i32) ; let val3 = safe_array_access (data , 10i32) ; let maximum = find_maximum_safe (data) ; println ! ("Values: {}, {}, {}" , val1 , val2 , val3) ; println ! ("Maximum: {}" , maximum) ; }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpFn8b6B/main.rs:1:634
  |
1 | ... 5i32 , 30i32 , 15i32] ; let val1 = safe_array_access (data , 2i32) ; let val2 = safe_array_access (data , - 1i32) ; let val3 = safe_a...
  |                                        -----------------  ^^^^ expected `[i32; 5]`, found `Vec<i32>`
  |                                        |
  |                                        arguments to this function are incorrect
  |
  = note: expected array `[i32; 5]`
            found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmpFn8b6B/main.rs:1:4
  |
1 | fn safe_array_access (arr : [i32 ; 5] , index : i32) -> i32 { if index < 0i32 { { println ! ("Error: Array index cannot be negative") ; r...
  |    ^^^^^^^^^^^^^^^^^  ---------------

error[E0308]: mismatched types
 --> /tmp/.tmpFn8b6B/main.rs:1:679
  |
1 | ...y_access (data , 2i32) ; let val2 = safe_array_access (data , - 1i32) ; let val3 = safe_array_access (data , 10i32) ; let maximum = fi...
  |                                        -----------------  ^^^^ expected `[i32; 5]`, found `Vec<i32>`
  |                                        |
  |                                        arguments to this function are incorrect
  |
  = note: expected array `[i32; 5]`
            found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmpFn8b6B/main.rs:1:4
  |
1 | fn safe_array_access (arr : [i32 ; 5] , index : i32) -> i32 { if index < 0i32 { { println ! ("Error: Array index cannot be negative") ; r...
  |    ^^^^^^^^^^^^^^^^^  ---------------

error[E0308]: mismatched types
 --> /tmp/.tmpFn8b6B/main.rs:1:726
  |
1 | ...access (data , - 1i32) ; let val3 = safe_array_access (data , 10i32) ; let maximum = find_maximum_safe (data) ; println ! ("Values: {}...
  |                                        -----------------  ^^^^ expected `[i32; 5]`, found `Vec<i32>`
  |                                        |
  |                                        arguments to this function are incorrect
  |
  = note: expected array `[i32; 5]`
            found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmpFn8b6B/main.rs:1:4
  |
1 | fn safe_array_access (arr : [i32 ; 5] , index : i32) -> i32 { if index < 0i32 { { println ! ("Error: Array index cannot be negative") ; r...
  |    ^^^^^^^^^^^^^^^^^  ---------------

error[E0308]: mismatched types
 --> /tmp/.tmpFn8b6B/main.rs:1:775
  |
1 | ...cess (data , 10i32) ; let maximum = find_maximum_safe (data) ; println ! ("Values: {}, {}, {}" , val1 , val2 , val3) ; println ! ("Max...
  |                                        -----------------  ^^^^ expected `[i32; 5]`, found `Vec<i32>`
  |                                        |
  |                                        arguments to this function are incorrect
  |
  = note: expected array `[i32; 5]`
            found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmpFn8b6B/main.rs:1:310
  |
1 | ...4i32 as usize] } } ; arr [index as usize] } fn find_maximum_safe (numbers : [i32 ; 5]) -> i32 { let mut max = numbers [0i32 as usize] ...
  |                                                   ^^^^^^^^^^^^^^^^^  -------------------

error: aborting due to 4 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0308`.

Error: Compilation failed:
warning: unnecessary trailing semicolon
 --> /tmp/.tmpFn8b6B/main.rs:1:399
  |
1 | ...]) -> i32 { let mut max = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < 5i32 { { if numbers [i as usize] > max { { max = ...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpFn8b6B/main.rs:1:420
  |
1 | ...ax = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < 5i32 { { if numbers [i as usize] > max { { max = numbers [i as usize] ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpFn8b6B/main.rs:1:473
  |
1 | ... while i < 5i32 { { if numbers [i as usize] > max { { max = numbers [i as usize] } } ; i = i + 1i32 } } ; max } fn main () { let data ...
  |                                                        ^^                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn safe_array_access (arr : [i32 ; 5] , index : i32) -> i32 { if index < 0i32 { { println ! ("Error: Array index cannot be negative") ; return arr [0i32 as usize] } } ; if index >= 5i32 { { println ! ("Error: Array index {} out of bounds" , index) ; return arr [4i32 as usize] } } ; arr [index as usize] } fn find_maximum_safe (numbers : [i32 ; 5]) -> i32 { let mut max = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < 5i32 { { if numbers [i as usize] > max { { max = numbers [i as usize] } } ; i = i + 1i32 } } ; max } fn main () { let data = vec ! [10i32 , 25i32 , 5i32 , 30i32 , 15i32] ; let val1 = safe_array_access (data , 2i32) ; let val2 = safe_array_access (data , - 1i32) ; let val3 = safe_array_access (data , 10i32) ; let maximum = find_maximum_safe (data) ; println ! ("Values: {}, {}, {}" , val1 , val2 , val3) ; println ! ("Maximum: {}" , maximum) ; }
1 + fn safe_array_access (arr : [i32 ; 5] , index : i32) -> i32 { if index < 0i32 { { println ! ("Error: Array index cannot be negative") ; return arr [0i32 as usize] } } ; if index >= 5i32 { { println ! ("Error: Array index {} out of bounds" , index) ; return arr [4i32 as usize] } } ; arr [index as usize] } fn find_maximum_safe (numbers : [i32 ; 5]) -> i32 { let mut max = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < 5i32 { { if numbers [i as usize] > max { max = numbers [i as usize] } ; i = i + 1i32 } } ; max } fn main () { let data = vec ! [10i32 , 25i32 , 5i32 , 30i32 , 15i32] ; let val1 = safe_array_access (data , 2i32) ; let val2 = safe_array_access (data , - 1i32) ; let val3 = safe_array_access (data , 10i32) ; let maximum = find_maximum_safe (data) ; println ! ("Values: {}, {}, {}" , val1 , val2 , val3) ; println ! ("Maximum: {}" , maximum) ; }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpFn8b6B/main.rs:1:634
  |
1 | ... 5i32 , 30i32 , 15i32] ; let val1 = safe_array_access (data , 2i32) ; let val2 = safe_array_access (data , - 1i32) ; let val3 = safe_a...
  |                                        -----------------  ^^^^ expected `[i32; 5]`, found `Vec<i32>`
  |                                        |
  |                                        arguments to this function are incorrect
  |
  = note: expected array `[i32; 5]`
            found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmpFn8b6B/main.rs:1:4
  |
1 | fn safe_array_access (arr : [i32 ; 5] , index : i32) -> i32 { if index < 0i32 { { println ! ("Error: Array index cannot be negative") ; r...
  |    ^^^^^^^^^^^^^^^^^  ---------------

error[E0308]: mismatched types
 --> /tmp/.tmpFn8b6B/main.rs:1:679
  |
1 | ...y_access (data , 2i32) ; let val2 = safe_array_access (data , - 1i32) ; let val3 = safe_array_access (data , 10i32) ; let maximum = fi...
  |                                        -----------------  ^^^^ expected `[i32; 5]`, found `Vec<i32>`
  |                                        |
  |                                        arguments to this function are incorrect
  |
  = note: expected array `[i32; 5]`
            found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmpFn8b6B/main.rs:1:4
  |
1 | fn safe_array_access (arr : [i32 ; 5] , index : i32) -> i32 { if index < 0i32 { { println ! ("Error: Array index cannot be negative") ; r...
  |    ^^^^^^^^^^^^^^^^^  ---------------

error[E0308]: mismatched types
 --> /tmp/.tmpFn8b6B/main.rs:1:726
  |
1 | ...access (data , - 1i32) ; let val3 = safe_array_access (data , 10i32) ; let maximum = find_maximum_safe (data) ; println ! ("Values: {}...
  |                                        -----------------  ^^^^ expected `[i32; 5]`, found `Vec<i32>`
  |                                        |
  |                                        arguments to this function are incorrect
  |
  = note: expected array `[i32; 5]`
            found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmpFn8b6B/main.rs:1:4
  |
1 | fn safe_array_access (arr : [i32 ; 5] , index : i32) -> i32 { if index < 0i32 { { println ! ("Error: Array index cannot be negative") ; r...
  |    ^^^^^^^^^^^^^^^^^  ---------------

error[E0308]: mismatched types
 --> /tmp/.tmpFn8b6B/main.rs:1:775
  |
1 | ...cess (data , 10i32) ; let maximum = find_maximum_safe (data) ; println ! ("Values: {}, {}, {}" , val1 , val2 , val3) ; println ! ("Max...
  |                                        -----------------  ^^^^ expected `[i32; 5]`, found `Vec<i32>`
  |                                        |
  |                                        arguments to this function are incorrect
  |
  = note: expected array `[i32; 5]`
            found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmpFn8b6B/main.rs:1:310
  |
1 | ...4i32 as usize] } } ; arr [index as usize] } fn find_maximum_safe (numbers : [i32 ; 5]) -> i32 { let mut max = numbers [0i32 as usize] ...
  |                                                   ^^^^^^^^^^^^^^^^^  -------------------

error: aborting due to 4 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch17-00-error-handling-robustness example 7 ===
DEBUG: About to call transpile_to_program
✗ Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Expected body after if condition, typically { ... }: Expected identifier after '::'


=== ch17-00-error-handling-robustness example 8 ===
DEBUG: About to call transpile_to_program
✗ Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Expected body after while condition: Expected RightParen, found Char('0')


=== ch17-00-error-handling-robustness example 9 ===
DEBUG: About to call transpile_to_program
DEBUG: transpile_to_program completed
✗ Compilation failed: Compilation failed:
warning: unnecessary trailing semicolon
 --> /tmp/.tmpo7AuFT/main.rs:1:630
  |
1 | ...intln ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let a...
  |                                                         ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpo7AuFT/main.rs:1:153
  |
1 | ...vide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test...
  |                                               ^^                                            ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
1 + fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { println ! ("✅ Normal division test passed") } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpo7AuFT/main.rs:1:210
  |
1 | ...✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ...
  |                                                ^^                                            ^^
  |
help: remove these braces
  |
1 - fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
1 + fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { println ! ("❌ Normal division test failed") } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpo7AuFT/main.rs:1:326
  |
1 | ...de (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero ...
  |                                             ^^                                                 ^^
  |
help: remove these braces
  |
1 - fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
1 + fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { println ! ("✅ Division by zero handling passed") } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpo7AuFT/main.rs:1:388
  |
1 | ...ion by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , ...
  |                                             ^^                                                 ^^
  |
help: remove these braces
  |
1 - fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
1 + fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { println ! ("❌ Division by zero handling failed") } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpo7AuFT/main.rs:1:513
  |
1 | ...- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number ha...
  |                                             ^^                                                ^^
  |
help: remove these braces
  |
1 - fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
1 + fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { println ! ("✅ Negative number handling passed") } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpo7AuFT/main.rs:1:574
  |
1 | ...tive number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { prin...
  |                                             ^^                                                ^^
  |
help: remove these braces
  |
1 - fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
1 + fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { println ! ("❌ Negative number handling failed") } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpo7AuFT/main.rs:1:1186
  |
1 | ...{ println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_vali...
  |                                                         ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpo7AuFT/main.rs:1:761
  |
1 | ...1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed")...
  |                                                  ^^                                      ^^
  |
help: remove these braces
  |
1 - fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
1 + fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { println ! ("✅ Valid age test passed") } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpo7AuFT/main.rs:1:812
  |
1 | ...ntln ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 =...
  |                                                   ^^                                      ^^
  |
help: remove these braces
  |
1 - fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
1 + fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { println ! ("❌ Valid age test failed") } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpo7AuFT/main.rs:1:911
  |
1 | ... validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handli...
  |                                               ^^                                             ^^
  |
help: remove these braces
  |
1 - fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
1 + fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { println ! ("✅ Negative age handling passed") } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpo7AuFT/main.rs:1:969
  |
1 | ... Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if ag...
  |                                                ^^                                             ^^
  |
help: remove these braces
  |
1 - fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
1 + fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { println ! ("❌ Negative age handling failed") } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpo7AuFT/main.rs:1:1077
  |
1 | ...alidate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling...
  |                                               ^^                                            ^^
  |
help: remove these braces
  |
1 - fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
1 + fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { println ! ("✅ Extreme age handling passed") } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpo7AuFT/main.rs:1:1134
  |
1 | ...✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_hand...
  |                                                ^^                                            ^^
  |
help: remove these braces
  |
1 - fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
1 + fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { println ! ("❌ Extreme age handling failed") } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
  |

error[E0425]: cannot find function `safe_divide` in this scope
 --> /tmp/.tmpo7AuFT/main.rs:1:103
  |
1 | ...ing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `safe_divide` in this scope
 --> /tmp/.tmpo7AuFT/main.rs:1:276
  |
1 | ...ormal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero hand...
  |                                                      ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `safe_divide` in this scope
 --> /tmp/.tmpo7AuFT/main.rs:1:459
  |
1 | ...on by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `validate_age` in this scope
 --> /tmp/.tmpo7AuFT/main.rs:1:719
  |
1 | ...n ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } ...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `validate_age` in this scope
 --> /tmp/.tmpo7AuFT/main.rs:1:869
  |
1 | ...n ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed"...
  |                                                      ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `validate_age` in this scope
 --> /tmp/.tmpo7AuFT/main.rs:1:1033
  |
1 | ... Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed...
  |                                                      ^^^^^^^^^^^^ not found in this scope

error: aborting due to 6 previous errors; 14 warnings emitted

For more information about this error, try `rustc --explain E0425`.

Error: Compilation failed:
warning: unnecessary trailing semicolon
 --> /tmp/.tmpo7AuFT/main.rs:1:630
  |
1 | ...intln ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let a...
  |                                                         ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpo7AuFT/main.rs:1:153
  |
1 | ...vide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test...
  |                                               ^^                                            ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
1 + fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { println ! ("✅ Normal division test passed") } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpo7AuFT/main.rs:1:210
  |
1 | ...✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ...
  |                                                ^^                                            ^^
  |
help: remove these braces
  |
1 - fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
1 + fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { println ! ("❌ Normal division test failed") } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpo7AuFT/main.rs:1:326
  |
1 | ...de (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero ...
  |                                             ^^                                                 ^^
  |
help: remove these braces
  |
1 - fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
1 + fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { println ! ("✅ Division by zero handling passed") } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpo7AuFT/main.rs:1:388
  |
1 | ...ion by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , ...
  |                                             ^^                                                 ^^
  |
help: remove these braces
  |
1 - fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
1 + fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { println ! ("❌ Division by zero handling failed") } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpo7AuFT/main.rs:1:513
  |
1 | ...- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number ha...
  |                                             ^^                                                ^^
  |
help: remove these braces
  |
1 - fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
1 + fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { println ! ("✅ Negative number handling passed") } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpo7AuFT/main.rs:1:574
  |
1 | ...tive number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { prin...
  |                                             ^^                                                ^^
  |
help: remove these braces
  |
1 - fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
1 + fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { println ! ("❌ Negative number handling failed") } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpo7AuFT/main.rs:1:1186
  |
1 | ...{ println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_vali...
  |                                                         ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpo7AuFT/main.rs:1:761
  |
1 | ...1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed")...
  |                                                  ^^                                      ^^
  |
help: remove these braces
  |
1 - fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
1 + fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { println ! ("✅ Valid age test passed") } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpo7AuFT/main.rs:1:812
  |
1 | ...ntln ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 =...
  |                                                   ^^                                      ^^
  |
help: remove these braces
  |
1 - fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
1 + fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { println ! ("❌ Valid age test failed") } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpo7AuFT/main.rs:1:911
  |
1 | ... validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handli...
  |                                               ^^                                             ^^
  |
help: remove these braces
  |
1 - fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
1 + fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { println ! ("✅ Negative age handling passed") } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpo7AuFT/main.rs:1:969
  |
1 | ... Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if ag...
  |                                                ^^                                             ^^
  |
help: remove these braces
  |
1 - fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
1 + fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { println ! ("❌ Negative age handling failed") } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpo7AuFT/main.rs:1:1077
  |
1 | ...alidate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling...
  |                                               ^^                                            ^^
  |
help: remove these braces
  |
1 - fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
1 + fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { println ! ("✅ Extreme age handling passed") } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpo7AuFT/main.rs:1:1134
  |
1 | ...✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_hand...
  |                                                ^^                                            ^^
  |
help: remove these braces
  |
1 - fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { { println ! ("❌ Extreme age handling failed") } } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
1 + fn test_division_error_handling () { println ! ("Testing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test passed") } } else { { println ! ("❌ Normal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero handling passed") } } else { { println ! ("❌ Division by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number handling passed") } } else { { println ! ("❌ Negative number handling failed") } } ; ; } fn test_input_validation () { println ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } else { { println ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed") } } else { { println ! ("❌ Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed") } } else { println ! ("❌ Extreme age handling failed") } ; ; } fn main () { test_division_error_handling () ; println ! ("") ; test_input_validation () ; println ! ("") ; println ! ("🎉 Error handling tests complete!") ; }
  |

error[E0425]: cannot find function `safe_divide` in this scope
 --> /tmp/.tmpo7AuFT/main.rs:1:103
  |
1 | ...ing division error handling...") ; let result1 = safe_divide (10i32 , 2i32) ; if result1 == 5i32 { { println ! ("✅ Normal division test...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `safe_divide` in this scope
 --> /tmp/.tmpo7AuFT/main.rs:1:276
  |
1 | ...ormal division test failed") } } ; let result2 = safe_divide (10i32 , 0i32) ; if result2 == 0i32 { { println ! ("✅ Division by zero hand...
  |                                                      ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `safe_divide` in this scope
 --> /tmp/.tmpo7AuFT/main.rs:1:459
  |
1 | ...on by zero handling failed") } } ; let result3 = safe_divide (- 10i32 , 2i32) ; if result3 == - 5i32 { { println ! ("✅ Negative number ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `validate_age` in this scope
 --> /tmp/.tmpo7AuFT/main.rs:1:719
  |
1 | ...n ! ("Testing input validation...") ; let age1 = validate_age (25i32) ; if age1 == 25i32 { { println ! ("✅ Valid age test passed") } } ...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `validate_age` in this scope
 --> /tmp/.tmpo7AuFT/main.rs:1:869
  |
1 | ...n ! ("❌ Valid age test failed") } } ; let age2 = validate_age (- 5i32) ; if age2 == 0i32 { { println ! ("✅ Negative age handling passed"...
  |                                                      ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `validate_age` in this scope
 --> /tmp/.tmpo7AuFT/main.rs:1:1033
  |
1 | ... Negative age handling failed") } } ; let age3 = validate_age (200i32) ; if age3 == 150i32 { { println ! ("✅ Extreme age handling passed...
  |                                                      ^^^^^^^^^^^^ not found in this scope

error: aborting due to 6 previous errors; 14 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch17-00-error-handling-robustness example 10 ===
DEBUG: About to call transpile_to_program
DEBUG: transpile_to_program completed
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpFgp2sI/main.rs:1:675
  |
1 | ... if data . len () > 1000i32 { { log_warning ("DataProcessor" , "Data size exceeds recommended limit") } } ; log_info ("DataProcessor" ...
  |                                  ^^                                                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn log_error (component : & str , message : & str) { println ! ("[ERROR] {}: {}" , component , message) } fn log_warning (component : & str , message : & str) { println ! ("[WARN] {}: {}" , component , message) } fn log_info (component : & str , message : & str) { println ! ("[INFO] {}: {}" , component , message) } fn process_user_data (user_id : i32 , data : & str) -> bool { log_info ("DataProcessor" , "Starting user data processing") ; if user_id <= 0i32 { { log_error ("DataProcessor" , "Invalid user ID provided") ; return false } } ; if data . len () == 0i32 { { log_error ("DataProcessor" , "Empty data received") ; return false } } ; if data . len () > 1000i32 { { log_warning ("DataProcessor" , "Data size exceeds recommended limit") } } ; log_info ("DataProcessor" , "Processing data for user") ; if user_id == 999i32 { { log_error ("DataProcessor" , "Processing failed for user 999") ; return false } } ; log_info ("DataProcessor" , "Data processing completed successfully") ; return true } fn main () { let results = vec ! [process_user_data (123i32 , "valid_data") , process_user_data (0i32 , "invalid_user") , process_user_data (456i32 , "") , process_user_data (999i32 , "test_data")] ; let mut successful = 0i32 ; let mut i = 0i32 ; while i < 4i32 { { if results [i as usize] { { successful = successful + 1i32 } } ; i = i + 1i32 } } ; println ! ("") ; println ! ("Summary: {}/4 operations successful" , successful) ; }
1 + fn log_error (component : & str , message : & str) { println ! ("[ERROR] {}: {}" , component , message) } fn log_warning (component : & str , message : & str) { println ! ("[WARN] {}: {}" , component , message) } fn log_info (component : & str , message : & str) { println ! ("[INFO] {}: {}" , component , message) } fn process_user_data (user_id : i32 , data : & str) -> bool { log_info ("DataProcessor" , "Starting user data processing") ; if user_id <= 0i32 { { log_error ("DataProcessor" , "Invalid user ID provided") ; return false } } ; if data . len () == 0i32 { { log_error ("DataProcessor" , "Empty data received") ; return false } } ; if data . len () > 1000i32 { log_warning ("DataProcessor" , "Data size exceeds recommended limit") } ; log_info ("DataProcessor" , "Processing data for user") ; if user_id == 999i32 { { log_error ("DataProcessor" , "Processing failed for user 999") ; return false } } ; log_info ("DataProcessor" , "Data processing completed successfully") ; return true } fn main () { let results = vec ! [process_user_data (123i32 , "valid_data") , process_user_data (0i32 , "invalid_user") , process_user_data (456i32 , "") , process_user_data (999i32 , "test_data")] ; let mut successful = 0i32 ; let mut i = 0i32 ; while i < 4i32 { { if results [i as usize] { { successful = successful + 1i32 } } ; i = i + 1i32 } } ; println ! ("") ; println ! ("Summary: {}/4 operations successful" , successful) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpFgp2sI/main.rs:1:1298
  |
1 | ...32 ; while i < 4i32 { { if results [i as usize] { { successful = successful + 1i32 } } ; i = i + 1i32 } } ; println ! ("") ; println !...
  |                                                      ^^                              ^^
  |
help: remove these braces
  |
1 - fn log_error (component : & str , message : & str) { println ! ("[ERROR] {}: {}" , component , message) } fn log_warning (component : & str , message : & str) { println ! ("[WARN] {}: {}" , component , message) } fn log_info (component : & str , message : & str) { println ! ("[INFO] {}: {}" , component , message) } fn process_user_data (user_id : i32 , data : & str) -> bool { log_info ("DataProcessor" , "Starting user data processing") ; if user_id <= 0i32 { { log_error ("DataProcessor" , "Invalid user ID provided") ; return false } } ; if data . len () == 0i32 { { log_error ("DataProcessor" , "Empty data received") ; return false } } ; if data . len () > 1000i32 { { log_warning ("DataProcessor" , "Data size exceeds recommended limit") } } ; log_info ("DataProcessor" , "Processing data for user") ; if user_id == 999i32 { { log_error ("DataProcessor" , "Processing failed for user 999") ; return false } } ; log_info ("DataProcessor" , "Data processing completed successfully") ; return true } fn main () { let results = vec ! [process_user_data (123i32 , "valid_data") , process_user_data (0i32 , "invalid_user") , process_user_data (456i32 , "") , process_user_data (999i32 , "test_data")] ; let mut successful = 0i32 ; let mut i = 0i32 ; while i < 4i32 { { if results [i as usize] { { successful = successful + 1i32 } } ; i = i + 1i32 } } ; println ! ("") ; println ! ("Summary: {}/4 operations successful" , successful) ; }
1 + fn log_error (component : & str , message : & str) { println ! ("[ERROR] {}: {}" , component , message) } fn log_warning (component : & str , message : & str) { println ! ("[WARN] {}: {}" , component , message) } fn log_info (component : & str , message : & str) { println ! ("[INFO] {}: {}" , component , message) } fn process_user_data (user_id : i32 , data : & str) -> bool { log_info ("DataProcessor" , "Starting user data processing") ; if user_id <= 0i32 { { log_error ("DataProcessor" , "Invalid user ID provided") ; return false } } ; if data . len () == 0i32 { { log_error ("DataProcessor" , "Empty data received") ; return false } } ; if data . len () > 1000i32 { { log_warning ("DataProcessor" , "Data size exceeds recommended limit") } } ; log_info ("DataProcessor" , "Processing data for user") ; if user_id == 999i32 { { log_error ("DataProcessor" , "Processing failed for user 999") ; return false } } ; log_info ("DataProcessor" , "Data processing completed successfully") ; return true } fn main () { let results = vec ! [process_user_data (123i32 , "valid_data") , process_user_data (0i32 , "invalid_user") , process_user_data (456i32 , "") , process_user_data (999i32 , "test_data")] ; let mut successful = 0i32 ; let mut i = 0i32 ; while i < 4i32 { { if results [i as usize] { successful = successful + 1i32 } ; i = i + 1i32 } } ; println ! ("") ; println ! ("Summary: {}/4 operations successful" , successful) ; }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpFgp2sI/main.rs:1:564
  |
1 | ...er ID provided") ; return false } } ; if data . len () == 0i32 { { log_error ("DataProcessor" , "Empty data received") ; return false ...
  |                                             -------------    ^^^^ expected `usize`, found `i32`
  |                                             |
  |                                             expected because this is `usize`
  |
help: change the type of the numeric literal from `i32` to `usize`
  |
1 - fn log_error (component : & str , message : & str) { println ! ("[ERROR] {}: {}" , component , message) } fn log_warning (component : & str , message : & str) { println ! ("[WARN] {}: {}" , component , message) } fn log_info (component : & str , message : & str) { println ! ("[INFO] {}: {}" , component , message) } fn process_user_data (user_id : i32 , data : & str) -> bool { log_info ("DataProcessor" , "Starting user data processing") ; if user_id <= 0i32 { { log_error ("DataProcessor" , "Invalid user ID provided") ; return false } } ; if data . len () == 0i32 { { log_error ("DataProcessor" , "Empty data received") ; return false } } ; if data . len () > 1000i32 { { log_warning ("DataProcessor" , "Data size exceeds recommended limit") } } ; log_info ("DataProcessor" , "Processing data for user") ; if user_id == 999i32 { { log_error ("DataProcessor" , "Processing failed for user 999") ; return false } } ; log_info ("DataProcessor" , "Data processing completed successfully") ; return true } fn main () { let results = vec ! [process_user_data (123i32 , "valid_data") , process_user_data (0i32 , "invalid_user") , process_user_data (456i32 , "") , process_user_data (999i32 , "test_data")] ; let mut successful = 0i32 ; let mut i = 0i32 ; while i < 4i32 { { if results [i as usize] { { successful = successful + 1i32 } } ; i = i + 1i32 } } ; println ! ("") ; println ! ("Summary: {}/4 operations successful" , successful) ; }
1 + fn log_error (component : & str , message : & str) { println ! ("[ERROR] {}: {}" , component , message) } fn log_warning (component : & str , message : & str) { println ! ("[WARN] {}: {}" , component , message) } fn log_info (component : & str , message : & str) { println ! ("[INFO] {}: {}" , component , message) } fn process_user_data (user_id : i32 , data : & str) -> bool { log_info ("DataProcessor" , "Starting user data processing") ; if user_id <= 0i32 { { log_error ("DataProcessor" , "Invalid user ID provided") ; return false } } ; if data . len () == 0usize { { log_error ("DataProcessor" , "Empty data received") ; return false } } ; if data . len () > 1000i32 { { log_warning ("DataProcessor" , "Data size exceeds recommended limit") } } ; log_info ("DataProcessor" , "Processing data for user") ; if user_id == 999i32 { { log_error ("DataProcessor" , "Processing failed for user 999") ; return false } } ; log_info ("DataProcessor" , "Data processing completed successfully") ; return true } fn main () { let results = vec ! [process_user_data (123i32 , "valid_data") , process_user_data (0i32 , "invalid_user") , process_user_data (456i32 , "") , process_user_data (999i32 , "test_data")] ; let mut successful = 0i32 ; let mut i = 0i32 ; while i < 4i32 { { if results [i as usize] { { successful = successful + 1i32 } } ; i = i + 1i32 } } ; println ! ("") ; println ! ("Summary: {}/4 operations successful" , successful) ; }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpFgp2sI/main.rs:1:665
  |
1 | ...data received") ; return false } } ; if data . len () > 1000i32 { { log_warning ("DataProcessor" , "Data size exceeds recommended limi...
  |                                            -------------   ^^^^^^^ expected `usize`, found `i32`
  |                                            |
  |                                            expected because this is `usize`
  |
help: change the type of the numeric literal from `i32` to `usize`
  |
1 - fn log_error (component : & str , message : & str) { println ! ("[ERROR] {}: {}" , component , message) } fn log_warning (component : & str , message : & str) { println ! ("[WARN] {}: {}" , component , message) } fn log_info (component : & str , message : & str) { println ! ("[INFO] {}: {}" , component , message) } fn process_user_data (user_id : i32 , data : & str) -> bool { log_info ("DataProcessor" , "Starting user data processing") ; if user_id <= 0i32 { { log_error ("DataProcessor" , "Invalid user ID provided") ; return false } } ; if data . len () == 0i32 { { log_error ("DataProcessor" , "Empty data received") ; return false } } ; if data . len () > 1000i32 { { log_warning ("DataProcessor" , "Data size exceeds recommended limit") } } ; log_info ("DataProcessor" , "Processing data for user") ; if user_id == 999i32 { { log_error ("DataProcessor" , "Processing failed for user 999") ; return false } } ; log_info ("DataProcessor" , "Data processing completed successfully") ; return true } fn main () { let results = vec ! [process_user_data (123i32 , "valid_data") , process_user_data (0i32 , "invalid_user") , process_user_data (456i32 , "") , process_user_data (999i32 , "test_data")] ; let mut successful = 0i32 ; let mut i = 0i32 ; while i < 4i32 { { if results [i as usize] { { successful = successful + 1i32 } } ; i = i + 1i32 } } ; println ! ("") ; println ! ("Summary: {}/4 operations successful" , successful) ; }
1 + fn log_error (component : & str , message : & str) { println ! ("[ERROR] {}: {}" , component , message) } fn log_warning (component : & str , message : & str) { println ! ("[WARN] {}: {}" , component , message) } fn log_info (component : & str , message : & str) { println ! ("[INFO] {}: {}" , component , message) } fn process_user_data (user_id : i32 , data : & str) -> bool { log_info ("DataProcessor" , "Starting user data processing") ; if user_id <= 0i32 { { log_error ("DataProcessor" , "Invalid user ID provided") ; return false } } ; if data . len () == 0i32 { { log_error ("DataProcessor" , "Empty data received") ; return false } } ; if data . len () > 1000usize { { log_warning ("DataProcessor" , "Data size exceeds recommended limit") } } ; log_info ("DataProcessor" , "Processing data for user") ; if user_id == 999i32 { { log_error ("DataProcessor" , "Processing failed for user 999") ; return false } } ; log_info ("DataProcessor" , "Data processing completed successfully") ; return true } fn main () { let results = vec ! [process_user_data (123i32 , "valid_data") , process_user_data (0i32 , "invalid_user") , process_user_data (456i32 , "") , process_user_data (999i32 , "test_data")] ; let mut successful = 0i32 ; let mut i = 0i32 ; while i < 4i32 { { if results [i as usize] { { successful = successful + 1i32 } } ; i = i + 1i32 } } ; println ! ("") ; println ! ("Summary: {}/4 operations successful" , successful) ; }
  |

error: aborting due to 2 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0308`.

Error: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpFgp2sI/main.rs:1:675
  |
1 | ... if data . len () > 1000i32 { { log_warning ("DataProcessor" , "Data size exceeds recommended limit") } } ; log_info ("DataProcessor" ...
  |                                  ^^                                                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn log_error (component : & str , message : & str) { println ! ("[ERROR] {}: {}" , component , message) } fn log_warning (component : & str , message : & str) { println ! ("[WARN] {}: {}" , component , message) } fn log_info (component : & str , message : & str) { println ! ("[INFO] {}: {}" , component , message) } fn process_user_data (user_id : i32 , data : & str) -> bool { log_info ("DataProcessor" , "Starting user data processing") ; if user_id <= 0i32 { { log_error ("DataProcessor" , "Invalid user ID provided") ; return false } } ; if data . len () == 0i32 { { log_error ("DataProcessor" , "Empty data received") ; return false } } ; if data . len () > 1000i32 { { log_warning ("DataProcessor" , "Data size exceeds recommended limit") } } ; log_info ("DataProcessor" , "Processing data for user") ; if user_id == 999i32 { { log_error ("DataProcessor" , "Processing failed for user 999") ; return false } } ; log_info ("DataProcessor" , "Data processing completed successfully") ; return true } fn main () { let results = vec ! [process_user_data (123i32 , "valid_data") , process_user_data (0i32 , "invalid_user") , process_user_data (456i32 , "") , process_user_data (999i32 , "test_data")] ; let mut successful = 0i32 ; let mut i = 0i32 ; while i < 4i32 { { if results [i as usize] { { successful = successful + 1i32 } } ; i = i + 1i32 } } ; println ! ("") ; println ! ("Summary: {}/4 operations successful" , successful) ; }
1 + fn log_error (component : & str , message : & str) { println ! ("[ERROR] {}: {}" , component , message) } fn log_warning (component : & str , message : & str) { println ! ("[WARN] {}: {}" , component , message) } fn log_info (component : & str , message : & str) { println ! ("[INFO] {}: {}" , component , message) } fn process_user_data (user_id : i32 , data : & str) -> bool { log_info ("DataProcessor" , "Starting user data processing") ; if user_id <= 0i32 { { log_error ("DataProcessor" , "Invalid user ID provided") ; return false } } ; if data . len () == 0i32 { { log_error ("DataProcessor" , "Empty data received") ; return false } } ; if data . len () > 1000i32 { log_warning ("DataProcessor" , "Data size exceeds recommended limit") } ; log_info ("DataProcessor" , "Processing data for user") ; if user_id == 999i32 { { log_error ("DataProcessor" , "Processing failed for user 999") ; return false } } ; log_info ("DataProcessor" , "Data processing completed successfully") ; return true } fn main () { let results = vec ! [process_user_data (123i32 , "valid_data") , process_user_data (0i32 , "invalid_user") , process_user_data (456i32 , "") , process_user_data (999i32 , "test_data")] ; let mut successful = 0i32 ; let mut i = 0i32 ; while i < 4i32 { { if results [i as usize] { { successful = successful + 1i32 } } ; i = i + 1i32 } } ; println ! ("") ; println ! ("Summary: {}/4 operations successful" , successful) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpFgp2sI/main.rs:1:1298
  |
1 | ...32 ; while i < 4i32 { { if results [i as usize] { { successful = successful + 1i32 } } ; i = i + 1i32 } } ; println ! ("") ; println !...
  |                                                      ^^                              ^^
  |
help: remove these braces
  |
1 - fn log_error (component : & str , message : & str) { println ! ("[ERROR] {}: {}" , component , message) } fn log_warning (component : & str , message : & str) { println ! ("[WARN] {}: {}" , component , message) } fn log_info (component : & str , message : & str) { println ! ("[INFO] {}: {}" , component , message) } fn process_user_data (user_id : i32 , data : & str) -> bool { log_info ("DataProcessor" , "Starting user data processing") ; if user_id <= 0i32 { { log_error ("DataProcessor" , "Invalid user ID provided") ; return false } } ; if data . len () == 0i32 { { log_error ("DataProcessor" , "Empty data received") ; return false } } ; if data . len () > 1000i32 { { log_warning ("DataProcessor" , "Data size exceeds recommended limit") } } ; log_info ("DataProcessor" , "Processing data for user") ; if user_id == 999i32 { { log_error ("DataProcessor" , "Processing failed for user 999") ; return false } } ; log_info ("DataProcessor" , "Data processing completed successfully") ; return true } fn main () { let results = vec ! [process_user_data (123i32 , "valid_data") , process_user_data (0i32 , "invalid_user") , process_user_data (456i32 , "") , process_user_data (999i32 , "test_data")] ; let mut successful = 0i32 ; let mut i = 0i32 ; while i < 4i32 { { if results [i as usize] { { successful = successful + 1i32 } } ; i = i + 1i32 } } ; println ! ("") ; println ! ("Summary: {}/4 operations successful" , successful) ; }
1 + fn log_error (component : & str , message : & str) { println ! ("[ERROR] {}: {}" , component , message) } fn log_warning (component : & str , message : & str) { println ! ("[WARN] {}: {}" , component , message) } fn log_info (component : & str , message : & str) { println ! ("[INFO] {}: {}" , component , message) } fn process_user_data (user_id : i32 , data : & str) -> bool { log_info ("DataProcessor" , "Starting user data processing") ; if user_id <= 0i32 { { log_error ("DataProcessor" , "Invalid user ID provided") ; return false } } ; if data . len () == 0i32 { { log_error ("DataProcessor" , "Empty data received") ; return false } } ; if data . len () > 1000i32 { { log_warning ("DataProcessor" , "Data size exceeds recommended limit") } } ; log_info ("DataProcessor" , "Processing data for user") ; if user_id == 999i32 { { log_error ("DataProcessor" , "Processing failed for user 999") ; return false } } ; log_info ("DataProcessor" , "Data processing completed successfully") ; return true } fn main () { let results = vec ! [process_user_data (123i32 , "valid_data") , process_user_data (0i32 , "invalid_user") , process_user_data (456i32 , "") , process_user_data (999i32 , "test_data")] ; let mut successful = 0i32 ; let mut i = 0i32 ; while i < 4i32 { { if results [i as usize] { successful = successful + 1i32 } ; i = i + 1i32 } } ; println ! ("") ; println ! ("Summary: {}/4 operations successful" , successful) ; }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpFgp2sI/main.rs:1:564
  |
1 | ...er ID provided") ; return false } } ; if data . len () == 0i32 { { log_error ("DataProcessor" , "Empty data received") ; return false ...
  |                                             -------------    ^^^^ expected `usize`, found `i32`
  |                                             |
  |                                             expected because this is `usize`
  |
help: change the type of the numeric literal from `i32` to `usize`
  |
1 - fn log_error (component : & str , message : & str) { println ! ("[ERROR] {}: {}" , component , message) } fn log_warning (component : & str , message : & str) { println ! ("[WARN] {}: {}" , component , message) } fn log_info (component : & str , message : & str) { println ! ("[INFO] {}: {}" , component , message) } fn process_user_data (user_id : i32 , data : & str) -> bool { log_info ("DataProcessor" , "Starting user data processing") ; if user_id <= 0i32 { { log_error ("DataProcessor" , "Invalid user ID provided") ; return false } } ; if data . len () == 0i32 { { log_error ("DataProcessor" , "Empty data received") ; return false } } ; if data . len () > 1000i32 { { log_warning ("DataProcessor" , "Data size exceeds recommended limit") } } ; log_info ("DataProcessor" , "Processing data for user") ; if user_id == 999i32 { { log_error ("DataProcessor" , "Processing failed for user 999") ; return false } } ; log_info ("DataProcessor" , "Data processing completed successfully") ; return true } fn main () { let results = vec ! [process_user_data (123i32 , "valid_data") , process_user_data (0i32 , "invalid_user") , process_user_data (456i32 , "") , process_user_data (999i32 , "test_data")] ; let mut successful = 0i32 ; let mut i = 0i32 ; while i < 4i32 { { if results [i as usize] { { successful = successful + 1i32 } } ; i = i + 1i32 } } ; println ! ("") ; println ! ("Summary: {}/4 operations successful" , successful) ; }
1 + fn log_error (component : & str , message : & str) { println ! ("[ERROR] {}: {}" , component , message) } fn log_warning (component : & str , message : & str) { println ! ("[WARN] {}: {}" , component , message) } fn log_info (component : & str , message : & str) { println ! ("[INFO] {}: {}" , component , message) } fn process_user_data (user_id : i32 , data : & str) -> bool { log_info ("DataProcessor" , "Starting user data processing") ; if user_id <= 0i32 { { log_error ("DataProcessor" , "Invalid user ID provided") ; return false } } ; if data . len () == 0usize { { log_error ("DataProcessor" , "Empty data received") ; return false } } ; if data . len () > 1000i32 { { log_warning ("DataProcessor" , "Data size exceeds recommended limit") } } ; log_info ("DataProcessor" , "Processing data for user") ; if user_id == 999i32 { { log_error ("DataProcessor" , "Processing failed for user 999") ; return false } } ; log_info ("DataProcessor" , "Data processing completed successfully") ; return true } fn main () { let results = vec ! [process_user_data (123i32 , "valid_data") , process_user_data (0i32 , "invalid_user") , process_user_data (456i32 , "") , process_user_data (999i32 , "test_data")] ; let mut successful = 0i32 ; let mut i = 0i32 ; while i < 4i32 { { if results [i as usize] { { successful = successful + 1i32 } } ; i = i + 1i32 } } ; println ! ("") ; println ! ("Summary: {}/4 operations successful" , successful) ; }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpFgp2sI/main.rs:1:665
  |
1 | ...data received") ; return false } } ; if data . len () > 1000i32 { { log_warning ("DataProcessor" , "Data size exceeds recommended limi...
  |                                            -------------   ^^^^^^^ expected `usize`, found `i32`
  |                                            |
  |                                            expected because this is `usize`
  |
help: change the type of the numeric literal from `i32` to `usize`
  |
1 - fn log_error (component : & str , message : & str) { println ! ("[ERROR] {}: {}" , component , message) } fn log_warning (component : & str , message : & str) { println ! ("[WARN] {}: {}" , component , message) } fn log_info (component : & str , message : & str) { println ! ("[INFO] {}: {}" , component , message) } fn process_user_data (user_id : i32 , data : & str) -> bool { log_info ("DataProcessor" , "Starting user data processing") ; if user_id <= 0i32 { { log_error ("DataProcessor" , "Invalid user ID provided") ; return false } } ; if data . len () == 0i32 { { log_error ("DataProcessor" , "Empty data received") ; return false } } ; if data . len () > 1000i32 { { log_warning ("DataProcessor" , "Data size exceeds recommended limit") } } ; log_info ("DataProcessor" , "Processing data for user") ; if user_id == 999i32 { { log_error ("DataProcessor" , "Processing failed for user 999") ; return false } } ; log_info ("DataProcessor" , "Data processing completed successfully") ; return true } fn main () { let results = vec ! [process_user_data (123i32 , "valid_data") , process_user_data (0i32 , "invalid_user") , process_user_data (456i32 , "") , process_user_data (999i32 , "test_data")] ; let mut successful = 0i32 ; let mut i = 0i32 ; while i < 4i32 { { if results [i as usize] { { successful = successful + 1i32 } } ; i = i + 1i32 } } ; println ! ("") ; println ! ("Summary: {}/4 operations successful" , successful) ; }
1 + fn log_error (component : & str , message : & str) { println ! ("[ERROR] {}: {}" , component , message) } fn log_warning (component : & str , message : & str) { println ! ("[WARN] {}: {}" , component , message) } fn log_info (component : & str , message : & str) { println ! ("[INFO] {}: {}" , component , message) } fn process_user_data (user_id : i32 , data : & str) -> bool { log_info ("DataProcessor" , "Starting user data processing") ; if user_id <= 0i32 { { log_error ("DataProcessor" , "Invalid user ID provided") ; return false } } ; if data . len () == 0i32 { { log_error ("DataProcessor" , "Empty data received") ; return false } } ; if data . len () > 1000usize { { log_warning ("DataProcessor" , "Data size exceeds recommended limit") } } ; log_info ("DataProcessor" , "Processing data for user") ; if user_id == 999i32 { { log_error ("DataProcessor" , "Processing failed for user 999") ; return false } } ; log_info ("DataProcessor" , "Data processing completed successfully") ; return true } fn main () { let results = vec ! [process_user_data (123i32 , "valid_data") , process_user_data (0i32 , "invalid_user") , process_user_data (456i32 , "") , process_user_data (999i32 , "test_data")] ; let mut successful = 0i32 ; let mut i = 0i32 ; while i < 4i32 { { if results [i as usize] { { successful = successful + 1i32 } } ; i = i + 1i32 } } ; println ! ("") ; println ! ("Summary: {}/4 operations successful" , successful) ; }
  |

error: aborting due to 2 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch05-00-control-flow-tdd example 6 ===
DEBUG: About to call transpile_to_program
DEBUG: transpile_to_program completed
✗ Compilation failed: Compilation failed:
error[E0308]: mismatched types
 --> /tmp/.tmpc6UMcz/main.rs:1:51
  |
1 | fn main () { { let number = 2i32 ; match number { 1i64 => println ! ("One") , 2i64 => println ! ("Two") , 3i64 => println ! ("Three") , _...
  |                                          ------   ^^^^ expected `i32`, found `i64`
  |                                          |
  |                                          this expression has type `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpc6UMcz/main.rs:1:79
  |
1 | fn main () { { let number = 2i32 ; match number { 1i64 => println ! ("One") , 2i64 => println ! ("Two") , 3i64 => println ! ("Three") , _...
  |                                          ------                               ^^^^ expected `i32`, found `i64`
  |                                          |
  |                                          this expression has type `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpc6UMcz/main.rs:1:107
  |
1 | ...er = 2i32 ; match number { 1i64 => println ! ("One") , 2i64 => println ! ("Two") , 3i64 => println ! ("Three") , _ => println ! ("Othe...
  |                      ------ this expression has type `i32`                            ^^^^ expected `i32`, found `i64`

error: aborting due to 3 previous errors

For more information about this error, try `rustc --explain E0308`.

Error: Compilation failed:
error[E0308]: mismatched types
 --> /tmp/.tmpc6UMcz/main.rs:1:51
  |
1 | fn main () { { let number = 2i32 ; match number { 1i64 => println ! ("One") , 2i64 => println ! ("Two") , 3i64 => println ! ("Three") , _...
  |                                          ------   ^^^^ expected `i32`, found `i64`
  |                                          |
  |                                          this expression has type `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpc6UMcz/main.rs:1:79
  |
1 | fn main () { { let number = 2i32 ; match number { 1i64 => println ! ("One") , 2i64 => println ! ("Two") , 3i64 => println ! ("Three") , _...
  |                                          ------                               ^^^^ expected `i32`, found `i64`
  |                                          |
  |                                          this expression has type `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpc6UMcz/main.rs:1:107
  |
1 | ...er = 2i32 ; match number { 1i64 => println ! ("One") , 2i64 => println ! ("Two") , 3i64 => println ! ("Three") , _ => println ! ("Othe...
  |                      ------ this expression has type `i32`                            ^^^^ expected `i32`, found `i64`

error: aborting due to 3 previous errors

For more information about this error, try `rustc --explain E0308`.



=== ch05-00-control-flow-tdd example 10 ===
DEBUG: About to call transpile_to_program
DEBUG: transpile_to_program completed
✗ Compilation failed: Compilation failed:
error[E0308]: mismatched types
 --> /tmp/.tmpxqE04e/main.rs:1:51
  |
1 | fn main () { { let number = 2i32 ; match number { 1i64 => println ! ("One") , 2i64 => println ! ("Two") , 3i64 => println ! ("Three") , _...
  |                                          ------   ^^^^ expected `i32`, found `i64`
  |                                          |
  |                                          this expression has type `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpxqE04e/main.rs:1:79
  |
1 | fn main () { { let number = 2i32 ; match number { 1i64 => println ! ("One") , 2i64 => println ! ("Two") , 3i64 => println ! ("Three") , _...
  |                                          ------                               ^^^^ expected `i32`, found `i64`
  |                                          |
  |                                          this expression has type `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpxqE04e/main.rs:1:107
  |
1 | ...er = 2i32 ; match number { 1i64 => println ! ("One") , 2i64 => println ! ("Two") , 3i64 => println ! ("Three") , _ => println ! ("Othe...
  |                      ------ this expression has type `i32`                            ^^^^ expected `i32`, found `i64`

error: aborting due to 3 previous errors

For more information about this error, try `rustc --explain E0308`.

Error: Compilation failed:
error[E0308]: mismatched types
 --> /tmp/.tmpxqE04e/main.rs:1:51
  |
1 | fn main () { { let number = 2i32 ; match number { 1i64 => println ! ("One") , 2i64 => println ! ("Two") , 3i64 => println ! ("Three") , _...
  |                                          ------   ^^^^ expected `i32`, found `i64`
  |                                          |
  |                                          this expression has type `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpxqE04e/main.rs:1:79
  |
1 | fn main () { { let number = 2i32 ; match number { 1i64 => println ! ("One") , 2i64 => println ! ("Two") , 3i64 => println ! ("Three") , _...
  |                                          ------                               ^^^^ expected `i32`, found `i64`
  |                                          |
  |                                          this expression has type `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpxqE04e/main.rs:1:107
  |
1 | ...er = 2i32 ; match number { 1i64 => println ! ("One") , 2i64 => println ! ("Two") , 3i64 => println ! ("Three") , _ => println ! ("Othe...
  |                      ------ this expression has type `i32`                            ^^^^ expected `i32`, found `i64`

error: aborting due to 3 previous errors

For more information about this error, try `rustc --explain E0308`.



=== ch05-00-control-flow-tdd example 14 ===
DEBUG: About to call transpile_to_program
DEBUG: transpile_to_program completed
✗ Compilation failed: Compilation failed:
error[E0308]: mismatched types
 --> /tmp/.tmpARfS8h/main.rs:1:63
  |
1 | fn main () { { let status_code = 200i32 ; match status_code { 200i64 => println ! ("Success") , 404i64 => println ! ("Not Found") , 500i6...
  |                                                 -----------   ^^^^^^ expected `i32`, found `i64`
  |                                                 |
  |                                                 this expression has type `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpARfS8h/main.rs:1:97
  |
1 | fn main () { { let status_code = 200i32 ; match status_code { 200i64 => println ! ("Success") , 404i64 => println ! ("Not Found") , 500i6...
  |                                                 ----------- this expression has type `i32`      ^^^^^^ expected `i32`, found `i64`

error[E0308]: mismatched types
 --> /tmp/.tmpARfS8h/main.rs:1:133
  |
1 | ...; match status_code { 200i64 => println ! ("Success") , 404i64 => println ! ("Not Found") , 500i64 => println ! ("Server Error") , _ =...
  |            ----------- this expression has type `i32`                                          ^^^^^^ expected `i32`, found `i64`

error: aborting due to 3 previous errors

For more information about this error, try `rustc --explain E0308`.

Error: Compilation failed:
error[E0308]: mismatched types
 --> /tmp/.tmpARfS8h/main.rs:1:63
  |
1 | fn main () { { let status_code = 200i32 ; match status_code { 200i64 => println ! ("Success") , 404i64 => println ! ("Not Found") , 500i6...
  |                                                 -----------   ^^^^^^ expected `i32`, found `i64`
  |                                                 |
  |                                                 this expression has type `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpARfS8h/main.rs:1:97
  |
1 | fn main () { { let status_code = 200i32 ; match status_code { 200i64 => println ! ("Success") , 404i64 => println ! ("Not Found") , 500i6...
  |                                                 ----------- this expression has type `i32`      ^^^^^^ expected `i32`, found `i64`

error[E0308]: mismatched types
 --> /tmp/.tmpARfS8h/main.rs:1:133
  |
1 | ...; match status_code { 200i64 => println ! ("Success") , 404i64 => println ! ("Not Found") , 500i64 => println ! ("Server Error") , _ =...
  |            ----------- this expression has type `i32`                                          ^^^^^^ expected `i32`, found `i64`

error: aborting due to 3 previous errors

For more information about this error, try `rustc --explain E0308`.



=== ch05-00-control-flow-tdd example 15 ===
DEBUG: About to call transpile_to_program
DEBUG: transpile_to_program completed
✗ Compilation failed: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmp2NSPKa/main.rs:1:23
  |
1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path ("sales.csv") . expect ("Failed to open CSV file") . finish () . expect...
  |                       ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

warning: unnecessary trailing semicolon
 --> /tmp/.tmp2NSPKa/main.rs:1:169
  |
1 | ... . finish () . expect ("Failed to read CSV file") ; ; if df . height () > 0i32 { { { let high_value = df . lazy () . filter (| row | {...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp2NSPKa/main.rs:1:198
  |
1 | ... { { { let high_value = df . lazy () . filter (| row | { if row . get ("amount") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) > 1000i32 { { row . get ("status") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) == "active" } } else { { false } } }) . collect () . expect ("DataFrame lazy operation collection should not fail") ; println ! ("Found {} high-value active sales" , high_value . rows ()) } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path ("sales.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; if df . height () > 0i32 { { { let high_value = df . lazy () . filter (| row | { if row . get ("amount") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) > 1000i32 { { row . get ("status") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) == "active" } } else { { false } } }) . collect () . expect ("DataFrame lazy operation collection should not fail") ; println ! ("Found {} high-value active sales" , high_value . rows ()) } } } else { { println ! ("No data to process") } } ; }
1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path ("sales.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; if df . height () > 0i32 { { let high_value = df . lazy () . filter (| row | { if row . get ("amount") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) > 1000i32 { { row . get ("status") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) == "active" } } else { { false } } }) . collect () . expect ("DataFrame lazy operation collection should not fail") ; println ! ("Found {} high-value active sales" , high_value . rows ()) } } else { { println ! ("No data to process") } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp2NSPKa/main.rs:1:348
  |
1 | ...und")) > 1000i32 { { row . get ("status") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) == "active" } } else { { false }...
  |                       ^^                                                                                            ^^
  |
help: remove these braces
  |
1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path ("sales.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; if df . height () > 0i32 { { { let high_value = df . lazy () . filter (| row | { if row . get ("amount") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) > 1000i32 { { row . get ("status") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) == "active" } } else { { false } } }) . collect () . expect ("DataFrame lazy operation collection should not fail") ; println ! ("Found {} high-value active sales" , high_value . rows ()) } } } else { { println ! ("No data to process") } } ; }
1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path ("sales.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; if df . height () > 0i32 { { { let high_value = df . lazy () . filter (| row | { if row . get ("amount") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) > 1000i32 { row . get ("status") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) == "active" } else { { false } } }) . collect () . expect ("DataFrame lazy operation collection should not fail") ; println ! ("Found {} high-value active sales" , high_value . rows ()) } } } else { { println ! ("No data to process") } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp2NSPKa/main.rs:1:454
  |
1 | ...or_else (|| panic ! ("Key not found")) == "active" } } else { { false } } }) . collect () . expect ("DataFrame lazy operation collecti...
  |                                                                  ^^     ^^
  |
help: remove these braces
  |
1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path ("sales.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; if df . height () > 0i32 { { { let high_value = df . lazy () . filter (| row | { if row . get ("amount") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) > 1000i32 { { row . get ("status") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) == "active" } } else { { false } } }) . collect () . expect ("DataFrame lazy operation collection should not fail") ; println ! ("Found {} high-value active sales" , high_value . rows ()) } } } else { { println ! ("No data to process") } } ; }
1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path ("sales.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; if df . height () > 0i32 { { { let high_value = df . lazy () . filter (| row | { if row . get ("amount") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) > 1000i32 { { row . get ("status") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) == "active" } } else { false } }) . collect () . expect ("DataFrame lazy operation collection should not fail") ; println ! ("Found {} high-value active sales" , high_value . rows ()) } } } else { { println ! ("No data to process") } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp2NSPKa/main.rs:1:632
  |
1 | ...tive sales" , high_value . rows ()) } } } else { { println ! ("No data to process") } } ; }
  |                                                     ^^                                ^^
  |
help: remove these braces
  |
1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path ("sales.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; if df . height () > 0i32 { { { let high_value = df . lazy () . filter (| row | { if row . get ("amount") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) > 1000i32 { { row . get ("status") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) == "active" } } else { { false } } }) . collect () . expect ("DataFrame lazy operation collection should not fail") ; println ! ("Found {} high-value active sales" , high_value . rows ()) } } } else { { println ! ("No data to process") } } ; }
1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path ("sales.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; if df . height () > 0i32 { { { let high_value = df . lazy () . filter (| row | { if row . get ("amount") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) > 1000i32 { { row . get ("status") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) == "active" } } else { { false } } }) . collect () . expect ("DataFrame lazy operation collection should not fail") ; println ! ("Found {} high-value active sales" , high_value . rows ()) } } } else { println ! ("No data to process") } ; }
  |

error: aborting due to 1 previous error; 5 warnings emitted

For more information about this error, try `rustc --explain E0433`.

Error: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmp2NSPKa/main.rs:1:23
  |
1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path ("sales.csv") . expect ("Failed to open CSV file") . finish () . expect...
  |                       ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

warning: unnecessary trailing semicolon
 --> /tmp/.tmp2NSPKa/main.rs:1:169
  |
1 | ... . finish () . expect ("Failed to read CSV file") ; ; if df . height () > 0i32 { { { let high_value = df . lazy () . filter (| row | {...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp2NSPKa/main.rs:1:198
  |
1 | ... { { { let high_value = df . lazy () . filter (| row | { if row . get ("amount") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) > 1000i32 { { row . get ("status") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) == "active" } } else { { false } } }) . collect () . expect ("DataFrame lazy operation collection should not fail") ; println ! ("Found {} high-value active sales" , high_value . rows ()) } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path ("sales.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; if df . height () > 0i32 { { { let high_value = df . lazy () . filter (| row | { if row . get ("amount") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) > 1000i32 { { row . get ("status") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) == "active" } } else { { false } } }) . collect () . expect ("DataFrame lazy operation collection should not fail") ; println ! ("Found {} high-value active sales" , high_value . rows ()) } } } else { { println ! ("No data to process") } } ; }
1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path ("sales.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; if df . height () > 0i32 { { let high_value = df . lazy () . filter (| row | { if row . get ("amount") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) > 1000i32 { { row . get ("status") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) == "active" } } else { { false } } }) . collect () . expect ("DataFrame lazy operation collection should not fail") ; println ! ("Found {} high-value active sales" , high_value . rows ()) } } else { { println ! ("No data to process") } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp2NSPKa/main.rs:1:348
  |
1 | ...und")) > 1000i32 { { row . get ("status") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) == "active" } } else { { false }...
  |                       ^^                                                                                            ^^
  |
help: remove these braces
  |
1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path ("sales.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; if df . height () > 0i32 { { { let high_value = df . lazy () . filter (| row | { if row . get ("amount") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) > 1000i32 { { row . get ("status") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) == "active" } } else { { false } } }) . collect () . expect ("DataFrame lazy operation collection should not fail") ; println ! ("Found {} high-value active sales" , high_value . rows ()) } } } else { { println ! ("No data to process") } } ; }
1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path ("sales.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; if df . height () > 0i32 { { { let high_value = df . lazy () . filter (| row | { if row . get ("amount") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) > 1000i32 { row . get ("status") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) == "active" } else { { false } } }) . collect () . expect ("DataFrame lazy operation collection should not fail") ; println ! ("Found {} high-value active sales" , high_value . rows ()) } } } else { { println ! ("No data to process") } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp2NSPKa/main.rs:1:454
  |
1 | ...or_else (|| panic ! ("Key not found")) == "active" } } else { { false } } }) . collect () . expect ("DataFrame lazy operation collecti...
  |                                                                  ^^     ^^
  |
help: remove these braces
  |
1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path ("sales.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; if df . height () > 0i32 { { { let high_value = df . lazy () . filter (| row | { if row . get ("amount") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) > 1000i32 { { row . get ("status") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) == "active" } } else { { false } } }) . collect () . expect ("DataFrame lazy operation collection should not fail") ; println ! ("Found {} high-value active sales" , high_value . rows ()) } } } else { { println ! ("No data to process") } } ; }
1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path ("sales.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; if df . height () > 0i32 { { { let high_value = df . lazy () . filter (| row | { if row . get ("amount") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) > 1000i32 { { row . get ("status") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) == "active" } } else { false } }) . collect () . expect ("DataFrame lazy operation collection should not fail") ; println ! ("Found {} high-value active sales" , high_value . rows ()) } } } else { { println ! ("No data to process") } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp2NSPKa/main.rs:1:632
  |
1 | ...tive sales" , high_value . rows ()) } } } else { { println ! ("No data to process") } } ; }
  |                                                     ^^                                ^^
  |
help: remove these braces
  |
1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path ("sales.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; if df . height () > 0i32 { { { let high_value = df . lazy () . filter (| row | { if row . get ("amount") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) > 1000i32 { { row . get ("status") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) == "active" } } else { { false } } }) . collect () . expect ("DataFrame lazy operation collection should not fail") ; println ! ("Found {} high-value active sales" , high_value . rows ()) } } } else { { println ! ("No data to process") } } ; }
1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path ("sales.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; if df . height () > 0i32 { { { let high_value = df . lazy () . filter (| row | { if row . get ("amount") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) > 1000i32 { { row . get ("status") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) == "active" } } else { { false } } }) . collect () . expect ("DataFrame lazy operation collection should not fail") ; println ! ("Found {} high-value active sales" , high_value . rows ()) } } } else { println ! ("No data to process") } ; }
  |

error: aborting due to 1 previous error; 5 warnings emitted

For more information about this error, try `rustc --explain E0433`.



=== ch05-00-control-flow-tdd example 16 ===
DEBUG: About to call transpile_to_program
DEBUG: transpile_to_program completed
✗ Compilation failed: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpuXMrNe/main.rs:1:23
  |
1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . ex...
  |                       ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

warning: unnecessary trailing semicolon
 --> /tmp/.tmpuXMrNe/main.rs:1:173
  |
1 | ... . finish () . expect ("Failed to read CSV file") ; ; for row in df . iter_rows () { { if row . get ("quantity") . cloned () . unwrap_...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpuXMrNe/main.rs:1:547
  |
1 | ..."Key not found"))) } } } } ; let mut total = 0f64 ; ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key n...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpuXMrNe/main.rs:1:206
  |
1 | ... { { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10i32 { { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; for row in df . iter_rows () { { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10i32 { { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } } ; let mut total = 0f64 ; ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) . iter () { { if value > 0f64 { { total = total + value } } } } ; println ! ("Total positive prices: {}" , total) ; }
1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; for row in df . iter_rows () { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10i32 { { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } ; let mut total = 0f64 ; ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) . iter () { { if value > 0f64 { { total = total + value } } } } ; println ! ("Total positive prices: {}" , total) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpuXMrNe/main.rs:1:304
  |
1 | ... { { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } ...
  |       ^^                                                                                                                                                                                                               ^^
  |
help: remove these braces
  |
1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; for row in df . iter_rows () { { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10i32 { { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } } ; let mut total = 0f64 ; ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) . iter () { { if value > 0f64 { { total = total + value } } } } ; println ! ("Total positive prices: {}" , total) ; }
1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; for row in df . iter_rows () { { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10i32 { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } ; let mut total = 0f64 ; ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) . iter () { { if value > 0f64 { { total = total + value } } } } ; println ! ("Total positive prices: {}" , total) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpuXMrNe/main.rs:1:653
  |
1 | ...|| panic ! ("Key not found")) . iter () { { if value > 0f64 { { total = total + value } } } } ; println ! ("Total positive prices: {}"...
  |                                              ^^                                             ^^
  |
help: remove these braces
  |
1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; for row in df . iter_rows () { { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10i32 { { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } } ; let mut total = 0f64 ; ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) . iter () { { if value > 0f64 { { total = total + value } } } } ; println ! ("Total positive prices: {}" , total) ; }
1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; for row in df . iter_rows () { { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10i32 { { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } } ; let mut total = 0f64 ; ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) . iter () { if value > 0f64 { { total = total + value } } } ; println ! ("Total positive prices: {}" , total) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpuXMrNe/main.rs:1:673
  |
1 | ... ! ("Key not found")) . iter () { { if value > 0f64 { { total = total + value } } } } ; println ! ("Total positive prices: {}" , total...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; for row in df . iter_rows () { { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10i32 { { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } } ; let mut total = 0f64 ; ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) . iter () { { if value > 0f64 { { total = total + value } } } } ; println ! ("Total positive prices: {}" , total) ; }
1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; for row in df . iter_rows () { { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10i32 { { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } } ; let mut total = 0f64 ; ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! ("Total positive prices: {}" , total) ; }
  |

error: aborting due to 1 previous error; 6 warnings emitted

For more information about this error, try `rustc --explain E0433`.

Error: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpuXMrNe/main.rs:1:23
  |
1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . ex...
  |                       ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

warning: unnecessary trailing semicolon
 --> /tmp/.tmpuXMrNe/main.rs:1:173
  |
1 | ... . finish () . expect ("Failed to read CSV file") ; ; for row in df . iter_rows () { { if row . get ("quantity") . cloned () . unwrap_...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpuXMrNe/main.rs:1:547
  |
1 | ..."Key not found"))) } } } } ; let mut total = 0f64 ; ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key n...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpuXMrNe/main.rs:1:206
  |
1 | ... { { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10i32 { { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; for row in df . iter_rows () { { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10i32 { { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } } ; let mut total = 0f64 ; ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) . iter () { { if value > 0f64 { { total = total + value } } } } ; println ! ("Total positive prices: {}" , total) ; }
1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; for row in df . iter_rows () { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10i32 { { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } ; let mut total = 0f64 ; ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) . iter () { { if value > 0f64 { { total = total + value } } } } ; println ! ("Total positive prices: {}" , total) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpuXMrNe/main.rs:1:304
  |
1 | ... { { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } ...
  |       ^^                                                                                                                                                                                                               ^^
  |
help: remove these braces
  |
1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; for row in df . iter_rows () { { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10i32 { { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } } ; let mut total = 0f64 ; ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) . iter () { { if value > 0f64 { { total = total + value } } } } ; println ! ("Total positive prices: {}" , total) ; }
1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; for row in df . iter_rows () { { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10i32 { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } ; let mut total = 0f64 ; ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) . iter () { { if value > 0f64 { { total = total + value } } } } ; println ! ("Total positive prices: {}" , total) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpuXMrNe/main.rs:1:653
  |
1 | ...|| panic ! ("Key not found")) . iter () { { if value > 0f64 { { total = total + value } } } } ; println ! ("Total positive prices: {}"...
  |                                              ^^                                             ^^
  |
help: remove these braces
  |
1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; for row in df . iter_rows () { { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10i32 { { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } } ; let mut total = 0f64 ; ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) . iter () { { if value > 0f64 { { total = total + value } } } } ; println ! ("Total positive prices: {}" , total) ; }
1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; for row in df . iter_rows () { { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10i32 { { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } } ; let mut total = 0f64 ; ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) . iter () { if value > 0f64 { { total = total + value } } } ; println ! ("Total positive prices: {}" , total) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpuXMrNe/main.rs:1:673
  |
1 | ... ! ("Key not found")) . iter () { { if value > 0f64 { { total = total + value } } } } ; println ! ("Total positive prices: {}" , total...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; for row in df . iter_rows () { { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10i32 { { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } } ; let mut total = 0f64 ; ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) . iter () { { if value > 0f64 { { total = total + value } } } } ; println ! ("Total positive prices: {}" , total) ; }
1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; for row in df . iter_rows () { { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10i32 { { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } } ; let mut total = 0f64 ; ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! ("Total positive prices: {}" , total) ; }
  |

error: aborting due to 1 previous error; 6 warnings emitted

For more information about this error, try `rustc --explain E0433`.



=== ch05-00-control-flow-tdd example 17 ===
DEBUG: About to call transpile_to_program
DEBUG: transpile_to_program completed
✗ Compilation failed: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpaguNra/main.rs:1:23
  |
1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path ("customers.csv") . expect ("Failed to open CSV file") . finish () . ex...
  |                       ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

warning: unnecessary trailing semicolon
 --> /tmp/.tmpaguNra/main.rs:1:173
  |
1 | ... . finish () . expect ("Failed to read CSV file") ; ; for row in df . iter_rows () { { { let category = match row . get ("total_purcha...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpaguNra/main.rs:1:206
  |
1 | ... { { { let category = match row . get ("total_purchases") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) { v if v > 10000i32 => "Platinum" , v if v > 5000i32 => "Gold" , v if v > 1000i32 => "Silver" , _ => "Bronze" , } ; println ! ("Customer {} is {} tier" , row . get ("name") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , category) } } } ; }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                       ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path ("customers.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; for row in df . iter_rows () { { { let category = match row . get ("total_purchases") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) { v if v > 10000i32 => "Platinum" , v if v > 5000i32 => "Gold" , v if v > 1000i32 => "Silver" , _ => "Bronze" , } ; println ! ("Customer {} is {} tier" , row . get ("name") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , category) } } } ; }
1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path ("customers.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; for row in df . iter_rows () { { let category = match row . get ("total_purchases") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) { v if v > 10000i32 => "Platinum" , v if v > 5000i32 => "Gold" , v if v > 1000i32 => "Silver" , _ => "Bronze" , } ; println ! ("Customer {} is {} tier" , row . get ("name") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , category) } } ; }
  |

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0433`.

Error: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpaguNra/main.rs:1:23
  |
1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path ("customers.csv") . expect ("Failed to open CSV file") . finish () . ex...
  |                       ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

warning: unnecessary trailing semicolon
 --> /tmp/.tmpaguNra/main.rs:1:173
  |
1 | ... . finish () . expect ("Failed to read CSV file") ; ; for row in df . iter_rows () { { { let category = match row . get ("total_purcha...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpaguNra/main.rs:1:206
  |
1 | ... { { { let category = match row . get ("total_purchases") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) { v if v > 10000i32 => "Platinum" , v if v > 5000i32 => "Gold" , v if v > 1000i32 => "Silver" , _ => "Bronze" , } ; println ! ("Customer {} is {} tier" , row . get ("name") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , category) } } } ; }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                       ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path ("customers.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; for row in df . iter_rows () { { { let category = match row . get ("total_purchases") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) { v if v > 10000i32 => "Platinum" , v if v > 5000i32 => "Gold" , v if v > 1000i32 => "Silver" , _ => "Bronze" , } ; println ! ("Customer {} is {} tier" , row . get ("name") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , category) } } } ; }
1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path ("customers.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; ; for row in df . iter_rows () { { let category = match row . get ("total_purchases") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) { v if v > 10000i32 => "Platinum" , v if v > 5000i32 => "Gold" , v if v > 1000i32 => "Silver" , _ => "Bronze" , } ; println ! ("Customer {} is {} tier" , row . get ("name") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , category) } } ; }
  |

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0433`.



=== ch04-00-practical-patterns-tdd example 2 ===
DEBUG: About to call transpile_to_program
DEBUG: transpile_to_program completed
✗ Compilation failed: Compilation failed:
error[E0106]: missing lifetime specifier
 --> /tmp/.tmpTnyBj9/main.rs:1:489
  |
1 | ...n create_user_profile (name : & str , age : i32 , email : & str) -> & str { if validate_user_input (name , age , email) { { println ! ...
  |                                  -----                       -----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `name` or `email`
help: consider introducing a named lifetime parameter
  |
1 | fn validate_user_input (name : & str , age : i32 , email : & str) -> bool { if name . len () == 0i32 { { println ! ("Error: Name cannot be empty") ; return false } } ; if age < 0i32 || age > 150i32 { { println ! ("Error: Age must be between 0 and 150") ; return false } } ; if ! email . contains ('@') { { println ! ("Error: Invalid email format") ; return false } } ; println ! ("User input is valid") ; return true } fn create_user_profile<'a> (name : &'a  str , age : i32 , email : &'a  str) -> &'a  str { if validate_user_input (name , age , email) { { println ! ("Creating profile for: {}" , name) ; return "Profile created successfully" } } else { { return "Profile creation failed" } } } fn main () { let result1 = create_user_profile ("Alice" , 25i32 , "alice@example.com") ; let result2 = create_user_profile ("" , 30i32 , "bob@example.com") ; let result3 = create_user_profile ("Charlie" , - 5i32 , "charlie@example.com") ; println ! ("Result 1: {}" , result1) ; println ! ("Result 2: {}" , result2) ; println ! ("Result 3: {}" , result3) ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                          ++++          ++                             ++           ++

warning: unnecessary braces around block return value
 --> /tmp/.tmpTnyBj9/main.rs:1:642
  |
1 | ...return "Profile created successfully" } } else { { return "Profile creation failed" } } } fn main () { let result1 = create_user_profi...
  |                                                     ^^                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn validate_user_input (name : & str , age : i32 , email : & str) -> bool { if name . len () == 0i32 { { println ! ("Error: Name cannot be empty") ; return false } } ; if age < 0i32 || age > 150i32 { { println ! ("Error: Age must be between 0 and 150") ; return false } } ; if ! email . contains ('@') { { println ! ("Error: Invalid email format") ; return false } } ; println ! ("User input is valid") ; return true } fn create_user_profile (name : & str , age : i32 , email : & str) -> & str { if validate_user_input (name , age , email) { { println ! ("Creating profile for: {}" , name) ; return "Profile created successfully" } } else { { return "Profile creation failed" } } } fn main () { let result1 = create_user_profile ("Alice" , 25i32 , "alice@example.com") ; let result2 = create_user_profile ("" , 30i32 , "bob@example.com") ; let result3 = create_user_profile ("Charlie" , - 5i32 , "charlie@example.com") ; println ! ("Result 1: {}" , result1) ; println ! ("Result 2: {}" , result2) ; println ! ("Result 3: {}" , result3) ; }
1 + fn validate_user_input (name : & str , age : i32 , email : & str) -> bool { if name . len () == 0i32 { { println ! ("Error: Name cannot be empty") ; return false } } ; if age < 0i32 || age > 150i32 { { println ! ("Error: Age must be between 0 and 150") ; return false } } ; if ! email . contains ('@') { { println ! ("Error: Invalid email format") ; return false } } ; println ! ("User input is valid") ; return true } fn create_user_profile (name : & str , age : i32 , email : & str) -> & str { if validate_user_input (name , age , email) { { println ! ("Creating profile for: {}" , name) ; return "Profile created successfully" } } else { return "Profile creation failed" } } fn main () { let result1 = create_user_profile ("Alice" , 25i32 , "alice@example.com") ; let result2 = create_user_profile ("" , 30i32 , "bob@example.com") ; let result3 = create_user_profile ("Charlie" , - 5i32 , "charlie@example.com") ; println ! ("Result 1: {}" , result1) ; println ! ("Result 2: {}" , result2) ; println ! ("Result 3: {}" , result3) ; }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpTnyBj9/main.rs:1:97
  |
1 | fn validate_user_input (name : & str , age : i32 , email : & str) -> bool { if name . len () == 0i32 { { println ! ("Error: Name cannot b...
  |                                                                                -------------    ^^^^ expected `usize`, found `i32`
  |                                                                                |
  |                                                                                expected because this is `usize`
  |
help: change the type of the numeric literal from `i32` to `usize`
  |
1 - fn validate_user_input (name : & str , age : i32 , email : & str) -> bool { if name . len () == 0i32 { { println ! ("Error: Name cannot be empty") ; return false } } ; if age < 0i32 || age > 150i32 { { println ! ("Error: Age must be between 0 and 150") ; return false } } ; if ! email . contains ('@') { { println ! ("Error: Invalid email format") ; return false } } ; println ! ("User input is valid") ; return true } fn create_user_profile (name : & str , age : i32 , email : & str) -> & str { if validate_user_input (name , age , email) { { println ! ("Creating profile for: {}" , name) ; return "Profile created successfully" } } else { { return "Profile creation failed" } } } fn main () { let result1 = create_user_profile ("Alice" , 25i32 , "alice@example.com") ; let result2 = create_user_profile ("" , 30i32 , "bob@example.com") ; let result3 = create_user_profile ("Charlie" , - 5i32 , "charlie@example.com") ; println ! ("Result 1: {}" , result1) ; println ! ("Result 2: {}" , result2) ; println ! ("Result 3: {}" , result3) ; }
1 + fn validate_user_input (name : & str , age : i32 , email : & str) -> bool { if name . len () == 0usize { { println ! ("Error: Name cannot be empty") ; return false } } ; if age < 0i32 || age > 150i32 { { println ! ("Error: Age must be between 0 and 150") ; return false } } ; if ! email . contains ('@') { { println ! ("Error: Invalid email format") ; return false } } ; println ! ("User input is valid") ; return true } fn create_user_profile (name : & str , age : i32 , email : & str) -> & str { if validate_user_input (name , age , email) { { println ! ("Creating profile for: {}" , name) ; return "Profile created successfully" } } else { { return "Profile creation failed" } } } fn main () { let result1 = create_user_profile ("Alice" , 25i32 , "alice@example.com") ; let result2 = create_user_profile ("" , 30i32 , "bob@example.com") ; let result3 = create_user_profile ("Charlie" , - 5i32 , "charlie@example.com") ; println ! ("Result 1: {}" , result1) ; println ! ("Result 2: {}" , result2) ; println ! ("Result 3: {}" , result3) ; }
  |

error: aborting due to 2 previous errors; 1 warning emitted

Some errors have detailed explanations: E0106, E0308.
For more information about an error, try `rustc --explain E0106`.

Error: Compilation failed:
error[E0106]: missing lifetime specifier
 --> /tmp/.tmpTnyBj9/main.rs:1:489
  |
1 | ...n create_user_profile (name : & str , age : i32 , email : & str) -> & str { if validate_user_input (name , age , email) { { println ! ...
  |                                  -----                       -----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `name` or `email`
help: consider introducing a named lifetime parameter
  |
1 | fn validate_user_input (name : & str , age : i32 , email : & str) -> bool { if name . len () == 0i32 { { println ! ("Error: Name cannot be empty") ; return false } } ; if age < 0i32 || age > 150i32 { { println ! ("Error: Age must be between 0 and 150") ; return false } } ; if ! email . contains ('@') { { println ! ("Error: Invalid email format") ; return false } } ; println ! ("User input is valid") ; return true } fn create_user_profile<'a> (name : &'a  str , age : i32 , email : &'a  str) -> &'a  str { if validate_user_input (name , age , email) { { println ! ("Creating profile for: {}" , name) ; return "Profile created successfully" } } else { { return "Profile creation failed" } } } fn main () { let result1 = create_user_profile ("Alice" , 25i32 , "alice@example.com") ; let result2 = create_user_profile ("" , 30i32 , "bob@example.com") ; let result3 = create_user_profile ("Charlie" , - 5i32 , "charlie@example.com") ; println ! ("Result 1: {}" , result1) ; println ! ("Result 2: {}" , result2) ; println ! ("Result 3: {}" , result3) ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                          ++++          ++                             ++           ++

warning: unnecessary braces around block return value
 --> /tmp/.tmpTnyBj9/main.rs:1:642
  |
1 | ...return "Profile created successfully" } } else { { return "Profile creation failed" } } } fn main () { let result1 = create_user_profi...
  |                                                     ^^                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn validate_user_input (name : & str , age : i32 , email : & str) -> bool { if name . len () == 0i32 { { println ! ("Error: Name cannot be empty") ; return false } } ; if age < 0i32 || age > 150i32 { { println ! ("Error: Age must be between 0 and 150") ; return false } } ; if ! email . contains ('@') { { println ! ("Error: Invalid email format") ; return false } } ; println ! ("User input is valid") ; return true } fn create_user_profile (name : & str , age : i32 , email : & str) -> & str { if validate_user_input (name , age , email) { { println ! ("Creating profile for: {}" , name) ; return "Profile created successfully" } } else { { return "Profile creation failed" } } } fn main () { let result1 = create_user_profile ("Alice" , 25i32 , "alice@example.com") ; let result2 = create_user_profile ("" , 30i32 , "bob@example.com") ; let result3 = create_user_profile ("Charlie" , - 5i32 , "charlie@example.com") ; println ! ("Result 1: {}" , result1) ; println ! ("Result 2: {}" , result2) ; println ! ("Result 3: {}" , result3) ; }
1 + fn validate_user_input (name : & str , age : i32 , email : & str) -> bool { if name . len () == 0i32 { { println ! ("Error: Name cannot be empty") ; return false } } ; if age < 0i32 || age > 150i32 { { println ! ("Error: Age must be between 0 and 150") ; return false } } ; if ! email . contains ('@') { { println ! ("Error: Invalid email format") ; return false } } ; println ! ("User input is valid") ; return true } fn create_user_profile (name : & str , age : i32 , email : & str) -> & str { if validate_user_input (name , age , email) { { println ! ("Creating profile for: {}" , name) ; return "Profile created successfully" } } else { return "Profile creation failed" } } fn main () { let result1 = create_user_profile ("Alice" , 25i32 , "alice@example.com") ; let result2 = create_user_profile ("" , 30i32 , "bob@example.com") ; let result3 = create_user_profile ("Charlie" , - 5i32 , "charlie@example.com") ; println ! ("Result 1: {}" , result1) ; println ! ("Result 2: {}" , result2) ; println ! ("Result 3: {}" , result3) ; }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpTnyBj9/main.rs:1:97
  |
1 | fn validate_user_input (name : & str , age : i32 , email : & str) -> bool { if name . len () == 0i32 { { println ! ("Error: Name cannot b...
  |                                                                                -------------    ^^^^ expected `usize`, found `i32`
  |                                                                                |
  |                                                                                expected because this is `usize`
  |
help: change the type of the numeric literal from `i32` to `usize`
  |
1 - fn validate_user_input (name : & str , age : i32 , email : & str) -> bool { if name . len () == 0i32 { { println ! ("Error: Name cannot be empty") ; return false } } ; if age < 0i32 || age > 150i32 { { println ! ("Error: Age must be between 0 and 150") ; return false } } ; if ! email . contains ('@') { { println ! ("Error: Invalid email format") ; return false } } ; println ! ("User input is valid") ; return true } fn create_user_profile (name : & str , age : i32 , email : & str) -> & str { if validate_user_input (name , age , email) { { println ! ("Creating profile for: {}" , name) ; return "Profile created successfully" } } else { { return "Profile creation failed" } } } fn main () { let result1 = create_user_profile ("Alice" , 25i32 , "alice@example.com") ; let result2 = create_user_profile ("" , 30i32 , "bob@example.com") ; let result3 = create_user_profile ("Charlie" , - 5i32 , "charlie@example.com") ; println ! ("Result 1: {}" , result1) ; println ! ("Result 2: {}" , result2) ; println ! ("Result 3: {}" , result3) ; }
1 + fn validate_user_input (name : & str , age : i32 , email : & str) -> bool { if name . len () == 0usize { { println ! ("Error: Name cannot be empty") ; return false } } ; if age < 0i32 || age > 150i32 { { println ! ("Error: Age must be between 0 and 150") ; return false } } ; if ! email . contains ('@') { { println ! ("Error: Invalid email format") ; return false } } ; println ! ("User input is valid") ; return true } fn create_user_profile (name : & str , age : i32 , email : & str) -> & str { if validate_user_input (name , age , email) { { println ! ("Creating profile for: {}" , name) ; return "Profile created successfully" } } else { { return "Profile creation failed" } } } fn main () { let result1 = create_user_profile ("Alice" , 25i32 , "alice@example.com") ; let result2 = create_user_profile ("" , 30i32 , "bob@example.com") ; let result3 = create_user_profile ("Charlie" , - 5i32 , "charlie@example.com") ; println ! ("Result 1: {}" , result1) ; println ! ("Result 2: {}" , result2) ; println ! ("Result 3: {}" , result3) ; }
  |

error: aborting due to 2 previous errors; 1 warning emitted

Some errors have detailed explanations: E0106, E0308.
For more information about an error, try `rustc --explain E0106`.



=== ch04-00-practical-patterns-tdd example 5 ===
DEBUG: About to call transpile_to_program
DEBUG: transpile_to_program completed
✗ Compilation failed: Compilation failed:
warning: unnecessary trailing semicolon
 --> /tmp/.tmpgI1V7O/main.rs:1:73
  |
1 | fn calculate_total (prices : [i32 ; 5]) -> i32 { let mut total = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { total = total + prices ...
  |                                                                         ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpgI1V7O/main.rs:1:94
  |
1 | fn calculate_total (prices : [i32 ; 5]) -> i32 { let mut total = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { total = total + prices ...
  |                                                                                              ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpgI1V7O/main.rs:1:273
  |
1 | ...i32 { let mut max_value = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < 5i32 { { if numbers [i as usize] > max_value { { ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpgI1V7O/main.rs:1:294
  |
1 | ...ue = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < 5i32 { { if numbers [i as usize] > max_value { { max_value = numbers [...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpgI1V7O/main.rs:1:353
  |
1 | ...< 5i32 { { if numbers [i as usize] > max_value { { max_value = numbers [i as usize] } } ; i = i + 1i32 } } ; max_value } fn count_posi...
  |                                                     ^^                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn calculate_total (prices : [i32 ; 5]) -> i32 { let mut total = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } fn find_maximum (numbers : [i32 ; 5]) -> i32 { let mut max_value = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < 5i32 { { if numbers [i as usize] > max_value { { max_value = numbers [i as usize] } } ; i = i + 1i32 } } ; max_value } fn count_positives (numbers : [i32 ; 5]) -> i32 { let mut count = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { if numbers [i as usize] > 0i32 { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } fn main () { let prices = vec ! [10i32 , 25i32 , 5i32 , 15i32 , 8i32] ; let numbers = vec ! [- 3i32 , 7i32 , - 1i32 , 12i32 , 0i32] ; let mut total = calculate_total (prices) ; let maximum = find_maximum (prices) ; let positive_count = count_positives (numbers) ; println ! ("Total: {}" , total) ; println ! ("Maximum: {}" , maximum) ; println ! ("Positive numbers: {}" , positive_count) ; }
1 + fn calculate_total (prices : [i32 ; 5]) -> i32 { let mut total = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } fn find_maximum (numbers : [i32 ; 5]) -> i32 { let mut max_value = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < 5i32 { { if numbers [i as usize] > max_value { max_value = numbers [i as usize] } ; i = i + 1i32 } } ; max_value } fn count_positives (numbers : [i32 ; 5]) -> i32 { let mut count = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { if numbers [i as usize] > 0i32 { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } fn main () { let prices = vec ! [10i32 , 25i32 , 5i32 , 15i32 , 8i32] ; let numbers = vec ! [- 3i32 , 7i32 , - 1i32 , 12i32 , 0i32] ; let mut total = calculate_total (prices) ; let maximum = find_maximum (prices) ; let positive_count = count_positives (numbers) ; println ! ("Total: {}" , total) ; println ! ("Maximum: {}" , maximum) ; println ! ("Positive numbers: {}" , positive_count) ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpgI1V7O/main.rs:1:498
  |
1 | ...umbers : [i32 ; 5]) -> i32 { let mut count = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { if numbers [i as usize] > 0i32 { { count...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpgI1V7O/main.rs:1:519
  |
1 | ...> i32 { let mut count = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { if numbers [i as usize] > 0i32 { { count = count + 1i32 } } ;...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpgI1V7O/main.rs:1:573
  |
1 | ... ; while i < 5i32 { { if numbers [i as usize] > 0i32 { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } fn main () { let prices...
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - fn calculate_total (prices : [i32 ; 5]) -> i32 { let mut total = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } fn find_maximum (numbers : [i32 ; 5]) -> i32 { let mut max_value = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < 5i32 { { if numbers [i as usize] > max_value { { max_value = numbers [i as usize] } } ; i = i + 1i32 } } ; max_value } fn count_positives (numbers : [i32 ; 5]) -> i32 { let mut count = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { if numbers [i as usize] > 0i32 { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } fn main () { let prices = vec ! [10i32 , 25i32 , 5i32 , 15i32 , 8i32] ; let numbers = vec ! [- 3i32 , 7i32 , - 1i32 , 12i32 , 0i32] ; let mut total = calculate_total (prices) ; let maximum = find_maximum (prices) ; let positive_count = count_positives (numbers) ; println ! ("Total: {}" , total) ; println ! ("Maximum: {}" , maximum) ; println ! ("Positive numbers: {}" , positive_count) ; }
1 + fn calculate_total (prices : [i32 ; 5]) -> i32 { let mut total = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } fn find_maximum (numbers : [i32 ; 5]) -> i32 { let mut max_value = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < 5i32 { { if numbers [i as usize] > max_value { { max_value = numbers [i as usize] } } ; i = i + 1i32 } } ; max_value } fn count_positives (numbers : [i32 ; 5]) -> i32 { let mut count = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { if numbers [i as usize] > 0i32 { count = count + 1i32 } ; i = i + 1i32 } } ; count } fn main () { let prices = vec ! [10i32 , 25i32 , 5i32 , 15i32 , 8i32] ; let numbers = vec ! [- 3i32 , 7i32 , - 1i32 , 12i32 , 0i32] ; let mut total = calculate_total (prices) ; let maximum = find_maximum (prices) ; let positive_count = count_positives (numbers) ; println ! ("Total: {}" , total) ; println ! ("Maximum: {}" , maximum) ; println ! ("Positive numbers: {}" , positive_count) ; }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpgI1V7O/main.rs:1:796
  |
1 | ...2 , 12i32 , 0i32] ; let mut total = calculate_total (prices) ; let maximum = find_maximum (prices) ; let positive_count = count_positi...
  |                                        ---------------  ^^^^^^ expected `[i32; 5]`, found `Vec<i32>`
  |                                        |
  |                                        arguments to this function are incorrect
  |
  = note: expected array `[i32; 5]`
            found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmpgI1V7O/main.rs:1:4
  |
1 | fn calculate_total (prices : [i32 ; 5]) -> i32 { let mut total = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { total = total + prices ...
  |    ^^^^^^^^^^^^^^^  ------------------

error[E0308]: mismatched types
 --> /tmp/.tmpgI1V7O/main.rs:1:834
  |
1 | ...culate_total (prices) ; let maximum = find_maximum (prices) ; let positive_count = count_positives (numbers) ; println ! ("Total: {}" ...
  |                                          ------------  ^^^^^^ expected `[i32; 5]`, found `Vec<i32>`
  |                                          |
  |                                          arguments to this function are incorrect
  |
  = note: expected array `[i32; 5]`
            found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmpgI1V7O/main.rs:1:183
  |
1 | ...ices [i as usize] ; i = i + 1i32 } } ; total } fn find_maximum (numbers : [i32 ; 5]) -> i32 { let mut max_value = numbers [0i32 as usi...
  |                                                      ^^^^^^^^^^^^  -------------------

error[E0308]: mismatched types
 --> /tmp/.tmpgI1V7O/main.rs:1:882
  |
1 | ...mum (prices) ; let positive_count = count_positives (numbers) ; println ! ("Total: {}" , total) ; println ! ("Maximum: {}" , maximum) ...
  |                                        ---------------  ^^^^^^^ expected `[i32; 5]`, found `Vec<i32>`
  |                                        |
  |                                        arguments to this function are incorrect
  |
  = note: expected array `[i32; 5]`
            found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmpgI1V7O/main.rs:1:428
  |
1 | ... usize] } } ; i = i + 1i32 } } ; max_value } fn count_positives (numbers : [i32 ; 5]) -> i32 { let mut count = 0i32 ; ; let mut i = 0i...
  |                                                    ^^^^^^^^^^^^^^^  -------------------

error: aborting due to 3 previous errors; 8 warnings emitted

For more information about this error, try `rustc --explain E0308`.

Error: Compilation failed:
warning: unnecessary trailing semicolon
 --> /tmp/.tmpgI1V7O/main.rs:1:73
  |
1 | fn calculate_total (prices : [i32 ; 5]) -> i32 { let mut total = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { total = total + prices ...
  |                                                                         ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpgI1V7O/main.rs:1:94
  |
1 | fn calculate_total (prices : [i32 ; 5]) -> i32 { let mut total = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { total = total + prices ...
  |                                                                                              ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpgI1V7O/main.rs:1:273
  |
1 | ...i32 { let mut max_value = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < 5i32 { { if numbers [i as usize] > max_value { { ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpgI1V7O/main.rs:1:294
  |
1 | ...ue = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < 5i32 { { if numbers [i as usize] > max_value { { max_value = numbers [...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpgI1V7O/main.rs:1:353
  |
1 | ...< 5i32 { { if numbers [i as usize] > max_value { { max_value = numbers [i as usize] } } ; i = i + 1i32 } } ; max_value } fn count_posi...
  |                                                     ^^                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn calculate_total (prices : [i32 ; 5]) -> i32 { let mut total = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } fn find_maximum (numbers : [i32 ; 5]) -> i32 { let mut max_value = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < 5i32 { { if numbers [i as usize] > max_value { { max_value = numbers [i as usize] } } ; i = i + 1i32 } } ; max_value } fn count_positives (numbers : [i32 ; 5]) -> i32 { let mut count = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { if numbers [i as usize] > 0i32 { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } fn main () { let prices = vec ! [10i32 , 25i32 , 5i32 , 15i32 , 8i32] ; let numbers = vec ! [- 3i32 , 7i32 , - 1i32 , 12i32 , 0i32] ; let mut total = calculate_total (prices) ; let maximum = find_maximum (prices) ; let positive_count = count_positives (numbers) ; println ! ("Total: {}" , total) ; println ! ("Maximum: {}" , maximum) ; println ! ("Positive numbers: {}" , positive_count) ; }
1 + fn calculate_total (prices : [i32 ; 5]) -> i32 { let mut total = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } fn find_maximum (numbers : [i32 ; 5]) -> i32 { let mut max_value = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < 5i32 { { if numbers [i as usize] > max_value { max_value = numbers [i as usize] } ; i = i + 1i32 } } ; max_value } fn count_positives (numbers : [i32 ; 5]) -> i32 { let mut count = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { if numbers [i as usize] > 0i32 { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } fn main () { let prices = vec ! [10i32 , 25i32 , 5i32 , 15i32 , 8i32] ; let numbers = vec ! [- 3i32 , 7i32 , - 1i32 , 12i32 , 0i32] ; let mut total = calculate_total (prices) ; let maximum = find_maximum (prices) ; let positive_count = count_positives (numbers) ; println ! ("Total: {}" , total) ; println ! ("Maximum: {}" , maximum) ; println ! ("Positive numbers: {}" , positive_count) ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpgI1V7O/main.rs:1:498
  |
1 | ...umbers : [i32 ; 5]) -> i32 { let mut count = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { if numbers [i as usize] > 0i32 { { count...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpgI1V7O/main.rs:1:519
  |
1 | ...> i32 { let mut count = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { if numbers [i as usize] > 0i32 { { count = count + 1i32 } } ;...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpgI1V7O/main.rs:1:573
  |
1 | ... ; while i < 5i32 { { if numbers [i as usize] > 0i32 { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } fn main () { let prices...
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - fn calculate_total (prices : [i32 ; 5]) -> i32 { let mut total = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } fn find_maximum (numbers : [i32 ; 5]) -> i32 { let mut max_value = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < 5i32 { { if numbers [i as usize] > max_value { { max_value = numbers [i as usize] } } ; i = i + 1i32 } } ; max_value } fn count_positives (numbers : [i32 ; 5]) -> i32 { let mut count = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { if numbers [i as usize] > 0i32 { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } fn main () { let prices = vec ! [10i32 , 25i32 , 5i32 , 15i32 , 8i32] ; let numbers = vec ! [- 3i32 , 7i32 , - 1i32 , 12i32 , 0i32] ; let mut total = calculate_total (prices) ; let maximum = find_maximum (prices) ; let positive_count = count_positives (numbers) ; println ! ("Total: {}" , total) ; println ! ("Maximum: {}" , maximum) ; println ! ("Positive numbers: {}" , positive_count) ; }
1 + fn calculate_total (prices : [i32 ; 5]) -> i32 { let mut total = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } fn find_maximum (numbers : [i32 ; 5]) -> i32 { let mut max_value = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < 5i32 { { if numbers [i as usize] > max_value { { max_value = numbers [i as usize] } } ; i = i + 1i32 } } ; max_value } fn count_positives (numbers : [i32 ; 5]) -> i32 { let mut count = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { if numbers [i as usize] > 0i32 { count = count + 1i32 } ; i = i + 1i32 } } ; count } fn main () { let prices = vec ! [10i32 , 25i32 , 5i32 , 15i32 , 8i32] ; let numbers = vec ! [- 3i32 , 7i32 , - 1i32 , 12i32 , 0i32] ; let mut total = calculate_total (prices) ; let maximum = find_maximum (prices) ; let positive_count = count_positives (numbers) ; println ! ("Total: {}" , total) ; println ! ("Maximum: {}" , maximum) ; println ! ("Positive numbers: {}" , positive_count) ; }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpgI1V7O/main.rs:1:796
  |
1 | ...2 , 12i32 , 0i32] ; let mut total = calculate_total (prices) ; let maximum = find_maximum (prices) ; let positive_count = count_positi...
  |                                        ---------------  ^^^^^^ expected `[i32; 5]`, found `Vec<i32>`
  |                                        |
  |                                        arguments to this function are incorrect
  |
  = note: expected array `[i32; 5]`
            found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmpgI1V7O/main.rs:1:4
  |
1 | fn calculate_total (prices : [i32 ; 5]) -> i32 { let mut total = 0i32 ; ; let mut i = 0i32 ; ; while i < 5i32 { { total = total + prices ...
  |    ^^^^^^^^^^^^^^^  ------------------

error[E0308]: mismatched types
 --> /tmp/.tmpgI1V7O/main.rs:1:834
  |
1 | ...culate_total (prices) ; let maximum = find_maximum (prices) ; let positive_count = count_positives (numbers) ; println ! ("Total: {}" ...
  |                                          ------------  ^^^^^^ expected `[i32; 5]`, found `Vec<i32>`
  |                                          |
  |                                          arguments to this function are incorrect
  |
  = note: expected array `[i32; 5]`
            found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmpgI1V7O/main.rs:1:183
  |
1 | ...ices [i as usize] ; i = i + 1i32 } } ; total } fn find_maximum (numbers : [i32 ; 5]) -> i32 { let mut max_value = numbers [0i32 as usi...
  |                                                      ^^^^^^^^^^^^  -------------------

error[E0308]: mismatched types
 --> /tmp/.tmpgI1V7O/main.rs:1:882
  |
1 | ...mum (prices) ; let positive_count = count_positives (numbers) ; println ! ("Total: {}" , total) ; println ! ("Maximum: {}" , maximum) ...
  |                                        ---------------  ^^^^^^^ expected `[i32; 5]`, found `Vec<i32>`
  |                                        |
  |                                        arguments to this function are incorrect
  |
  = note: expected array `[i32; 5]`
            found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmpgI1V7O/main.rs:1:428
  |
1 | ... usize] } } ; i = i + 1i32 } } ; max_value } fn count_positives (numbers : [i32 ; 5]) -> i32 { let mut count = 0i32 ; ; let mut i = 0i...
  |                                                    ^^^^^^^^^^^^^^^  -------------------

error: aborting due to 3 previous errors; 8 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch04-00-practical-patterns-tdd example 6 ===
DEBUG: About to call transpile_to_program
✗ Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Expected identifier or pattern after 'let mut'


=== ch04-00-practical-patterns-tdd example 8 ===
DEBUG: About to call transpile_to_program
✗ Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Expected body after if condition, typically { ... }: Expected identifier after '::'


=== ch04-00-practical-patterns-tdd example 10 ===
DEBUG: About to call transpile_to_program
✗ Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Expected body after while condition: Unexpected token: Else


=== ch18-00-dataframes-data-processing example 1 ===
DEBUG: About to call transpile_to_program
DEBUG: transpile_to_program completed
✗ Compilation failed: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpllD3oY/main.rs:1:35
  |
1 | fn create_dataframe () { let df = polars :: prelude :: DataFrame :: empty () . column ("employee_id" , vec ! [101i32 , 102i32 , 103i32 , ...
  |                                   ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

warning: unnecessary trailing semicolon
 --> /tmp/.tmpllD3oY/main.rs:1:369
  |
1 | ...c ! [95000i32 , 75000i32 , 105000i32 , 65000i32]) ; ; println ! ("Created DataFrame with {} employees" , df . height ()) ; println ! (...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0433`.

Error: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpllD3oY/main.rs:1:35
  |
1 | fn create_dataframe () { let df = polars :: prelude :: DataFrame :: empty () . column ("employee_id" , vec ! [101i32 , 102i32 , 103i32 , ...
  |                                   ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

warning: unnecessary trailing semicolon
 --> /tmp/.tmpllD3oY/main.rs:1:369
  |
1 | ...c ! [95000i32 , 75000i32 , 105000i32 , 65000i32]) ; ; println ! ("Created DataFrame with {} employees" , df . height ()) ; println ! (...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0433`.



=== ch18-00-dataframes-data-processing example 2 ===
DEBUG: About to call transpile_to_program
DEBUG: transpile_to_program completed
✗ Compilation failed: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmp0GpfZe/main.rs:1:189
  |
1 | ...es ()) ; } fn main () { { let sales = polars :: prelude :: DataFrame :: empty () . column ("product" , vec ! ["Widget" , "Gadget" , "G...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0412]: cannot find type `DataFrame` in this scope
 --> /tmp/.tmp0GpfZe/main.rs:1:24
  |
1 | fn analyze_sales (df : DataFrame) { println ! ("Analyzing {} sales records" , df . height ()) ; println ! ("Data has {} columns" , df . g...
  |                        ^^^^^^^^^ not found in this scope

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0412, E0433.
For more information about an error, try `rustc --explain E0412`.

Error: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmp0GpfZe/main.rs:1:189
  |
1 | ...es ()) ; } fn main () { { let sales = polars :: prelude :: DataFrame :: empty () . column ("product" , vec ! ["Widget" , "Gadget" , "G...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0412]: cannot find type `DataFrame` in this scope
 --> /tmp/.tmp0GpfZe/main.rs:1:24
  |
1 | fn analyze_sales (df : DataFrame) { println ! ("Analyzing {} sales records" , df . height ()) ; println ! ("Data has {} columns" , df . g...
  |                        ^^^^^^^^^ not found in this scope

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0412, E0433.
For more information about an error, try `rustc --explain E0412`.



=== ch18-00-dataframes-data-processing example 3 ===
DEBUG: About to call transpile_to_program
DEBUG: transpile_to_program completed
✗ Compilation failed: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpWrF6co/main.rs:1:55
  |
1 | fn work_with_multiple_dataframes () { let customers = polars :: prelude :: DataFrame :: empty () . column ("customer_id" , vec ! [1i32 , ...
  |                                                       ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpWrF6co/main.rs:1:290
  |
1 | ...Angeles" , "Chicago"]) ; let orders = polars :: prelude :: DataFrame :: empty () . column ("order_id" , vec ! [101i32 , 102i32 , 103i3...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0433`.

Error: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpWrF6co/main.rs:1:55
  |
1 | fn work_with_multiple_dataframes () { let customers = polars :: prelude :: DataFrame :: empty () . column ("customer_id" , vec ! [1i32 , ...
  |                                                       ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpWrF6co/main.rs:1:290
  |
1 | ...Angeles" , "Chicago"]) ; let orders = polars :: prelude :: DataFrame :: empty () . column ("order_id" , vec ! [101i32 , 102i32 , 103i3...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0433`.



=== ch18-00-dataframes-data-processing example 4 ===
DEBUG: About to call transpile_to_program
DEBUG: transpile_to_program completed
✗ Compilation failed: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpYdhoYC/main.rs:1:41
  |
1 | fn conditional_processing () { let df = polars :: prelude :: DataFrame :: empty () . column ("status" , vec ! ["active" , "pending" , "cl...
  |                                         ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

warning: unnecessary trailing semicolon
 --> /tmp/.tmpYdhoYC/main.rs:1:204
  |
1 | ...mn ("value" , vec ! [1000i32 , 500i32 , 1500i32]) ; ; if df . height () > 0i32 { { println ! ("DataFrame contains data") } } ; if df ....
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpYdhoYC/main.rs:1:233
  |
1 | ...32 , 1500i32]) ; ; if df . height () > 0i32 { { println ! ("DataFrame contains data") } } ; if df . get_column_names () == 2i32 { { pr...
  |                                                  ^^                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn conditional_processing () { let df = polars :: prelude :: DataFrame :: empty () . column ("status" , vec ! ["active" , "pending" , "closed"]) . column ("value" , vec ! [1000i32 , 500i32 , 1500i32]) ; ; if df . height () > 0i32 { { println ! ("DataFrame contains data") } } ; if df . get_column_names () == 2i32 { { println ! ("DataFrame has exactly 2 columns") } } ; for i in 0i32 .. df . height () { { println ! ("Processing row {}" , i) } } ; } fn main () { }
1 + fn conditional_processing () { let df = polars :: prelude :: DataFrame :: empty () . column ("status" , vec ! ["active" , "pending" , "closed"]) . column ("value" , vec ! [1000i32 , 500i32 , 1500i32]) ; ; if df . height () > 0i32 { println ! ("DataFrame contains data") } ; if df . get_column_names () == 2i32 { { println ! ("DataFrame has exactly 2 columns") } } ; for i in 0i32 .. df . height () { { println ! ("Processing row {}" , i) } } ; } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpYdhoYC/main.rs:1:317
  |
1 | ...} ; if df . get_column_names () == 2i32 { { println ! ("DataFrame has exactly 2 columns") } } ; for i in 0i32 .. df . height () { { pr...
  |                                              ^^                                             ^^
  |
help: remove these braces
  |
1 - fn conditional_processing () { let df = polars :: prelude :: DataFrame :: empty () . column ("status" , vec ! ["active" , "pending" , "closed"]) . column ("value" , vec ! [1000i32 , 500i32 , 1500i32]) ; ; if df . height () > 0i32 { { println ! ("DataFrame contains data") } } ; if df . get_column_names () == 2i32 { { println ! ("DataFrame has exactly 2 columns") } } ; for i in 0i32 .. df . height () { { println ! ("Processing row {}" , i) } } ; } fn main () { }
1 + fn conditional_processing () { let df = polars :: prelude :: DataFrame :: empty () . column ("status" , vec ! ["active" , "pending" , "closed"]) . column ("value" , vec ! [1000i32 , 500i32 , 1500i32]) ; ; if df . height () > 0i32 { { println ! ("DataFrame contains data") } } ; if df . get_column_names () == 2i32 { println ! ("DataFrame has exactly 2 columns") } ; for i in 0i32 .. df . height () { { println ! ("Processing row {}" , i) } } ; } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpYdhoYC/main.rs:1:405
  |
1 | ...umns") } } ; for i in 0i32 .. df . height () { { println ! ("Processing row {}" , i) } } ; } fn main () { }
  |                                                   ^^                                   ^^
  |
help: remove these braces
  |
1 - fn conditional_processing () { let df = polars :: prelude :: DataFrame :: empty () . column ("status" , vec ! ["active" , "pending" , "closed"]) . column ("value" , vec ! [1000i32 , 500i32 , 1500i32]) ; ; if df . height () > 0i32 { { println ! ("DataFrame contains data") } } ; if df . get_column_names () == 2i32 { { println ! ("DataFrame has exactly 2 columns") } } ; for i in 0i32 .. df . height () { { println ! ("Processing row {}" , i) } } ; } fn main () { }
1 + fn conditional_processing () { let df = polars :: prelude :: DataFrame :: empty () . column ("status" , vec ! ["active" , "pending" , "closed"]) . column ("value" , vec ! [1000i32 , 500i32 , 1500i32]) ; ; if df . height () > 0i32 { { println ! ("DataFrame contains data") } } ; if df . get_column_names () == 2i32 { { println ! ("DataFrame has exactly 2 columns") } } ; for i in 0i32 .. df . height () { println ! ("Processing row {}" , i) } ; } fn main () { }
  |

error: aborting due to 1 previous error; 4 warnings emitted

For more information about this error, try `rustc --explain E0433`.

Error: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpYdhoYC/main.rs:1:41
  |
1 | fn conditional_processing () { let df = polars :: prelude :: DataFrame :: empty () . column ("status" , vec ! ["active" , "pending" , "cl...
  |                                         ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

warning: unnecessary trailing semicolon
 --> /tmp/.tmpYdhoYC/main.rs:1:204
  |
1 | ...mn ("value" , vec ! [1000i32 , 500i32 , 1500i32]) ; ; if df . height () > 0i32 { { println ! ("DataFrame contains data") } } ; if df ....
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpYdhoYC/main.rs:1:233
  |
1 | ...32 , 1500i32]) ; ; if df . height () > 0i32 { { println ! ("DataFrame contains data") } } ; if df . get_column_names () == 2i32 { { pr...
  |                                                  ^^                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn conditional_processing () { let df = polars :: prelude :: DataFrame :: empty () . column ("status" , vec ! ["active" , "pending" , "closed"]) . column ("value" , vec ! [1000i32 , 500i32 , 1500i32]) ; ; if df . height () > 0i32 { { println ! ("DataFrame contains data") } } ; if df . get_column_names () == 2i32 { { println ! ("DataFrame has exactly 2 columns") } } ; for i in 0i32 .. df . height () { { println ! ("Processing row {}" , i) } } ; } fn main () { }
1 + fn conditional_processing () { let df = polars :: prelude :: DataFrame :: empty () . column ("status" , vec ! ["active" , "pending" , "closed"]) . column ("value" , vec ! [1000i32 , 500i32 , 1500i32]) ; ; if df . height () > 0i32 { println ! ("DataFrame contains data") } ; if df . get_column_names () == 2i32 { { println ! ("DataFrame has exactly 2 columns") } } ; for i in 0i32 .. df . height () { { println ! ("Processing row {}" , i) } } ; } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpYdhoYC/main.rs:1:317
  |
1 | ...} ; if df . get_column_names () == 2i32 { { println ! ("DataFrame has exactly 2 columns") } } ; for i in 0i32 .. df . height () { { pr...
  |                                              ^^                                             ^^
  |
help: remove these braces
  |
1 - fn conditional_processing () { let df = polars :: prelude :: DataFrame :: empty () . column ("status" , vec ! ["active" , "pending" , "closed"]) . column ("value" , vec ! [1000i32 , 500i32 , 1500i32]) ; ; if df . height () > 0i32 { { println ! ("DataFrame contains data") } } ; if df . get_column_names () == 2i32 { { println ! ("DataFrame has exactly 2 columns") } } ; for i in 0i32 .. df . height () { { println ! ("Processing row {}" , i) } } ; } fn main () { }
1 + fn conditional_processing () { let df = polars :: prelude :: DataFrame :: empty () . column ("status" , vec ! ["active" , "pending" , "closed"]) . column ("value" , vec ! [1000i32 , 500i32 , 1500i32]) ; ; if df . height () > 0i32 { { println ! ("DataFrame contains data") } } ; if df . get_column_names () == 2i32 { println ! ("DataFrame has exactly 2 columns") } ; for i in 0i32 .. df . height () { { println ! ("Processing row {}" , i) } } ; } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpYdhoYC/main.rs:1:405
  |
1 | ...umns") } } ; for i in 0i32 .. df . height () { { println ! ("Processing row {}" , i) } } ; } fn main () { }
  |                                                   ^^                                   ^^
  |
help: remove these braces
  |
1 - fn conditional_processing () { let df = polars :: prelude :: DataFrame :: empty () . column ("status" , vec ! ["active" , "pending" , "closed"]) . column ("value" , vec ! [1000i32 , 500i32 , 1500i32]) ; ; if df . height () > 0i32 { { println ! ("DataFrame contains data") } } ; if df . get_column_names () == 2i32 { { println ! ("DataFrame has exactly 2 columns") } } ; for i in 0i32 .. df . height () { { println ! ("Processing row {}" , i) } } ; } fn main () { }
1 + fn conditional_processing () { let df = polars :: prelude :: DataFrame :: empty () . column ("status" , vec ! ["active" , "pending" , "closed"]) . column ("value" , vec ! [1000i32 , 500i32 , 1500i32]) ; ; if df . height () > 0i32 { { println ! ("DataFrame contains data") } } ; if df . get_column_names () == 2i32 { { println ! ("DataFrame has exactly 2 columns") } } ; for i in 0i32 .. df . height () { println ! ("Processing row {}" , i) } ; } fn main () { }
  |

error: aborting due to 1 previous error; 4 warnings emitted

For more information about this error, try `rustc --explain E0433`.


