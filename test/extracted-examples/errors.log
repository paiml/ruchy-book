=== ch02-00-variables-types-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found `let` statement
 --> /tmp/.tmpVXgWhY/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let result = value1 + value2 ; ; if let Some (s) = (& result as & dyn std :...
  |                                                               ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

error[E0425]: cannot find value `value1` in this scope
 --> /tmp/.tmpVXgWhY/main.rs:1:76
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let result = value1 + value2 ; ; if let Some (s) = (& result as & dyn std :...
  |                                                                            ^^^^^^ not found in this scope

error[E0425]: cannot find value `value2` in this scope
 --> /tmp/.tmpVXgWhY/main.rs:1:85
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let result = value1 + value2 ; ; if let Some (s) = (& result as & dyn std :...
  |                                                                                     ^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpVXgWhY/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let result = value1 + value2 ; ; if let Some (s) = (& result as & dyn std :...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpVXgWhY/main.rs:1:94
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let result = value1 + value2 ; ; if let Some (s) = (& result as & dyn std :...
  |                                                                                              ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error: aborting due to 3 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch02-00-variables-types-tdd example 7 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `initial_value` in this scope
 --> /tmp/.tmpytM0R3/main.rs:1:62
  |
1 | use std :: collections :: HashMap ; fn main () { let step1 = initial_value * factor ; ; let step2 = step1 + adjustment ; ; let final_resu...
  |                                                              ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `factor` in this scope
 --> /tmp/.tmpytM0R3/main.rs:1:78
  |
1 | use std :: collections :: HashMap ; fn main () { let step1 = initial_value * factor ; ; let step2 = step1 + adjustment ; ; let final_resu...
  |                                                                              ^^^^^^ not found in this scope

error[E0425]: cannot find value `adjustment` in this scope
 --> /tmp/.tmpytM0R3/main.rs:1:109
  |
1 | ... = initial_value * factor ; ; let step2 = step1 + adjustment ; ; let final_result = step2 / divisor ; ; }
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `divisor` in this scope
 --> /tmp/.tmpytM0R3/main.rs:1:151
  |
1 | ... step1 + adjustment ; ; let final_result = step2 / divisor ; ; }
  |                                                       ^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpytM0R3/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let step1 = initial_value * factor ; ; let step2 = step1 + adjustment ; ; let final_resu...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpytM0R3/main.rs:1:87
  |
1 | use std :: collections :: HashMap ; fn main () { let step1 = initial_value * factor ; ; let step2 = step1 + adjustment ; ; let final_resu...
  |                                                                                       ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpytM0R3/main.rs:1:122
  |
1 | ...value * factor ; ; let step2 = step1 + adjustment ; ; let final_result = step2 / divisor ; ; }
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpytM0R3/main.rs:1:161
  |
1 | ...adjustment ; ; let final_result = step2 / divisor ; ; }
  |                                                        ^ help: remove this semicolon

error: aborting due to 4 previous errors; 4 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch10-00-performance-optimization example 1 ===
✗ Compilation failed: Compilation failed:
error[E0432]: unresolved import `std::perf`
 --> /tmp/.tmpvrDFpc/main.rs:1:737
  |
1 | ...eturn lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; ;...
  |                                                      ^^^^^^^^^^^ no `perf` in the root

error[E0432]: unresolved import `std::parallel`
 --> /tmp/.tmpvrDFpc/main.rs:1:757
  |
1 | ... } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; ; let naive_time = perf :...
  |                                                  ^^^^^^^^^^^^^^^ no `parallel` in the root

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpvrDFpc/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpvrDFpc/main.rs:1:84
  |
1 | ... { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } ...
  |       ^^                                                                                                                                                                                                                                                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; ; let naive_time = perf :: measure ; ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; ; let naive_time = perf :: measure ; ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpvrDFpc/main.rs:1:134
  |
1 | ... { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ...
  |       ^^                                                                                                                                                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; ; let naive_time = perf :: measure ; ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; ; let naive_time = perf :: measure ; ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpvrDFpc/main.rs:1:211
  |
1 | ...; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed...
  |                                  ^^                                                                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; ; let naive_time = perf :: measure ; ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { if similar (processed , existing) { { processed . merge (existing) } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; ; let naive_time = perf :: measure ; ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpvrDFpc/main.rs:1:249
  |
1 | ...in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; retur...
  |                                                       ^^                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; ; let naive_time = perf :: measure ; ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { processed . merge (existing) } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; ; let naive_time = perf :: measure ; ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpvrDFpc/main.rs:1:401
  |
1 | ... { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; ; let naive_time = perf :: measure ; ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; ; let naive_time = perf :: measure ; ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpvrDFpc/main.rs:1:506
  |
1 | ...expensive_transform (item) }) ; { let lookup = () ; ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (ke...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpvrDFpc/main.rs:1:530
  |
1 | ... { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ...
  |       ^^                                                                                                                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; ; let naive_time = perf :: measure ; ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; ; for item in results { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; ; let naive_time = perf :: measure ; ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpvrDFpc/main.rs:1:593
  |
1 | ...em . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } ...
  |                                                   ^^                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; ; let naive_time = perf :: measure ; ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { lookup [key as usize] . merge (item) } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; ; let naive_time = perf :: measure ; ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpvrDFpc/main.rs:1:643
  |
1 | ... { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn mai...
  |                                                       ^^                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; ; let naive_time = perf :: measure ; ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { lookup [key as usize] = item } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; ; let naive_time = perf :: measure ; ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {:.1}x" , naive_time / optimized_time) ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpvrDFpc/main.rs:1:751
  |
1 | ... . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; ; let naive_t...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpvrDFpc/main.rs:1:775
  |
1 | ...main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; ; let naive_time = perf :: measure ; ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpvrDFpc/main.rs:1:820
  |
1 | ...llel ; ; let data = generate_test_data (10000i32) ; ; let naive_time = perf :: measure ; ; { process_data_naive (data) } ; let optimiz...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpvrDFpc/main.rs:1:857
  |
1 | ...a (10000i32) ; ; let naive_time = perf :: measure ; ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; ; { proce...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpvrDFpc/main.rs:1:930
  |
1 | ...e (data) } ; let optimized_time = perf :: measure ; ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; pri...
  |                                                        ^ help: remove this semicolon

error[E0277]: `String` is not an iterator
 --> /tmp/.tmpvrDFpc/main.rs:1:127
  |
1 | ...ults = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (proc...
  |                                    ^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`
  |
  = help: the trait `Iterator` is not implemented for `String`
  = note: required for `String` to implement `IntoIterator`

error[E0425]: cannot find function `expensive_transform` in this scope
 --> /tmp/.tmpvrDFpc/main.rs:1:154
  |
1 | ...] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existi...
  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `similar` in this scope
 --> /tmp/.tmpvrDFpc/main.rs:1:216
  |
1 | ...ransform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results ....
  |                                                       ^^^^^^^ not found in this scope

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `parallel`
 --> /tmp/.tmpvrDFpc/main.rs:1:419
  |
1 | ... String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; ; for item ...
  |                                        ^^^^^^^^ use of unresolved module or unlinked crate `parallel`
  |
  = help: you might be missing a crate named `parallel`

error[E0425]: cannot find function `expensive_transform` in this scope
 --> /tmp/.tmpvrDFpc/main.rs:1:454
  |
1 | ...results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; ; for item in results { { { let key =...
  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `has_key` found for unit type `()` in the current scope
 --> /tmp/.tmpvrDFpc/main.rs:1:577
  |
1 | ...s { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as ...
  |                                                       ^^^^^^^ method not found in `()`

error[E0599]: no method named `values` found for unit type `()` in the current scope
 --> /tmp/.tmpvrDFpc/main.rs:1:702
  |
1 | ... [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data...
  |                                                       ^^^^^^ method not found in `()`

error[E0425]: cannot find function `generate_test_data` in this scope
 --> /tmp/.tmpvrDFpc/main.rs:1:788
  |
1 | ...: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; ; let naive_time = perf :: measure ; ; { process_data_na...
  |                                                  ^^^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 10 previous errors; 15 warnings emitted

Some errors have detailed explanations: E0277, E0425, E0432, E0433, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch10-00-performance-optimization example 2 ===

thread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:
"perf::CpuProfiler" is not a valid Ident
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


=== ch10-00-performance-optimization example 3 ===
✗ Compilation failed: Compilation failed:
error[E0432]: unresolved import `std::bench`
 --> /tmp/.tmpskqaic/main.rs:1:435
  |
1 | ...ms" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite ("String Operations" . to_string () , { let mut map :...
  |                                                     ^^^^^^^^^^^^ no `bench` in the root

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmpskqaic/main.rs:1:148
  |
1 | ...a : String) { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmpskqaic/main.rs:1:192
  |
1 | ...or i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmpskqaic/main.rs:1:707
  |
1 | ...g () , (|| { { let s = "" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ("str...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmpskqaic/main.rs:1:878
  |
1 | ... let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } ...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmpskqaic/main.rs:1:1027
  |
1 | ...g ()) ; map . insert ("join" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () ....
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpskqaic/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) { { { let times = vec ! [] ; {...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpskqaic/main.rs:1:110
  |
1 | ... { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let avg = times . mean () ; ; let std = times . std_dev () ; ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg , std) } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let avg = times . mean () ; ; let std = times . std_dev () ; ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite ("String Operations" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("concatenation" . to_string () , (|| { { let s = "" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ("string builder" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert ("join" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join (& "") }) . to_string ()) ; map }) ; }
1 + use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let avg = times . mean () ; ; let std = times . std_dev () ; ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg , std) } } } fn main () { use std :: bench ; ; bench :: suite ("String Operations" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("concatenation" . to_string () , (|| { { let s = "" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ("string builder" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert ("join" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join (& "") }) . to_string ()) ; map }) ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpskqaic/main.rs:1:320
  |
1 | .... push (time) } } } } ; let avg = times . mean () ; ; let std = times . std_dev () ; ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpskqaic/main.rs:1:353
  |
1 | ... times . mean () ; ; let std = times . std_dev () ; ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg , std) } } } } fn main () { use ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpskqaic/main.rs:1:163
  |
1 | ...ng) { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measur...
  |                                                               ^^           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let avg = times . mean () ; ; let std = times . std_dev () ; ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite ("String Operations" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("concatenation" . to_string () , (|| { { let s = "" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ("string builder" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert ("join" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join (& "") }) . to_string ()) ; map }) ; }
1 + use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) { { { let times = vec ! [] ; { for i in range (5i32) { func (data) } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let avg = times . mean () ; ; let std = times . std_dev () ; ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite ("String Operations" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("concatenation" . to_string () , (|| { { let s = "" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ("string builder" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert ("join" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join (& "") }) . to_string ()) ; map }) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpskqaic/main.rs:1:209
  |
1 | ...; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let avg = times . mean ...
  |                                ^^                                                                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let avg = times . mean () ; ; let std = times . std_dev () ; ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite ("String Operations" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("concatenation" . to_string () , (|| { { let s = "" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ("string builder" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert ("join" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join (& "") }) . to_string ()) ; map }) ; }
1 + use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } ; let avg = times . mean () ; ; let std = times . std_dev () ; ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite ("String Operations" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("concatenation" . to_string () , (|| { { let s = "" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ("string builder" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert ("join" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join (& "") }) . to_string ()) ; map }) ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpskqaic/main.rs:1:450
  |
1 | ... avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite ("String Operations" . to_string () , { let mut map : std :: coll...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpskqaic/main.rs:1:725
  |
1 | ...{ let s = "" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ("string builder" ...
  |                                                             ^^                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let avg = times . mean () ; ; let std = times . std_dev () ; ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite ("String Operations" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("concatenation" . to_string () , (|| { { let s = "" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ("string builder" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert ("join" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join (& "") }) . to_string ()) ; map }) ; }
1 + use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let avg = times . mean () ; ; let std = times . std_dev () ; ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite ("String Operations" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("concatenation" . to_string () , (|| { { let s = "" . to_string () ; for i in range (1000i32) { s += i . to_s () } } }) . to_string ()) ; map . insert ("string builder" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert ("join" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join (& "") }) . to_string ()) ; map }) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpskqaic/main.rs:1:896
  |
1 | ...gBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ())...
  |                                                      ^^                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let avg = times . mean () ; ; let std = times . std_dev () ; ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite ("String Operations" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("concatenation" . to_string () , (|| { { let s = "" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ("string builder" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert ("join" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join (& "") }) . to_string ()) ; map }) ; }
1 + use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let avg = times . mean () ; ; let std = times . std_dev () ; ; println ! ("{}: {:.2}ms ± {:.2}ms" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite ("String Operations" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("concatenation" . to_string () , (|| { { let s = "" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ("string builder" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { builder . append (i . to_s ()) } ; builder . to_string () } } }) . to_string ()) ; map . insert ("join" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join (& "") }) . to_string ()) ; map }) ; }
  |

error[E0618]: expected function, found `String`
 --> /tmp/.tmpskqaic/main.rs:1:165
  |
1 | ...e : String , func : String , data : String) { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range ...
  |                 ----                                                                                    ^^^^-------
  |                 |                                                                                       |
  |                 `func` has type `String`                                                                call expression requires function

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `perf`
 --> /tmp/.tmpskqaic/main.rs:1:224
  |
1 | ...or i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let avg = times . mean () ...
  |                                            ^^^^ use of unresolved module or unlinked crate `perf`
  |
  = help: you might be missing a crate named `perf`

error[E0618]: expected function, found `String`
 --> /tmp/.tmpskqaic/main.rs:1:246
  |
1 | ... , func : String , data : String) { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ...
  |       ----                                                                                                                                                                     ^^^^-------
  |       |                                                                                                                                                                        |
  |       `func` has type `String`                                                                                                                                                 call expression requires function

error[E0599]: `{closure@/tmp/.tmpskqaic/main.rs:1:663: 1:665}` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpskqaic/main.rs:1:755
  |
1 | ...string () , (|| { { let s = "" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ...
  |                 -- doesn't satisfy `_: Display` or `_: ToString`                                            ^^^^^^^^^ method cannot be called on `{closure@/tmp/.tmpskqaic/main.rs:1:663: 1:665}` due to unsatisfied trait bounds
  |
  = note: the following trait bounds were not satisfied:
          `{closure@/tmp/.tmpskqaic/main.rs:1:663: 1:665}: std::fmt::Display`
          which is required by `{closure@/tmp/.tmpskqaic/main.rs:1:663: 1:665}: ToString`

error[E0433]: failed to resolve: use of undeclared type `StringBuilder`
 --> /tmp/.tmpskqaic/main.rs:1:841
  |
1 | ..." . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ;...
  |                                             ^^^^^^^^^^^^^ use of undeclared type `StringBuilder`

error: aborting due to 11 previous errors; 9 warnings emitted

Some errors have detailed explanations: E0425, E0432, E0433, E0599, E0618.
For more information about an error, try `rustc --explain E0425`.



=== ch10-00-performance-optimization example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `fibonacci_cache` in this scope
 --> /tmp/.tmpVn5iel/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n...
  |                                                                               ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `fibonacci_cache` in this scope
 --> /tmp/.tmpVn5iel/main.rs:1:120
  |
1 | ... { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibon...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `fibonacci_cache` in this scope
 --> /tmp/.tmpVn5iel/main.rs:1:264
  |
1 | ...(n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive ...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmpVn5iel/main.rs:1:420
  |
1 | ...-> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmpVn5iel/main.rs:1:456
  |
1 | ...[] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] ...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpVn5iel/main.rs:1:961
  |
1 | ...e (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> ...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpVn5iel/main.rs:1:1052
  |
1 | ...ve_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predica...
  |                                                       ^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpVn5iel/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpVn5iel/main.rs:1:111
  |
1 | ... -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else ...
  |                                                   ^^                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { return fibonacci_cache [n as usize] } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpVn5iel/main.rs:1:185
  |
1 | ...ibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32)...
  |                                                                    ^^ ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { n } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpVn5iel/main.rs:1:200
  |
1 | ...esult = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = r...
  |                                          ^^                                                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpVn5iel/main.rs:1:377
  |
1 | ... { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } ...
  |       ^^                                                                                                                                                                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpVn5iel/main.rs:1:445
  |
1 | ... { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ...
  |       ^^                                                                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpVn5iel/main.rs:1:492
  |
1 | ..., items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return dupl...
  |                        ^^                                                                                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpVn5iel/main.rs:1:540
  |
1 | ...if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find...
  |                                                  ^^                                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { duplicates . push (items [i as usize]) } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpVn5iel/main.rs:1:676
  |
1 | ... { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } ...
  |       ^^                                                                                                                                                                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpVn5iel/main.rs:1:742
  |
1 | ... Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpVn5iel/main.rs:1:794
  |
1 | ... ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_ar...
  |                                                         ^^                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { duplicates . add (item) } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpVn5iel/main.rs:1:933
  |
1 | ...e_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records...
  |                                         ^^                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { for record in records { { database . insert (record) } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpVn5iel/main.rs:1:959
  |
1 | ...aive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) ...
  |                                                        ^^                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { database . insert (record) } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpVn5iel/main.rs:1:1050
  |
1 | ...e_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicat...
  |                                                    ^^                                 ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { database . insert_batch (records) } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpVn5iel/main.rs:1:1179
  |
1 | ...ate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacc...
  |                                                 ^^                                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { if predicate (item) { { return item } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpVn5iel/main.rs:1:1203
  |
1 | ...ng) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = ...
  |                                                               ^^           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { return item } } } ; return None } } fn main () { let fibonacci_cache = () ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpVn5iel/main.rs:1:1283
  |
1 | ...rn None } } fn main () { let fibonacci_cache = () ; ; }
  |                                                        ^ help: remove this semicolon

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpVn5iel/main.rs:1:504
  |
1 | ... (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; ...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpVn5iel/main.rs:1:526
  |
1 | ...en ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } ...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpVn5iel/main.rs:1:568
  |
1 | ...[j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : ...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0308]: mismatched types
 --> /tmp/.tmpVn5iel/main.rs:1:602
  |
1 | ...-> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } ...
  |       --- expected `i32` because of return type                                                                                                                                                                                              ^^^^^^^^^^ expected `i32`, found `Vec<_>`
  |
  = note: expected type `i32`
           found struct `Vec<_>`

error[E0433]: failed to resolve: use of undeclared type `Set`
 --> /tmp/.tmpVn5iel/main.rs:1:691
  |
1 | ...optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen ...
  |                                                       ^^^ use of undeclared type `Set`

error[E0433]: failed to resolve: use of undeclared type `Set`
 --> /tmp/.tmpVn5iel/main.rs:1:726
  |
1 | ... { { let seen = Set :: new () ; { let duplicates = Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . ...
  |                                                       ^^^ use of undeclared type `Set`

error[E0277]: `String` is not an iterator
 --> /tmp/.tmpVn5iel/main.rs:1:756
  |
1 | ... Set :: new () ; ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return du...
  |                                   ^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`
  |
  = help: the trait `Iterator` is not implemented for `String`
  = note: required for `String` to implement `IntoIterator`

error[E0277]: `String` is not an iterator
 --> /tmp/.tmpVn5iel/main.rs:1:949
  |
1 | ...s : String) { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { d...
  |                                  ^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`
  |
  = help: the trait `Iterator` is not implemented for `String`
  = note: required for `String` to implement `IntoIterator`

error[E0277]: `String` is not an iterator
 --> /tmp/.tmpVn5iel/main.rs:1:1171
  |
1 | ...String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cach...
  |                                   ^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`
  |
  = help: the trait `Iterator` is not implemented for `String`
  = note: required for `String` to implement `IntoIterator`

error[E0618]: expected function, found `String`
 --> /tmp/.tmpVn5iel/main.rs:1:1184
  |
1 | ...ms : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn ma...
  |                  ---------                                               ^^^^^^^^^-------
  |                  |                                                       |
  |                  `predicate` has type `String`                           call expression requires function

error[E0308]: mismatched types
 --> /tmp/.tmpVn5iel/main.rs:1:1234
  |
1 | ...g) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return None } } fn main () { let fibonacci_cache = (...
  |          --- expected `i32` because of return type                                          ^^^^ expected `i32`, found `Option<_>`
  |
  = note: expected type `i32`
             found enum `Option<_>`

warning: unused variable: `fibonacci_cache`
 --> /tmp/.tmpVn5iel/main.rs:1:1260
  |
1 | ... } fn main () { let fibonacci_cache = () ; ; }
  |                        ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_fibonacci_cache`
  |
  = note: `#[warn(unused_variables)]` on by default

error: aborting due to 18 previous errors; 18 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0425, E0433, E0618.
For more information about an error, try `rustc --explain E0277`.



=== ch10-00-performance-optimization example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 8 ===
✗ Compilation failed: Compilation failed:
error[E0432]: unresolved import `std::db`
 --> /tmp/.tmpJC6b7n/main.rs:1:1390
  |
1 | ... []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect ("postgres://localhost/myapp" . t...
  |                                          ^^^^^^^--
  |                                          |      |
  |                                          |      help: a similar name exists in the module: `dbg`
  |                                          no `db` in the root

error[E0432]: unresolved import `std::perf`
 --> /tmp/.tmpJC6b7n/main.rs:1:1408
  |
1 | ... unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect ("postgres://localhost/myapp" . to_stri...
  |                                                      ^^^^^^^^^^^ no `perf` in the root

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpJC6b7n/main.rs:1:83
  |
1 | use std :: collections :: HashMap ; fn analyze_query (sql : i32) { { { let plan = database . explain (sql) ; { println ! ("{:?}" , format...
  |                                                                                   ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpJC6b7n/main.rs:1:540
  |
1 | ..., where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; ; let patterns = find_patterns (query_log)...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpJC6b7n/main.rs:1:938
  |
1 | ...users_with_posts_naive () -> i32 { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = d...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpJC6b7n/main.rs:1:1020
  |
1 | ...M users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpJC6b7n/main.rs:1:1181
  |
1 | ...et_users_with_posts_optimized () -> i32 { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JO...
  |                                                       ^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpJC6b7n/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn analyze_query (sql : i32) { { { let plan = database . explain (sql) ; { println ! ("{:?}" , format...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpJC6b7n/main.rs:1:68
  |
1 | ... { { { let plan = database . explain (sql) ; { println ! ("{:?}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{:?}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; ; let patterns = find_patterns (query_log) ; ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn analyze_query (sql : i32) { { { let plan = database . explain (sql) ; { println ! ("{:?}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{:?}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; ; let patterns = find_patterns (query_log) ; ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; ; database . log_queries (true) ; let naive_time = perf :: measure ; ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {:.1}x faster" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn analyze_query (sql : i32) { { let plan = database . explain (sql) ; { println ! ("{:?}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{:?}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; ; let patterns = find_patterns (query_log) ; ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; ; database . log_queries (true) ; let naive_time = perf :: measure ; ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {:.1}x faster" , naive_time / optimized_time) ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpJC6b7n/main.rs:1:581
  |
1 | ...uery_log = database . get_recent_queries (100i32) ; ; let patterns = find_patterns (query_log) ; ; for pattern in patterns { { if patt...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpJC6b7n/main.rs:1:626
  |
1 | ...i32) ; ; let patterns = find_patterns (query_log) ; ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpJC6b7n/main.rs:1:431
  |
1 | ... (sql) ; { let where_clause = extract_where (sql) ; ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column)...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpJC6b7n/main.rs:1:654
  |
1 | ... { { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } ...
  |       ^^                                                                                                                                                                                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn analyze_query (sql : i32) { { { let plan = database . explain (sql) ; { println ! ("{:?}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{:?}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; ; let patterns = find_patterns (query_log) ; ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; ; database . log_queries (true) ; let naive_time = perf :: measure ; ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {:.1}x faster" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn analyze_query (sql : i32) { { { let plan = database . explain (sql) ; { println ! ("{:?}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{:?}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; ; let patterns = find_patterns (query_log) ; ; for pattern in patterns { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; ; database . log_queries (true) ; let naive_time = perf :: measure ; ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {:.1}x faster" , naive_time / optimized_time) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpJC6b7n/main.rs:1:922
  |
1 | ... { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } ...
  |       ^^                                                                                                                                                                                                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn analyze_query (sql : i32) { { { let plan = database . explain (sql) ; { println ! ("{:?}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{:?}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; ; let patterns = find_patterns (query_log) ; ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; ; database . log_queries (true) ; let naive_time = perf :: measure ; ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {:.1}x faster" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn analyze_query (sql : i32) { { { let plan = database . explain (sql) ; { println ! ("{:?}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{:?}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; ; let patterns = find_patterns (query_log) ; ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () -> i32 { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } fn get_users_with_posts_optimized () -> i32 { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; ; database . log_queries (true) ; let naive_time = perf :: measure ; ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {:.1}x faster" , naive_time / optimized_time) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpJC6b7n/main.rs:1:1003
  |
1 | ...r user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users }...
  |                      ^^                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn analyze_query (sql : i32) { { { let plan = database . explain (sql) ; { println ! ("{:?}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{:?}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; ; let patterns = find_patterns (query_log) ; ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; ; database . log_queries (true) ; let naive_time = perf :: measure ; ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {:.1}x faster" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn analyze_query (sql : i32) { { { let plan = database . explain (sql) ; { println ! ("{:?}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{:?}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; ; let patterns = find_patterns (query_log) ; ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query ("SELECT * FROM users") ; { for user in users { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; ; database . log_queries (true) ; let naive_time = perf :: measure ; ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {:.1}x faster" , naive_time / optimized_time) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpJC6b7n/main.rs:1:1172
  |
1 | ... { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } ...
  |       ^^                                                                                                                                                                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn analyze_query (sql : i32) { { { let plan = database . explain (sql) ; { println ! ("{:?}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{:?}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; ; let patterns = find_patterns (query_log) ; ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; ; database . log_queries (true) ; let naive_time = perf :: measure ; ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {:.1}x faster" , naive_time / optimized_time) ; }
1 + use std :: collections :: HashMap ; fn analyze_query (sql : i32) { { { let plan = database . explain (sql) ; { println ! ("{:?}" , format ! ("{}{}" , "Query: " , sql)) ; println ! ("{:?}" , format ! ("{}{}" , "Execution plan: " , plan)) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; ; let patterns = find_patterns (query_log) ; ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{:?}" , format ! ("{}{}" , "⚠\u{fe0f}  N+1 query pattern detected: " , pattern . example)) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; ; database . log_queries (true) ; let naive_time = perf :: measure ; ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {:.1}x faster" , naive_time / optimized_time) ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpJC6b7n/main.rs:1:1402
  |
1 | ...(& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect ("postgres://localhost/myapp" ....
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpJC6b7n/main.rs:1:1422
  |
1 | ... } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect ("postgres://localhost/myapp" . to_string ()) ; ; d...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpJC6b7n/main.rs:1:1501
  |
1 | ...ect ("postgres://localhost/myapp" . to_string ()) ; ; database . log_queries (true) ; let naive_time = perf :: measure ; ; { get_users...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpJC6b7n/main.rs:1:1570
  |
1 | ...queries (true) ; let naive_time = perf :: measure ; ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; ; { g...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpJC6b7n/main.rs:1:1647
  |
1 | ...naive () } ; let optimized_time = perf :: measure ; ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {:.1}x faster" ...
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `extract_table` in this scope
 --> /tmp/.tmpJC6b7n/main.rs:1:366
  |
1 | ...ected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; ; println ! ("Suggest...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `extract_where` in this scope
 --> /tmp/.tmpJC6b7n/main.rs:1:409
  |
1 | ...le = extract_table (sql) ; { let where_clause = extract_where (sql) ; ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , wher...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `find_patterns` in this scope
 --> /tmp/.tmpJC6b7n/main.rs:1:598
  |
1 | ... get_recent_queries (100i32) ; ; let patterns = find_patterns (query_log) ; ; for pattern in patterns { { if pattern . count > 10i32 &...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error: aborting due to 10 previous errors; 14 warnings emitted

Some errors have detailed explanations: E0425, E0432.
For more information about an error, try `rustc --explain E0425`.



=== ch10-00-performance-optimization example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch04-00-modules-tdd example 3 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found keyword `mod`
 --> /tmp/.tmp3xVrx6/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod module_name { { pub fn public_function () { () } ; fn private_function ...
  |                                                               ^^^ expected expression

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp3xVrx6/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod module_name { { pub fn public_function () { () } ; fn private_function ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch04-00-modules-tdd example 4 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpcBRALV/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpcBRALV/main.rs:1:50
  |
1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }
  |                                                  ^^                                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }
1 + use std :: collections :: HashMap ; fn main () { module_name :: public_function () }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `module_name`
 --> /tmp/.tmpcBRALV/main.rs:1:52
  |
1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }
  |                                                    ^^^^^^^^^^^ use of unresolved module or unlinked crate `module_name`
  |
  = help: you might be missing a crate named `module_name`

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0433`.



=== ch04-00-modules-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found keyword `mod`
 --> /tmp/.tmp5gD7vg/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod math { { pub fn add (a : i32 , b : i32) -> i32 { { a + b } } ; pub fn s...
  |                                                               ^^^ expected expression

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp5gD7vg/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod math { { pub fn add (a : i32 , b : i32) -> i32 { { a + b } } ; pub fn s...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch04-00-modules-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found keyword `mod`
 --> /tmp/.tmpAWIjck/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod strings { { pub fn greet () { { println ! ("Hello!") } } ; pub fn farew...
  |                                                               ^^^ expected expression

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpAWIjck/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = mod strings { { pub fn greet () { { println ! ("Hello!") } } ; pub fn farew...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted




=== ch09-00-collections-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `start` in this scope
 --> /tmp/.tmpqnR4Pm/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{:?}" , variable) } } ; if let...
  |                                                                               ^^^^^ not found in this scope

error[E0425]: cannot find value `end` in this scope
 --> /tmp/.tmpqnR4Pm/main.rs:1:88
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{:?}" , variable) } } ; if let...
  |                                                                                        ^^^ not found in this scope
  |
help: you might have meant to write `.` instead of `..`
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{:?}" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for variable in start.end { { println ! ("{:?}" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpqnR4Pm/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{:?}" , variable) } } ; if let...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpqnR4Pm/main.rs:1:94
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{:?}" , variable) } } ; if let...
  |                                                                                              ^^                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! ("{:?}" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { println ! ("{:?}" , variable) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error: aborting due to 2 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `initial_value` in this scope
 --> /tmp/.tmpSH1cNj/main.rs:1:72
  |
1 | use std :: collections :: HashMap ; fn main () { let mut accumulator = initial_value ; ; let mut counter = start ; ; while counter <= end...
  |                                                                        ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `start` in this scope
 --> /tmp/.tmpSH1cNj/main.rs:1:108
  |
1 | ...t accumulator = initial_value ; ; let mut counter = start ; ; while counter <= end { { accumulator = update (accumulator , counter) ; ...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `end` in this scope
 --> /tmp/.tmpSH1cNj/main.rs:1:135
  |
1 | ...lue ; ; let mut counter = start ; ; while counter <= end { { accumulator = update (accumulator , counter) ; counter = counter + 1i32 }...
  |                                                         ^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpSH1cNj/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let mut accumulator = initial_value ; ; let mut counter = start ; ; while counter <= end...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpSH1cNj/main.rs:1:88
  |
1 | use std :: collections :: HashMap ; fn main () { let mut accumulator = initial_value ; ; let mut counter = start ; ; while counter <= end...
  |                                                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpSH1cNj/main.rs:1:116
  |
1 | ...lator = initial_value ; ; let mut counter = start ; ; while counter <= end { { accumulator = update (accumulator , counter) ; counter ...
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `update` in this scope
 --> /tmp/.tmpSH1cNj/main.rs:1:157
  |
1 | ... = start ; ; while counter <= end { { accumulator = update (accumulator , counter) ; counter = counter + 1i32 } } ; }
  |                                                        ^^^^^^ not found in this scope

error: aborting due to 4 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `height` in this scope
 --> /tmp/.tmp6woHH9/main.rs:1:84
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (out...
  |                                                                                    ^^^^^^ not found in this scope

error[E0425]: cannot find value `width` in this scope
 --> /tmp/.tmp6woHH9/main.rs:1:116
  |
1 | ...or outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn s...
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp6woHH9/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (out...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp6woHH9/main.rs:1:93
  |
1 | ...ult = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as ...
  |                                        ^^                                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { for inner in 0i32 .. width { { process (outer , inner) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp6woHH9/main.rs:1:124
  |
1 | ...r in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: a...
  |                                                         ^^                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { process (outer , inner) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `process` in this scope
 --> /tmp/.tmp6woHH9/main.rs:1:126
  |
1 | ... 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :...
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 7 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpRriVJW/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! ("{:?}" ,...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpRriVJW/main.rs:1:88
  |
1 | ...t result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! ("{:?}" , result) } } } ; if let Some (s) = (& result as ...
  |                                        ^^                                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! ("{:?}" , result) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { let result = process (i) ; println ! ("{:?}" , result) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `process` in this scope
 --> /tmp/.tmpRriVJW/main.rs:1:105
  |
1 | ...result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! ("{:?}" , result) } } } ; if let Some (s) = (& result as & ...
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 9 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `height` in this scope
 --> /tmp/.tmpESTZqF/main.rs:1:82
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = ca...
  |                                                                                  ^^^^^^ not found in this scope

error[E0425]: cannot find value `width` in this scope
 --> /tmp/.tmpESTZqF/main.rs:1:112
  |
1 | ... = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let...
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpESTZqF/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = ca...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpESTZqF/main.rs:1:91
  |
1 | ... in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) ...
  |                         ^^                                                                                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpESTZqF/main.rs:1:120
  |
1 | ...eight { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result a...
  |                                         ^^                                                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { let value = calculate (row , col) ; display (value) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `calculate` in this scope
 --> /tmp/.tmpESTZqF/main.rs:1:136
  |
1 | ...ht { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as &...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `display` in this scope
 --> /tmp/.tmpESTZqF/main.rs:1:160
  |
1 | ..... width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any)...
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 4 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch09-00-collections-tdd example 10 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpOQ3Anj/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let mut count = 0i32 ; ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpOQ3Anj/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn main () { let mut count = 0i32 ; ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count ...
  |                                                                         ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpOQ3Anj/main.rs:1:101
  |
1 | ...ount = 0i32 ; ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } ; }
  |                                              ^^                                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let mut count = 0i32 ; ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } ; }
1 + use std :: collections :: HashMap ; fn main () { let mut count = 0i32 ; ; for i in 1i32 .. 100i32 { if condition (i) { { count = count + 1i32 } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpOQ3Anj/main.rs:1:122
  |
1 | ...i32 ; ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } ; }
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let mut count = 0i32 ; ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } ; }
1 + use std :: collections :: HashMap ; fn main () { let mut count = 0i32 ; ; for i in 1i32 .. 100i32 { { if condition (i) { count = count + 1i32 } } } ; }
  |

error[E0425]: cannot find function `condition` in this scope
 --> /tmp/.tmpOQ3Anj/main.rs:1:106
  |
1 | ...t count = 0i32 ; ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } ; }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 4 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch19-00-real-world-projects example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch19-00-real-world-projects example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch19-00-real-world-projects example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch19-00-real-world-projects example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== conclusion example 2 ===
✗ Compilation failed: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`
 --> /tmp/.tmpHEAnf1/main.rs:1:455
  |
1 | .... pop () ; } } input } ; ; let contents = fs :: read_to_string ("file.txt" . to_string ()) ; ; let add_one = | x | x + 1i32 ; ; }
  |                                              ^^ use of unresolved module or unlinked crate `fs`
  |
  = help: you might be missing a crate named `fs`
help: consider importing this module
  |
1 + use std::fs;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpHEAnf1/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let arr = vec ! [1i32 , 2i32 , 3i32] ; ; let name = { print ! ("{}" , "Enter name: ") ; ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpHEAnf1/main.rs:1:89
  |
1 | use std :: collections :: HashMap ; fn main () { let arr = vec ! [1i32 , 2i32 , 3i32] ; ; let name = { print ! ("{}" , "Enter name: ") ; ...
  |                                                                                         ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpHEAnf1/main.rs:1:438
  |
1 | .... ends_with ('\r') { input . pop () ; } } input } ; ; let contents = fs :: read_to_string ("file.txt" . to_string ()) ; ; let add_one ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpHEAnf1/main.rs:1:506
  |
1 | ... fs :: read_to_string ("file.txt" . to_string ()) ; ; let add_one = | x | x + 1i32 ; ; }
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpHEAnf1/main.rs:1:539
  |
1 | ... . to_string ()) ; ; let add_one = | x | x + 1i32 ; ; }
  |                                                        ^ help: remove this semicolon

error: aborting due to 1 previous error; 5 warnings emitted

For more information about this error, try `rustc --explain E0433`.



=== ch11-00-advanced-patterns example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 12 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 3 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `xFF` in this scope
 --> /tmp/.tmpLPUTu4/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...
  |                                                                                ^^^ not found in this scope

error[E0425]: cannot find value `o77` in this scope
 --> /tmp/.tmpLPUTu4/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...
  |                                                                                             ^^^ not found in this scope

error[E0425]: cannot find value `b1010` in this scope
 --> /tmp/.tmpLPUTu4/main.rs:1:106
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...
  |                                                                                                          ^^^^^ not found in this scope

error[E0425]: cannot find value `_000_000` in this scope
 --> /tmp/.tmpLPUTu4/main.rs:1:121
  |
1 | ... ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f64 ; 2f64 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; 3.14f64 ; f64 ; ...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `e6` in this scope
 --> /tmp/.tmpLPUTu4/main.rs:1:156
  |
1 | ...2 ; b1010 ; 1i32 ; _000_000 ; 3.14f64 ; 2f64 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; 3.14f64 ; f64 ; 100i32 } ; if let Some (s) = (& ...
  |                                                          ^^ not found in this scope

error[E0423]: expected value, found builtin type `f64`
 --> /tmp/.tmpLPUTu4/main.rs:1:198
  |
1 | ... ; 2f64 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; 3.14f64 ; f64 ; 100i32 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . ...
  |                                                               ^^^ not a value

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpLPUTu4/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 6 previous errors; 1 warning emitted

Some errors have detailed explanations: E0423, E0425.
For more information about an error, try `rustc --explain E0423`.



=== appendix-b-syntax-reference example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 6 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found `let` statement
 --> /tmp/.tmp5afIn1/main.rs:1:242
  |
1 | ... - 2147483648i64 ; ; let uint = 4294967295i64 ; ; let long = - ! let ulong = ! let size = - 1i32 ; ; ; ; let usize = 1i32 ; ; let sing...
  |                                                                     ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

error: expected expression, found `let` statement
 --> /tmp/.tmp5afIn1/main.rs:1:256
  |
1 | ...64 ; ; let uint = 4294967295i64 ; ; let long = - ! let ulong = ! let size = - 1i32 ; ; ; ; let usize = 1i32 ; ; let single = 3.14f64 ;...
  |                                                                     ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp5afIn1/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let flag = true ; ; let small = - 128i32 ; ; let byte = 255i32 ; ; let short = - 32768i3...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmp5afIn1/main.rs:1:68
  |
1 | use std :: collections :: HashMap ; fn main () { let flag = true ; ; let small = - 128i32 ; ; let byte = 255i32 ; ; let short = - 32768i3...
  |                                                                    ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmp5afIn1/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn main () { let flag = true ; ; let small = - 128i32 ; ; let byte = 255i32 ; ; let short = - 32768i3...
  |                                                                                             ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmp5afIn1/main.rs:1:115
  |
1 | ...ue ; ; let small = - 128i32 ; ; let byte = 255i32 ; ; let short = - 32768i32 ; ; let word = 65535i32 ; ; let int = - 2147483648i64 ; ;...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmp5afIn1/main.rs:1:142
  |
1 | ... ; ; let byte = 255i32 ; ; let short = - 32768i32 ; ; let word = 65535i32 ; ; let int = - 2147483648i64 ; ; let uint = 4294967295i64 ;...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmp5afIn1/main.rs:1:166
  |
1 | ... ; let short = - 32768i32 ; ; let word = 65535i32 ; ; let int = - 2147483648i64 ; ; let uint = 4294967295i64 ; ; let long = - ! let ul...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmp5afIn1/main.rs:1:196
  |
1 | ...let word = 65535i32 ; ; let int = - 2147483648i64 ; ; let uint = 4294967295i64 ; ; let long = - ! let ulong = ! let size = - 1i32 ; ; ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmp5afIn1/main.rs:1:225
  |
1 | ...nt = - 2147483648i64 ; ; let uint = 4294967295i64 ; ; let long = - ! let ulong = ! let size = - 1i32 ; ; ; ; let usize = 1i32 ; ; let ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolons
 --> /tmp/.tmp5afIn1/main.rs:1:276
  |
1 | ...let long = - ! let ulong = ! let size = - 1i32 ; ; ; ; let usize = 1i32 ; ; let single = 3.14f64 ; ; let double = 2.718281828f64 ; ; l...
  |                                                     ^^^^^ help: remove these semicolons

warning: unnecessary trailing semicolon
 --> /tmp/.tmp5afIn1/main.rs:1:301
  |
1 | ...ng = ! let size = - 1i32 ; ; ; ; let usize = 1i32 ; ; let single = 3.14f64 ; ; let double = 2.718281828f64 ; ; let ch = 'A' ; ; let te...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmp5afIn1/main.rs:1:326
  |
1 | ...; ; ; ; let usize = 1i32 ; ; let single = 3.14f64 ; ; let double = 2.718281828f64 ; ; let ch = 'A' ; ; let text = "hello" . to_string ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmp5afIn1/main.rs:1:358
  |
1 | ... single = 3.14f64 ; ; let double = 2.718281828f64 ; ; let ch = 'A' ; ; let text = "hello" . to_string () ; ; let owned = "world" . to_...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmp5afIn1/main.rs:1:375
  |
1 | ... ; ; let double = 2.718281828f64 ; ; let ch = 'A' ; ; let text = "hello" . to_string () ; ; let owned = "world" . to_string () ; ; }
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmp5afIn1/main.rs:1:413
  |
1 | ...et ch = 'A' ; ; let text = "hello" . to_string () ; ; let owned = "world" . to_string () ; ; }
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmp5afIn1/main.rs:1:452
  |
1 | ..._string () ; ; let owned = "world" . to_string () ; ; }
  |                                                        ^ help: remove this semicolon

error: aborting due to 2 previous errors; 15 warnings emitted




=== appendix-b-syntax-reference example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 8 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpimwimB/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let x = 42i32 ; ; let name = "Alice" . to_string () ; ; let count = 100i32 ; ; let score...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpimwimB/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let x = 42i32 ; ; let name = "Alice" . to_string () ; ; let count = 100i32 ; ; let score...
  |                                                                  ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpimwimB/main.rs:1:104
  |
1 | use std :: collections :: HashMap ; fn main () { let x = 42i32 ; ; let name = "Alice" . to_string () ; ; let count = 100i32 ; ; let score...
  |                                                                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpimwimB/main.rs:1:127
  |
1 | ...e = "Alice" . to_string () ; ; let count = 100i32 ; ; let score = 95.5f64 ; ; let mut counter = 0i32 ; ; counter += 1i32 ; let (x , y)...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpimwimB/main.rs:1:151
  |
1 | ...() ; ; let count = 100i32 ; ; let score = 95.5f64 ; ; let mut counter = 0i32 ; ; counter += 1i32 ; let (x , y) = (10i32 , 20i32) ; let...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpimwimB/main.rs:1:178
  |
1 | ... ; let score = 95.5f64 ; ; let mut counter = 0i32 ; ; counter += 1i32 ; let (x , y) = (10i32 , 20i32) ; let [first , second , ..] = ve...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpimwimB/main.rs:1:317
  |
1 | ...1i32 , 2i32 , 3i32 , 4i32 , 5i32] ; let x = 42i32 ; ; let x = "now a string" . to_string () ; ; }
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpimwimB/main.rs:1:359
  |
1 | ...= 42i32 ; ; let x = "now a string" . to_string () ; ; }
  |                                                        ^ help: remove this semicolon

error[E0529]: expected an array or slice, found `Vec<i32>`
 --> /tmp/.tmpimwimB/main.rs:1:234
  |
1 | ...(x , y) = (10i32 , 20i32) ; let [first , second , ..] = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32] ; let x = 42i32 ; ; let x = "now a st...
  |                                    ^^^^^^^^^^^^^^^^^^^^^ pattern cannot match with input type `Vec<i32>`
  |
help: consider slicing here
  |
1 | use std :: collections :: HashMap ; fn main () { let x = 42i32 ; ; let name = "Alice" . to_string () ; ; let count = 100i32 ; ; let score = 95.5f64 ; ; let mut counter = 0i32 ; ; counter += 1i32 ; let (x , y) = (10i32 , 20i32) ; let [first , second , ..] = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32][..] ; let x = 42i32 ; ; let x = "now a string" . to_string () ; ; }
  |                                                                                                                                                                                                                                                                                                          ++++

error: aborting due to 1 previous error; 8 warnings emitted

For more information about this error, try `rustc --explain E0529`.



=== appendix-b-syntax-reference example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 11 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `value` in this scope
 --> /tmp/.tmpobuznz/main.rs:1:71
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { match value { 0i32 => "zero" , 1i32 | 2i32 => "one or two" , 3i32 ..= 10i...
  |                                                                       ^^^^^ not found in this scope

error[E0425]: cannot find value `point` in this scope
 --> /tmp/.tmpobuznz/main.rs:1:234
  |
1 | ...=> "big number" , _ => "something else" , } ; match point { Point { x : 0i32 , y : 0i32 } => "origin" , Point { x , y : 0i32 } => form...
  |                                                        ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmpobuznz/main.rs:1:242
  |
1 | ...number" , _ => "something else" , } ; match point { Point { x : 0i32 , y : 0i32 } => "origin" , Point { x , y : 0i32 } => format ! ("{...
  |                                                        ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmpobuznz/main.rs:1:286
  |
1 | ...point { Point { x : 0i32 , y : 0i32 } => "origin" , Point { x , y : 0i32 } => format ! ("{}{}" , format ! ("{}{}" , "on x-axis at " , ...
  |                                                        ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmpobuznz/main.rs:1:390
  |
1 | ...! ("{}{}" , "on x-axis at " , x . to_s ()) , ",") , Point { x : 0i32 , y } => format ! ("{}{}" , format ! ("{}{}" , "on y-axis at " , ...
  |                                                        ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmpobuznz/main.rs:1:494
  |
1 | ...! ("{}{}" , "on y-axis at " , y . to_s ()) , ",") , Point { x , y } => format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `number` in this scope
 --> /tmp/.tmpobuznz/main.rs:1:659
  |
1 | ... to_s ()) , ", ") , y . to_s ()) , ")") , } ; match number { n if n < 0i32 => "negative" , n if n > 0i32 => "positive" , _ => "zero" ,...
  |                                                        ^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpobuznz/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { match value { 0i32 => "zero" , 1i32 | 2i32 => "one or two" , 3i32 ..= 10i...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0308]: `match` arms have incompatible types
 --> /tmp/.tmpobuznz/main.rs:1:312
  |
1 | ... ; match point { Point { x : 0i32 , y : 0i32 } => "origin" , Point { x , y : 0i32 } => format ! ("{}{}" , format ! ("{}{}" , "on x-axis at " , x . to_s ()) , ",") , ...
  |       -----------                                    --------                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `String`
  |       |                                              |
  |       |                                              this is found to be of type `&str`
  |       `match` arms have incompatible types
  |
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 8 previous errors; 1 warning emitted

Some errors have detailed explanations: E0308, E0422, E0425.
For more information about an error, try `rustc --explain E0308`.



=== appendix-b-syntax-reference example 12 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 14 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 15 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `r#move` in this scope
 --> /tmp/.tmpoP6Qia/main.rs:1:295
  |
1 | ... :: from ("Alice" . to_string ()) ; ; let greeter = r#move | greeting | { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , gre...
  |                                                        ^^^^^^ not found in this scope

error[E0425]: cannot find value `greeting` in this scope
 --> /tmp/.tmpoP6Qia/main.rs:1:304
  |
1 | ..."Alice" . to_string ()) ; ; let greeter = r#move | greeting | { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , greeting , ",...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `greeting` in this scope
 --> /tmp/.tmpoP6Qia/main.rs:1:374
  |
1 | ... ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , greeting , ", ") , name) , "!") } ; ; }
  |                                                       ^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpoP6Qia/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let add = | a , b | a + b ; ; let result = add (5i32 , 3i32) ; ; let multiply = | a , b ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpoP6Qia/main.rs:1:78
  |
1 | use std :: collections :: HashMap ; fn main () { let add = | a , b | a + b ; ; let result = add (5i32 , 3i32) ; ; let multiply = | a , b ...
  |                                                                              ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpoP6Qia/main.rs:1:113
  |
1 | ... a , b | a + b ; ; let result = add (5i32 , 3i32) ; ; let multiply = | a , b | a * b ; ; let x = 10i32 ; ; let add_x = | y | x + y ; ;...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpoP6Qia/main.rs:1:148
  |
1 | ... (5i32 , 3i32) ; ; let multiply = | a , b | a * b ; ; let x = 10i32 ; ; let add_x = | y | x + y ; ; let result = add_x (5i32) ; ; let ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpoP6Qia/main.rs:1:166
  |
1 | ... let multiply = | a , b | a * b ; ; let x = 10i32 ; ; let add_x = | y | x + y ; ; let result = add_x (5i32) ; ; let name = String :: f...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpoP6Qia/main.rs:1:194
  |
1 | ...* b ; ; let x = 10i32 ; ; let add_x = | y | x + y ; ; let result = add_x (5i32) ; ; let name = String :: from ("Alice" . to_string ())...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpoP6Qia/main.rs:1:224
  |
1 | ...add_x = | y | x + y ; ; let result = add_x (5i32) ; ; let name = String :: from ("Alice" . to_string ()) ; ; let greeter = r#move | gr...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpoP6Qia/main.rs:1:279
  |
1 | ...et name = String :: from ("Alice" . to_string ()) ; ; let greeter = r#move | greeting | { format ! ("{}{}" , format ! ("{}{}" , format...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpoP6Qia/main.rs:1:410
  |
1 | ...mat ! ("{}{}" , greeting , ", ") , name) , "!") } ; ; }
  |                                                        ^ help: remove this semicolon

error: aborting due to 3 previous errors; 9 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== appendix-b-syntax-reference example 16 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 17 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 18 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 19 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 20 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 21 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 22 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 23 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 24 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 25 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 26 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 27 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 28 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 29 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 30 ===
✗ Compilation failed: Failed to transpile to Rust


=== appendix-b-syntax-reference example 31 ===
✗ Compilation failed: Failed to transpile to Rust


=== appendix-b-syntax-reference example 32 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 33 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 34 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 35 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-input-output-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `variable` in this scope
 --> /tmp/.tmpx2zywi/main.rs:1:99
  |
1 | use std :: collections :: HashMap ; fn main () { println ! ("text message") ; println ! ("{:?}" , variable) ; println ! ("{:?}" , 42i32) ...
  |                                                                                                   ^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpx2zywi/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { println ! ("text message") ; println ! ("{:?}" , variable) ; println ! ("{:?}" , 42i32) ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch10-00-input-output-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `value` in this scope
 --> /tmp/.tmph0U6AB/main.rs:1:61
  |
1 | use std :: collections :: HashMap ; fn main () { let data = value ; ; println ! ("Label:") ; println ! ("{:?}" , data) ; }
  |                                                             ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmph0U6AB/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let data = value ; ; println ! ("Label:") ; println ! ("{:?}" , data) ; }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmph0U6AB/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let data = value ; ; println ! ("Label:") ; println ! ("{:?}" , data) ; }
  |                                                                     ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch10-00-input-output-tdd example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch18-00-deployment-devops example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch18-00-deployment-devops example 2 ===
✗ Compilation failed: Compilation failed:
error: argument never used
 --> /tmp/.tmpEwdJma/main.rs:1:651
  |
1 | ... ; blue . destroy () ; println ! ("✅ Deployed version {}" , "{:?}" , new_version) } } } } fn main () { }
  |                                      ------------------------            ^^^^^^^^^^^ argument never used
  |                                      |
  |                                      formatting specifier missing

error[E0425]: cannot find function `sleep` in this scope
 --> /tmp/.tmpEwdJma/main.rs:1:404
  |
1 | ...healthy") } } ; LoadBalancer :: switch_to (green) ; sleep (Duration :: from_mins (5i32)) ; if green . error_rate () > 0.01f64 { { Load...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::sleep;
  |

error[E0433]: failed to resolve: use of undeclared type `Duration`
 --> /tmp/.tmpEwdJma/main.rs:1:411
  |
1 | ... ; LoadBalancer :: switch_to (green) ; sleep (Duration :: from_mins (5i32)) ; if green . error_rate () > 0.01f64 { { LoadBalancer :: s...
  |                                                  ^^^^^^^^ use of undeclared type `Duration`
  |
help: consider importing this struct
  |
1 + use std::time::Duration;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpEwdJma/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn deploy_blue_green (new_version : String) -> i32 { { { let blue = Environment :: current () ; { let...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpEwdJma/main.rs:1:90
  |
1 | ... { { { let blue = Environment :: current () ; { let green = Environment :: provision (new_version) ; ; green . deploy () ; green . run_health_checks () ; green . run_smoke_tests () ; if ! green . is_healthy () { { green . destroy () ; panic ! ("Green environment unhealthy") } } ; LoadBalancer :: switch_to (green) ; sleep (Duration :: from_mins (5i32)) ; if green . error_rate () > 0.01f64 { { LoadBalancer :: switch_to (blue) ; green . destroy () ; panic ! ("High error rate, rolled back") } } ; blue . destroy () ; println ! ("✅ Deployed version {}" , "{:?}" , new_version) } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn deploy_blue_green (new_version : String) -> i32 { { { let blue = Environment :: current () ; { let green = Environment :: provision (new_version) ; ; green . deploy () ; green . run_health_checks () ; green . run_smoke_tests () ; if ! green . is_healthy () { { green . destroy () ; panic ! ("Green environment unhealthy") } } ; LoadBalancer :: switch_to (green) ; sleep (Duration :: from_mins (5i32)) ; if green . error_rate () > 0.01f64 { { LoadBalancer :: switch_to (blue) ; green . destroy () ; panic ! ("High error rate, rolled back") } } ; blue . destroy () ; println ! ("✅ Deployed version {}" , "{:?}" , new_version) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn deploy_blue_green (new_version : String) -> i32 { { let blue = Environment :: current () ; { let green = Environment :: provision (new_version) ; ; green . deploy () ; green . run_health_checks () ; green . run_smoke_tests () ; if ! green . is_healthy () { { green . destroy () ; panic ! ("Green environment unhealthy") } } ; LoadBalancer :: switch_to (green) ; sleep (Duration :: from_mins (5i32)) ; if green . error_rate () > 0.01f64 { { LoadBalancer :: switch_to (blue) ; green . destroy () ; panic ! ("High error rate, rolled back") } } ; blue . destroy () ; println ! ("✅ Deployed version {}" , "{:?}" , new_version) } } } fn main () { }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpEwdJma/main.rs:1:188
  |
1 | ...et green = Environment :: provision (new_version) ; ; green . deploy () ; green . run_health_checks () ; green . run_smoke_tests () ; ...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error[E0433]: failed to resolve: use of undeclared type `Environment`
 --> /tmp/.tmpEwdJma/main.rs:1:105
  |
1 | ..._version : String) -> i32 { { { let blue = Environment :: current () ; { let green = Environment :: provision (new_version) ; ; green ...
  |                                               ^^^^^^^^^^^ use of undeclared type `Environment`

error[E0433]: failed to resolve: use of undeclared type `Environment`
 --> /tmp/.tmpEwdJma/main.rs:1:147
  |
1 | ... Environment :: current () ; { let green = Environment :: provision (new_version) ; ; green . deploy () ; green . run_health_checks ()...
  |                                               ^^^^^^^^^^^ use of undeclared type `Environment`

error[E0433]: failed to resolve: use of undeclared type `LoadBalancer`
 --> /tmp/.tmpEwdJma/main.rs:1:368
  |
1 | ...c ! ("Green environment unhealthy") } } ; LoadBalancer :: switch_to (green) ; sleep (Duration :: from_mins (5i32)) ; if green . error_...
  |                                              ^^^^^^^^^^^^ use of undeclared type `LoadBalancer`

error[E0433]: failed to resolve: use of undeclared type `LoadBalancer`
 --> /tmp/.tmpEwdJma/main.rs:1:482
  |
1 | ... ; if green . error_rate () > 0.01f64 { { LoadBalancer :: switch_to (blue) ; green . destroy () ; panic ! ("High error rate, rolled ba...
  |                                              ^^^^^^^^^^^^ use of undeclared type `LoadBalancer`

error[E0308]: mismatched types
 --> /tmp/.tmpEwdJma/main.rs:1:605
  |
1 | ...} ; blue . destroy () ; println ! ("✅ Deployed version {}" , "{:?}" , new_version) } } } } fn main () { }
  |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 8 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0308, E0425, E0433.
For more information about an error, try `rustc --explain E0308`.



=== ch18-00-deployment-devops example 3 ===
✗ Compilation failed: Compilation failed:
error: argument never used
 --> /tmp/.tmpt1BZOw/main.rs:1:789
  |
1 | ... by >20%") } } ; println ! ("✅ Canary at {}% - metrics healthy" , "{:?}" , percentage) } } } } ; deployment . finalize () } } } } fn ma...
  |                                ------------------------------------            ^^^^^^^^^^ argument never used
  |                                |
  |                                formatting specifier missing

error[E0425]: cannot find function `sleep` in this scope
 --> /tmp/.tmpt1BZOw/main.rs:1:380
  |
1 | ... deployment . set_traffic_percentage (percentage) ; sleep (Duration :: from_mins (10i32)) ; { let current = Metrics :: current () ; { ...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::sleep;
  |

error[E0433]: failed to resolve: use of undeclared type `Duration`
 --> /tmp/.tmpt1BZOw/main.rs:1:387
  |
1 | ... set_traffic_percentage (percentage) ; sleep (Duration :: from_mins (10i32)) ; { let current = Metrics :: current () ; { if current . ...
  |                                                  ^^^^^^^^ use of undeclared type `Duration`
  |
help: consider importing this struct
  |
1 + use std::time::Duration;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpt1BZOw/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn deploy_canary (new_version : String) -> i32 { { { let deployment = CanaryDeployment :: new (new_ve...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpt1BZOw/main.rs:1:86
  |
1 | ... { { { let deployment = CanaryDeployment :: new (new_version) ; { deployment . set_traffic_percentage (5i32) ; deployment . deploy () ; let baseline = Metrics :: baseline () ; ; for percentage in vec ! [5i32 , 10i32 , 25i32 , 50i32 , 100i32] { { deployment . set_traffic_percentage (percentage) ; sleep (Duration :: from_mins (10i32)) ; { let current = Metrics :: current () ; { if current . error_rate > baseline . error_rate * 1.1f64 { { deployment . rollback () ; panic ! ("Error rate increased by >10%") } } ; if current . p99_latency > baseline . p99_latency * 1.2f64 { { deployment . rollback () ; panic ! ("Latency increased by >20%") } } ; println ! ("✅ Canary at {}% - metrics healthy" , "{:?}" , percentage) } } } } ; deployment . finalize () } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn deploy_canary (new_version : String) -> i32 { { { let deployment = CanaryDeployment :: new (new_version) ; { deployment . set_traffic_percentage (5i32) ; deployment . deploy () ; let baseline = Metrics :: baseline () ; ; for percentage in vec ! [5i32 , 10i32 , 25i32 , 50i32 , 100i32] { { deployment . set_traffic_percentage (percentage) ; sleep (Duration :: from_mins (10i32)) ; { let current = Metrics :: current () ; { if current . error_rate > baseline . error_rate * 1.1f64 { { deployment . rollback () ; panic ! ("Error rate increased by >10%") } } ; if current . p99_latency > baseline . p99_latency * 1.2f64 { { deployment . rollback () ; panic ! ("Latency increased by >20%") } } ; println ! ("✅ Canary at {}% - metrics healthy" , "{:?}" , percentage) } } } } ; deployment . finalize () } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn deploy_canary (new_version : String) -> i32 { { let deployment = CanaryDeployment :: new (new_version) ; { deployment . set_traffic_percentage (5i32) ; deployment . deploy () ; let baseline = Metrics :: baseline () ; ; for percentage in vec ! [5i32 , 10i32 , 25i32 , 50i32 , 100i32] { { deployment . set_traffic_percentage (percentage) ; sleep (Duration :: from_mins (10i32)) ; { let current = Metrics :: current () ; { if current . error_rate > baseline . error_rate * 1.1f64 { { deployment . rollback () ; panic ! ("Error rate increased by >10%") } } ; if current . p99_latency > baseline . p99_latency * 1.2f64 { { deployment . rollback () ; panic ! ("Latency increased by >20%") } } ; println ! ("✅ Canary at {}% - metrics healthy" , "{:?}" , percentage) } } } } ; deployment . finalize () } } } fn main () { }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpt1BZOw/main.rs:1:259
  |
1 | ...deploy () ; let baseline = Metrics :: baseline () ; ; for percentage in vec ! [5i32 , 10i32 , 25i32 , 50i32 , 100i32] { { deployment ....
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error[E0433]: failed to resolve: use of undeclared type `CanaryDeployment`
 --> /tmp/.tmpt1BZOw/main.rs:1:107
  |
1 | ...String) -> i32 { { { let deployment = CanaryDeployment :: new (new_version) ; { deployment . set_traffic_percentage (5i32) ; deploymen...
  |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `CanaryDeployment`

error[E0433]: failed to resolve: use of undeclared type `Metrics`
 --> /tmp/.tmpt1BZOw/main.rs:1:234
  |
1 | ...i32) ; deployment . deploy () ; let baseline = Metrics :: baseline () ; ; for percentage in vec ! [5i32 , 10i32 , 25i32 , 50i32 , 100i...
  |                                                   ^^^^^^^ use of undeclared type `Metrics`

error[E0433]: failed to resolve: use of undeclared type `Metrics`
 --> /tmp/.tmpt1BZOw/main.rs:1:436
  |
1 | ...ration :: from_mins (10i32)) ; { let current = Metrics :: current () ; { if current . error_rate > baseline . error_rate * 1.1f64 { { ...
  |                                                   ^^^^^^^ use of undeclared type `Metrics`

error: aborting due to 6 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0425, E0433.
For more information about an error, try `rustc --explain E0425`.



=== ch18-00-deployment-devops example 4 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch18-00-deployment-devops example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch18-00-deployment-devops example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch18-00-deployment-devops example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch18-00-deployment-devops example 8 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch01-03-interpreter-scripting example 1 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `ruchy` in this scope
 --> /tmp/.tmp2JT9jI/main.rs:1:65
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "2 + 2" } ; if let Some (s) = (& result as & dyn std :: any :...
  |                                                                 ^^^^^ not found in this scope

error[E0425]: cannot find value `e` in this scope
 --> /tmp/.tmp2JT9jI/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "2 + 2" } ; if let Some (s) = (& result as & dyn std :: any :...
  |                                                                         ^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp2JT9jI/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "2 + 2" } ; if let Some (s) = (& result as & dyn std :: any :...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 2 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `ruchy` in this scope
 --> /tmp/.tmpXSsQ6m/main.rs:1:65
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let name = \"World\"; \"Hello \" + name + \"!\"" } ; if let ...
  |                                                                 ^^^^^ not found in this scope

error[E0425]: cannot find value `e` in this scope
 --> /tmp/.tmpXSsQ6m/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let name = \"World\"; \"Hello \" + name + \"!\"" } ; if let ...
  |                                                                         ^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpXSsQ6m/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let name = \"World\"; \"Hello \" + name + \"!\"" } ; if let ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 3 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `ruchy` in this scope
 --> /tmp/.tmpj1GHwS/main.rs:1:65
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let nums = [1, 2, 3]; nums[1]" } ; if let Some (s) = (& resu...
  |                                                                 ^^^^^ not found in this scope

error[E0425]: cannot find value `e` in this scope
 --> /tmp/.tmpj1GHwS/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let nums = [1, 2, 3]; nums[1]" } ; if let Some (s) = (& resu...
  |                                                                         ^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpj1GHwS/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; "let nums = [1, 2, 3]; nums[1]" } ; if let Some (s) = (& resu...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 7 ===
✗ Compilation failed: Compilation failed:
error[E0434]: can't capture dynamic environment in a fn item
 --> /tmp/.tmpK80ZK7/main.rs:1:259
  |
1 | ... () { { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ...
  |                                                                  ^^^^^^^^^
  |
  = help: use the `|| { ... }` closure form instead

error[E0425]: cannot find value `global_var` in this scope
 --> /tmp/.tmpK80ZK7/main.rs:1:141
  |
1 | ...ng () ; { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; fn nested () { { println ! ("{:?}" , global_var) ; printl...
  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `local_var`

error[E0425]: cannot find value `global_var` in this scope
 --> /tmp/.tmpK80ZK7/main.rs:1:225
  |
1 | ...ed () { { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ...
  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `local_var`

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpK80ZK7/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { { let local_var = "I'm local" . to_string () ; { println ! ("{:?}"...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpK80ZK7/main.rs:1:70
  |
1 | ... { { { let local_var = "I'm local" . to_string () ; { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; fn nested () { { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ("{:?}" , nested_var) } } } ; nested () } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { { let local_var = "I'm local" . to_string () ; { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; fn nested () { { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ("{:?}" , nested_var) } } } ; nested () } } } } fn main () { let global_var = "I'm global" . to_string () ; ; { demonstrate_scope () } }
1 + use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { let local_var = "I'm local" . to_string () ; { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; fn nested () { { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ("{:?}" , nested_var) } } } ; nested () } } } fn main () { let global_var = "I'm global" . to_string () ; ; { demonstrate_scope () } }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpK80ZK7/main.rs:1:359
  |
1 | ...o_string () ; println ! ("{:?}" , nested_var) } } } ; nested () } } } } fn main () { let global_var = "I'm global" . to_string () ; ; ...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpK80ZK7/main.rs:1:439
  |
1 | ...() { let global_var = "I'm global" . to_string () ; ; { demonstrate_scope () } }
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpK80ZK7/main.rs:1:441
  |
1 | ... () { let global_var = "I'm global" . to_string () ; ; { demonstrate_scope () } }
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { { let local_var = "I'm local" . to_string () ; { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; fn nested () { { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ("{:?}" , nested_var) } } } ; nested () } } } } fn main () { let global_var = "I'm global" . to_string () ; ; { demonstrate_scope () } }
1 + use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { { let local_var = "I'm local" . to_string () ; { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; fn nested () { { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ("{:?}" , nested_var) } } } ; nested () } } } } fn main () { let global_var = "I'm global" . to_string () ; ; demonstrate_scope () }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpK80ZK7/main.rs:1:361
  |
1 | ...-> i32 { { { let local_var = "I'm local" . to_string () ; { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; fn nested () { { println ! ("{:?}" , global_var) ; println ! ("{:?}" , local_var) ; { let nested_var = "I'm nested" . to_string () ; println ! ("{:?}" , nested_var) } } } ; nested () } ...
  |       --- expected `i32` because of return type                                                                                                                                                                                                                                                                ^^^^^^^^^ expected `i32`, found `()`

error[E0308]: mismatched types
 --> /tmp/.tmpK80ZK7/main.rs:1:443
  |
1 | ... main () { let global_var = "I'm global" . to_string () ; ; { demonstrate_scope () } }
  |            -                                                     ^^^^^^^^^^^^^^^^^^^^- help: consider using a semicolon here: `;`
  |            |                                                     |
  |            expected `()` because of default return type          expected `()`, found `i32`

error: aborting due to 5 previous errors; 5 warnings emitted

Some errors have detailed explanations: E0308, E0425, E0434.
For more information about an error, try `rustc --explain E0308`.



=== ch01-03-interpreter-scripting example 8 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpPJ0ek7/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpPJ0ek7/main.rs:1:50
  |
1 | ... { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } } }
  |       ^^                                                                                                                                                                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } } }
1 + use std :: collections :: HashMap ; fn main () { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpPJ0ek7/main.rs:1:118
  |
1 | ...32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds")...
  |                                                 ^^                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { println ! ("{:?}" , arr [5i32 as usize]) } else { { println ! ("Index out of bounds") } } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpPJ0ek7/main.rs:1:172
  |
1 | ...tln ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } } }
  |                                                    ^^                                 ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" , arr [5i32 as usize]) } } else { println ! ("Index out of bounds") } } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpPJ0ek7/main.rs:1:103
  |
1 | ...let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("In...
  |                                              ----   ^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                              |
  |                                              expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len ().try_into().unwrap() { { println ! ("{:?}" , arr [5i32 as usize]) } } else { { println ! ("Index out of bounds") } } } } }
  |                                                                                                                   ++++++++++++++++++++

error: aborting due to 1 previous error; 4 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch01-03-interpreter-scripting example 12 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `items` in this scope
 --> /tmp/.tmpfI91t5/main.rs:1:112
  |
1 | ...ount = 42i32 ; ; let total_price = calculate_price (items) ; ; let x = 42i32 ; ; let y = calc (z) ; ; }
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `z` in this scope
 --> /tmp/.tmpfI91t5/main.rs:1:155
  |
1 | ...s) ; ; let x = 42i32 ; ; let y = calc (z) ; ; }
  |                                           ^ help: a local variable with a similar name exists: `x`

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpfI91t5/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let user_count = 42i32 ; ; let total_price = calculate_price (items) ; ; let x = 42i32 ;...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpfI91t5/main.rs:1:75
  |
1 | use std :: collections :: HashMap ; fn main () { let user_count = 42i32 ; ; let total_price = calculate_price (items) ; ; let x = 42i32 ;...
  |                                                                           ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpfI91t5/main.rs:1:121
  |
1 | ...i32 ; ; let total_price = calculate_price (items) ; ; let x = 42i32 ; ; let y = calc (z) ; ; }
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpfI91t5/main.rs:1:139
  |
1 | ...price = calculate_price (items) ; ; let x = 42i32 ; ; let y = calc (z) ; ; }
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpfI91t5/main.rs:1:160
  |
1 | ...ce (items) ; ; let x = 42i32 ; ; let y = calc (z) ; ; }
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `calculate_price` in this scope
 --> /tmp/.tmpfI91t5/main.rs:1:95
  |
1 | use std :: collections :: HashMap ; fn main () { let user_count = 42i32 ; ; let total_price = calculate_price (items) ; ; let x = 42i32 ;...
  |                                                                                               ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `calc` in this scope
 --> /tmp/.tmpfI91t5/main.rs:1:149
  |
1 | ...alculate_price (items) ; ; let x = 42i32 ; ; let y = calc (z) ; ; }
  |                                                         ^^^^ not found in this scope

error: aborting due to 4 previous errors; 5 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch17-00-documentation example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 9 ===
✗ Compilation failed: Compilation failed:
error[E0670]: `async fn` is not permitted in Rust 2015
 --> /tmp/.tmpwdTGUI/main.rs:1:37
  |
1 | use std :: collections :: HashMap ; async fn request_flow () -> i32 { { client . send_request () ; server . validate () ; server . proces...
  |                                     ^^^^^ to use `async fn`, switch to Rust 2018 or later
  |
  = help: pass `--edition 2024` to `rustc`
  = note: for more on editions, read https://doc.rust-lang.org/edition-guide

error[E0425]: cannot find value `client` in this scope
 --> /tmp/.tmpwdTGUI/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; async fn request_flow () -> i32 { { client . send_request () ; server . validate () ; server . proces...
  |                                                                         ^^^^^^ not found in this scope

error[E0425]: cannot find value `server` in this scope
 --> /tmp/.tmpwdTGUI/main.rs:1:100
  |
1 | use std :: collections :: HashMap ; async fn request_flow () -> i32 { { client . send_request () ; server . validate () ; server . proces...
  |                                                                                                    ^^^^^^ not found in this scope

error[E0425]: cannot find value `server` in this scope
 --> /tmp/.tmpwdTGUI/main.rs:1:123
  |
1 | ...{ client . send_request () ; server . validate () ; server . process () ; server . respond () } } fn main () { impl ConfigBuilder { } ; }
  |                                                        ^^^^^^ not found in this scope

error[E0425]: cannot find value `server` in this scope
 --> /tmp/.tmpwdTGUI/main.rs:1:145
  |
1 | ...t () ; server . validate () ; server . process () ; server . respond () } } fn main () { impl ConfigBuilder { } ; }
  |                                                        ^^^^^^ not found in this scope

error[E0412]: cannot find type `ConfigBuilder` in this scope
 --> /tmp/.tmpwdTGUI/main.rs:1:187
  |
1 | ... () ; server . respond () } } fn main () { impl ConfigBuilder { } ; }
  |                                                    ^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpwdTGUI/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; async fn request_flow () -> i32 { { client . send_request () ; server . validate () ; server . proces...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpwdTGUI/main.rs:1:205
  |
1 | ... respond () } } fn main () { impl ConfigBuilder { } ; }
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error: aborting due to 6 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0412, E0425, E0670.
For more information about an error, try `rustc --explain E0412`.



=== ch17-00-documentation example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch06-00-file-operations example 1 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `create_dir` in this scope
 --> /tmp/.tmp7wC9Zx/main.rs:1:1290
  |
1 | ... , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{:?}" , format ! ("{}{}" , "Created folder: " ...
  |                                                      ^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::create_dir;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp7wC9Zx/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { println ! ("=== Desktop Organizer ===") ; let file_categories = { let mut map : std :: c...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmp7wC9Zx/main.rs:1:762
  |
1 | ...son" , ".xml" , ".xlsx"]) . to_string ()) ; map } ; ; let source_dir = "~/Desktop" . to_string () ; ; let files = list_files (source_d...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmp7wC9Zx/main.rs:1:810
  |
1 | ...} ; ; let source_dir = "~/Desktop" . to_string () ; ; let files = list_files (source_dir) ; ; println ! ("{:?}" , format ! ("{}{}" , f...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmp7wC9Zx/main.rs:1:850
  |
1 | ...string () ; ; let files = list_files (source_dir) ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmp7wC9Zx/main.rs:1:994
  |
1 | ... { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{:?}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let source = join_path (source_dir , file) ; ; let destination = join_path (target_dir , file) ; ; move_file (source , destination) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") , category) , "/")) ; break } } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { println ! ("=== Desktop Organizer ===") ; let file_categories = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("Documents" . to_string () , (vec ! [".pdf" , ".doc" , ".docx" , ".txt"]) . to_string ()) ; map . insert ("Images" . to_string () , (vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"]) . to_string ()) ; map . insert ("Videos" . to_string () , (vec ! [".mp4" , ".avi" , ".mov" , ".mkv"]) . to_string ()) ; map . insert ("Code" . to_string () , (vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"]) . to_string ()) ; map . insert ("Data" . to_string () , (vec ! [".csv" , ".json" , ".xml" , ".xlsx"]) . to_string ()) ; map } ; ; let source_dir = "~/Desktop" . to_string () ; ; let files = list_files (source_dir) ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{:?}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let source = join_path (source_dir , file) ; ; let destination = join_path (target_dir , file) ; ; move_file (source , destination) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") , category) , "/")) ; break } } } } } } } } } ; println ! ("✅ Desktop organized!") ; }
1 + use std :: collections :: HashMap ; fn main () { println ! ("=== Desktop Organizer ===") ; let file_categories = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("Documents" . to_string () , (vec ! [".pdf" , ".doc" , ".docx" , ".txt"]) . to_string ()) ; map . insert ("Images" . to_string () , (vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"]) . to_string ()) ; map . insert ("Videos" . to_string () , (vec ! [".mp4" , ".avi" , ".mov" , ".mkv"]) . to_string ()) ; map . insert ("Code" . to_string () , (vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"]) . to_string ()) ; map . insert ("Data" . to_string () , (vec ! [".csv" , ".json" , ".xml" , ".xlsx"]) . to_string ()) ; map } ; ; let source_dir = "~/Desktop" . to_string () ; ; let files = list_files (source_dir) ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{:?}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let source = join_path (source_dir , file) ; ; let destination = join_path (target_dir , file) ; ; move_file (source , destination) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") , category) , "/")) ; break } } } } } } } } ; println ! ("✅ Desktop organized!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7wC9Zx/main.rs:1:1157
  |
1 | ... { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{:?}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let source = join_path (source_dir , file) ; ; let destination = join_path (target_dir , file) ; ; move_file (source , destination) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") , category) , "/")) ; break } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { println ! ("=== Desktop Organizer ===") ; let file_categories = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("Documents" . to_string () , (vec ! [".pdf" , ".doc" , ".docx" , ".txt"]) . to_string ()) ; map . insert ("Images" . to_string () , (vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"]) . to_string ()) ; map . insert ("Videos" . to_string () , (vec ! [".mp4" , ".avi" , ".mov" , ".mkv"]) . to_string ()) ; map . insert ("Code" . to_string () , (vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"]) . to_string ()) ; map . insert ("Data" . to_string () , (vec ! [".csv" , ".json" , ".xml" , ".xlsx"]) . to_string ()) ; map } ; ; let source_dir = "~/Desktop" . to_string () ; ; let files = list_files (source_dir) ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{:?}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let source = join_path (source_dir , file) ; ; let destination = join_path (target_dir , file) ; ; move_file (source , destination) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") , category) , "/")) ; break } } } } } } } } } ; println ! ("✅ Desktop organized!") ; }
1 + use std :: collections :: HashMap ; fn main () { println ! ("=== Desktop Organizer ===") ; let file_categories = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("Documents" . to_string () , (vec ! [".pdf" , ".doc" , ".docx" , ".txt"]) . to_string ()) ; map . insert ("Images" . to_string () , (vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"]) . to_string ()) ; map . insert ("Videos" . to_string () , (vec ! [".mp4" , ".avi" , ".mov" , ".mkv"]) . to_string ()) ; map . insert ("Code" . to_string () , (vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"]) . to_string ()) ; map . insert ("Data" . to_string () , (vec ! [".csv" , ".json" , ".xml" , ".xlsx"]) . to_string ()) ; map } ; ; let source_dir = "~/Desktop" . to_string () ; ; let files = list_files (source_dir) ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . iter () . map (| (k , v) | (k . clone () , v . clone ())) { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{:?}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let source = join_path (source_dir , file) ; ; let destination = join_path (target_dir , file) ; ; move_file (source , destination) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") , category) , "/")) ; break } } } } } } } } ; println ! ("✅ Desktop organized!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7wC9Zx/main.rs:1:1198
  |
1 | ... { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{:?}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let source = join_path (source_dir , file) ; ; let destination = join_path (target_dir , file) ; ; move_file (source , destination) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") , category) , "/")) ; break } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { println ! ("=== Desktop Organizer ===") ; let file_categories = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("Documents" . to_string () , (vec ! [".pdf" , ".doc" , ".docx" , ".txt"]) . to_string ()) ; map . insert ("Images" . to_string () , (vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"]) . to_string ()) ; map . insert ("Videos" . to_string () , (vec ! [".mp4" , ".avi" , ".mov" , ".mkv"]) . to_string ()) ; map . insert ("Code" . to_string () , (vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"]) . to_string ()) ; map . insert ("Data" . to_string () , (vec ! [".csv" , ".json" , ".xml" , ".xlsx"]) . to_string ()) ; map } ; ; let source_dir = "~/Desktop" . to_string () ; ; let files = list_files (source_dir) ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{:?}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let source = join_path (source_dir , file) ; ; let destination = join_path (target_dir , file) ; ; move_file (source , destination) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") , category) , "/")) ; break } } } } } } } } } ; println ! ("✅ Desktop organized!") ; }
1 + use std :: collections :: HashMap ; fn main () { println ! ("=== Desktop Organizer ===") ; let file_categories = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("Documents" . to_string () , (vec ! [".pdf" , ".doc" , ".docx" , ".txt"]) . to_string ()) ; map . insert ("Images" . to_string () , (vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"]) . to_string ()) ; map . insert ("Videos" . to_string () , (vec ! [".mp4" , ".avi" , ".mov" , ".mkv"]) . to_string ()) ; map . insert ("Code" . to_string () , (vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"]) . to_string ()) ; map . insert ("Data" . to_string () , (vec ! [".csv" , ".json" , ".xml" , ".xlsx"]) . to_string ()) ; map } ; ; let source_dir = "~/Desktop" . to_string () ; ; let files = list_files (source_dir) ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Found " , files . len () . to_s ()) , " files to organize")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { if extensions . contains (extension) { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{:?}" , format ! ("{}{}" , "Created folder: " , category)) } } ; let source = join_path (source_dir , file) ; ; let destination = join_path (target_dir , file) ; ; move_file (source , destination) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  Moved " , file) , " -> ") , category) , "/")) ; break } } } } } } } } ; println ! ("✅ Desktop organized!") ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmp7wC9Zx/main.rs:1:1438
  |
1 | ... } } ; let source = join_path (source_dir , file) ; ; let destination = join_path (target_dir , file) ; ; move_file (source , destinat...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmp7wC9Zx/main.rs:1:1490
  |
1 | ...; let destination = join_path (target_dir , file) ; ; move_file (source , destination) ; println ! ("{:?}" , format ! ("{}{}" , format...
  |                                                        ^ help: remove this semicolon

error[E0599]: the method `to_string` exists for struct `Vec<&str>`, but its trait bounds were not satisfied
   --> /tmp/.tmp7wC9Zx/main.rs:1:314
    |
1   | ...oc" , ".docx" , ".txt"]) . to_string ()) ; map . insert ("Images" . to_string () , (vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"...
    |                               ^^^^^^^^^ method cannot be called on `Vec<&str>` due to unsatisfied trait bounds
    |
   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1
    |
414 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<&str>: ToString` or `Vec<&str>: std::fmt::Display`
    |
    = note: the following trait bounds were not satisfied:
            `Vec<&str>: std::fmt::Display`
            which is required by `Vec<&str>: ToString`
            `[&str]: std::fmt::Display`
            which is required by `[&str]: ToString`

error[E0599]: the method `to_string` exists for struct `Vec<&str>`, but its trait bounds were not satisfied
   --> /tmp/.tmp7wC9Zx/main.rs:1:426
    |
1   | ...png" , ".gif" , ".svg"]) . to_string ()) ; map . insert ("Videos" . to_string () , (vec ! [".mp4" , ".avi" , ".mov" , ".mkv"]) . to_st...
    |                               ^^^^^^^^^ method cannot be called on `Vec<&str>` due to unsatisfied trait bounds
    |
   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1
    |
414 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<&str>: ToString` or `Vec<&str>: std::fmt::Display`
    |
    = note: the following trait bounds were not satisfied:
            `Vec<&str>: std::fmt::Display`
            which is required by `Vec<&str>: ToString`
            `[&str]: std::fmt::Display`
            which is required by `[&str]: ToString`

error[E0599]: the method `to_string` exists for struct `Vec<&str>`, but its trait bounds were not satisfied
   --> /tmp/.tmp7wC9Zx/main.rs:1:528
    |
1   | ...avi" , ".mov" , ".mkv"]) . to_string ()) ; map . insert ("Code" . to_string () , (vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"]) ....
    |                               ^^^^^^^^^ method cannot be called on `Vec<&str>` due to unsatisfied trait bounds
    |
   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1
    |
414 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<&str>: ToString` or `Vec<&str>: std::fmt::Display`
    |
    = note: the following trait bounds were not satisfied:
            `Vec<&str>: std::fmt::Display`
            which is required by `Vec<&str>: ToString`
            `[&str]: std::fmt::Display`
            which is required by `[&str]: ToString`

error[E0599]: the method `to_string` exists for struct `Vec<&str>`, but its trait bounds were not satisfied
   --> /tmp/.tmp7wC9Zx/main.rs:1:636
    |
1   | ...s" , ".ruchy" , ".cpp"]) . to_string ()) ; map . insert ("Data" . to_string () , (vec ! [".csv" , ".json" , ".xml" , ".xlsx"]) . to_st...
    |                               ^^^^^^^^^ method cannot be called on `Vec<&str>` due to unsatisfied trait bounds
    |
   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1
    |
414 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<&str>: ToString` or `Vec<&str>: std::fmt::Display`
    |
    = note: the following trait bounds were not satisfied:
            `Vec<&str>: std::fmt::Display`
            which is required by `Vec<&str>: ToString`
            `[&str]: std::fmt::Display`
            which is required by `[&str]: ToString`

error[E0599]: the method `to_string` exists for struct `Vec<&str>`, but its trait bounds were not satisfied
   --> /tmp/.tmp7wC9Zx/main.rs:1:738
    |
1   | ...on" , ".xml" , ".xlsx"]) . to_string ()) ; map } ; ; let source_dir = "~/Desktop" . to_string () ; ; let files = list_files (source_di...
    |                               ^^^^^^^^^ method cannot be called on `Vec<&str>` due to unsatisfied trait bounds
    |
   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1
    |
414 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<&str>: ToString` or `Vec<&str>: std::fmt::Display`
    |
    = note: the following trait bounds were not satisfied:
            `Vec<&str>: std::fmt::Display`
            which is required by `Vec<&str>: ToString`
            `[&str]: std::fmt::Display`
            which is required by `[&str]: ToString`

error[E0425]: cannot find function `list_files` in this scope
 --> /tmp/.tmp7wC9Zx/main.rs:1:824
  |
1 | ..._dir = "~/Desktop" . to_string () ; ; let files = list_files (source_dir) ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" ...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `get_extension` in this scope
 --> /tmp/.tmp7wC9Zx/main.rs:1:1014
  |
1 | ...ze")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . ite...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmp7wC9Zx/main.rs:1:1219
  |
1 | ...ons . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (t...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `dir_exists` in this scope
 --> /tmp/.tmp7wC9Zx/main.rs:1:1262
  |
1 | ..._dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{:?}" , format ! (...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmp7wC9Zx/main.rs:1:1406
  |
1 | ...Created folder: " , category)) } } ; let source = join_path (source_dir , file) ; ; let destination = join_path (target_dir , file) ; ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmp7wC9Zx/main.rs:1:1458
  |
1 | ...in_path (source_dir , file) ; ; let destination = join_path (target_dir , file) ; ; move_file (source , destination) ; println ! ("{:?...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `move_file` in this scope
 --> /tmp/.tmp7wC9Zx/main.rs:1:1492
  |
1 | ...t destination = join_path (target_dir , file) ; ; move_file (source , destination) ; println ! ("{:?}" , format ! ("{}{}" , format ! (...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 13 previous errors; 9 warnings emitted

Some errors have detailed explanations: E0425, E0599.
For more information about an error, try `rustc --explain E0425`.



=== ch06-00-file-operations example 2 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `set_current_dir` in this scope
 --> /tmp/.tmpGrLknu/main.rs:1:91
  |
1 | use std :: collections :: HashMap ; fn main () { let current_dir = get_current_dir () ; ; set_current_dir ("/home/user/projects" . to_str...
  |                                                                                           ^^^^^^^^^^^^^^^
  |
help: a local variable with a similar name exists
  |
1 - use std :: collections :: HashMap ; fn main () { let current_dir = get_current_dir () ; ; set_current_dir ("/home/user/projects" . to_string ()) ; let full_path = absolute_path ("data.txt" . to_string ()) ; ; let parent = parent_dir (full_path) ; ; let filename = file_name (full_path) ; ; let extension = file_extension (full_path) ; ; let project_path = join_path (home_dir () , "projects" . to_string () , "my_app" . to_string ()) ; ; let clean_path = normalize_path (".././data//file.txt" . to_string ()) ; ; }
1 + use std :: collections :: HashMap ; fn main () { let current_dir = get_current_dir () ; ; current_dir ("/home/user/projects" . to_string ()) ; let full_path = absolute_path ("data.txt" . to_string ()) ; ; let parent = parent_dir (full_path) ; ; let filename = file_name (full_path) ; ; let extension = file_extension (full_path) ; ; let project_path = join_path (home_dir () , "projects" . to_string () , "my_app" . to_string ()) ; ; let clean_path = normalize_path (".././data//file.txt" . to_string ()) ; ; }
  |
help: consider importing this function
  |
1 + use std::env::set_current_dir;
  |

error[E0425]: cannot find function `home_dir` in this scope
 --> /tmp/.tmpGrLknu/main.rs:1:368
  |
1 | ...sion (full_path) ; ; let project_path = join_path (home_dir () , "projects" . to_string () , "my_app" . to_string ()) ; ; let clean_pa...
  |                                                       ^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::env::home_dir;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpGrLknu/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let current_dir = get_current_dir () ; ; set_current_dir ("/home/user/projects" . to_str...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpGrLknu/main.rs:1:89
  |
1 | use std :: collections :: HashMap ; fn main () { let current_dir = get_current_dir () ; ; set_current_dir ("/home/user/projects" . to_str...
  |                                                                                         ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpGrLknu/main.rs:1:208
  |
1 | ..._path = absolute_path ("data.txt" . to_string ()) ; ; let parent = parent_dir (full_path) ; ; let filename = file_name (full_path) ; ;...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpGrLknu/main.rs:1:248
  |
1 | ...tring ()) ; ; let parent = parent_dir (full_path) ; ; let filename = file_name (full_path) ; ; let extension = file_extension (full_pa...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpGrLknu/main.rs:1:289
  |
1 | ...ll_path) ; ; let filename = file_name (full_path) ; ; let extension = file_extension (full_path) ; ; let project_path = join_path (hom...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpGrLknu/main.rs:1:336
  |
1 | ...h) ; ; let extension = file_extension (full_path) ; ; let project_path = join_path (home_dir () , "projects" . to_string () , "my_app"...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpGrLknu/main.rs:1:437
  |
1 | ...ojects" . to_string () , "my_app" . to_string ()) ; ; let clean_path = normalize_path (".././data//file.txt" . to_string ()) ; ; }
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpGrLknu/main.rs:1:512
  |
1 | ...alize_path (".././data//file.txt" . to_string ()) ; ; }
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `get_current_dir` in this scope
 --> /tmp/.tmpGrLknu/main.rs:1:68
  |
1 | use std :: collections :: HashMap ; fn main () { let current_dir = get_current_dir () ; ; set_current_dir ("/home/user/projects" . to_str...
  |                                                                    ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `absolute_path` in this scope
 --> /tmp/.tmpGrLknu/main.rs:1:164
  |
1 | ...ser/projects" . to_string ()) ; let full_path = absolute_path ("data.txt" . to_string ()) ; ; let parent = parent_dir (full_path) ; ; ...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `parent_dir` in this scope
 --> /tmp/.tmpGrLknu/main.rs:1:223
  |
1 | ..._string ()) ; ; let parent = parent_dir (full_path) ; ; let filename = file_name (full_path) ; ; let extension = file_extension (full_...
  |                                 ^^^^^^^^^^ help: a local variable with a similar name exists: `current_dir`

error[E0425]: cannot find function `file_name` in this scope
 --> /tmp/.tmpGrLknu/main.rs:1:265
  |
1 | ...arent = parent_dir (full_path) ; ; let filename = file_name (full_path) ; ; let extension = file_extension (full_path) ; ; let project...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_extension` in this scope
 --> /tmp/.tmpGrLknu/main.rs:1:307
  |
1 | ...ame = file_name (full_path) ; ; let extension = file_extension (full_path) ; ; let project_path = join_path (home_dir () , "projects" ...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpGrLknu/main.rs:1:357
  |
1 | ...file_extension (full_path) ; ; let project_path = join_path (home_dir () , "projects" . to_string () , "my_app" . to_string ()) ; ; le...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `normalize_path` in this scope
 --> /tmp/.tmpGrLknu/main.rs:1:456
  |
1 | ..., "my_app" . to_string ()) ; ; let clean_path = normalize_path (".././data//file.txt" . to_string ()) ; ; }
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 9 previous errors; 8 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch06-00-file-operations example 3 ===
✗ Compilation failed: Compilation failed:
error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpjLrLCL/main.rs:1:317
  |
1 | ... ("system.conf" . to_string ()) ; ; let is_file = is_file (path) ; ; let is_dir = is_directory (path) ; ; let is_symlink = is_symbolic...
  |                                                               ^^^^ not a value

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpjLrLCL/main.rs:1:354
  |
1 | ...et is_file = is_file (path) ; ; let is_dir = is_directory (path) ; ; let is_symlink = is_symbolic_link (path) ; ; let can_read = is_re...
  |                                                               ^^^^ not a value

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpjLrLCL/main.rs:1:399
  |
1 | ...is_directory (path) ; ; let is_symlink = is_symbolic_link (path) ; ; let can_read = is_readable (path) ; ; let can_write = is_writable...
  |                                                               ^^^^ not a value

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpjLrLCL/main.rs:1:437
  |
1 | ... = is_symbolic_link (path) ; ; let can_read = is_readable (path) ; ; let can_write = is_writable (path) ; ; let can_execute = is_execu...
  |                                                               ^^^^ not a value

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpjLrLCL/main.rs:1:476
  |
1 | ...read = is_readable (path) ; ; let can_write = is_writable (path) ; ; let can_execute = is_executable (path) ; ; }
  |                                                               ^^^^ not a value

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpjLrLCL/main.rs:1:519
  |
1 | ... = is_writable (path) ; ; let can_execute = is_executable (path) ; ; }
  |                                                               ^^^^ not a value

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpjLrLCL/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let exists = file_exists ("config.json" . to_string ()) ; ; let size = file_size ("data....
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpjLrLCL/main.rs:1:108
  |
1 | ...ists = file_exists ("config.json" . to_string ()) ; ; let size = file_size ("data.csv" . to_string ()) ; ; let modified = file_modifie...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpjLrLCL/main.rs:1:161
  |
1 | ... let size = file_size ("data.csv" . to_string ()) ; ; let modified = file_modified_time ("log.txt" . to_string ()) ; ; let is_read_onl...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpjLrLCL/main.rs:1:226
  |
1 | ...d = file_modified_time ("log.txt" . to_string ()) ; ; let is_read_only = is_readonly ("system.conf" . to_string ()) ; ; let is_file = ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpjLrLCL/main.rs:1:292
  |
1 | ...only = is_readonly ("system.conf" . to_string ()) ; ; let is_file = is_file (path) ; ; let is_dir = is_directory (path) ; ; let is_sym...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpjLrLCL/main.rs:1:325
  |
1 | ... . to_string ()) ; ; let is_file = is_file (path) ; ; let is_dir = is_directory (path) ; ; let is_symlink = is_symbolic_link (path) ; ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpjLrLCL/main.rs:1:362
  |
1 | ..._file (path) ; ; let is_dir = is_directory (path) ; ; let is_symlink = is_symbolic_link (path) ; ; let can_read = is_readable (path) ;...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpjLrLCL/main.rs:1:407
  |
1 | ...ath) ; ; let is_symlink = is_symbolic_link (path) ; ; let can_read = is_readable (path) ; ; let can_write = is_writable (path) ; ; let...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpjLrLCL/main.rs:1:445
  |
1 | ...link (path) ; ; let can_read = is_readable (path) ; ; let can_write = is_writable (path) ; ; let can_execute = is_executable (path) ; ; }
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpjLrLCL/main.rs:1:484
  |
1 | ...ble (path) ; ; let can_write = is_writable (path) ; ; let can_execute = is_executable (path) ; ; }
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpjLrLCL/main.rs:1:527
  |
1 | ...(path) ; ; let can_execute = is_executable (path) ; ; }
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpjLrLCL/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let exists = file_exists ("config.json" . to_string ()) ; ; let size = file_size ("data....
  |                                                               ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_size` in this scope
 --> /tmp/.tmpjLrLCL/main.rs:1:121
  |
1 | ...sts ("config.json" . to_string ()) ; ; let size = file_size ("data.csv" . to_string ()) ; ; let modified = file_modified_time ("log.tx...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_modified_time` in this scope
 --> /tmp/.tmpjLrLCL/main.rs:1:178
  |
1 | ..."data.csv" . to_string ()) ; ; let modified = file_modified_time ("log.txt" . to_string ()) ; ; let is_read_only = is_readonly ("syste...
  |                                                  ^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_readonly` in this scope
 --> /tmp/.tmpjLrLCL/main.rs:1:247
  |
1 | ..."log.txt" . to_string ()) ; ; let is_read_only = is_readonly ("system.conf" . to_string ()) ; ; let is_file = is_file (path) ; ; let i...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_file` in this scope
 --> /tmp/.tmpjLrLCL/main.rs:1:308
  |
1 | ...y ("system.conf" . to_string ()) ; ; let is_file = is_file (path) ; ; let is_dir = is_directory (path) ; ; let is_symlink = is_symboli...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_directory` in this scope
 --> /tmp/.tmpjLrLCL/main.rs:1:340
  |
1 | ... ; let is_file = is_file (path) ; ; let is_dir = is_directory (path) ; ; let is_symlink = is_symbolic_link (path) ; ; let can_read = i...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_symbolic_link` in this scope
 --> /tmp/.tmpjLrLCL/main.rs:1:381
  |
1 | ...dir = is_directory (path) ; ; let is_symlink = is_symbolic_link (path) ; ; let can_read = is_readable (path) ; ; let can_write = is_wr...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_readable` in this scope
 --> /tmp/.tmpjLrLCL/main.rs:1:424
  |
1 | ...ink = is_symbolic_link (path) ; ; let can_read = is_readable (path) ; ; let can_write = is_writable (path) ; ; let can_execute = is_ex...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_writable` in this scope
 --> /tmp/.tmpjLrLCL/main.rs:1:463
  |
1 | ...an_read = is_readable (path) ; ; let can_write = is_writable (path) ; ; let can_execute = is_executable (path) ; ; }
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_executable` in this scope
 --> /tmp/.tmpjLrLCL/main.rs:1:504
  |
1 | ...rite = is_writable (path) ; ; let can_execute = is_executable (path) ; ; }
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error: aborting due to 16 previous errors; 11 warnings emitted

Some errors have detailed explanations: E0423, E0425.
For more information about an error, try `rustc --explain E0423`.



=== ch06-00-file-operations example 4 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `create_dir` in this scope
 --> /tmp/.tmpPQq4gx/main.rs:1:273
  |
1 | ... process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" ....
  |                                                      ^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::create_dir;
  |

error[E0425]: cannot find function `create_dir_all` in this scope
 --> /tmp/.tmpPQq4gx/main.rs:1:316
  |
1 | ...() { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" ....
  |                                                    ^^^^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::create_dir_all;
  |

error[E0425]: cannot find function `remove_dir` in this scope
 --> /tmp/.tmpPQq4gx/main.rs:1:374
  |
1 | ...ir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" ...
  |                                                      ^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_dir;
  |

error[E0425]: cannot find function `remove_dir_all` in this scope
 --> /tmp/.tmpPQq4gx/main.rs:1:419
  |
1 | ... ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let all_items = list_dir ("."...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_dir_all;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpPQq4gx/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn walk_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = j...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpPQq4gx/main.rs:1:69
  |
1 | ... { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } ...
  |       ^^                                                                                                                                                                                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn walk_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let all_items = list_dir ("." . to_string ()) ; ; let files_only = list_files ("." . to_string ()) ; ; let dirs_only = list_directories ("." . to_string ()) ; ; }
1 + use std :: collections :: HashMap ; fn walk_directory (dir : i32) { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let all_items = list_dir ("." . to_string ()) ; ; let files_only = list_files ("." . to_string ()) ; ; let dirs_only = list_directories ("." . to_string ()) ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpPQq4gx/main.rs:1:122
  |
1 | ... { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } ...
  |       ^^                                                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn walk_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let all_items = list_dir ("." . to_string ()) ; ; let files_only = list_files ("." . to_string ()) ; ; let dirs_only = list_directories ("." . to_string ()) ; ; }
1 + use std :: collections :: HashMap ; fn walk_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let all_items = list_dir ("." . to_string ()) ; ; let files_only = list_files ("." . to_string ()) ; ; let dirs_only = list_directories ("." . to_string ()) ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpPQq4gx/main.rs:1:187
  |
1 | ...h = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn walk_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let all_items = list_dir ("." . to_string ()) ; ; let files_only = list_files ("." . to_string ()) ; ; let dirs_only = list_directories ("." . to_string ()) ; ; }
1 + use std :: collections :: HashMap ; fn walk_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { walk_directory (path) } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let all_items = list_dir ("." . to_string ()) ; ; let files_only = list_files ("." . to_string ()) ; ; let dirs_only = list_directories ("." . to_string ()) ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpPQq4gx/main.rs:1:222
  |
1 | ..._directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . t...
  |                                                           ^^                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn walk_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let all_items = list_dir ("." . to_string ()) ; ; let files_only = list_files ("." . to_string ()) ; ; let dirs_only = list_directories ("." . to_string ()) ; ; }
1 + use std :: collections :: HashMap ; fn walk_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { process_file (path) } } } } } } } fn main () { create_dir ("new_folder" . to_string ()) ; create_dir_all ("path/to/nested/folder" . to_string ()) ; remove_dir ("empty_folder" . to_string ()) ; remove_dir_all ("folder_with_contents" . to_string ()) ; let all_items = list_dir ("." . to_string ()) ; ; let files_only = list_files ("." . to_string ()) ; ; let dirs_only = list_directories ("." . to_string ()) ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpPQq4gx/main.rs:1:524
  |
1 | ...) ; let all_items = list_dir ("." . to_string ()) ; ; let files_only = list_files ("." . to_string ()) ; ; let dirs_only = list_direct...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpPQq4gx/main.rs:1:577
  |
1 | ... let files_only = list_files ("." . to_string ()) ; ; let dirs_only = list_directories ("." . to_string ()) ; ; }
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpPQq4gx/main.rs:1:635
  |
1 | ...dirs_only = list_directories ("." . to_string ()) ; ; }
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `list_dir` in this scope
 --> /tmp/.tmpPQq4gx/main.rs:1:85
  |
1 | use std :: collections :: HashMap ; fn walk_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = j...
  |                                                                                     ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpPQq4gx/main.rs:1:137
  |
1 | ...st_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else {...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_directory` in this scope
 --> /tmp/.tmpPQq4gx/main.rs:1:165
  |
1 | ...ems { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } ...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `process_file` in this scope
 --> /tmp/.tmpPQq4gx/main.rs:1:224
  |
1 | ...ry (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder" . to_string...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `list_dir` in this scope
 --> /tmp/.tmpPQq4gx/main.rs:1:492
  |
1 | ...r_with_contents" . to_string ()) ; let all_items = list_dir ("." . to_string ()) ; ; let files_only = list_files ("." . to_string ()) ...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `list_files` in this scope
 --> /tmp/.tmpPQq4gx/main.rs:1:543
  |
1 | ...ist_dir ("." . to_string ()) ; ; let files_only = list_files ("." . to_string ()) ; ; let dirs_only = list_directories ("." . to_strin...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `list_directories` in this scope
 --> /tmp/.tmpPQq4gx/main.rs:1:595
  |
1 | ...files ("." . to_string ()) ; ; let dirs_only = list_directories ("." . to_string ()) ; ; }
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 11 previous errors; 8 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch06-00-file-operations example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch06-00-file-operations example 6 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `min_size` in this scope
 --> /tmp/.tmpqNC0m1/main.rs:1:390
  |
1 | ...th) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { du...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `file_hashes` in this scope
 --> /tmp/.tmpqNC0m1/main.rs:1:438
  |
1 | ... min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collection...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `duplicates` in this scope
 --> /tmp/.tmpqNC0m1/main.rs:1:471
  |
1 | ...file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String >...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `file_hashes` in this scope
 --> /tmp/.tmpqNC0m1/main.rs:1:643
  |
1 | ... () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `file_hashes` in this scope
 --> /tmp/.tmpqNC0m1/main.rs:1:904
  |
1 | ...) , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `remove_file` in this scope
 --> /tmp/.tmpqNC0m1/main.rs:1:3038
  |
1 | ... . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , ...
  |                                                     ^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_file;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpqNC0m1/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpqNC0m1/main.rs:1:72
  |
1 | ...n hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) { ...
  |                                      ^^                                                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let file_hashes = () ; ; let duplicates = vec ! [] ; ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { let content = read_bytes (path) ; return sha256 (content) } } fn scan_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let file_hashes = () ; ; let duplicates = vec ! [] ; ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpqNC0m1/main.rs:1:172
  |
1 | ... { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let file_hashes = () ; ; let duplicates = vec ! [] ; ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let file_hashes = () ; ; let duplicates = vec ! [] ; ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpqNC0m1/main.rs:1:225
  |
1 | ... { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let file_hashes = () ; ; let duplicates = vec ! [] ; ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let file_hashes = () ; ; let duplicates = vec ! [] ; ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpqNC0m1/main.rs:1:290
  |
1 | ...h = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size ...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let file_hashes = () ; ; let duplicates = vec ! [] ; ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { scan_directory (path) } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let file_hashes = () ; ; let duplicates = vec ! [] ; ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpqNC0m1/main.rs:1:345
  |
1 | ... { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let file_hashes = () ; ; let duplicates = vec ! [] ; ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let file_hashes = () ; ; let duplicates = vec ! [] ; ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpqNC0m1/main.rs:1:401
  |
1 | ... { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let file_hashes = () ; ; let duplicates = vec ! [] ; ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let file_hashes = () ; ; let duplicates = vec ! [] ; ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpqNC0m1/main.rs:1:469
  |
1 | ... { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let file_hashes = () ; ; let duplicates = vec ! [] ; ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let file_hashes = () ; ; let duplicates = vec ! [] ; ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpqNC0m1/main.rs:1:902
  |
1 | ...() , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { printl...
  |                                                    ^^                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let file_hashes = () ; ; let duplicates = vec ! [] ; ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { file_hashes [hash as usize] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let file_hashes = () ; ; let duplicates = vec ! [] ; ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpqNC0m1/main.rs:1:1396
  |
1 | .... ends_with ('\r') { input . pop () ; } } input } ; ; let min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpqNC0m1/main.rs:1:1785
  |
1 | ...h ('\r') { input . pop () ; } } input } . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpqNC0m1/main.rs:1:1908
  |
1 | ... " , search_dir) , "...")) ; let file_hashes = () ; ; let duplicates = vec ! [] ; ; scan_directory (search_dir) ; if duplicates . is_e...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpqNC0m1/main.rs:1:1938
  |
1 | ...et file_hashes = () ; ; let duplicates = vec ! [] ; ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpqNC0m1/main.rs:1:2000
  |
1 | ...earch_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}...
  |                                               ^^                                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let file_hashes = () ; ; let duplicates = vec ! [] ; ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("original" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert ("duplicate" . to_string () , (path) . to_string ()) ; map . insert ("size" . to_string () , (size) . to_string ()) ; map . insert ("hash" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = { print ! ("{}" , "Enter directory to search: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let min_size = { print ! ("{}" , "Minimum file size (bytes, 0 for all): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " , search_dir) , "...")) ; let file_hashes = () ; ; let duplicates = vec ! [] ; ; scan_directory (search_dir) ; if duplicates . is_empty () { println ! ("\n✅ No duplicate files found!") } else { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{:?}" , format ! ("{}{}" , "\nOriginal: " , dup . original)) ; println ! ("{:?}" , format ! ("{}{}" , "Duplicate: " , dup . duplicate)) ; println ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let action = { print ! ("{}" , "\nDelete duplicates? (y/n): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{:?}" , format ! ("{}{}" , "Deleted: " , dup . duplicate)) } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpqNC0m1/main.rs:1:2978
  |
1 | .... ends_with ('\r') { input . pop () ; } } input } ; ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . dup...
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `read_bytes` in this scope
 --> /tmp/.tmpqNC0m1/main.rs:1:90
  |
1 | use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } ...
  |                                                                                          ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `sha256` in this scope
 --> /tmp/.tmpqNC0m1/main.rs:1:117
  |
1 | ... i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) { { { let items = list_dir (d...
  |                                                        ^^^^^^ not found in this scope

error[E0425]: cannot find function `list_dir` in this scope
 --> /tmp/.tmpqNC0m1/main.rs:1:188
  |
1 | ... } fn scan_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpqNC0m1/main.rs:1:240
  |
1 | ...st_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else {...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_directory` in this scope
 --> /tmp/.tmpqNC0m1/main.rs:1:268
  |
1 | ...ems { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let ...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_file` in this scope
 --> /tmp/.tmpqNC0m1/main.rs:1:328
  |
1 | ...ory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let ha...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_size` in this scope
 --> /tmp/.tmpqNC0m1/main.rs:1:360
  |
1 | ...th) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_h...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0599]: no method named `to_i` found for struct `String` in the current scope
 --> /tmp/.tmpqNC0m1/main.rs:1:1775
  |
1 | ...ends_with ('\r') { input . pop () ; } } input } . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nScanning " ...
  |                                                      ^^^^ method not found in `String`

error[E0308]: mismatched types
 --> /tmp/.tmpqNC0m1/main.rs:1:1956
  |
1 | ... () ; ; let duplicates = vec ! [] ; ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files ...
  |                                          --------------  ^^^^^^^^^^ expected `i32`, found `String`
  |                                          |
  |                                          arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpqNC0m1/main.rs:1:143
  |
1 | ... read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) { { { let items = list_dir (dir) ; for item in items ...
  |                                                          ^^^^^^^^^^^^^^  ---------

error[E0599]: no method named `to_s` found for type `usize` in the current scope
 --> /tmp/.tmpqNC0m1/main.rs:1:2163
  |
1 | ...}" , "\n⚠\u{fe0f}  Found " , duplicates . len () . to_s ()) , " duplicate files:")) ; { let total_wasted = 0i32 ; { for dup in duplica...
  |                                                       ^^^^ method not found in `usize`

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpqNC0m1/main.rs:1:2454
  |
1 | ...rintln ! ("{:?}" , format ! ("{}{}" , "Size: " , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! ("{:?}" , for...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpqNC0m1/main.rs:1:2582
  |
1 | ... , format ! ("{}{}" , "\nTotal space wasted: " , format_size (total_wasted))) ; let action = { print ! ("{}" , "\nDelete duplicates? (...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `lower` found for struct `String` in the current scope
 --> /tmp/.tmpqNC0m1/main.rs:1:2992
  |
1 | ...') { input . pop () ; } } input } ; ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; printl...
  |                                                      ^^^^^ method not found in `String`

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpqNC0m1/main.rs:1:3220
  |
1 | ...at ! ("{}{}" , format ! ("{}{}" , "\n✅ Freed " , format_size (total_wasted)) , " of space!")) } } } } } } ; }
  |                                                      ^^^^^^^^^^^ not found in this scope

error: aborting due to 20 previous errors; 15 warnings emitted

Some errors have detailed explanations: E0308, E0425, E0599.
For more information about an error, try `rustc --explain E0308`.



=== ch06-00-file-operations example 7 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmpz89Eih/main.rs:1:852
  |
1 | ..., " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = for...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0425]: cannot find function `remove_file` in this scope
 --> /tmp/.tmpz89Eih/main.rs:1:1177
  |
1 | ... { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } }...
  |                                                     ^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_file;
  |

error[E0425]: cannot find function `remove_file` in this scope
 --> /tmp/.tmpz89Eih/main.rs:1:1471
  |
1 | ...ath , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" ,...
  |                                                     ^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_file;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpz89Eih/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { println ! ("=== Log Rotation System ===") ; let log_config = { let mut map : std :: coll...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpz89Eih/main.rs:1:454
  |
1 | ..." . to_string () , (true) . to_string ()) ; map } ; ; let log_dir = "/var/log/myapp" . to_string () ; ; let log_files = glob (join_pat...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpz89Eih/main.rs:1:504
  |
1 | ...; ; let log_dir = "/var/log/myapp" . to_string () ; ; let log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; ; for log_...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpz89Eih/main.rs:1:576
  |
1 | ...ob (join_path (log_dir , "*.log" . to_string ())) ; ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpz89Eih/main.rs:1:606
  |
1 | ... { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , format ! ("{}{}" , log_file , ".") , i . to_s ()) ; { let new_backup = format ! ("{}{}" , format ! ("{}{}" , log_file , ".") , i + 1i32 . to_s ()) ; ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { println ! ("=== Log Rotation System ===") ; let log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("max_size" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert ("max_backups" . to_string () , (5i32) . to_string ()) ; map . insert ("compress" . to_string () , (true) . to_string ()) ; map } ; ; let log_dir = "/var/log/myapp" . to_string () ; ; let log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , format ! ("{}{}" , log_file , ".") , i . to_s ()) ; { let new_backup = format ! ("{}{}" , format ! ("{}{}" , log_file , ".") , i + 1i32 . to_s ()) ; ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") ; }
1 + use std :: collections :: HashMap ; fn main () { println ! ("=== Log Rotation System ===") ; let log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("max_size" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert ("max_backups" . to_string () , (5i32) . to_string ()) ; map . insert ("compress" . to_string () , (true) . to_string ()) ; map } ; ; let log_dir = "/var/log/myapp" . to_string () ; ; let log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; ; for log_file in log_files { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , format ! ("{}{}" , log_file , ".") , i . to_s ()) ; { let new_backup = format ! ("{}{}" , format ! ("{}{}" , log_file , ".") , i + 1i32 . to_s ()) ; ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } ; println ! ("\n✅ Log rotation complete!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpz89Eih/main.rs:1:910
  |
1 | ... { { { let old_backup = format ! ("{}{}" , format ! ("{}{}" , log_file , ".") , i . to_s ()) ; { let new_backup = format ! ("{}{}" , format ! ("{}{}" , log_file , ".") , i + 1i32 . to_s ()) ; ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { println ! ("=== Log Rotation System ===") ; let log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("max_size" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert ("max_backups" . to_string () , (5i32) . to_string ()) ; map . insert ("compress" . to_string () , (true) . to_string ()) ; map } ; ; let log_dir = "/var/log/myapp" . to_string () ; ; let log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , format ! ("{}{}" , log_file , ".") , i . to_s ()) ; { let new_backup = format ! ("{}{}" , format ! ("{}{}" , log_file , ".") , i + 1i32 . to_s ()) ; ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") ; }
1 + use std :: collections :: HashMap ; fn main () { println ! ("=== Log Rotation System ===") ; let log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("max_size" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert ("max_backups" . to_string () , (5i32) . to_string ()) ; map . insert ("compress" . to_string () , (true) . to_string ()) ; map } ; ; let log_dir = "/var/log/myapp" . to_string () ; ; let log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { let old_backup = format ! ("{}{}" , format ! ("{}{}" , log_file , ".") , i . to_s ()) ; { let new_backup = format ! ("{}{}" , format ! ("{}{}" , log_file , ".") , i + 1i32 . to_s ()) ; ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpz89Eih/main.rs:1:1099
  |
1 | ...! ("{}{}" , log_file , ".") , i + 1i32 . to_s ()) ; ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remo...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpz89Eih/main.rs:1:1131
  |
1 | ... { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } }...
  |       ^^                                                                                                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { println ! ("=== Log Rotation System ===") ; let log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("max_size" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert ("max_backups" . to_string () , (5i32) . to_string ()) ; map . insert ("compress" . to_string () , (true) . to_string ()) ; map } ; ; let log_dir = "/var/log/myapp" . to_string () ; ; let log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , format ! ("{}{}" , log_file , ".") , i . to_s ()) ; { let new_backup = format ! ("{}{}" , format ! ("{}{}" , log_file , ".") , i + 1i32 . to_s ()) ; ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") ; }
1 + use std :: collections :: HashMap ; fn main () { println ! ("=== Log Rotation System ===") ; let log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("max_size" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert ("max_backups" . to_string () , (5i32) . to_string ()) ; map . insert ("compress" . to_string () , (true) . to_string ()) ; map } ; ; let log_dir = "/var/log/myapp" . to_string () ; ; let log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , format ! ("{}{}" , log_file , ".") , i . to_s ()) ; { let new_backup = format ! ("{}{}" , format ! ("{}{}" , log_file , ".") , i + 1i32 . to_s ()) ; ; if file_exists (old_backup) { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpz89Eih/main.rs:1:1175
  |
1 | ...ackup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } }...
  |                                                         ^^                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { println ! ("=== Log Rotation System ===") ; let log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("max_size" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert ("max_backups" . to_string () , (5i32) . to_string ()) ; map . insert ("compress" . to_string () , (true) . to_string ()) ; map } ; ; let log_dir = "/var/log/myapp" . to_string () ; ; let log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , format ! ("{}{}" , log_file , ".") , i . to_s ()) ; { let new_backup = format ! ("{}{}" , format ! ("{}{}" , log_file , ".") , i + 1i32 . to_s ()) ; ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") ; }
1 + use std :: collections :: HashMap ; fn main () { println ! ("=== Log Rotation System ===") ; let log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("max_size" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert ("max_backups" . to_string () , (5i32) . to_string ()) ; map . insert ("compress" . to_string () , (true) . to_string ()) ; map } ; ; let log_dir = "/var/log/myapp" . to_string () ; ; let log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , format ! ("{}{}" , log_file , ".") , i . to_s ()) ; { let new_backup = format ! ("{}{}" , format ! ("{}{}" , log_file , ".") , i + 1i32 . to_s ()) ; ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { remove_file (old_backup) } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpz89Eih/main.rs:1:1213
  |
1 | ... 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! (...
  |                                                  ^^                                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { println ! ("=== Log Rotation System ===") ; let log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("max_size" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert ("max_backups" . to_string () , (5i32) . to_string ()) ; map . insert ("compress" . to_string () , (true) . to_string ()) ; map } ; ; let log_dir = "/var/log/myapp" . to_string () ; ; let log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , format ! ("{}{}" , log_file , ".") , i . to_s ()) ; { let new_backup = format ! ("{}{}" , format ! ("{}{}" , log_file , ".") , i + 1i32 . to_s ()) ; ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") ; }
1 + use std :: collections :: HashMap ; fn main () { println ! ("=== Log Rotation System ===") ; let log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("max_size" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert ("max_backups" . to_string () , (5i32) . to_string ()) ; map . insert ("compress" . to_string () , (true) . to_string ()) ; map } ; ; let log_dir = "/var/log/myapp" . to_string () ; ; let log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , format ! ("{}{}" , log_file , ".") , i . to_s ()) ; { let new_backup = format ! ("{}{}" , format ! ("{}{}" , log_file , ".") , i + 1i32 . to_s ()) ; ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { rename_file (old_backup , new_backup) } } } } } } } ; { let backup_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (backup_path) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "  Created new " , log_file)) } } } } } } } ; println ! ("\n✅ Log rotation complete!") ; }
  |

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpz89Eih/main.rs:1:528
  |
1 | ...g/myapp" . to_string () ; ; let log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; ; for log_file in log_files { { { le...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `glob` in this scope
 --> /tmp/.tmpz89Eih/main.rs:1:522
  |
1 | ... "/var/log/myapp" . to_string () ; ; let log_files = glob (join_path (log_dir , "*.log" . to_string ())) ; ; for log_file in log_files...
  |                                                         ^^^^ not found in this scope

error[E0425]: cannot find function `file_size` in this scope
 --> /tmp/.tmpz89Eih/main.rs:1:621
  |
1 | ...)) ; ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , forma...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0609]: no field `max_size` on type `HashMap<String, String>`
 --> /tmp/.tmpz89Eih/main.rs:1:667
  |
1 | ...et size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ...
  |                                                            ^^^^^^^^ unknown field

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpz89Eih/main.rs:1:810
  |
1 | ...at ! ("{}{}" , "Rotating " , log_file) , " (") , format_size (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0609]: no field `max_backups` on type `HashMap<String, String>`
 --> /tmp/.tmpz89Eih/main.rs:1:872
  |
1 | ...ize (size)) , ")...")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! ("{}{}" , fo...
  |                                                          ^^^^^^^^^^^ unknown field

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpz89Eih/main.rs:1:1088
  |
1 | ..." , format ! ("{}{}" , log_file , ".") , i + 1i32 . to_s ()) ; ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpz89Eih/main.rs:1:1104
  |
1 | ..." , log_file , ".") , i + 1i32 . to_s ()) ; ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0609]: no field `max_backups` on type `HashMap<String, String>`
 --> /tmp/.tmpz89Eih/main.rs:1:1154
  |
1 | ... if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_ba...
  |                                                          ^^^^^^^^^^^ unknown field

error[E0425]: cannot find function `rename_file` in this scope
 --> /tmp/.tmpz89Eih/main.rs:1:1215
  |
1 | ...- 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `rename_file` in this scope
 --> /tmp/.tmpz89Eih/main.rs:1:1331
  |
1 | ...p_path = format ! ("{}{}" , log_file , ".1") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (ba...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0609]: no field `compress` on type `HashMap<String, String>`
 --> /tmp/.tmpz89Eih/main.rs:1:1386
  |
1 | ... rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".g...
  |                                                            ^^^^^^^^ unknown field

error[E0425]: cannot find function `compress_file` in this scope
 --> /tmp/.tmpz89Eih/main.rs:1:1399
  |
1 | ...e , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! ("{}{}" , backup_path , ".gz")) ; remove_file (b...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpz89Eih/main.rs:1:1607
  |
1 | ..."  Compressed to " , backup_path) , ".gz")) } } ; write_file (log_file , "" . to_string ()) ; println ! ("{:?}" , format ! ("{}{}" , "...
  |                                                      ^^^^^^^^^^ not found in this scope

error: aborting due to 17 previous errors; 10 warnings emitted

Some errors have detailed explanations: E0425, E0599, E0609.
For more information about an error, try `rustc --explain E0425`.



=== ch06-00-file-operations example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch06-00-file-operations example 9 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch06-00-file-operations example 10 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpQIOwQY/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let files = list_files ("data" . to_string ()) ; ; for file in files { { { let size = fi...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpQIOwQY/main.rs:1:99
  |
1 | use std :: collections :: HashMap ; fn main () { let files = list_files ("data" . to_string ()) ; ; for file in files { { { let size = fi...
  |                                                                                                   ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpQIOwQY/main.rs:1:121
  |
1 | ... { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } ; }
  |       ^^                                                                                                                           ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let files = list_files ("data" . to_string ()) ; ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } ; }
1 + use std :: collections :: HashMap ; fn main () { let files = list_files ("data" . to_string ()) ; ; for file in files { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpQIOwQY/main.rs:1:178
  |
1 | ...ze (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } ; }
  |                                       ^^                                                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let files = list_files ("data" . to_string ()) ; ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } ; }
1 + use std :: collections :: HashMap ; fn main () { let files = list_files ("data" . to_string ()) ; ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } ; }
  |

error[E0425]: cannot find function `list_files` in this scope
 --> /tmp/.tmpQIOwQY/main.rs:1:62
  |
1 | use std :: collections :: HashMap ; fn main () { let files = list_files ("data" . to_string ()) ; ; for file in files { { { let size = fi...
  |                                                              ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_size` in this scope
 --> /tmp/.tmpQIOwQY/main.rs:1:136
  |
1 | ...string ()) ; ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "la...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `move_file` in this scope
 --> /tmp/.tmpQIOwQY/main.rs:1:180
  |
1 | ...ize = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! ("{}{}" , "large_files/" , file)) } } } } } ; }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 4 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch20-00-tooling example 1 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpZOjwAI/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let y = x + 1i32 ; ; return ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpZOjwAI/main.rs:1:79
  |
1 | ...late_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let y = x + 1i32 ; ; return y } } } } fn main () { { { let result = c...
  |                                      ^^                                                              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let y = x + 1i32 ; ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{:?}" , result) } } }
1 + use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { let unused_var = 42i32 ; { let y = x + 1i32 ; ; return y } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{:?}" , result) } } }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpZOjwAI/main.rs:1:129
  |
1 | ...{ { { let unused_var = 42i32 ; { let y = x + 1i32 ; ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; pri...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpZOjwAI/main.rs:1:161
  |
1 | ...turn y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{:?}" , result) } } }
  |                                ^^                                                                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let y = x + 1i32 ; ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{:?}" , result) } } }
1 + use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let y = x + 1i32 ; ; return y } } } } fn main () { { let result = calculate_something (10i32) ; println ! ("{:?}" , result) } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpZOjwAI/main.rs:1:122
  |
1 | ...> i32 { { { let unused_var = 42i32 ; { let y = x + 1i32 ; ; return y } } } } fn main () { { { let result = calculate_something (10i32)...
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot add `i32` to `i64`
 --> /tmp/.tmpZOjwAI/main.rs:1:120
  |
1 | ...> i32 { { { let unused_var = 42i32 ; { let y = x + 1i32 ; ; return y } } } } fn main () { { { let result = calculate_something (10i32)...
  |                                                     ^ no implementation for `i64 + i32`
  |
  = help: the trait `Add<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Add<Rhs>`:
            `&i64` implements `Add<i64>`
            `&i64` implements `Add`
            `i64` implements `Add<&i64>`
            `i64` implements `Add`

error[E0308]: mismatched types
 --> /tmp/.tmpZOjwAI/main.rs:1:138
  |
1 | ...ething (x : i64) -> i32 { { { let unused_var = 42i32 ; { let y = x + 1i32 ; ; return y } } } } fn main () { { { let result = calculate...
  |                        --- expected `i32` because of return type                        ^ expected `i32`, found `i64`
  |
help: you can convert an `i64` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let y = x + 1i32 ; ; return y.try_into().unwrap() } } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{:?}" , result) } } }
  |                                                                                                                                           ++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpZOjwAI/main.rs:1:199
  |
1 | ... } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{:?}" , result) } } }
  |                                         -------------------  ^^^^^ expected `i64`, found `i32`
  |                                         |
  |                                         arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpZOjwAI/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let y = x + 1i32 ; ; return ...
  |                                        ^^^^^^^^^^^^^^^^^^^  -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let y = x + 1i32 ; ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{:?}" , result) } } }
1 + use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let y = x + 1i32 ; ; return y } } } } fn main () { { { let result = calculate_something (10i64) ; println ! ("{:?}" , result) } } }
  |

error: aborting due to 4 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.



=== ch20-00-tooling example 2 ===
✗ Compilation failed: Compilation failed:
error[E0428]: the name `fibonacci` is defined multiple times
 --> /tmp/.tmp9zmsyG/main.rs:1:155
  |
1 | ... ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { ...
  |       ----------------------------- previous definition of the value `fibonacci` here                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `fibonacci` redefined here
  |
  = note: `fibonacci` must be defined only once in the value namespace of this module

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp9zmsyG/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp9zmsyG/main.rs:1:69
  |
1 | ...nacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) ...
  |                             ^^                                                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp9zmsyG/main.rs:1:86
  |
1 | use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n...
  |                                                                                      ^^ ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { n } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp9zmsyG/main.rs:1:101
  |
1 | ...) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if ...
  |                                               ^^                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp9zmsyG/main.rs:1:187
  |
1 | ...nacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |                             ^^                                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp9zmsyG/main.rs:1:204
  |
1 | ... 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } f...
  |                                                                    ^^ ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { n } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp9zmsyG/main.rs:1:219
  |
1 | ...) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |                                               ^^                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp9zmsyG/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n...
  |                                                                          -    ^^^^ expected `i64`, found `i32`
  |                                                                          |
  |                                                                          expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i64 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp9zmsyG/main.rs:1:118
  |
1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32...
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmp9zmsyG/main.rs:1:116
  |
1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32...
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmp9zmsyG/main.rs:1:141
  |
1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fib...
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmp9zmsyG/main.rs:1:139
  |
1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fib...
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmp9zmsyG/main.rs:1:197
  |
1 | ...2) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn ma...
  |                                                    -    ^^^^ expected `i64`, found `i32`
  |                                                    |
  |                                                    expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i64 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp9zmsyG/main.rs:1:236
  |
1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmp9zmsyG/main.rs:1:234
  |
1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmp9zmsyG/main.rs:1:259
  |
1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmp9zmsyG/main.rs:1:257
  |
1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error: aborting due to 11 previous errors; 7 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0428.
For more information about an error, try `rustc --explain E0277`.



=== ch20-00-tooling example 3 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpU7aCuU/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpU7aCuU/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                                                         ^^     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { a + b } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpU7aCuU/main.rs:1:126
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                                                                                                              ^^     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { a * b } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpU7aCuU/main.rs:1:170
  |
1 | ... { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (...
  |                                                 ^^^  ----   ---- expected `i64`, found `i32`
  |                                                      |
  |                                                      expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpU7aCuU/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                        ^^^  -------   -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i64 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i64) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpU7aCuU/main.rs:1:190
  |
1 | ...n test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) ,...
  |                                                       ^^^^ expected `i64`, found `i32`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i64) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpU7aCuU/main.rs:1:211
  |
1 | ...! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply ...
  |                                                ^^^  ------   ---- expected `i64`, found `i32`
  |                                                     |
  |                                                     expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpU7aCuU/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                        ^^^  -------   -------
help: you can convert an `i32` to an `i64`
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add ((- 1i32).into() , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                                                                                                        +      ++++++++
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i64) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpU7aCuU/main.rs:1:233
  |
1 | ...3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_e...
  |                                                       ^^^^ expected `i64`, found `i32`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i64) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpU7aCuU/main.rs:1:254
  |
1 | ... (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32)...
  |                                                 ^^^  ----   ---- expected `i64`, found `i32`
  |                                                      |
  |                                                      expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpU7aCuU/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                        ^^^  -------   -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i64 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i64) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpU7aCuU/main.rs:1:274
  |
1 | ..., 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; ass...
  |                                                       ^^^^ expected `i64`, found `i32`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i64) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpU7aCuU/main.rs:1:321
  |
1 | ... } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq...
  |                                              ^^^^^^^^  ----   ---- expected `i64`, found `i32`
  |                                                        |
  |                                                        expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpU7aCuU/main.rs:1:88
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                                                                        ^^^^^^^^  -------   -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i64 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i64) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpU7aCuU/main.rs:1:346
  |
1 | ...tiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i...
  |                                                       ^^^^ expected `i64`, found `i32`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i64) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpU7aCuU/main.rs:1:367
  |
1 | ...ply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn mai...
  |                                             ^^^^^^^^  ------   ---- expected `i64`, found `i32`
  |                                                       |
  |                                                       expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpU7aCuU/main.rs:1:88
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                                                                        ^^^^^^^^  -------   -------
help: you can convert an `i32` to an `i64`
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply ((- 1i32).into() , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                         +      ++++++++
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i64) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpU7aCuU/main.rs:1:394
  |
1 | ..., 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                      ^^^^^^ expected `i64`, found `i32`
  |
help: you can convert an `i32` to an `i64`
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , (- 5i32).into()) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                          +      ++++++++

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpU7aCuU/main.rs:1:417
  |
1 | ...(- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                             ^^^^^^^^  ----   ------ expected `i64`, found `i32`
  |                                                       |
  |                                                       expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpU7aCuU/main.rs:1:88
  |
1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...
  |                                                                                        ^^^^^^^^  -------   -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i64 , 100i32) , 0i32) } } fn main () { }
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i64) , 0i32) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpU7aCuU/main.rs:1:444
  |
1 | ... - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                       ^^^^ expected `i64`, found `i32`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i64) } } fn main () { }
  |

error: aborting due to 12 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch20-00-tooling example 4 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpItvrsl/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () -> i...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpItvrsl/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () -> i...
  |                                                                                ^^ ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () -> i32 { { property_test (| s | { assert_eq ! (reverse_string (reverse_string (s)) , s) }) } } fn main () { }
1 + use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { s } fn property_test_reverse_twice_is_identity () -> i32 { { property_test (| s | { assert_eq ! (reverse_string (reverse_string (s)) , s) }) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpItvrsl/main.rs:1:143
  |
1 | ..._is_identity () -> i32 { { property_test (| s | { assert_eq ! (reverse_string (reverse_string (s)) , s) }) } } fn main () { }
  |                             ^^                                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () -> i32 { { property_test (| s | { assert_eq ! (reverse_string (reverse_string (s)) , s) }) } } fn main () { }
1 + use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () -> i32 { property_test (| s | { assert_eq ! (reverse_string (reverse_string (s)) , s) }) } fn main () { }
  |

error[E0425]: cannot find function `property_test` in this scope
 --> /tmp/.tmpItvrsl/main.rs:1:145
  |
1 | ...ty_test_reverse_twice_is_identity () -> i32 { { property_test (| s | { assert_eq ! (reverse_string (reverse_string (s)) , s) }) } } fn...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch20-00-tooling example 5 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpsRiJUK/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative number...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpsRiJUK/main.rs:1:85
  |
1 | ...al (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i3...
  |                                          ^^                                                      ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { panic ! ("Factorial not defined for negative numbers") } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpsRiJUK/main.rs:1:176
  |
1 | ...fined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                                   ^^    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { 1i32 } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpsRiJUK/main.rs:1:194
  |
1 | ... } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                         ^^                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { n * factorial (n - 1i32) } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpsRiJUK/main.rs:1:78
  |
1 | use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative number...
  |                                                                          -   ^^^^ expected `i64`, found `i32`
  |                                                                          |
  |                                                                          expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i64 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpsRiJUK/main.rs:1:156
  |
1 | ...ial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main ...
  |                                                    -    ^^^^ expected `i64`, found `i32`
  |                                                    |
  |                                                    expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i64 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpsRiJUK/main.rs:1:169
  |
1 | ...ed for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                    -    ^^^^ expected `i64`, found `i32`
  |                                                    |
  |                                                    expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i64 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpsRiJUK/main.rs:1:178
  |
1 | ...) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else ...
  |         --- expected `i64` because of return type                                                                          ^^^^ expected `i64`, found `i32`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i64 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpsRiJUK/main.rs:1:215
  |
1 | ...n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmpsRiJUK/main.rs:1:213
  |
1 | ...n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error: aborting due to 6 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.



=== ch20-00-tooling example 6 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmpnVv3bW/main.rs:1:280
  |
1 | ... let mut a = 0i32 ; ; let mut b = 1i32 ; ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_rec...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpnVv3bW/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpnVv3bW/main.rs:1:79
  |
1 | ... i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_...
  |                   ^^                                                                                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; ; let mut b = 1i32 ; ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; ; let mut b = 1i32 ; ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpnVv3bW/main.rs:1:96
  |
1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - ...
  |                                                                                                ^^ ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; ; let mut b = 1i32 ; ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { n } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; ; let mut b = 1i32 ; ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpnVv3bW/main.rs:1:111
  |
1 | ... { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n :...
  |                                     ^^                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; ; let mut b = 1i32 ; ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; ; let mut b = 1i32 ; ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpnVv3bW/main.rs:1:248
  |
1 | ...i_iterative (n : i64) -> i64 { { let mut a = 0i32 ; ; let mut b = 1i32 ; ; for i in range (n) { { { let temp = a + b ; { a = b ; b = t...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpnVv3bW/main.rs:1:269
  |
1 | ... -> i64 { { let mut a = 0i32 ; ; let mut b = 1i32 ; ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } f...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpnVv3bW/main.rs:1:292
  |
1 | ... let mut b = 1i32 ; ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 ...
  |                                               ^^                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; ; let mut b = 1i32 ; ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; ; let mut b = 1i32 ; ; for i in range (n) { { let temp = a + b ; { a = b ; b = temp } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpnVv3bW/main.rs:1:385
  |
1 | ...ecursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib...
  |                             ^^                                                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; ; let mut b = 1i32 ; ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; ; let mut b = 1i32 ; ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpnVv3bW/main.rs:1:507
  |
1 | ...terative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |                             ^^                                                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; ; let mut b = 1i32 ; ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; ; let mut b = 1i32 ; ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpnVv3bW/main.rs:1:89
  |
1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - ...
  |                                                                                    -    ^^^^ expected `i64`, found `i32`
  |                                                                                    |
  |                                                                                    expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; ; let mut b = 1i32 ; ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i64 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; ; let mut b = 1i32 ; ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpnVv3bW/main.rs:1:138
  |
1 | ...= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> ...
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmpnVv3bW/main.rs:1:136
  |
1 | ...= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> ...
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmpnVv3bW/main.rs:1:171
  |
1 | ...ci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; ; let ...
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmpnVv3bW/main.rs:1:169
  |
1 | ...ci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; ; let ...
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmpnVv3bW/main.rs:1:344
  |
1 | ...-> i64 { { let mut a = 0i32 ; ; let mut b = 1i32 ; ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn...
  |       --- expected `i64` because of return type                                                                                  ^ expected `i64`, found `i32`
  |
help: you can convert an `i32` to an `i64`
  |
1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; ; let mut b = 1i32 ; ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a.into() } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                         +++++++

error[E0308]: mismatched types
 --> /tmp/.tmpnVv3bW/main.rs:1:460
  |
1 | ...ci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative...
  |                                         -------------------  ^^^^^ expected `i64`, found `i32`
  |                                         |
  |                                         arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpnVv3bW/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - ...
  |                                        ^^^^^^^^^^^^^^^^^^^  -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; ; let mut b = 1i32 ; ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; ; let mut b = 1i32 ; ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i64)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |

error[E0423]: expected function, found attribute macro `bench`
 --> /tmp/.tmpnVv3bW/main.rs:1:387
  |
1 | ...emp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i3...
  |                                                             ^^^^^ not a function

error[E0308]: mismatched types
 --> /tmp/.tmpnVv3bW/main.rs:1:582
  |
1 | ...ci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
  |                                         -------------------  ^^^^^ expected `i64`, found `i32`
  |                                         |
  |                                         arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpnVv3bW/main.rs:1:188
  |
1 | ...- 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; ; let mut b = 1i32 ; ;...
  |                                                        ^^^^^^^^^^^^^^^^^^^  -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; ; let mut b = 1i32 ; ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; ; let mut b = 1i32 ; ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench ("fibonacci_recursive_20" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i64)) } } fn main () { }
  |

error[E0423]: expected function, found attribute macro `bench`
 --> /tmp/.tmpnVv3bW/main.rs:1:509
  |
1 | ...ursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench ("fibonacci_iterative_20" . to_string () , || fibonacci_iterative (20i3...
  |                                                             ^^^^^ not a function

error: aborting due to 11 previous errors; 9 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0423, E0425.
For more information about an error, try `rustc --explain E0277`.



=== ch07-00-building-applications example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch07-00-building-applications example 2 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `User` in this scope
 --> /tmp/.tmp6PyM7a/main.rs:1:109
  |
1 | ...e : String , email : String) -> i32 { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . ema...
  |                                                         ^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp6PyM7a/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn create_user (name : String , email : String) -> i32 { { { let user = User . copy () ; { user . id ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp6PyM7a/main.rs:1:94
  |
1 | ... { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } ...
  |       ^^                                                                                                                                                                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn create_user (name : String , email : String) -> i32 { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user (user : String) { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{:?}" , format ! ("{}{}" , "Member since: " , user . created)) } } fn main () { let APP = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("name" . to_string () , ("MyApp") . to_string ()) ; map . insert ("version" . to_string () , ("1.0.0") . to_string ()) ; map . insert ("config_dir" . to_string () , ("~/.config/myapp") . to_string ()) ; map . insert ("data_dir" . to_string () , ("~/.local/share/myapp") . to_string ()) ; map . insert ("cache_dir" . to_string () , ("~/.cache/myapp") . to_string ()) ; map } ; ; let User = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("id" . to_string () , (None) . to_string ()) ; map . insert ("name" . to_string () , ("") . to_string ()) ; map . insert ("email" . to_string () , ("") . to_string ()) ; map . insert ("created" . to_string () , (None) . to_string ()) ; map } ; ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
1 + use std :: collections :: HashMap ; fn create_user (name : String , email : String) -> i32 { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } fn display_user (user : String) { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{:?}" , format ! ("{}{}" , "Member since: " , user . created)) } } fn main () { let APP = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("name" . to_string () , ("MyApp") . to_string ()) ; map . insert ("version" . to_string () , ("1.0.0") . to_string ()) ; map . insert ("config_dir" . to_string () , ("~/.config/myapp") . to_string ()) ; map . insert ("data_dir" . to_string () , ("~/.local/share/myapp") . to_string ()) ; map . insert ("cache_dir" . to_string () , ("~/.cache/myapp") . to_string ()) ; map } ; ; let User = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("id" . to_string () , (None) . to_string ()) ; map . insert ("name" . to_string () , ("") . to_string ()) ; map . insert ("email" . to_string () , ("") . to_string ()) ; map . insert ("created" . to_string () , (None) . to_string ()) ; map } ; ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmp6PyM7a/main.rs:1:959
  |
1 | ...g () , ("~/.cache/myapp") . to_string ()) ; map } ; ; let User = { let mut map : std :: collections :: HashMap < String , String > = s...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmp6PyM7a/main.rs:1:1340
  |
1 | ..." . to_string () , (None) . to_string ()) ; map } ; ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `generate_uuid` in this scope
 --> /tmp/.tmp6PyM7a/main.rs:1:140
  |
1 | ...{ { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = curren...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `current_datetime` in this scope
 --> /tmp/.tmp6PyM7a/main.rs:1:220
  |
1 | ...name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user (user : String) { { println !...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0609]: no field `name` on type `String`
 --> /tmp/.tmp6PyM7a/main.rs:1:334
  |
1 | ...r (user : String) { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{:?}" , format ! ("{}{}" , "Member since:...
  |                                                              ^^^^ unknown field

error[E0609]: no field `email` on type `String`
 --> /tmp/.tmp6PyM7a/main.rs:1:348
  |
1 | ...g) { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{:?}" , format ! ("{}{}" , "Member since: " , user . cre...
  |                                                             ^^^^^ unknown field

error[E0609]: no field `created` on type `String`
 --> /tmp/.tmp6PyM7a/main.rs:1:422
  |
1 | ... ("{:?}" , format ! ("{}{}" , "Member since: " , user . created)) } } fn main () { let APP = { let mut map : std :: collections :: Has...
  |                                                            ^^^^^^^ unknown field

error[E0599]: the method `to_string` exists for enum `Option<_>`, but its trait bounds were not satisfied
   --> /tmp/.tmp6PyM7a/main.rs:1:1127
    |
1   | ... . to_string () , (None) . to_string ()) ; map . insert ("name" . to_string () , ("") . to_string ()) ; map . insert ("email" . to_str...
    |                               ^^^^^^^^^ method cannot be called on `Option<_>` due to unsatisfied trait bounds
    |
   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:591:1
    |
591 | pub enum Option<T> {
    | ------------------ doesn't satisfy `Option<_>: ToString` or `Option<_>: std::fmt::Display`
    |
    = note: the following trait bounds were not satisfied:
            `Option<_>: std::fmt::Display`
            which is required by `Option<_>: ToString`

error[E0599]: the method `to_string` exists for enum `Option<_>`, but its trait bounds were not satisfied
   --> /tmp/.tmp6PyM7a/main.rs:1:1316
    |
1   | ... . to_string () , (None) . to_string ()) ; map } ; ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
    |                               ^^^^^^^^^ method cannot be called on `Option<_>` due to unsatisfied trait bounds
    |
   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:591:1
    |
591 | pub enum Option<T> {
    | ------------------ doesn't satisfy `Option<_>: ToString` or `Option<_>: std::fmt::Display`
    |
    = note: the following trait bounds were not satisfied:
            `Option<_>: std::fmt::Display`
            which is required by `Option<_>: ToString`

error[E0425]: cannot find function `init_app` in this scope
 --> /tmp/.tmp6PyM7a/main.rs:1:1344
  |
1 | ...o_string () , (None) . to_string ()) ; map } ; ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `load_config` in this scope
 --> /tmp/.tmp6PyM7a/main.rs:1:1358
  |
1 | ...one) . to_string ()) ; map } ; ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `run_event_loop` in this scope
 --> /tmp/.tmp6PyM7a/main.rs:1:1375
  |
1 | ...)) ; map } ; ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `cleanup` in this scope
 --> /tmp/.tmp6PyM7a/main.rs:1:1395
  |
1 | ...init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 12 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0425, E0599, E0609.
For more information about an error, try `rustc --explain E0425`.



=== ch07-00-building-applications example 3 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpPWN7zk/main.rs:1:96
  |
1 | use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dir...
  |                                                                                                ^^^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpPWN7zk/main.rs:1:127
  |
1 | ...: String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty {...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpPWN7zk/main.rs:1:194
  |
1 | ... true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `APP` in this scope
 --> /tmp/.tmpPWN7zk/main.rs:1:242
  |
1 | ...{ if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_jso...
  |                                                         ^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpPWN7zk/main.rs:1:326
  |
1 | ...to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file ...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpPWN7zk/main.rs:1:336
  |
1 | ...()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_pat...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `APP` in this scope
 --> /tmp/.tmpPWN7zk/main.rs:1:421
  |
1 | ...} fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { S...
  |                                                         ^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpPWN7zk/main.rs:1:501
  |
1 | ..." . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { l...
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpPWN7zk/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dir...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpPWN7zk/main.rs:1:189
  |
1 | ... { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } ...
  |       ^^                                                                                                                                                                              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("users" . to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (None) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; ; }
1 + use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("users" . to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (None) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpPWN7zk/main.rs:1:210
  |
1 | ... { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } ...
  |       ^^                                                                                                                                                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("users" . to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (None) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; ; }
1 + use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("users" . to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (None) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpPWN7zk/main.rs:1:389
  |
1 | ... { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } ...
  |       ^^                                                                                                                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("users" . to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (None) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; ; }
1 + use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } fn main () { let STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("users" . to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (None) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpPWN7zk/main.rs:1:499
  |
1 | ...string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut ...
  |                                               ^^                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("users" . to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (None) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; ; }
1 + use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { STATE = parse_json (read_file (state_file)) } } } } fn main () { let STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("users" . to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (None) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpPWN7zk/main.rs:1:1029
  |
1 | ... . to_string () , (false) . to_string ()) ; map } ; ; }
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error[E0425]: cannot find function `trigger_save` in this scope
 --> /tmp/.tmpPWN7zk/main.rs:1:150
  |
1 | ... [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0605]: non-primitive cast: `String` as `usize`
 --> /tmp/.tmpPWN7zk/main.rs:1:103
  |
1 | ...ATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = j...
  |         ^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpPWN7zk/main.rs:1:231
  |
1 | ...te () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; { write_file (state_file ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_json` in this scope
 --> /tmp/.tmpPWN7zk/main.rs:1:317
  |
1 | ...json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let sta...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpPWN7zk/main.rs:1:292
  |
1 | ...ate.json" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let...
  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `state_file`

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpPWN7zk/main.rs:1:410
  |
1 | ...} } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json" . to_string ()) ; if file_exists (state_fil...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpPWN7zk/main.rs:1:472
  |
1 | ...P . data_dir , "state.json" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpPWN7zk/main.rs:1:521
  |
1 | ... file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut map : std :: co...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `parse_json` in this scope
 --> /tmp/.tmpPWN7zk/main.rs:1:509
  |
1 | ...ing ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut map...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0599]: the method `to_string` exists for struct `Vec<_>`, but its trait bounds were not satisfied
   --> /tmp/.tmpPWN7zk/main.rs:1:742
    |
1   | ...to_string () , (vec ! []) . to_string ()) ; map . insert ("current_user" . to_string () , (None) . to_string ()) ; map . insert ("sett...
    |                                ^^^^^^^^^ method cannot be called on `Vec<_>` due to unsatisfied trait bounds
    |
   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1
    |
414 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<_>: ToString` or `Vec<_>: std::fmt::Display`
    |
    = note: the following trait bounds were not satisfied:
            `Vec<_>: std::fmt::Display`
            which is required by `Vec<_>: ToString`
            `[_]: std::fmt::Display`
            which is required by `[_]: ToString`

error[E0599]: the method `to_string` exists for enum `Option<_>`, but its trait bounds were not satisfied
   --> /tmp/.tmpPWN7zk/main.rs:1:813
    |
1   | ... . to_string () , (None) . to_string ()) ; map . insert ("settings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to...
    |                               ^^^^^^^^^ method cannot be called on `Option<_>` due to unsatisfied trait bounds
    |
   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:591:1
    |
591 | pub enum Option<T> {
    | ------------------ doesn't satisfy `Option<_>: ToString` or `Option<_>: std::fmt::Display`
    |
    = note: the following trait bounds were not satisfied:
            `Option<_>: std::fmt::Display`
            which is required by `Option<_>: ToString`

error[E0599]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpPWN7zk/main.rs:1:878
  |
1 | ...ings" . to_string () , (()) . to_string ()) ; map . insert ("cache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to...
  |                                  ^^^^^^^^^ method cannot be called on `()` due to unsatisfied trait bounds
  |
  = note: the following trait bounds were not satisfied:
          `(): std::fmt::Display`
          which is required by `(): ToString`

error[E0599]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpPWN7zk/main.rs:1:940
  |
1 | ...ache" . to_string () , (()) . to_string ()) ; map . insert ("dirty" . to_string () , (false) . to_string ()) ; map } ; ; }
  |                                  ^^^^^^^^^ method cannot be called on `()` due to unsatisfied trait bounds
  |
  = note: the following trait bounds were not satisfied:
          `(): std::fmt::Display`
          which is required by `(): ToString`

error: aborting due to 21 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0425, E0599, E0605.
For more information about an error, try `rustc --explain E0425`.



=== ch07-00-building-applications example 4 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch07-00-building-applications example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `MASTER_KEY` in this scope
 --> /tmp/.tmpGJJwp0/main.rs:1:1055
  |
1 | ...("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_dat...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `MASTER_KEY` in this scope
 --> /tmp/.tmpGJJwp0/main.rs:1:1412
  |
1 | ...e] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipb...
  |                                                      ^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpGJJwp0/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpGJJwp0/main.rs:1:88
  |
1 | ... { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } ...
  |       ^^                                                                                                                                                                                                                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpGJJwp0/main.rs:1:172
  |
1 | ...erate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return ...
  |               ^^                                                                                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpGJJwp0/main.rs:1:382
  |
1 | ... { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } ...
  |       ^^                                                                                                                                                                                                                                                                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpGJJwp0/main.rs:1:455
  |
1 | ...4_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len (...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpGJJwp0/main.rs:1:498
  |
1 | ...te () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; ret...
  |            ^^                                                                                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpGJJwp0/main.rs:1:741
  |
1 | ... { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpGJJwp0/main.rs:1:1251
  |
1 | ... { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpGJJwp0/main.rs:1:1323
  |
1 | ... { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } e...
  |       ^^                                                                                                                                                                                                                                         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpGJJwp0/main.rs:1:1426
  |
1 | ...assword = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; sp...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpGJJwp0/main.rs:1:1569
  |
1 | ...lipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MAS...
  |                                ^^                                                                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpGJJwp0/main.rs:1:1693
  |
1 | ...te)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpGJJwp0/main.rs:1:1752
  |
1 | ...ASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
  |                                                        ^ help: remove this semicolon

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpGJJwp0/main.rs:1:196
  |
1 | ...merate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return...
  |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0599]: no method named `code` found for type `char` in the current scope
 --> /tmp/.tmpGJJwp0/main.rs:1:250
  |
1 | ... key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn d...
  |                                                       ^^^^ method not found in `char`

error[E0425]: cannot find function `base64_encode` in this scope
 --> /tmp/.tmpGJJwp0/main.rs:1:295
  |
1 | ... . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 {...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `base64_decode` in this scope
 --> /tmp/.tmpGJJwp0/main.rs:1:398
  |
1 | ... : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . e...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `char_from_code` in this scope
 --> /tmp/.tmpGJJwp0/main.rs:1:569
  |
1 | ...[i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } }...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `load_passwords` in this scope
 --> /tmp/.tmpGJJwp0/main.rs:1:761
  |
1 | ...password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `current_datetime` in this scope
 --> /tmp/.tmpGJJwp0/main.rs:1:1128
  |
1 | ...)) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn ge...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `save_passwords` in this scope
 --> /tmp/.tmpGJJwp0/main.rs:1:1175
  |
1 | ...(current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let pa...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0605]: non-primitive cast: `String` as `usize`
 --> /tmp/.tmpGJJwp0/main.rs:1:794
  |
1 | ...rds [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; ma...
  |         ^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0425]: cannot find function `load_passwords` in this scope
 --> /tmp/.tmpGJJwp0/main.rs:1:1271
  |
1 | ... } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords ()...
  |       ------------------------------------------------------------------------------ similarly named function `add_password` defined here                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^^^^^^^^^^^^^ help: a function with a similar name exists: `add_password`

error[E0425]: cannot find function `copy_to_clipboard` in this scope
 --> /tmp/.tmpGJJwp0/main.rs:1:1428
  |
1 | ...= decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_afte...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `clear_clipboard` in this scope
 --> /tmp/.tmpGJJwp0/main.rs:1:1534
  |
1 | ...d to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No passwo...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `spawn_after` in this scope
 --> /tmp/.tmpGJJwp0/main.rs:1:1507
  |
1 | ... println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , fo...
  |                                                      ^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpGJJwp0/main.rs:1:1571
  |
1 | ... } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY = None...
  |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0605]: non-primitive cast: `String` as `usize`
 --> /tmp/.tmpGJJwp0/main.rs:1:1350
  |
1 | ...rds [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Passwor...
  |         ^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0282]: type annotations needed for `Option<_>`
 --> /tmp/.tmpGJJwp0/main.rs:1:1673
  |
1 | ...for " , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
  |                                              ^^^^^^^^^^   ---- type must be known at this point
  |
help: consider giving `MASTER_KEY` an explicit type, where the type for type parameter `T` is specified
  |
1 | use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& "") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("username" . to_string () , (username) . to_string ()) ; map . insert ("password" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert ("created" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{:?}" , format ! ("{}{}" , "❌ No password found for " , site)) } } } } } fn main () { let MASTER_KEY: Option<T> = None ; ; let PASSWORDS_FILE = "~/.passwords.enc" . to_string () ; ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     +++++++++++

error: aborting due to 18 previous errors; 13 warnings emitted

Some errors have detailed explanations: E0277, E0282, E0308, E0425, E0599, E0605.
For more information about an error, try `rustc --explain E0277`.



=== ch07-00-building-applications example 6 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `TRANSACTIONS_FILE` in this scope
 --> /tmp/.tmphU8B4S/main.rs:1:559
  |
1 | ...tion) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; ...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `report_data` in this scope
 --> /tmp/.tmphU8B4S/main.rs:1:1998
  |
1 | ...{}.pdf" , month) ; ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_...
  |                                                     ^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmphU8B4S/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) { { { let transaction = ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmphU8B4S/main.rs:1:116
  |
1 | ... { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") , monthly_spent . to_s ()) , "/$") , budget_limit . to_s ())) } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") , monthly_spent . to_s ()) , "/$") , budget_limit . to_s ())) } } } } } } fn generate_report (month : i32) { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category" . to_string ()) ; ; println ! ("{:?}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") , category_total . to_s ()) , " ") , bar)) } } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; ; }
1 + use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") , monthly_spent . to_s ()) , "/$") , budget_limit . to_s ())) } } } } } fn generate_report (month : i32) { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category" . to_string ()) ; ; println ! ("{:?}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") , category_total . to_s ()) , " ") , bar)) } } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmphU8B4S/main.rs:1:645
  |
1 | ... let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_lim...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmphU8B4S/main.rs:1:696
  |
1 | ... ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmphU8B4S/main.rs:1:1078
  |
1 | ... { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category" . to_string ()) ; ; println ! ("{:?}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") , category_total . to_s ()) , " ") , bar)) } } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") , monthly_spent . to_s ()) , "/$") , budget_limit . to_s ())) } } } } } } fn generate_report (month : i32) { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category" . to_string ()) ; ; println ! ("{:?}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") , category_total . to_s ()) , " ") , bar)) } } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; ; }
1 + use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") , monthly_spent . to_s ()) , "/$") , budget_limit . to_s ())) } } } } } } fn generate_report (month : i32) { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category" . to_string ()) ; ; println ! ("{:?}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") , category_total . to_s ()) , " ") , bar)) } } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } fn main () { let TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmphU8B4S/main.rs:1:1203
  |
1 | ...oup_by (transactions , "category" . to_string ()) ; ; println ! ("{:?}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; print...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmphU8B4S/main.rs:1:1335
  |
1 | ...intln ! ("{:?}" , "=" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . iter () . map (| (k , v) | (k . clone ()...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmphU8B4S/main.rs:1:1968
  |
1 | ..._file = format ! ("budget_report_{}.pdf" , month) ; ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmphU8B4S/main.rs:1:1437
  |
1 | ... { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") , category_total . to_s ()) , " ") , bar)) } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") , monthly_spent . to_s ()) , "/$") , budget_limit . to_s ())) } } } } } } fn generate_report (month : i32) { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category" . to_string ()) ; ; println ! ("{:?}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") , category_total . to_s ()) , " ") , bar)) } } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; ; }
1 + use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") , monthly_spent . to_s ()) , "/$") , budget_limit . to_s ())) } } } } } } fn generate_report (month : i32) { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category" . to_string ()) ; ; println ! ("{:?}" , format ! ("{}{}" , "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") , category_total . to_s ()) , " ") , bar)) } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄 Report saved to " , report_file)) } } } } fn main () { let TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmphU8B4S/main.rs:1:1622
  |
1 | ... let bar = "█" * category_total / 50i32 . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , for...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmphU8B4S/main.rs:1:2182
  |
1 | ...ILE = "~/.budget/transactions.csv" . to_string () ; ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Othe...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmphU8B4S/main.rs:1:2270
  |
1 | ...Transport" , "Bills" , "Entertainment" , "Other"] ; ; }
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `current_date` in this scope
 --> /tmp/.tmphU8B4S/main.rs:1:287
  |
1 | ... new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) ....
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `append_csv` in this scope
 --> /tmp/.tmphU8B4S/main.rs:1:547
  |
1 | ...ng () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `get_monthly_total` in this scope
 --> /tmp/.tmphU8B4S/main.rs:1:614
  |
1 | ...ONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if m...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `get_budget_limit` in this scope
 --> /tmp/.tmphU8B4S/main.rs:1:666
  |
1 | ...onthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `send_notification` in this scope
 --> /tmp/.tmphU8B4S/main.rs:1:734
  |
1 | ...gory) ; ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `load_transactions` in this scope
 --> /tmp/.tmphU8B4S/main.rs:1:1101
  |
1 | ... ; fn add_transaction (amount : String , category : i32 , description : String) { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("date" . to_string () , (current_date ()) . to_string ()) ; map . insert ("amount" . to_string () , (amount) . to_string ()) ; map . insert ("category" . to_string () , (category) . to_string ()) ; map . insert ("description" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Warning: " , category) , " spending at $") , monthly_spent . to_s ()) , "/$") , budget_limit . to_s ())) } } } } } } fn generate_report (month : i32) { { { let transactions = load_transactions (m...
  |       ---------------------------------------------------------------------------- similarly named function `add_transaction` defined here                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^^^^^^^^^^^^^^^^^ help: a function with a similar name exists: `add_transaction`

error[E0425]: cannot find function `group_by` in this scope
 --> /tmp/.tmphU8B4S/main.rs:1:1149
  |
1 | ... = load_transactions (month) ; { let by_category = group_by (transactions , "category" . to_string ()) ; ; println ! ("{:?}" , format ...
  |                                                       ^^^^^^^^ not found in this scope

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmphU8B4S/main.rs:1:1305
  |
1 | ..., "\n📊 Budget Report for " , month)) ; println ! ("{:?}" , "=" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . ...
  |                                                                --- ^ ----- i32
  |                                                                |
  |                                                                &str

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmphU8B4S/main.rs:1:1612
  |
1 | ...ry_total ; let bar = "█" * category_total / 50i32 . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{...
  |                                                        ^^^^ method not found in `i32`

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmphU8B4S/main.rs:1:1575
  |
1 | ... . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , fo...
  |                                                ^^^ doesn't have a size known at compile-time
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: all local variables must have a statically known size

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmphU8B4S/main.rs:1:1774
  |
1 | ... ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , category , " $") , category_total . to_s ()) , " ") , bar)) } } } ...
  |         -- required by this formatting parameter                                                                             ^^^ doesn't have a size known at compile-time
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmphU8B4S/main.rs:1:1814
  |
1 | ...al . to_s ()) , " ") , bar)) } } } } ; println ! ("{:?}" , "=" * 40i32) ; println ! ("{:?}" , format ! ("{}{}" , "Total:          $" ,...
  |                                                               --- ^ ----- i32
  |                                                               |
  |                                                               &str

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmphU8B4S/main.rs:1:1894
  |
1 | ... , format ! ("{}{}" , "Total:          $" , total . to_s ())) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; ; genera...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `generate_pdf` in this scope
 --> /tmp/.tmphU8B4S/main.rs:1:1970
  |
1 | ... = format ! ("budget_report_{}.pdf" , month) ; ; generate_pdf (report_file , report_data) ; println ! ("{:?}" , format ! ("{}{}" , "\n📄...
  |                                                     ^^^^^^^^^^^^ not found in this scope

warning: unused variable: `TRANSACTIONS_FILE`
 --> /tmp/.tmphU8B4S/main.rs:1:2116
  |
1 | ... fn main () { let TRANSACTIONS_FILE = "~/.budget/transactions.csv" . to_string () ; ; let CATEGORIES = vec ! ["Food" , "Transport" , "...
  |                      ^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_TRANSACTIONS_FILE`
  |
  = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `CATEGORIES`
 --> /tmp/.tmphU8B4S/main.rs:1:2188
  |
1 | ..." . to_string () ; ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; ; }
  |                             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_CATEGORIES`

error: aborting due to 16 previous errors; 14 warnings emitted

Some errors have detailed explanations: E0277, E0369, E0425, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch07-00-building-applications example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch07-00-building-applications example 8 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `remove_file` in this scope
 --> /tmp/.tmp3i7zu1/main.rs:1:921
  |
1 | ...est == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_...
  |                                                     ^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_file;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp3i7zu1/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" ....
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp3i7zu1/main.rs:1:64
  |
1 | ... { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert ! (user . name == "Alice" , "{}" , "Name should be set") ; assert ! (user . email == "alice@example.com" , "{}" , "Email should be set") ; assert ! (user . id != None , "{}" , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                            ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert ! (user . name == "Alice" , "{}" , "Name should be set") ; assert ! (user . email == "alice@example.com" , "{}" , "Email should be set") ; assert ! (user . id != None , "{}" , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } fn test_data_persistence () { { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("test" . to_string () , ("value") . to_string ()) ; map } ; { let test_file = "test_data.json" . to_string () ; ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let loaded = load_json (test_file) ; ; assert ! (loaded . test == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_user_creation () { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert ! (user . name == "Alice" , "{}" , "Name should be set") ; assert ! (user . email == "alice@example.com" , "{}" , "Email should be set") ; assert ! (user . id != None , "{}" , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } fn test_data_persistence () { { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("test" . to_string () , ("value") . to_string ()) ; map } ; { let test_file = "test_data.json" . to_string () ; ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let loaded = load_json (test_file) ; ; assert ! (loaded . test == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp3i7zu1/main.rs:1:448
  |
1 | ... { { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("test" . to_string () , ("value") . to_string ()) ; map } ; { let test_file = "test_data.json" . to_string () ; ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let loaded = load_json (test_file) ; ; assert ! (loaded . test == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert ! (user . name == "Alice" , "{}" , "Name should be set") ; assert ! (user . email == "alice@example.com" , "{}" , "Email should be set") ; assert ! (user . id != None , "{}" , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } fn test_data_persistence () { { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("test" . to_string () , ("value") . to_string ()) ; map } ; { let test_file = "test_data.json" . to_string () ; ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let loaded = load_json (test_file) ; ; assert ! (loaded . test == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" . to_string ()) ; { assert ! (user . name == "Alice" , "{}" , "Name should be set") ; assert ! (user . email == "alice@example.com" , "{}" , "Email should be set") ; assert ! (user . id != None , "{}" , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } fn test_data_persistence () { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("test" . to_string () , ("value") . to_string ()) ; map } ; { let test_file = "test_data.json" . to_string () ; ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let loaded = load_json (test_file) ; ; assert ! (loaded . test == "value" , "{}" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmp3i7zu1/main.rs:1:704
  |
1 | ...{ let test_file = "test_data.json" . to_string () ; ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmp3i7zu1/main.rs:1:850
  |
1 | ...be created") ; let loaded = load_json (test_file) ; ; assert ! (loaded . test == "value" , "{}" , "Data should persist") ; remove_file...
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `create_user` in this scope
 --> /tmp/.tmp3i7zu1/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user ("Alice" . to_string () , "alice@example.com" ....
  |                                                                               ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `save_json` in this scope
 --> /tmp/.tmp3i7zu1/main.rs:1:706
  |
1 | ...t test_file = "test_data.json" . to_string () ; ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmp3i7zu1/main.rs:1:752
  |
1 | ... ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , "{}" , "File should be created") ; let loaded = load_json (...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `load_json` in this scope
 --> /tmp/.tmp3i7zu1/main.rs:1:826
  |
1 | ..., "{}" , "File should be created") ; let loaded = load_json (test_file) ; ; assert ! (loaded . test == "value" , "{}" , "Data should p...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `test_error_handling` in this scope
 --> /tmp/.tmp3i7zu1/main.rs:1:1122
  |
1 | ...ser_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn ...
  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `test_performance` in this scope
 --> /tmp/.tmp3i7zu1/main.rs:1:1147
  |
1 | ...data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 7 previous errors; 5 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-building-applications example 9 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `VERSION` in this scope
 --> /tmp/.tmpDhQY2W/main.rs:1:174
  |
1 | ... let release_dir = format ! ("{}{}" , "release_" , VERSION) ; { create_dir_all (release_dir) ; copy_file ("main.ruchy" . to_string () ...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find function `create_dir_all` in this scope
 --> /tmp/.tmpDhQY2W/main.rs:1:187
  |
1 | ... = format ! ("{}{}" , "release_" , VERSION) ; { create_dir_all (release_dir) ; copy_file ("main.ruchy" . to_string () , join_path (rel...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::create_dir_all;
  |

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmpDhQY2W/main.rs:1:284
  |
1 | ...n.ruchy" . to_string () , join_path (release_dir , APP_NAME)) ; copy_dir ("resources" . to_string () , join_path (release_dir , "resou...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmpDhQY2W/main.rs:1:646
  |
1 | ...cho 'Installation complete! Run {} to start.'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; ; write_file (join_path (rel...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `VERSION` in this scope
 --> /tmp/.tmpDhQY2W/main.rs:1:657
  |
1 | ...lation complete! Run {} to start.'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; ; write_file (join_path (release_dir , ...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmpDhQY2W/main.rs:1:667
  |
1 | ...plete! Run {} to start.'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; ; write_file (join_path (release_dir , "install.s...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmpDhQY2W/main.rs:1:678
  |
1 | ...{} to start.'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; ; write_file (join_path (release_dir , "install.sh" . to_str...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmpDhQY2W/main.rs:1:689
  |
1 | ....'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; ; write_file (join_path (release_dir , "install.sh" . to_string ()) , i...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmpDhQY2W/main.rs:1:827
  |
1 | ...ller) ; create_archive (format ! ("{}-{}.tar.gz" , APP_NAME , VERSION) , release_dir) ; println ! ("✅ Release built: {}-{}.tar.gz" , AP...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `VERSION` in this scope
 --> /tmp/.tmpDhQY2W/main.rs:1:838
  |
1 | ...ate_archive (format ! ("{}-{}.tar.gz" , APP_NAME , VERSION) , release_dir) ; println ! ("✅ Release built: {}-{}.tar.gz" , APP_NAME , VE...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmpDhQY2W/main.rs:1:909
  |
1 | ...ir) ; println ! ("✅ Release built: {}-{}.tar.gz" , APP_NAME , VERSION) } } } } fn main () { }
  |                                                        ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `VERSION` in this scope
 --> /tmp/.tmpDhQY2W/main.rs:1:920
  |
1 | ...ln ! ("✅ Release built: {}-{}.tar.gz" , APP_NAME , VERSION) } } } } fn main () { }
  |                                                        ^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpDhQY2W/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn build_release () { { println ! ("🔨 Building release version...") ; run_tests () ; { let release_dir...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpDhQY2W/main.rs:1:701
  |
1 | ..._NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; ; write_file (join_path (release_dir , "install.sh" . to_string ()) , installer) ;...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error[E0425]: cannot find function `run_tests` in this scope
 --> /tmp/.tmpDhQY2W/main.rs:1:107
  |
1 | ...{ { println ! ("🔨 Building release version...") ; run_tests () ; { let release_dir = format ! ("{}{}" , "release_" , VERSION) ; { creat...
  |                                                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpDhQY2W/main.rs:1:259
  |
1 | ...e_dir) ; copy_file ("main.ruchy" . to_string () , join_path (release_dir , APP_NAME)) ; copy_dir ("resources" . to_string () , join_pa...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `copy_file` in this scope
 --> /tmp/.tmpDhQY2W/main.rs:1:218
  |
1 | ...e_" , VERSION) ; { create_dir_all (release_dir) ; copy_file ("main.ruchy" . to_string () , join_path (release_dir , APP_NAME)) ; copy_...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpDhQY2W/main.rs:1:336
  |
1 | ...P_NAME)) ; copy_dir ("resources" . to_string () , join_path (release_dir , "resources" . to_string ())) ; generate_docs (join_path (re...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `copy_dir` in this scope
 --> /tmp/.tmpDhQY2W/main.rs:1:297
  |
1 | ..._string () , join_path (release_dir , APP_NAME)) ; copy_dir ("resources" . to_string () , join_path (release_dir , "resources" . to_st...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpDhQY2W/main.rs:1:407
  |
1 | ...r , "resources" . to_string ())) ; generate_docs (join_path (release_dir , "docs" . to_string ())) ; let installer = format ! ("#!/bin...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `generate_docs` in this scope
 --> /tmp/.tmpDhQY2W/main.rs:1:392
  |
1 | ...h (release_dir , "resources" . to_string ())) ; generate_docs (join_path (release_dir , "docs" . to_string ())) ; let installer = form...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpDhQY2W/main.rs:1:715
  |
1 | ..., APP_NAME , APP_NAME , APP_NAME) ; ; write_file (join_path (release_dir , "install.sh" . to_string ()) , installer) ; create_archive ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpDhQY2W/main.rs:1:703
  |
1 | ...E , VERSION , APP_NAME , APP_NAME , APP_NAME) ; ; write_file (join_path (release_dir , "install.sh" . to_string ()) , installer) ; cre...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `create_archive` in this scope
 --> /tmp/.tmpDhQY2W/main.rs:1:784
  |
1 | ...r , "install.sh" . to_string ()) , installer) ; create_archive (format ! ("{}-{}.tar.gz" , APP_NAME , VERSION) , release_dir) ; printl...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 22 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch15-00-macros-metaprogramming example 2 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `User` in this scope
 --> /tmp/.tmpwmD2Vm/main.rs:1:59
  |
1 | use std :: collections :: HashMap ; fn debug_user (user : User) -> String { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , fo...
  |                                                           ^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpwmD2Vm/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn debug_user (user : User) -> String { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , fo...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpwmD2Vm/main.rs:1:77
  |
1 | ... { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "User { name: " , user . name) , ", age: ") , user . age . to_string ()) , " }") } } ...
  |       ^^                                                                                                                                                            ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn debug_user (user : User) -> String { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "User { name: " , user . name) , ", age: ") , user . age . to_string ()) , " }") } } fn main () { struct User { name : String , age : i32 , } ; }
1 + use std :: collections :: HashMap ; fn debug_user (user : User) -> String { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "User { name: " , user . name) , ", age: ") , user . age . to_string ()) , " }") } fn main () { struct User { name : String , age : i32 , } ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpwmD2Vm/main.rs:1:297
  |
1 | ...in () { struct User { name : String , age : i32 , } ; }
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error: aborting due to 1 previous error; 3 warnings emitted

For more information about this error, try `rustc --explain E0412`.



=== ch09-00-network-programming example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 2 ===

thread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:
"net::TcpListener" is not a valid Ident
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


=== ch09-00-network-programming example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 10 ===

thread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:
"net::PacketCapture" is not a valid Ident
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


=== ch07-00-error-handling-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `value` in this scope
 --> /tmp/.tmprStJsP/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid") } } else { { println ! ("Invalid") ...
  |                                                                  ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmprStJsP/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid") } } else { { println ! ("Invalid") ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmprStJsP/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid") } } else { { println ! ("Invalid") ...
  |                                                                                 ^^                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid") } } else { { println ! ("Invalid") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { println ! ("Valid") } else { { println ! ("Invalid") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmprStJsP/main.rs:1:114
  |
1 | ... = if value > 0i32 { { println ! ("Valid") } } else { { println ! ("Invalid") } } ; if let Some (s) = (& result as & dyn std :: any ::...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid") } } else { { println ! ("Invalid") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! ("Valid") } } else { println ! ("Invalid") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error: aborting due to 1 previous error; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `status` in this scope
 --> /tmp/.tmpYPjvzJ/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match status { 0i32 => println ! ("Error") , 1i32 => println ! ("Warning") ...
  |                                                                     ^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpYPjvzJ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match status { 0i32 => println ! ("Error") , 1i32 => println ! ("Warning") ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `age` in this scope
 --> /tmp/.tmp5hMQV3/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match age { 0i32 => println ! ("Invalid age") , 1i32 ..= 17i32 => println !...
  |                                                                     ^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp5hMQV3/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match age { 0i32 => println ! ("Invalid age") , 1i32 ..= 17i32 => println !...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 7 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `input` in this scope
 --> /tmp/.tmpbZTvqe/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed") } } els...
  |                                                                  ^^^^^ not found in this scope

error[E0425]: cannot find value `input` in this scope
 --> /tmp/.tmpbZTvqe/main.rs:1:159
  |
1 | ...ive input not allowed") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_re...
  |                                                        ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpbZTvqe/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed") } } els...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpbZTvqe/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed") } } els...
  |                                                                                 ^^                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { println ! ("Error: Negative input not allowed") } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpbZTvqe/main.rs:1:142
  |
1 | ...ln ! ("Error: Negative input not allowed") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any ::...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! ("Error: Negative input not allowed") } } else { process_input (input) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `process_input` in this scope
 --> /tmp/.tmpbZTvqe/main.rs:1:144
  |
1 | ...rror: Negative input not allowed") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . ...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 8 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `score` in this scope
 --> /tmp/.tmp7DjAyW/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match score { 0i32 ..= 59i32 => println ! ("Fail") , 60i32 ..= 79i32 => pri...
  |                                                                     ^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp7DjAyW/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match score { 0i32 ..= 59i32 => println ! ("Fail") , 60i32 ..= 79i32 => pri...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-error-handling-tdd example 9 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `system_ready` in this scope
 --> /tmp/.tmp2sIUVv/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational") } } else { { println !...
  |                                                                  ^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp2sIUVv/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational") } } else { { println !...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp2sIUVv/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational") } } else { { println !...
  |                                                                                 ^^                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational") } } else { { println ! ("System not ready") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if system_ready { println ! ("System operational") } else { { println ! ("System not ready") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp2sIUVv/main.rs:1:127
  |
1 | ...y { { println ! ("System operational") } } else { { println ! ("System not ready") } } ; if let Some (s) = (& result as & dyn std :: a...
  |                                                      ^^                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational") } } else { { println ! ("System not ready") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! ("System operational") } } else { println ! ("System not ready") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error: aborting due to 1 previous error; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch08-00-systems-programming example 1 ===
✗ Compilation failed: Compilation failed:
error[E0432]: unresolved import `std::system`
 --> /tmp/.tmpKeQkPt/main.rs:1:54
  |
1 | use std :: collections :: HashMap ; fn main () { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===") ; let ...
  |                                                      ^^^^^^^^^^^^^ no `system` in the root

error[E0425]: cannot find function `list` in module `process`
 --> /tmp/.tmpKeQkPt/main.rs:1:2283
  |
1 | ...Top Processes by CPU:") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; ; for proc in process...
  |                                                         ^^^^ not found in `process`

error[E0425]: cannot find function `sleep` in this scope
 --> /tmp/.tmpKeQkPt/main.rs:1:2609
  |
1 | ... " ") , proc . cpu_percent . to_s ()) , "%")) } } ; sleep (1000i32) } } } } ; }
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::sleep;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpKeQkPt/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===") ; let ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpKeQkPt/main.rs:1:70
  |
1 | use std :: collections :: HashMap ; fn main () { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===") ; let ...
  |                                                                      ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpKeQkPt/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn main () { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===") ; let ...
  |                                                                                             ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpKeQkPt/main.rs:1:175
  |
1 | ...or ===") ; let cpu_count = system :: cpu_count () ; ; let total_memory = system :: total_memory () ; ; let hostname = system :: hostna...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpKeQkPt/main.rs:1:224
  |
1 | ... ; ; let total_memory = system :: total_memory () ; ; let hostname = system :: hostname () ; ; let os_info = system :: os_info () ; ; ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpKeQkPt/main.rs:1:265
  |
1 | ...emory () ; ; let hostname = system :: hostname () ; ; let os_info = system :: os_info () ; ; println ! ("{:?}" , format ! ("{}{}" , "H...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpKeQkPt/main.rs:1:304
  |
1 | ...ostname () ; ; let os_info = system :: os_info () ; ; println ! ("{:?}" , format ! ("{}{}" , "Host: " , hostname)) ; println ! ("{:?}"...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpKeQkPt/main.rs:1:683
  |
1 | ... { { { let cpu_usage = system :: cpu_usage () ; { let memory_info = system :: memory_info () ; ; let disk_io = system :: disk_io_stats () ; ; let network_stats = system :: network_stats () ; ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{:?}" , "=" * 50i32) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") , "█" * cpu_usage * 50i32 . to_i ()) , "░" * 50i32 - cpu_usage * 50i32 . to_i ()) , "|")) ; let mem_percent = memory_info . used / memory_info . total ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") , "█" * mem_percent * 50i32 . to_i ()) , "░" * 50i32 - mem_percent * 50i32 . to_i ()) , "|")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") , format_size (memory_info . total))) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; ; for proc in processes { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") , proc . name) , " ") , proc . cpu_percent . to_s ()) , "%")) } } ; sleep (1000i32) } } } } ; }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===") ; let cpu_count = system :: cpu_count () ; ; let total_memory = system :: total_memory () ; ; let hostname = system :: hostname () ; ; let os_info = system :: os_info () ; ; println ! ("{:?}" , format ! ("{}{}" , "Host: " , hostname)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "OS: " , os_info . name) , " ") , os_info . version)) ; println ! ("{:?}" , format ! ("{}{}" , "CPUs: " , cpu_count . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let memory_info = system :: memory_info () ; ; let disk_io = system :: disk_io_stats () ; ; let network_stats = system :: network_stats () ; ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{:?}" , "=" * 50i32) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") , "█" * cpu_usage * 50i32 . to_i ()) , "░" * 50i32 - cpu_usage * 50i32 . to_i ()) , "|")) ; let mem_percent = memory_info . used / memory_info . total ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") , "█" * mem_percent * 50i32 . to_i ()) , "░" * 50i32 - mem_percent * 50i32 . to_i ()) , "|")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") , format_size (memory_info . total))) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; ; for proc in processes { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") , proc . name) , " ") , proc . cpu_percent . to_s ()) , "%")) } } ; sleep (1000i32) } } } } ; }
1 + use std :: collections :: HashMap ; fn main () { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===") ; let cpu_count = system :: cpu_count () ; ; let total_memory = system :: total_memory () ; ; let hostname = system :: hostname () ; ; let os_info = system :: os_info () ; ; println ! ("{:?}" , format ! ("{}{}" , "Host: " , hostname)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "OS: " , os_info . name) , " ") , os_info . version)) ; println ! ("{:?}" , format ! ("{}{}" , "CPUs: " , cpu_count . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("") ; loop { { let cpu_usage = system :: cpu_usage () ; { let memory_info = system :: memory_info () ; ; let disk_io = system :: disk_io_stats () ; ; let network_stats = system :: network_stats () ; ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{:?}" , "=" * 50i32) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") , "█" * cpu_usage * 50i32 . to_i ()) , "░" * 50i32 - cpu_usage * 50i32 . to_i ()) , "|")) ; let mem_percent = memory_info . used / memory_info . total ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") , "█" * mem_percent * 50i32 . to_i ()) , "░" * 50i32 - mem_percent * 50i32 . to_i ()) , "|")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") , format_size (memory_info . total))) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; ; for proc in processes { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") , proc . name) , " ") , proc . cpu_percent . to_s ()) , "%")) } } ; sleep (1000i32) } } } ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpKeQkPt/main.rs:1:775
  |
1 | ...() ; { let memory_info = system :: memory_info () ; ; let disk_io = system :: disk_io_stats () ; ; let network_stats = system :: netwo...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpKeQkPt/main.rs:1:820
  |
1 | ...o () ; ; let disk_io = system :: disk_io_stats () ; ; let network_stats = system :: network_stats () ; ; clear_screen () ; println ! (...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpKeQkPt/main.rs:1:871
  |
1 | ... ; let network_stats = system :: network_stats () ; ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpKeQkPt/main.rs:1:1288
  |
1 | ...ercent = memory_info . used / memory_info . total ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , for...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpKeQkPt/main.rs:1:2343
  |
1 | .... sort_by (| p | - p . cpu_percent) . take (5i32) ; ; for proc in processes { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpKeQkPt/main.rs:1:2369
  |
1 | ... { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") , proc . name) , " ") , proc . cpu_percent . to_s ()) , "%")) } } ...
  |       ^^                                                                                                                                                                                                                                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===") ; let cpu_count = system :: cpu_count () ; ; let total_memory = system :: total_memory () ; ; let hostname = system :: hostname () ; ; let os_info = system :: os_info () ; ; println ! ("{:?}" , format ! ("{}{}" , "Host: " , hostname)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "OS: " , os_info . name) , " ") , os_info . version)) ; println ! ("{:?}" , format ! ("{}{}" , "CPUs: " , cpu_count . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let memory_info = system :: memory_info () ; ; let disk_io = system :: disk_io_stats () ; ; let network_stats = system :: network_stats () ; ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{:?}" , "=" * 50i32) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") , "█" * cpu_usage * 50i32 . to_i ()) , "░" * 50i32 - cpu_usage * 50i32 . to_i ()) , "|")) ; let mem_percent = memory_info . used / memory_info . total ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") , "█" * mem_percent * 50i32 . to_i ()) , "░" * 50i32 - mem_percent * 50i32 . to_i ()) , "|")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") , format_size (memory_info . total))) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; ; for proc in processes { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") , proc . name) , " ") , proc . cpu_percent . to_s ()) , "%")) } } ; sleep (1000i32) } } } } ; }
1 + use std :: collections :: HashMap ; fn main () { use std :: system ; ; use std :: process ; ; println ! ("=== System Monitor ===") ; let cpu_count = system :: cpu_count () ; ; let total_memory = system :: total_memory () ; ; let hostname = system :: hostname () ; ; let os_info = system :: os_info () ; ; println ! ("{:?}" , format ! ("{}{}" , "Host: " , hostname)) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "OS: " , os_info . name) , " ") , os_info . version)) ; println ! ("{:?}" , format ! ("{}{}" , "CPUs: " , cpu_count . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let memory_info = system :: memory_info () ; ; let disk_io = system :: disk_io_stats () ; ; let network_stats = system :: network_stats () ; ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{:?}" , "=" * 50i32) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") , "█" * cpu_usage * 50i32 . to_i ()) , "░" * 50i32 - cpu_usage * 50i32 . to_i ()) , "|")) ; let mem_percent = memory_info . used / memory_info . total ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") , "█" * mem_percent * 50i32 . to_i ()) , "░" * 50i32 - mem_percent * 50i32 . to_i ()) , "|")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") , format_size (memory_info . total))) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by CPU:") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; ; for proc in processes { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "  " , proc . pid . to_s ()) , " ") , proc . name) , " ") , proc . cpu_percent . to_s ()) , "%")) } ; sleep (1000i32) } } } } ; }
  |

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpKeQkPt/main.rs:1:628
  |
1 | ...ntln ! ("{:?}" , format ! ("{}{}" , "Memory: " , format_size (total_memory))) ; println ! ("") ; loop { { { let cpu_usage = system :: ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `clear_screen` in this scope
 --> /tmp/.tmpKeQkPt/main.rs:1:873
  |
1 | ...t network_stats = system :: network_stats () ; ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmpKeQkPt/main.rs:1:969
  |
1 | ...tem Monitor - Press Ctrl+C to exit") ; println ! ("{:?}" , "=" * 50i32) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , fo...
  |                                                               --- ^ ----- i32
  |                                                               |
  |                                                               &str

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmpKeQkPt/main.rs:1:1163
  |
1 | ...age . to_s ()) , "% |") , "█" * cpu_usage * 50i32 . to_i ()) , "░" * 50i32 - cpu_usage * 50i32 . to_i ()) , "|")) ; let mem_percent = ...
  |                                                        ^^^^ method not found in `i32`

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpKeQkPt/main.rs:1:1137
  |
1 | ... ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "CPU: " , cpu_usage . to_s ()) , "% |") , "█" * cpu_usage * 50i32 . to_i ()) , "░" * ...
  |         -- required by this formatting parameter                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmpKeQkPt/main.rs:1:1178
  |
1 | .... to_s ()) , "% |") , "█" * cpu_usage * 50i32 . to_i ()) , "░" * 50i32 - cpu_usage * 50i32 . to_i ()) , "|")) ; let mem_percent = memo...
  |                                                               --- ^ ----- i32
  |                                                               |
  |                                                               &str

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmpKeQkPt/main.rs:1:1208
  |
1 | ...0i32 . to_i ()) , "░" * 50i32 - cpu_usage * 50i32 . to_i ()) , "|")) ; let mem_percent = memory_info . used / memory_info . total ; ; ...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmpKeQkPt/main.rs:1:1477
  |
1 | ...t . to_s ()) , "% |") , "█" * mem_percent * 50i32 . to_i ()) , "░" * 50i32 - mem_percent * 50i32 . to_i ()) , "|")) ; println ! ("{:?}...
  |                                                        ^^^^ method not found in `i32`

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpKeQkPt/main.rs:1:1449
  |
1 | ... ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "MEM: " , mem_percent . to_s ()) , "% |") , "█" * mem_percent * 50i32 . to_i ()) , "░...
  |         -- required by this formatting parameter                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmpKeQkPt/main.rs:1:1492
  |
1 | ...to_s ()) , "% |") , "█" * mem_percent * 50i32 . to_i ()) , "░" * 50i32 - mem_percent * 50i32 . to_i ()) , "|")) ; println ! ("{:?}" , ...
  |                                                               --- ^ ----- i32
  |                                                               |
  |                                                               &str

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmpKeQkPt/main.rs:1:1524
  |
1 | ...32 . to_i ()) , "░" * 50i32 - mem_percent * 50i32 . to_i ()) , "|")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , forma...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpKeQkPt/main.rs:1:1630
  |
1 | ... format ! ("{}{}" , format ! ("{}{}" , "     " , format_size (memory_info . used)) , " / ") , format_size (memory_info . total))) ; pr...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpKeQkPt/main.rs:1:1675
  |
1 | ..." , format_size (memory_info . used)) , " / ") , format_size (memory_info . total))) ; println ! ("{:?}" , format ! ("{}{}" , format !...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpKeQkPt/main.rs:1:1788
  |
1 | ... ! ("{}{}" , format ! ("{}{}" , "Disk Read:  " , format_size (disk_io . read_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" ,...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpKeQkPt/main.rs:1:1910
  |
1 | ... ! ("{}{}" , format ! ("{}{}" , "Disk Write: " , format_size (disk_io . write_bytes)) , "/s")) ; println ! ("{:?}" , format ! ("{}{}" ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpKeQkPt/main.rs:1:2031
  |
1 | ...at ! ("{}{}" , format ! ("{}{}" , "Net Down: " , format_size (network_stats . download_speed)) , "/s")) ; println ! ("{:?}" , format !...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpKeQkPt/main.rs:1:2161
  |
1 | ...at ! ("{}{}" , format ! ("{}{}" , "Net Up:   " , format_size (network_stats . upload_speed)) , "/s")) ; println ! ("\nTop Processes by...
  |                                                     ^^^^^^^^^^^ not found in this scope

error: aborting due to 20 previous errors; 14 warnings emitted

Some errors have detailed explanations: E0277, E0369, E0425, E0432, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch08-00-systems-programming example 2 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpoSy6oy/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let pid = process :: current_pid () ; ; let ppid = process :: parent_pid () ; ; let exe_...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpoSy6oy/main.rs:1:88
  |
1 | use std :: collections :: HashMap ; fn main () { let pid = process :: current_pid () ; ; let ppid = process :: parent_pid () ; ; let exe_...
  |                                                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpoSy6oy/main.rs:1:128
  |
1 | ...nt_pid () ; ; let ppid = process :: parent_pid () ; ; let exe_path = process :: executable_path () ; ; let args = process :: args () ;...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpoSy6oy/main.rs:1:177
  |
1 | ... ; ; let exe_path = process :: executable_path () ; ; let args = process :: args () ; ; let env = process :: environment () ; ; let al...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpoSy6oy/main.rs:1:211
  |
1 | ...cutable_path () ; ; let args = process :: args () ; ; let env = process :: environment () ; ; let all_processes = process :: list () ;...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpoSy6oy/main.rs:1:251
  |
1 | ...: args () ; ; let env = process :: environment () ; ; let all_processes = process :: list () ; ; for proc in all_processes { { println...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpoSy6oy/main.rs:1:294
  |
1 | ...ent () ; ; let all_processes = process :: list () ; ; for proc in all_processes { { println ! ("{:?}" , format ! ("{}{}" , format ! ("...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpoSy6oy/main.rs:1:651
  |
1 | ...process :: find_by_name ("chrome" . to_string ()) ; ; let high_cpu_procs = process :: list () . into_iter () . filter (| p | p . cpu_p...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpoSy6oy/main.rs:1:780
  |
1 | ...cpu_percent > 50i32) . collect :: < Vec < _ >> () ; ; let proc = process :: from_pid (1234i32) ; ; proc . suspend () ; proc . resume (...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpoSy6oy/main.rs:1:825
  |
1 | ...> () ; ; let proc = process :: from_pid (1234i32) ; ; proc . suspend () ; proc . resume () ; proc . terminate () ; proc . kill () ; le...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpoSy6oy/main.rs:1:974
  |
1 | ...ss :: spawn ("ls" . to_string () , vec ! ["-la"]) ; ; let output = child . wait_with_output () ; ; println ! ("{:?}" , output . stdout...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpoSy6oy/main.rs:1:1019
  |
1 | ...a"]) ; ; let output = child . wait_with_output () ; ; println ! ("{:?}" , output . stdout) ; }
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpoSy6oy/main.rs:1:324
  |
1 | ... { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "PID: " , proc . pid . to_s ()) , ", Name: ") , proc . name) , ", CPU: ") , proc . cpu_percent . to_s ()) , "%")) } } ...
  |       ^^                                                                                                                                                                                                                                                       ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let pid = process :: current_pid () ; ; let ppid = process :: parent_pid () ; ; let exe_path = process :: executable_path () ; ; let args = process :: args () ; ; let env = process :: environment () ; ; let all_processes = process :: list () ; ; for proc in all_processes { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "PID: " , proc . pid . to_s ()) , ", Name: ") , proc . name) , ", CPU: ") , proc . cpu_percent . to_s ()) , "%")) } } ; let chrome_procs = process :: find_by_name ("chrome" . to_string ()) ; ; let high_cpu_procs = process :: list () . into_iter () . filter (| p | p . cpu_percent > 50i32) . collect :: < Vec < _ >> () ; ; let proc = process :: from_pid (1234i32) ; ; proc . suspend () ; proc . resume () ; proc . terminate () ; proc . kill () ; let child = process :: spawn ("ls" . to_string () , vec ! ["-la"]) ; ; let output = child . wait_with_output () ; ; println ! ("{:?}" , output . stdout) ; }
1 + use std :: collections :: HashMap ; fn main () { let pid = process :: current_pid () ; ; let ppid = process :: parent_pid () ; ; let exe_path = process :: executable_path () ; ; let args = process :: args () ; ; let env = process :: environment () ; ; let all_processes = process :: list () ; ; for proc in all_processes { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "PID: " , proc . pid . to_s ()) , ", Name: ") , proc . name) , ", CPU: ") , proc . cpu_percent . to_s ()) , "%")) } ; let chrome_procs = process :: find_by_name ("chrome" . to_string ()) ; ; let high_cpu_procs = process :: list () . into_iter () . filter (| p | p . cpu_percent > 50i32) . collect :: < Vec < _ >> () ; ; let proc = process :: from_pid (1234i32) ; ; proc . suspend () ; proc . resume () ; proc . terminate () ; proc . kill () ; let child = process :: spawn ("ls" . to_string () , vec ! ["-la"]) ; ; let output = child . wait_with_output () ; ; println ! ("{:?}" , output . stdout) ; }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpoSy6oy/main.rs:1:60
  |
1 | use std :: collections :: HashMap ; fn main () { let pid = process :: current_pid () ; ; let ppid = process :: parent_pid () ; ; let exe_...
  |                                                            ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpoSy6oy/main.rs:1:101
  |
1 | ...ess :: current_pid () ; ; let ppid = process :: parent_pid () ; ; let exe_path = process :: executable_path () ; ; let args = process ...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpoSy6oy/main.rs:1:145
  |
1 | ... :: parent_pid () ; ; let exe_path = process :: executable_path () ; ; let args = process :: args () ; ; let env = process :: environm...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpoSy6oy/main.rs:1:190
  |
1 | ...:: executable_path () ; ; let args = process :: args () ; ; let env = process :: environment () ; ; let all_processes = process :: lis...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpoSy6oy/main.rs:1:223
  |
1 | ...s = process :: args () ; ; let env = process :: environment () ; ; let all_processes = process :: list () ; ; for proc in all_processe...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpoSy6oy/main.rs:1:273
  |
1 | ...vironment () ; ; let all_processes = process :: list () ; ; for proc in all_processes { { println ! ("{:?}" , format ! ("{}{}" , forma...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpoSy6oy/main.rs:1:599
  |
1 | ...()) , "%")) } } ; let chrome_procs = process :: find_by_name ("chrome" . to_string ()) ; ; let high_cpu_procs = process :: list () . i...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpoSy6oy/main.rs:1:674
  |
1 | ..._string ()) ; ; let high_cpu_procs = process :: list () . into_iter () . filter (| p | p . cpu_percent > 50i32) . collect :: < Vec < _...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpoSy6oy/main.rs:1:793
  |
1 | ...ct :: < Vec < _ >> () ; ; let proc = process :: from_pid (1234i32) ; ; proc . suspend () ; proc . resume () ; proc . terminate () ; pr...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmpoSy6oy/main.rs:1:917
  |
1 | ...te () ; proc . kill () ; let child = process :: spawn ("ls" . to_string () , vec ! ["-la"]) ; ; let output = child . wait_with_output ...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error: aborting due to 10 previous errors; 13 warnings emitted

For more information about this error, try `rustc --explain E0433`.



=== ch08-00-systems-programming example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-systems-programming example 4 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `_000_000` in this scope
 --> /tmp/.tmp0eolMZ/main.rs:1:551
  |
1 | ...d . to_s ())) ; if mem_info . available < 100i32 { _000_000 } ; { println ! ("WARNING: Low memory!") ; free_caches () } ; let mmap = m...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `READ_ONLY` in this scope
 --> /tmp/.tmp0eolMZ/main.rs:1:689
  |
1 | ... :: map_file ("huge_dataset.bin" . to_string () , READ_ONLY) ; ; let data = mmap . read_range (0i32 , 1000000i32) ; ; mmap . close () ...
  |                                                      ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp0eolMZ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let mem_info = system :: memory_info () ; ; println ! ("{:?}" , format ! ("{}{}" , "Tota...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmp0eolMZ/main.rs:1:92
  |
1 | use std :: collections :: HashMap ; fn main () { let mem_info = system :: memory_info () ; ; println ! ("{:?}" , format ! ("{}{}" , "Tota...
  |                                                                                            ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmp0eolMZ/main.rs:1:702
  |
1 | ...e ("huge_dataset.bin" . to_string () , READ_ONLY) ; ; let data = mmap . read_range (0i32 , 1000000i32) ; ; mmap . close () ; let share...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmp0eolMZ/main.rs:1:755
  |
1 | ... let data = mmap . read_range (0i32 , 1000000i32) ; ; mmap . close () ; let shared = memory :: create_shared ("my_buffer" . to_string ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmp0eolMZ/main.rs:1:863
  |
1 | ... ("my_buffer" . to_string () , 1024i32 * 1024i32) ; ; shared . write (0i32 , data) ; let shared = memory :: open_shared ("my_buffer" ....
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmp0eolMZ/main.rs:1:962
  |
1 | ...emory :: open_shared ("my_buffer" . to_string ()) ; ; let data = shared . read (0i32 , 1024i32) ; ; }
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmp0eolMZ/main.rs:1:1008
  |
1 | ...()) ; ; let data = shared . read (0i32 , 1024i32) ; ; }
  |                                                        ^ help: remove this semicolon

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `system`
 --> /tmp/.tmp0eolMZ/main.rs:1:65
  |
1 | use std :: collections :: HashMap ; fn main () { let mem_info = system :: memory_info () ; ; println ! ("{:?}" , format ! ("{}{}" , "Tota...
  |                                                                 ^^^^^^ use of unresolved module or unlinked crate `system`
  |
  = help: you might be missing a crate named `system`

error[E0425]: cannot find function `free_caches` in this scope
 --> /tmp/.tmp0eolMZ/main.rs:1:603
  |
1 | ...0_000 } ; { println ! ("WARNING: Low memory!") ; free_caches () } ; let mmap = memory :: map_file ("huge_dataset.bin" . to_string () ,...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `memory`
 --> /tmp/.tmp0eolMZ/main.rs:1:633
  |
1 | ...ry!") ; free_caches () } ; let mmap = memory :: map_file ("huge_dataset.bin" . to_string () , READ_ONLY) ; ; let data = mmap . read_ra...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `memory`
  |
  = help: you might be missing a crate named `memory`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `memory`
 --> /tmp/.tmp0eolMZ/main.rs:1:788
  |
1 | ...2) ; ; mmap . close () ; let shared = memory :: create_shared ("my_buffer" . to_string () , 1024i32 * 1024i32) ; ; shared . write (0i3...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `memory`
  |
  = help: you might be missing a crate named `memory`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `memory`
 --> /tmp/.tmp0eolMZ/main.rs:1:909
  |
1 | ... . write (0i32 , data) ; let shared = memory :: open_shared ("my_buffer" . to_string ()) ; ; let data = shared . read (0i32 , 1024i32)...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `memory`
  |
  = help: you might be missing a crate named `memory`

error: aborting due to 7 previous errors; 7 warnings emitted

Some errors have detailed explanations: E0425, E0433.
For more information about an error, try `rustc --explain E0425`.



=== ch08-00-systems-programming example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-systems-programming example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-systems-programming example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-systems-programming example 8 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `RECURSIVE` in this scope
 --> /tmp/.tmptca1Pp/main.rs:1:111
  |
1 | ... = fs :: watch ("/path/to/watch" . to_string () , RECURSIVE) ; ; watcher . on ("created" , | path | { println ! ("{:?}" , format ! ("{...
  |                                                      ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmptca1Pp/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let watcher = fs :: watch ("/path/to/watch" . to_string () , RECURSIVE) ; ; watcher . on...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmptca1Pp/main.rs:1:124
  |
1 | ...tch ("/path/to/watch" . to_string () , RECURSIVE) ; ; watcher . on ("created" , | path | { println ! ("{:?}" , format ! ("{}{}" , "Fil...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`
 --> /tmp/.tmptca1Pp/main.rs:1:64
  |
1 | use std :: collections :: HashMap ; fn main () { let watcher = fs :: watch ("/path/to/watch" . to_string () , RECURSIVE) ; ; watcher . on...
  |                                                                ^^ use of unresolved module or unlinked crate `fs`
  |
  = help: you might be missing a crate named `fs`

error[E0425]: cannot find function `process_change` in this scope
 --> /tmp/.tmptca1Pp/main.rs:1:339
  |
1 | ...format ! ("{}{}" , "File modified: " , path)) ; process_change (path) }) ; watcher . on ("deleted" , | path | { println ! ("{:?}" , fo...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0425, E0433.
For more information about an error, try `rustc --explain E0425`.



=== ch08-00-systems-programming example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-advanced-functions-tdd example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-advanced-functions-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `Type` in this scope
 --> /tmp/.tmptrtfRU/main.rs:1:60
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |                                                            ^^^^ not found in this scope

error[E0412]: cannot find type `ResultType` in this scope
 --> /tmp/.tmptrtfRU/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |                                                                     ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `condition1` in this scope
 --> /tmp/.tmptrtfRU/main.rs:1:87
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |                                                                                       ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `result1` in this scope
 --> /tmp/.tmptrtfRU/main.rs:1:109
  |
1 | ...: Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn m...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `condition2` in this scope
 --> /tmp/.tmptrtfRU/main.rs:1:126
  |
1 | ...ype { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `result2` in this scope
 --> /tmp/.tmptrtfRU/main.rs:1:148
  |
1 | ... { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `default_result` in this scope
 --> /tmp/.tmptrtfRU/main.rs:1:169
  |
1 | ...; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmptrtfRU/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmptrtfRU/main.rs:1:100
  |
1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...
  |                                                                                                    ^^              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
1 + use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { return result1 } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmptrtfRU/main.rs:1:139
  |
1 | ... { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
  |                                                              ^^              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }
1 + use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { return result2 } ; return default_result } } fn main () { }
  |

error: aborting due to 7 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch08-00-advanced-functions-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `Type` in this scope
 --> /tmp/.tmpv5UejM/main.rs:1:60
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |                                                            ^^^^ not found in this scope

error[E0412]: cannot find type `Type` in this scope
 --> /tmp/.tmpv5UejM/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |                                                                     ^^^^ not found in this scope

error[E0425]: cannot find value `base_condition` in this scope
 --> /tmp/.tmpv5UejM/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |                                                                                 ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `base_value` in this scope
 --> /tmp/.tmpv5UejM/main.rs:1:107
  |
1 | ... : Type) -> Type { { if base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
  |                                                      ^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpv5UejM/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpv5UejM/main.rs:1:98
  |
1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...
  |                                                                                                  ^^                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
1 + use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { return base_value } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
  |

error[E0425]: cannot find function `reduce` in this scope
 --> /tmp/.tmpv5UejM/main.rs:1:160
  |
1 | ...ase_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
  |                                                        ^^^^^^ not found in this scope

error[E0425]: cannot find function `combine` in this scope
 --> /tmp/.tmpv5UejM/main.rs:1:131
  |
1 | ... base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 6 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch08-00-advanced-functions-tdd example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 12 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch03-01-testing-functions example 1 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpAdvmLH/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn add (a : i32 , b : i32) -> i32 { { a + b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpAdvmLH/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn add (a : i32 , b : i32) -> i32 { { a + b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i...
  |                                                                         ^^     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn add (a : i32 , b : i32) -> i32 { { a + b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn add (a : i32 , b : i32) -> i32 { a + b } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) } } fn main () { }
  |

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpAdvmLH/main.rs:1:193
  |
1 | ...q ! (add (0i32 , 0i32) , 0i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) } } fn main () { }
  |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0317`.



=== ch03-01-testing-functions example 2 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `actual` in this scope
 --> /tmp/.tmp4YAt2N/main.rs:1:86
  |
1 | use std :: collections :: HashMap ; fn test_function_name () -> i32 { { assert_eq ! (actual , expected) } } fn main () { }
  |                                                                                      ^^^^^^ not found in this scope

error[E0425]: cannot find value `expected` in this scope
 --> /tmp/.tmp4YAt2N/main.rs:1:95
  |
1 | use std :: collections :: HashMap ; fn test_function_name () -> i32 { { assert_eq ! (actual , expected) } } fn main () { }
  |                                                                                               ^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp4YAt2N/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test_function_name () -> i32 { { assert_eq ! (actual , expected) } } fn main () { }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp4YAt2N/main.rs:1:71
  |
1 | use std :: collections :: HashMap ; fn test_function_name () -> i32 { { assert_eq ! (actual , expected) } } fn main () { }
  |                                                                       ^^                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_function_name () -> i32 { { assert_eq ! (actual , expected) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_function_name () -> i32 { assert_eq ! (actual , expected) } fn main () { }
  |

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmp4YAt2N/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn test_function_name () -> i32 { { assert_eq ! (actual , expected) } } fn main () { }
  |                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 3 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0317, E0425.
For more information about an error, try `rustc --explain E0317`.



=== ch03-01-testing-functions example 3 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch03-01-testing-functions example 4 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpBX3ZuU/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b ==...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpBX3ZuU/main.rs:1:78
  |
1 | use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b ==...
  |                                                                              ^^     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { a * b } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpBX3ZuU/main.rs:1:129
  |
1 | ...} } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32...
  |                                               ^^                                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { if b == 0i32 { { 0i32 } } else { { a / b } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpBX3ZuU/main.rs:1:146
  |
1 | ... b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2...
  |                                                                   ^^    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { 0i32 } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpBX3ZuU/main.rs:1:164
  |
1 | ... : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn ...
  |                                                                  ^^     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { a / b } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpBX3ZuU/main.rs:1:210
  |
1 | ...} } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (...
  |                                                             ^^                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { n % 2i32 == 0i32 } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpBX3ZuU/main.rs:1:212
  |
1 | ...{ a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32...
  |                                            ---     ^^^^^^^^^^^^^^^^ expected `i32`, found `bool`
  |                                            |
  |                                            expected `i32` because of return type

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpBX3ZuU/main.rs:1:357
  |
1 | ...tiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpBX3ZuU/main.rs:1:527
  |
1 | ... (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32))...
  |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
 --> /tmp/.tmpBX3ZuU/main.rs:1:603
  |
1 | ...0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert !...
  |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpBX3ZuU/main.rs:1:631
  |
1 | ...-> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn ...
  |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpBX3ZuU/main.rs:1:661
  |
1 | ...(4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpBX3ZuU/main.rs:1:689
  |
1 | ...(3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpBX3ZuU/main.rs:1:689
  |
1 | ... (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }
  |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |                                           |
  |                                           expected `i32`, found `()`
  |                                           found here
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type

error: aborting due to 8 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0308, E0317.
For more information about an error, try `rustc --explain E0308`.



=== ch03-01-testing-functions example 5 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpkcCRbg/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { le...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpkcCRbg/main.rs:1:77
  |
1 | ... { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } ...
  |       ^^                                                                                                                                                                                                                                                                    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpkcCRbg/main.rs:1:109
  |
1 | use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { le...
  |                                                                                                             ^^           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { - 999999i32 } else { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpkcCRbg/main.rs:1:180
  |
1 | ...lse { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < numbers . len () { { if numbers [i as usize] > ma...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpkcCRbg/main.rs:1:201
  |
1 | ...al = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = n...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpkcCRbg/main.rs:1:270
  |
1 | ... . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_fi...
  |                                                      ^^                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { max_val = numbers [i as usize] } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpkcCRbg/main.rs:1:102
  |
1 | ...nd_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize...
  |                                            ----------------    ^^^^ expected `usize`, found `i32`
  |                                            |
  |                                            expected because this is `usize`
  |
help: change the type of the numeric literal from `i32` to `usize`
  |
1 - use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0usize { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
  |

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpkcCRbg/main.rs:1:163
  |
1 | ...2 } } else { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < numbers . len () { { if numbers [i as usiz...
  |                                              ^^^^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0308]: mismatched types
 --> /tmp/.tmpkcCRbg/main.rs:1:213
  |
1 | ... as usize] ; ; let mut i = 1i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize...
  |                                              -   ^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                              |
  |                                              expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 1i32 ; ; while i < numbers . len ().try_into().unwrap() { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
  |                                                                                                                                                                                                                                     ++++++++++++++++++++

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpkcCRbg/main.rs:1:246
  |
1 | ...while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val }...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpkcCRbg/main.rs:1:291
  |
1 | ...as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0308]: mismatched types
 --> /tmp/.tmpkcCRbg/main.rs:1:398
  |
1 | ...-> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ;...
  |                            --------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `Vec<i32>`
  |                            |
  |                            arguments to this function are incorrect
  |
  = note: expected struct `String`
             found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmpkcCRbg/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { le...
  |                                        ^^^^^^^^  ----------------

error[E0308]: mismatched types
 --> /tmp/.tmpkcCRbg/main.rs:1:473
  |
1 | ...9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq !...
  |                                         --------  ^^^^^^^^^^^^^ expected `String`, found `Vec<i32>`
  |                                         |
  |                                         arguments to this function are incorrect
  |
  = note: expected struct `String`
             found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmpkcCRbg/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { le...
  |                                        ^^^^^^^^  ----------------

error[E0308]: mismatched types
 --> /tmp/.tmpkcCRbg/main.rs:1:522
  |
1 | ... (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]...
  |                                             --------  ^^^^^^^^ expected `String`, found `Vec<_>`
  |                                             |
  |                                             arguments to this function are incorrect
  |
  = note: expected struct `String`
             found struct `Vec<_>`
note: function defined here
 --> /tmp/.tmpkcCRbg/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { le...
  |                                        ^^^^^^^^  ----------------

error[E0308]: mismatched types
 --> /tmp/.tmpkcCRbg/main.rs:1:572
  |
1 | ... 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32])...
  |                               --------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `Vec<i32>`
  |                               |
  |                               arguments to this function are incorrect
  |
  = note: expected struct `String`
             found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmpkcCRbg/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { le...
  |                                        ^^^^^^^^  ----------------

error[E0308]: mismatched types
 --> /tmp/.tmpkcCRbg/main.rs:1:642
  |
1 | ...i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
  |                                   --------  ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `Vec<i32>`
  |                                   |
  |                                   arguments to this function are incorrect
  |
  = note: expected struct `String`
             found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmpkcCRbg/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { le...
  |                                        ^^^^^^^^  ----------------

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpkcCRbg/main.rs:1:619
  |
1 | ..., - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }
  |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 11 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0317.
For more information about an error, try `rustc --explain E0277`.



=== ch03-01-testing-functions example 6 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpN1lv57/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { { raw_username . replace (" " , "_") } } fn count_...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpN1lv57/main.rs:1:88
  |
1 | use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { { raw_username . replace (" " , "_") } } fn count_...
  |                                                                                        ^^                                  ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { { raw_username . replace (" " , "_") } } fn count_vowels (text : String) -> i32 { { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; ; let mut i = 0i32 ; ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_username () -> i32 { { assert_eq ! (clean_username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () -> i32 { { assert_eq ! (count_vowels ("hello" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { raw_username . replace (" " , "_") } fn count_vowels (text : String) -> i32 { { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; ; let mut i = 0i32 ; ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_username () -> i32 { { assert_eq ! (clean_username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () -> i32 { { assert_eq ! (count_vowels ("hello" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpN1lv57/main.rs:1:170
  |
1 | ... { { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; ; let mut i = 0i32 ; ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } ...
  |       ^^                                                                                                                                                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { { raw_username . replace (" " , "_") } } fn count_vowels (text : String) -> i32 { { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; ; let mut i = 0i32 ; ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_username () -> i32 { { assert_eq ! (clean_username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () -> i32 { { assert_eq ! (count_vowels ("hello" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { { raw_username . replace (" " , "_") } } fn count_vowels (text : String) -> i32 { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; ; let mut i = 0i32 ; ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } fn test_clean_username () -> i32 { { assert_eq ! (clean_username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () -> i32 { { assert_eq ! (count_vowels ("hello" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpN1lv57/main.rs:1:242
  |
1 | ...iouAEIOU" . to_string () ; { let mut count = 0i32 ; ; let mut i = 0i32 ; ; while i < text . len () { { if vowels . contains (text [i a...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpN1lv57/main.rs:1:263
  |
1 | ... () ; { let mut count = 0i32 ; ; let mut i = 0i32 ; ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count =...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpN1lv57/main.rs:1:336
  |
1 | ... len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_use...
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { { raw_username . replace (" " , "_") } } fn count_vowels (text : String) -> i32 { { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; ; let mut i = 0i32 ; ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_username () -> i32 { { assert_eq ! (clean_username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () -> i32 { { assert_eq ! (count_vowels ("hello" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { { raw_username . replace (" " , "_") } } fn count_vowels (text : String) -> i32 { { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; ; let mut i = 0i32 ; ; while i < text . len () { { if vowels . contains (text [i as usize]) { count = count + 1i32 } ; i = i + 1i32 } } ; count } } } } fn test_clean_username () -> i32 { { assert_eq ! (clean_username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () -> i32 { { assert_eq ! (count_vowels ("hello" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpN1lv57/main.rs:1:90
  |
1 | ...me (raw_username : String) -> i32 { { raw_username . replace (" " , "_") } } fn count_vowels (text : String) -> i32 { { { let vowels =...
  |                                  ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`
  |                                  |
  |                                  expected `i32` because of return type

error[E0308]: mismatched types
 --> /tmp/.tmpN1lv57/main.rs:1:275
  |
1 | ...ount = 0i32 ; ; let mut i = 0i32 ; ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } }...
  |                                               -   ^^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                               |
  |                                               expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { { raw_username . replace (" " , "_") } } fn count_vowels (text : String) -> i32 { { { let vowels = "aeiouAEIOU" . to_string () ; { let mut count = 0i32 ; ; let mut i = 0i32 ; ; while i < text . len ().try_into().unwrap() { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_username () -> i32 { { assert_eq ! (clean_username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () -> i32 { { assert_eq ! (count_vowels ("hello" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("HELLO" . to_string ()) , 2i32) ; assert_eq ! (count_vowels ("xyz" . to_string ()) , 0i32) ; assert_eq ! (count_vowels ("aeiou" . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                ++++++++++++++++++++

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpN1lv57/main.rs:1:321
  |
1 | ...t . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0308]: mismatched types
 --> /tmp/.tmpN1lv57/main.rs:1:498
  |
1 | ..._username ("Alice Johnson" . to_string ()) , "Alice_Johnson") ; assert_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert...
  |                                                 ^^^^^^^^^^^^^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpN1lv57/main.rs:1:571
  |
1 | ...t_eq ! (clean_username ("JOHN" . to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vow...
  |                                                     ^^^^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpN1lv57/main.rs:1:631
  |
1 | ... assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () -> i32 { { assert_eq ! (count_vowels ("hello" . to_...
  |                                                       ^^ expected `i32`, found `&str`

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpN1lv57/main.rs:1:581
  |
1 | ... to_string ()) , "JOHN") ; assert_eq ! (clean_username ("" . to_string ()) , "") } } fn test_count_vowels () -> i32 { { assert_eq ! (c...
  |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpN1lv57/main.rs:1:916
  |
1 | ... . to_string ()) , 5i32) ; assert_eq ! (count_vowels ("" . to_string ()) , 0i32) } } fn main () { }
  |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 8 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0317.
For more information about an error, try `rustc --explain E0277`.



=== ch03-01-testing-functions example 7 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmphNCNzd/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmphNCNzd/main.rs:1:82
  |
1 | ... { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } ...
  |       ^^                                                                                                                                                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmphNCNzd/main.rs:1:104
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32...
  |                                                                                                        ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { "A" } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmphNCNzd/main.rs:1:141
  |
1 | ...2 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { "B" } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmphNCNzd/main.rs:1:178
  |
1 | ...lse { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } }...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { "C" } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmphNCNzd/main.rs:1:215
  |
1 | ...lse { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_cit...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { "D" } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmphNCNzd/main.rs:1:232
  |
1 | ... 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) ->...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { "F" } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmphNCNzd/main.rs:1:310
  |
1 | ..._vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq !...
  |                                                        ^^                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
1 + use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { age >= 18i32 && is_citizen } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:96
  |
1 | ...de (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } }...
  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`
  |                                      |        |
  |                                      |        expected `String`, found `i32`
  |                                      expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:106
  |
1 | ...calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i3...
  |                                        ---                           ^^^ expected `i32`, found `&str`
  |                                        |
  |                                        expected `i32` because of return type

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:133
  |
1 | ...re >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } }...
  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`
  |                                      |        |
  |                                      |        expected `String`, found `i32`
  |                                      expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:143
  |
1 | ...ore : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else ...
  |                     --- expected `i32` because of return type                          ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:170
  |
1 | ...re >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vo...
  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`
  |                                      |        |
  |                                      |        expected `String`, found `i32`
  |                                      expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:180
  |
1 | ...String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if s...
  |               --- expected `i32` because of return type                                                               ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:207
  |
1 | ...re >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : Strin...
  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`
  |                                      |        |
  |                                      |        expected `String`, found `i32`
  |                                      expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:217
  |
1 | ...-> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } ...
  |       --- expected `i32` because of return type                                                                                                    ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:234
  |
1 | ...-> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } ...
  |       --- expected `i32` because of return type                                                                                                                     ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:319
  |
1 | ... , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (...
  |                                       ---    ^^^^^- help: try using a conversion method: `.to_string()`
  |                                       |      |
  |                                       |      expected `String`, found `i32`
  |                                       expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:328
  |
1 | ...ing , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grad...
  |                                          ------------    ^^^^^^^^^^ expected `bool`, found `String`
  |                                          |
  |                                          expected because this is `bool`

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:312
  |
1 | ...: String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate...
  |                                       ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `bool`
  |                                       |
  |                                       expected `i32` because of return type

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:411
  |
1 | ...de () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_gr...
  |                                  ---------------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                  |                |
  |                                  |                expected `String`, found `i32`
  |                                  arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmphNCNzd/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32...
  |                                        ^^^^^^^^^^^^^^^  --------------

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:420
  |
1 | ... -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (...
  |                                                       ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:457
  |
1 | ...(95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_gr...
  |                                  ---------------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                  |                |
  |                                  |                expected `String`, found `i32`
  |                                  arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmphNCNzd/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32...
  |                                        ^^^^^^^^^^^^^^^  --------------

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:466
  |
1 | ...2) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (...
  |                                                       ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:503
  |
1 | ...(90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_gr...
  |                                  ---------------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                  |                |
  |                                  |                expected `String`, found `i32`
  |                                  arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmphNCNzd/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32...
  |                                        ^^^^^^^^^^^^^^^  --------------

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:512
  |
1 | ...2) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (...
  |                                                       ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:549
  |
1 | ...(89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_gr...
  |                                  ---------------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                  |                |
  |                                  |                expected `String`, found `i32`
  |                                  arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmphNCNzd/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32...
  |                                        ^^^^^^^^^^^^^^^  --------------

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:558
  |
1 | ...2) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (...
  |                                                       ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:595
  |
1 | ...(80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_gr...
  |                                  ---------------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                  |                |
  |                                  |                expected `String`, found `i32`
  |                                  arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmphNCNzd/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32...
  |                                        ^^^^^^^^^^^^^^^  --------------

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:604
  |
1 | ...2) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (...
  |                                                       ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:641
  |
1 | ...(79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i...
  |                                  ---------------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                  |                |
  |                                  |                expected `String`, found `i32`
  |                                  arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmphNCNzd/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32...
  |                                        ^^^^^^^^^^^^^^^  --------------

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:650
  |
1 | ...2) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { ...
  |                                                       ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:687
  |
1 | ...(59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; as...
  |                                  ---------------  ^^^^- help: try using a conversion method: `.to_string()`
  |                                  |                |
  |                                  |                expected `String`, found `i32`
  |                                  arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmphNCNzd/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32...
  |                                        ^^^^^^^^^^^^^^^  --------------

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:695
  |
1 | ...32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert...
  |                                                       ^^^ expected `i32`, found `&str`

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmphNCNzd/main.rs:1:657
  |
1 | ...alculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i3...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmphNCNzd/main.rs:1:745
  |
1 | ...n test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , ...
  |                                            ^^^^^^^^  -----   ---- expected `String`, found `bool`
  |                                                      |
  |                                                      expected `String`, found `i32`
  |
note: function defined here
 --> /tmp/.tmphNCNzd/main.rs:1:255
  |
1 | ...2 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn...
  |                                                ^^^^^^^^  ------------   -------------------
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32.to_string() , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ++++++++++++
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true.to_string())) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:735
  |
1 | ...} } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i...
  |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmphNCNzd/main.rs:1:782
  |
1 | ...! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 ...
  |                                            ^^^^^^^^  -----   ---- expected `String`, found `bool`
  |                                                      |
  |                                                      expected `String`, found `i32`
  |
note: function defined here
 --> /tmp/.tmphNCNzd/main.rs:1:255
  |
1 | ...2 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn...
  |                                                ^^^^^^^^  ------------   -------------------
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32.to_string() , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ++++++++++++
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true.to_string())) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:772
  |
1 | ...sert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (2...
  |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmphNCNzd/main.rs:1:821
  |
1 | ...(can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32...
  |                                            ^^^^^^^^  -----   ---- expected `String`, found `bool`
  |                                                      |
  |                                                      expected `String`, found `i32`
  |
note: function defined here
 --> /tmp/.tmphNCNzd/main.rs:1:255
  |
1 | ...2 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn...
  |                                                ^^^^^^^^  ------------   -------------------
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32.to_string() , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ++++++++++++
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true.to_string())) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:809
  |
1 | ...ert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote ...
  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmphNCNzd/main.rs:1:860
  |
1 | ...can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                           ^^^^^^^^  -----   ----- expected `String`, found `bool`
  |                                                     |
  |                                                     expected `String`, found `i32`
  |
note: function defined here
 --> /tmp/.tmphNCNzd/main.rs:1:255
  |
1 | ...2 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn...
  |                                                ^^^^^^^^  ------------   -------------------
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32.to_string() , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ++++++++++++
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false.to_string())) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:848
  |
1 | ...t ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmphNCNzd/main.rs:1:900
  |
1 | ...an_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                           ^^^^^^^^  -----   ----- expected `String`, found `bool`
  |                                                     |
  |                                                     expected `String`, found `i32`
  |
note: function defined here
 --> /tmp/.tmphNCNzd/main.rs:1:255
  |
1 | ...2 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn...
  |                                                ^^^^^^^^  ------------   -------------------
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32.to_string() , false)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ++++++++++++
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , "A") ; assert_eq ! (calculate_grade (90i32) , "A") ; assert_eq ! (calculate_grade (89i32) , "B") ; assert_eq ! (calculate_grade (80i32) , "B") ; assert_eq ! (calculate_grade (79i32) , "C") ; assert_eq ! (calculate_grade (59i32) , "F") ; assert_eq ! (calculate_grade (0i32) , "F") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false.to_string())) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmphNCNzd/main.rs:1:888
  |
1 | ... ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmphNCNzd/main.rs:1:888
  |
1 | ...t ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }
  |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |                                       |
  |                                       expected `i32`, found `()`
  |                                       found here
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type

error: aborting due to 38 previous errors; 8 warnings emitted

Some errors have detailed explanations: E0308, E0317.
For more information about an error, try `rustc --explain E0308`.



=== ch03-01-testing-functions example 8 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpl4H8Xk/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test_fahrenheit_to_celsius () -> i32 { { assert_eq ! (fahrenheit_to_celsius (32i32) , 0i32) ; asse...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpl4H8Xk/main.rs:1:304
  |
1 | ...t_to_celsius (fahrenheit : String) -> i32 { { return (fahrenheit - 32i32) * 5i32 / 9i32 } } fn main () { }
  |                                                ^^                                         ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_fahrenheit_to_celsius () -> i32 { { assert_eq ! (fahrenheit_to_celsius (32i32) , 0i32) ; assert_eq ! (fahrenheit_to_celsius (212i32) , 100i32) ; assert_eq ! (fahrenheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius (fahrenheit : String) -> i32 { { return (fahrenheit - 32i32) * 5i32 / 9i32 } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_fahrenheit_to_celsius () -> i32 { { assert_eq ! (fahrenheit_to_celsius (32i32) , 0i32) ; assert_eq ! (fahrenheit_to_celsius (212i32) , 100i32) ; assert_eq ! (fahrenheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius (fahrenheit : String) -> i32 { return (fahrenheit - 32i32) * 5i32 / 9i32 } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpl4H8Xk/main.rs:1:117
  |
1 | ...() -> i32 { { assert_eq ! (fahrenheit_to_celsius (32i32) , 0i32) ; assert_eq ! (fahrenheit_to_celsius (212i32) , 100i32) ; assert_eq !...
  |                               ---------------------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                               |                      |
  |                               |                      expected `String`, found `i32`
  |                               arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpl4H8Xk/main.rs:1:251
  |
1 | ...renheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius (fahrenheit : String) -> i32 { { return (fahrenheit - 32i32) * 5i32...
  |                                                 ^^^^^^^^^^^^^^^^^^^^^  -------------------

error[E0308]: mismatched types
 --> /tmp/.tmpl4H8Xk/main.rs:1:170
  |
1 | ...2) , 0i32) ; assert_eq ! (fahrenheit_to_celsius (212i32) , 100i32) ; assert_eq ! (fahrenheit_to_celsius (98.6f64) , 37i32) } } fn fahr...
  |                              ---------------------  ^^^^^^- help: try using a conversion method: `.to_string()`
  |                              |                      |
  |                              |                      expected `String`, found `i32`
  |                              arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpl4H8Xk/main.rs:1:251
  |
1 | ...renheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius (fahrenheit : String) -> i32 { { return (fahrenheit - 32i32) * 5i32...
  |                                                 ^^^^^^^^^^^^^^^^^^^^^  -------------------

error[E0308]: mismatched types
 --> /tmp/.tmpl4H8Xk/main.rs:1:226
  |
1 | ... , 100i32) ; assert_eq ! (fahrenheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius (fahrenheit : String) -> i32 { { retur...
  |                              ---------------------  ^^^^^^^- help: try using a conversion method: `.to_string()`
  |                              |                      |
  |                              |                      expected `String`, found `f64`
  |                              arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpl4H8Xk/main.rs:1:251
  |
1 | ...renheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius (fahrenheit : String) -> i32 { { return (fahrenheit - 32i32) * 5i32...
  |                                                 ^^^^^^^^^^^^^^^^^^^^^  -------------------

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpl4H8Xk/main.rs:1:190
  |
1 | ...lsius (212i32) , 100i32) ; assert_eq ! (fahrenheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius (fahrenheit : String) ->...
  |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0369]: cannot subtract `i32` from `String`
   --> /tmp/.tmpl4H8Xk/main.rs:1:325
    |
1   | ...eit_to_celsius (fahrenheit : String) -> i32 { { return (fahrenheit - 32i32) * 5i32 / 9i32 } } fn main () { }
    |                                                            ---------- ^ ----- i32
    |                                                            |
    |                                                            String
    |
note: the foreign item type `String` doesn't implement `Sub<i32>`
   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:360:1
    |
360 | pub struct String {
    | ^^^^^^^^^^^^^^^^^ not implement `Sub<i32>`

error: aborting due to 5 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0308, E0317, E0369.
For more information about an error, try `rustc --explain E0308`.



=== ch03-01-testing-functions example 9 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpbZ98nK/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test_divide_bad () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) } } fn test_divide_good (...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpbZ98nK/main.rs:1:68
  |
1 | use std :: collections :: HashMap ; fn test_divide_bad () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) } } fn test_divide_good (...
  |                                                                    ^^                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_divide_bad () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) } } fn test_divide_good () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (0i32 , 5i32) , 0i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_divide_bad () -> i32 { assert_eq ! (divide (10i32 , 2i32) , 5i32) } fn test_divide_good () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (0i32 , 5i32) , 0i32) } } fn main () { }
  |

error[E0425]: cannot find function `divide` in this scope
 --> /tmp/.tmpbZ98nK/main.rs:1:83
  |
1 | use std :: collections :: HashMap ; fn test_divide_bad () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) } } fn test_divide_good (...
  |                                                                                   ^^^^^^ not found in this scope

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpbZ98nK/main.rs:1:70
  |
1 | ...n test_divide_bad () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) } } fn test_divide_good () -> i32 { { assert_eq ! (divide (...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `divide` in this scope
 --> /tmp/.tmpbZ98nK/main.rs:1:164
  |
1 | ... } } fn test_divide_good () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (0i32 , 5i32) , 0i32) } } fn m...
  |                                                        ^^^^^^ not found in this scope

error[E0425]: cannot find function `divide` in this scope
 --> /tmp/.tmpbZ98nK/main.rs:1:209
  |
1 | ..._eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (0i32 , 5i32) , 0i32) } } fn main () { }
  |                                                        ^^^^^^ not found in this scope

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpbZ98nK/main.rs:1:196
  |
1 | ...(divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (0i32 , 5i32) , 0i32) } } fn main () { }
  |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 5 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0317, E0425.
For more information about an error, try `rustc --explain E0317`.



=== ch03-01-testing-functions example 10 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp95F6Z8/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn te...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp95F6Z8/main.rs:1:65
  |
1 | use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn te...
  |                                                                 ^^                                                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_useless () -> i32 { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp95F6Z8/main.rs:1:160
  |
1 | ...sult > 0i32) } } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
  |                                                  ^^                                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () -> i32 { assert_eq ! (add (2i32 , 3i32) , 5i32) } fn main () { }
  |

error[E0425]: cannot find function `add` in this scope
 --> /tmp/.tmp95F6Z8/main.rs:1:82
  |
1 | use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn te...
  |                                                                                  ^^^ not found in this scope
  |
help: use the `.` operator to call the method `Add::add` on `i32`
  |
1 - use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = 2i32.add(3i32) ; assert ! (result > 0i32) } } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
  |

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmp95F6Z8/main.rs:1:102
  |
1 | ...2 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , ...
  |                                             ^^^^^^^^^^^^^^^^^^^^^^^^
  |                                             |
  |                                             expected `i32`, found `()`
  |                                             found here
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type

error[E0425]: cannot find function `add` in this scope
 --> /tmp/.tmp95F6Z8/main.rs:1:175
  |
1 | ...i32) } } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
  |                                                         ^^^ not found in this scope
  |
help: use the `.` operator to call the method `Add::add` on `i32`
  |
1 - use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () -> i32 { { assert_eq ! (2i32.add(3i32) , 5i32) } } fn main () { }
  |

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmp95F6Z8/main.rs:1:162
  |
1 | ... } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }
  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 4 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0317, E0425.
For more information about an error, try `rustc --explain E0317`.



=== ch03-01-testing-functions example 11 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp04pf73/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test1 () -> i32 { { assert_eq ! (is_valid ("abc" . to_string ()) , false) } } fn test_password_too...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp04pf73/main.rs:1:58
  |
1 | use std :: collections :: HashMap ; fn test1 () -> i32 { { assert_eq ! (is_valid ("abc" . to_string ()) , false) } } fn test_password_too...
  |                                                          ^^                                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test1 () -> i32 { { assert_eq ! (is_valid ("abc" . to_string ()) , false) } } fn test_password_too_short () -> i32 { { assert_eq ! (is_valid_password ("abc" . to_string ()) , false) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test1 () -> i32 { assert_eq ! (is_valid ("abc" . to_string ()) , false) } fn test_password_too_short () -> i32 { { assert_eq ! (is_valid_password ("abc" . to_string ()) , false) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp04pf73/main.rs:1:157
  |
1 | ...st_password_too_short () -> i32 { { assert_eq ! (is_valid_password ("abc" . to_string ()) , false) } } fn main () { }
  |                                      ^^                                                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test1 () -> i32 { { assert_eq ! (is_valid ("abc" . to_string ()) , false) } } fn test_password_too_short () -> i32 { { assert_eq ! (is_valid_password ("abc" . to_string ()) , false) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test1 () -> i32 { { assert_eq ! (is_valid ("abc" . to_string ()) , false) } } fn test_password_too_short () -> i32 { assert_eq ! (is_valid_password ("abc" . to_string ()) , false) } fn main () { }
  |

error[E0425]: cannot find function `is_valid` in this scope
 --> /tmp/.tmp04pf73/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn test1 () -> i32 { { assert_eq ! (is_valid ("abc" . to_string ()) , false) } } fn test_password_too...
  |                                                                         ^^^^^^^^ not found in this scope

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmp04pf73/main.rs:1:60
  |
1 | ...p ; fn test1 () -> i32 { { assert_eq ! (is_valid ("abc" . to_string ()) , false) } } fn test_password_too_short () -> i32 { { assert_e...
  |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `is_valid_password` in this scope
 --> /tmp/.tmp04pf73/main.rs:1:172
  |
1 | ...password_too_short () -> i32 { { assert_eq ! (is_valid_password ("abc" . to_string ()) , false) } } fn main () { }
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmp04pf73/main.rs:1:159
  |
1 | ...o_short () -> i32 { { assert_eq ! (is_valid_password ("abc" . to_string ()) , false) } } fn main () { }
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 4 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0317, E0425.
For more information about an error, try `rustc --explain E0317`.



=== ch03-01-testing-functions example 12 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpjLJin7/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn test_is_strong_password () -> i32 { { assert ! (is_strong_password ("MyPass123!" . to_string ())) ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpjLJin7/main.rs:1:413
  |
1 | ...assword : String) -> i32 { { if password . len () < 8i32 { { return false } } ; { let has_digit = password . chars () . any (| c | c ....
  |                                                               ^^            ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn test_is_strong_password () -> i32 { { assert ! (is_strong_password ("MyPass123!" . to_string ())) ; assert ! (! is_strong_password ("weak" . to_string ())) ; assert ! (! is_strong_password ("NoNumbers!" . to_string ())) ; assert ! (! is_strong_password ("nonumbers123" . to_string ())) } } fn is_strong_password (password : String) -> i32 { { if password . len () < 8i32 { { return false } } ; { let has_digit = password . chars () . any (| c | c . is_digit ()) ; { let has_special = password . chars () . any (| c | "!@#$%^&*" . contains (c)) ; ; return has_digit && has_special } } } } fn test_password_edge_cases () -> i32 { { assert ! (! is_strong_password ("" . to_string ())) ; assert ! (! is_strong_password ("12345678" . to_string ())) ; assert ! (! is_strong_password ("!!!!!!!!" . to_string ())) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_is_strong_password () -> i32 { { assert ! (is_strong_password ("MyPass123!" . to_string ())) ; assert ! (! is_strong_password ("weak" . to_string ())) ; assert ! (! is_strong_password ("NoNumbers!" . to_string ())) ; assert ! (! is_strong_password ("nonumbers123" . to_string ())) } } fn is_strong_password (password : String) -> i32 { { if password . len () < 8i32 { return false } ; { let has_digit = password . chars () . any (| c | c . is_digit ()) ; { let has_special = password . chars () . any (| c | "!@#$%^&*" . contains (c)) ; ; return has_digit && has_special } } } } fn test_password_edge_cases () -> i32 { { assert ! (! is_strong_password ("" . to_string ())) ; assert ! (! is_strong_password ("12345678" . to_string ())) ; assert ! (! is_strong_password ("!!!!!!!!" . to_string ())) } } fn main () { }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpjLJin7/main.rs:1:586
  |
1 | ... chars () . any (| c | "!@#$%^&*" . contains (c)) ; ; return has_digit && has_special } } } } fn test_password_edge_cases () -> i32 { ...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error[E0308]: mismatched types
 --> /tmp/.tmpjLJin7/main.rs:1:78
  |
1 | ...password () -> i32 { { assert ! (is_strong_password ("MyPass123!" . to_string ())) ; assert ! (! is_strong_password ("weak" . to_strin...
  |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpjLJin7/main.rs:1:140
  |
1 | ...123!" . to_string ())) ; assert ! (! is_strong_password ("weak" . to_string ())) ; assert ! (! is_strong_password ("NoNumbers!" . to_s...
  |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpjLJin7/main.rs:1:198
  |
1 | ...k" . to_string ())) ; assert ! (! is_strong_password ("NoNumbers!" . to_string ())) ; assert ! (! is_strong_password ("nonumbers123" ....
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpjLJin7/main.rs:1:262
  |
1 | ..." . to_string ())) ; assert ! (! is_strong_password ("nonumbers123" . to_string ())) } } fn is_strong_password (password : String) -> ...
  |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpjLJin7/main.rs:1:262
  |
1 | ...!" . to_string ())) ; assert ! (! is_strong_password ("nonumbers123" . to_string ())) } } fn is_strong_password (password : String) ->...
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |                          |
  |                          expected `i32`, found `()`
  |                          found here
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type

error[E0308]: mismatched types
 --> /tmp/.tmpjLJin7/main.rs:1:406
  |
1 | ...sword (password : String) -> i32 { { if password . len () < 8i32 { { return false } } ; { let has_digit = password . chars () . any (|...
  |                                            -----------------   ^^^^ expected `usize`, found `i32`
  |                                            |
  |                                            expected because this is `usize`
  |
help: change the type of the numeric literal from `i32` to `usize`
  |
1 - use std :: collections :: HashMap ; fn test_is_strong_password () -> i32 { { assert ! (is_strong_password ("MyPass123!" . to_string ())) ; assert ! (! is_strong_password ("weak" . to_string ())) ; assert ! (! is_strong_password ("NoNumbers!" . to_string ())) ; assert ! (! is_strong_password ("nonumbers123" . to_string ())) } } fn is_strong_password (password : String) -> i32 { { if password . len () < 8i32 { { return false } } ; { let has_digit = password . chars () . any (| c | c . is_digit ()) ; { let has_special = password . chars () . any (| c | "!@#$%^&*" . contains (c)) ; ; return has_digit && has_special } } } } fn test_password_edge_cases () -> i32 { { assert ! (! is_strong_password ("" . to_string ())) ; assert ! (! is_strong_password ("12345678" . to_string ())) ; assert ! (! is_strong_password ("!!!!!!!!" . to_string ())) } } fn main () { }
1 + use std :: collections :: HashMap ; fn test_is_strong_password () -> i32 { { assert ! (is_strong_password ("MyPass123!" . to_string ())) ; assert ! (! is_strong_password ("weak" . to_string ())) ; assert ! (! is_strong_password ("NoNumbers!" . to_string ())) ; assert ! (! is_strong_password ("nonumbers123" . to_string ())) } } fn is_strong_password (password : String) -> i32 { { if password . len () < 8usize { { return false } } ; { let has_digit = password . chars () . any (| c | c . is_digit ()) ; { let has_special = password . chars () . any (| c | "!@#$%^&*" . contains (c)) ; ; return has_digit && has_special } } } } fn test_password_edge_cases () -> i32 { { assert ! (! is_strong_password ("" . to_string ())) ; assert ! (! is_strong_password ("12345678" . to_string ())) ; assert ! (! is_strong_password ("!!!!!!!!" . to_string ())) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpjLJin7/main.rs:1:422
  |
1 | ...rd (password : String) -> i32 { { if password . len () < 8i32 { { return false } } ; { let has_digit = password . chars () . any (| c ...
  |                              --- expected `i32` because of return type      ^^^^^ expected `i32`, found `bool`

error[E0061]: this method takes 1 argument but 0 arguments were supplied
   --> /tmp/.tmpjLJin7/main.rs:1:489
    |
1   | ...git = password . chars () . any (| c | c . is_digit ()) ; { let has_special = password . chars () . any (| c | "!@#$%^&*" . contains (...
    |                                               ^^^^^^^^--- argument #1 of type `u32` is missing
    |
note: method defined here
   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/char/methods.rs:343:18
    |
343 |     pub const fn is_digit(self, radix: u32) -> bool {
    |                  ^^^^^^^^
help: provide the argument
    |
1   | use std :: collections :: HashMap ; fn test_is_strong_password () -> i32 { { assert ! (is_strong_password ("MyPass123!" . to_string ())) ; assert ! (! is_strong_password ("weak" . to_string ())) ; assert ! (! is_strong_password ("NoNumbers!" . to_string ())) ; assert ! (! is_strong_password ("nonumbers123" . to_string ())) } } fn is_strong_password (password : String) -> i32 { { if password . len () < 8i32 { { return false } } ; { let has_digit = password . chars () . any (| c | c . is_digit(/* u32 */)) ; { let has_special = password . chars () . any (| c | "!@#$%^&*" . contains (c)) ; ; return has_digit && has_special } } } } fn test_password_edge_cases () -> i32 { { assert ! (! is_strong_password ("" . to_string ())) ; assert ! (! is_strong_password ("12345678" . to_string ())) ; assert ! (! is_strong_password ("!!!!!!!!" . to_string ())) } } fn main () { }
    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ~~~~~~~~~~~

error[E0308]: mismatched types
 --> /tmp/.tmpjLJin7/main.rs:1:670
  |
1 | ...d_edge_cases () -> i32 { { assert ! (! is_strong_password ("" . to_string ())) ; assert ! (! is_strong_password ("12345678" . to_strin...
  |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpjLJin7/main.rs:1:724
  |
1 | ...("" . to_string ())) ; assert ! (! is_strong_password ("12345678" . to_string ())) ; assert ! (! is_strong_password ("!!!!!!!!" . to_s...
  |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpjLJin7/main.rs:1:786
  |
1 | ...78" . to_string ())) ; assert ! (! is_strong_password ("!!!!!!!!" . to_string ())) } } fn main () { }
  |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpjLJin7/main.rs:1:786
  |
1 | ...678" . to_string ())) ; assert ! (! is_strong_password ("!!!!!!!!" . to_string ())) } } fn main () { }
  |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |                            |
  |                            expected `i32`, found `()`
  |                            found here
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type

error: aborting due to 12 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0061, E0308, E0317.
For more information about an error, try `rustc --explain E0061`.



=== ch16-00-testing-quality example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 2 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch14-00-concurrency example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 12 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 13 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch04-00-command-line-tools example 1 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpdEn1g6/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { println ! ("Word Counter Tool") ; print ! ("Enter filename: ") ; let filename = { let mu...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpdEn1g6/main.rs:1:359
  |
1 | .... ends_with ('\r') { input . pop () ; } } input } ; ; let content = read_file (filename) ; ; let words = content . split_whitespace ()...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpdEn1g6/main.rs:1:398
  |
1 | ... } input } ; ; let content = read_file (filename) ; ; let words = content . split_whitespace () ; ; let word_count = words . len () ; ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpdEn1g6/main.rs:1:444
  |
1 | ...me) ; ; let words = content . split_whitespace () ; ; let word_count = words . len () ; ; let char_count = content . len () ; ; let li...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpdEn1g6/main.rs:1:480
  |
1 | ...whitespace () ; ; let word_count = words . len () ; ; let char_count = content . len () ; ; let line_count = content . lines () . len ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpdEn1g6/main.rs:1:518
  |
1 | ...ds . len () ; ; let char_count = content . len () ; ; let line_count = content . lines () . len () ; ; println ! ("{:?}" , format ! ("...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpdEn1g6/main.rs:1:567
  |
1 | ... ; ; let line_count = content . lines () . len () ; ; println ! ("{:?}" , format ! ("{}{}" , "\nFile Analysis: " , filename)) ; printl...
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpdEn1g6/main.rs:1:375
  |
1 | ... { input . pop () ; } } input } ; ; let content = read_file (filename) ; ; let words = content . split_whitespace () ; ; let word_coun...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 7 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 2 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpVxfGJi/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let name = { print ! ("{}" , "What's your name? ") ; std :: io :: Write :: flush (& mut ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpVxfGJi/main.rs:1:403
  |
1 | .... ends_with ('\r') { input . pop () ; } } input } ; ; let age = { print ! ("{}" , "How old are you? ") ; std :: io :: Write :: flush (...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpVxfGJi/main.rs:1:766
  |
1 | ...h ('\r') { input . pop () ; } } input } . to_i () ; ; let is_student = { print ! ("{}" , "Are you a student? (y/n) ") ; std :: io :: W...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpVxfGJi/main.rs:1:1141
  |
1 | ...with ('\r') { input . pop () ; } } input } == "y" ; ; }
  |                                                        ^ help: remove this semicolon

error[E0599]: no method named `to_i` found for struct `String` in the current scope
 --> /tmp/.tmpVxfGJi/main.rs:1:756
  |
1 | ...ends_with ('\r') { input . pop () ; } } input } . to_i () ; ; let is_student = { print ! ("{}" , "Are you a student? (y/n) ") ; std ::...
  |                                                      ^^^^ method not found in `String`

error: aborting due to 1 previous error; 4 warnings emitted

For more information about this error, try `rustc --explain E0599`.



=== ch04-00-command-line-tools example 3 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpuwLnfp/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let content = read_file ("data.txt" . to_string ()) ; ; let lines = read_lines ("data.tx...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpuwLnfp/main.rs:1:104
  |
1 | use std :: collections :: HashMap ; fn main () { let content = read_file ("data.txt" . to_string ()) ; ; let lines = read_lines ("data.tx...
  |                                                                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpuwLnfp/main.rs:1:159
  |
1 | ...et lines = read_lines ("data.txt" . to_string ()) ; ; write_file ("output.txt" . to_string () , "Hello, World!" . to_string ()) ; appe...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpuwLnfp/main.rs:1:386
  |
1 | ...xists = file_exists ("config.txt" . to_string ()) ; ; let size = file_size ("data.txt" . to_string ()) ; ; }
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpuwLnfp/main.rs:1:439
  |
1 | ... let size = file_size ("data.txt" . to_string ()) ; ; }
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpuwLnfp/main.rs:1:64
  |
1 | use std :: collections :: HashMap ; fn main () { let content = read_file ("data.txt" . to_string ()) ; ; let lines = read_lines ("data.tx...
  |                                                                ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_lines` in this scope
 --> /tmp/.tmpuwLnfp/main.rs:1:118
  |
1 | ..._file ("data.txt" . to_string ()) ; ; let lines = read_lines ("data.txt" . to_string ()) ; ; write_file ("output.txt" . to_string () ,...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpuwLnfp/main.rs:1:161
  |
1 | ...ines = read_lines ("data.txt" . to_string ()) ; ; write_file ("output.txt" . to_string () , "Hello, World!" . to_string ()) ; append_f...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `timestamp` in this scope
 --> /tmp/.tmpuwLnfp/main.rs:1:312
  |
1 | ...to_string () , format ! ("{}{}" , "New entry: " , timestamp ())) ; let exists = file_exists ("config.txt" . to_string ()) ; ; let size...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `append_file` in this scope
 --> /tmp/.tmpuwLnfp/main.rs:1:237
  |
1 | ...to_string () , "Hello, World!" . to_string ()) ; append_file ("log.txt" . to_string () , format ! ("{}{}" , "New entry: " , timestamp ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpuwLnfp/main.rs:1:342
  |
1 | ... , "New entry: " , timestamp ())) ; let exists = file_exists ("config.txt" . to_string ()) ; ; let size = file_size ("data.txt" . to_s...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_size` in this scope
 --> /tmp/.tmpuwLnfp/main.rs:1:399
  |
1 | ...ists ("config.txt" . to_string ()) ; ; let size = file_size ("data.txt" . to_string ()) ; ; }
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 7 previous errors; 5 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 4 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpwreN0j/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let args = command_args () ; ; let program_name = args [0i32 as usize] ; ; let first_fil...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpwreN0j/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn main () { let args = command_args () ; ; let program_name = args [0i32 as usize] ; ; let first_fil...
  |                                                                               ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpwreN0j/main.rs:1:123
  |
1 | ...gs () ; ; let program_name = args [0i32 as usize] ; ; let first_file = args [1i32 as usize] ; ; let second_file = args [2i32 as usize]...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpwreN0j/main.rs:1:165
  |
1 | ... usize] ; ; let first_file = args [1i32 as usize] ; ; let second_file = args [2i32 as usize] ; ; println ! ("{:?}" , format ! ("{}{}" ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpwreN0j/main.rs:1:208
  |
1 | ...usize] ; ; let second_file = args [2i32 as usize] ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Pr...
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `command_args` in this scope
 --> /tmp/.tmpwreN0j/main.rs:1:61
  |
1 | use std :: collections :: HashMap ; fn main () { let args = command_args () ; ; let program_name = args [0i32 as usize] ; ; let first_fil...
  |                                                             ^^^^^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 5 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `exit` in this scope
 --> /tmp/.tmpA9cUlV/main.rs:1:585
  |
1 | ..." , "Error: File '" , filename) , "' not found!")) ; exit (1i32) } } ; let content = read_file (filename) ; ; let lines = content . li...
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::process::exit;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpA9cUlV/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { println ! ("=== Text Processor ===") ; let filename = { print ! ("{}" , "Enter filename:...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpA9cUlV/main.rs:1:444
  |
1 | .... ends_with ('\r') { input . pop () ; } } input } ; ; if ! file_exists (filename) { { println ! ("{:?}" , format ! ("{}{}" , format ! ...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpA9cUlV/main.rs:1:640
  |
1 | ...t (1i32) } } ; let content = read_file (filename) ; ; let lines = content . lines () ; ; println ! ("\nChoose operation:") ; println !...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpA9cUlV/main.rs:1:675
  |
1 | ...ile (filename) ; ; let lines = content . lines () ; ; println ! ("\nChoose operation:") ; println ! ("1. Count lines") ; println ! ("2...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpA9cUlV/main.rs:1:1225
  |
1 | ...h ('\r') { input . pop () ; } } input } . to_i () ; ; let result = match choice { 1i32 => { println ! ("{:?}" , format ! ("{}{}" , "To...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpA9cUlV/main.rs:1:2060
  |
1 | .... ends_with ('\r') { input . pop () ; } } input } ; ; let new_content = content . replace (find , replace) ; ; let output_file = filen...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpA9cUlV/main.rs:1:2117
  |
1 | ... new_content = content . replace (find , replace) ; ; let output_file = filename . replace (".txt" , "_modified.txt") ; ; write_file (...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpA9cUlV/main.rs:1:2185
  |
1 | ...e = filename . replace (".txt" , "_modified.txt") ; ; write_file (output_file , new_content) ; println ! ("{:?}" , format ! ("{}{}" , ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpA9cUlV/main.rs:1:2429
  |
1 | ...file = filename . replace (".txt" , "_upper.txt") ; ; write_file (output_file , upper_content) ; println ! ("{:?}" , format ! ("{}{}" ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpA9cUlV/main.rs:1:2735
  |
1 | ...{ let clean_content = clean_lines . join (& "\n") ; ; let output_file = filename . replace (".txt" , "_clean.txt") ; ; write_file (out...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpA9cUlV/main.rs:1:2800
  |
1 | ...file = filename . replace (".txt" , "_clean.txt") ; ; write_file (output_file , clean_content) ; println ! ("{:?}" , format ! ("{}{}" ...
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpA9cUlV/main.rs:1:451
  |
1 | ...h ('\r') { input . pop () ; } } input } ; ; if ! file_exists (filename) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpA9cUlV/main.rs:1:617
  |
1 | ...' not found!")) ; exit (1i32) } } ; let content = read_file (filename) ; ; let lines = content . lines () ; ; println ! ("\nChoose ope...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0599]: no method named `to_i` found for struct `String` in the current scope
 --> /tmp/.tmpA9cUlV/main.rs:1:1215
  |
1 | ...ends_with ('\r') { input . pop () ; } } input } . to_i () ; ; let result = match choice { 1i32 => { println ! ("{:?}" , format ! ("{}{...
  |                                                      ^^^^ method not found in `String`

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpA9cUlV/main.rs:1:2187
  |
1 | ...filename . replace (".txt" , "_modified.txt") ; ; write_file (output_file , new_content) ; println ! ("{:?}" , format ! ("{}{}" , "Sav...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpA9cUlV/main.rs:1:2431
  |
1 | ... = filename . replace (".txt" , "_upper.txt") ; ; write_file (output_file , upper_content) ; println ! ("{:?}" , format ! ("{}{}" , "S...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpA9cUlV/main.rs:1:2802
  |
1 | ... = filename . replace (".txt" , "_clean.txt") ; ; write_file (output_file , clean_content) ; println ! ("{:?}" , format ! ("{}{}" , "S...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpA9cUlV/main.rs:1:3100
  |
1 | .... contains ("&str") => println ! ("{}" , result) , _ => println ! ("{:?}" , result) } }
  |                                       --    ^^^^^^ `()` cannot be formatted with the default formatter
  |                                       |
  |                                       required by this formatting parameter
  |
  = help: the trait `std::fmt::Display` is not implemented for `()`
  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 8 previous errors; 11 warnings emitted

Some errors have detailed explanations: E0277, E0425, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch04-00-command-line-tools example 6 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmplQH8pA/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { println ! ("=== Log Analyzer ===") ; let log_file = { print ! ("{}" , "Enter log file pa...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmplQH8pA/main.rs:1:447
  |
1 | .... ends_with ('\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; le...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmplQH8pA/main.rs:1:485
  |
1 | ...} } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_c...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmplQH8pA/main.rs:1:525
  |
1 | ...log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmplQH8pA/main.rs:1:554
  |
1 | ...sts = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmplQH8pA/main.rs:1:581
  |
1 | ...t success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (" 200 "...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmplQH8pA/main.rs:1:612
  |
1 | ...error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } }...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmplQH8pA/main.rs:1:901
  |
1 | ...percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_perc...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmplQH8pA/main.rs:1:963
  |
1 | ...r_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmplQH8pA/main.rs:1:1033
  |
1 | ...rcent = not_found_count * 100i32 / total_requests ; ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmplQH8pA/main.rs:1:1764
  |
1 | ...ercent . to_s ()) , "%)")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [times...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmplQH8pA/main.rs:1:1984
  |
1 | ...usiest_hour = hour_counts . max_by_value () . key ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , bus...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmplQH8pA/main.rs:1:634
  |
1 | ... { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ...
  |       ^^                                                                                                                                                                                                  ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { println ! ("=== Log Analyzer ===") ; let log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") , success_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") , not_found_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") , error_percent . to_s ()) , "%)")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) ; }
1 + use std :: collections :: HashMap ; fn main () { println ! ("=== Log Analyzer ===") ; let log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") , success_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") , not_found_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") , error_percent . to_s ()) , "%)")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmplQH8pA/main.rs:1:667
  |
1 | ... for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_co...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { println ! ("=== Log Analyzer ===") ; let log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") , success_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") , not_found_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") , error_percent . to_s ()) , "%)")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) ; }
1 + use std :: collections :: HashMap ; fn main () { println ! ("=== Log Analyzer ===") ; let log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (" 200 ") { success_count += 1i32 } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") , success_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") , not_found_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") , error_percent . to_s ()) , "%)")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmplQH8pA/main.rs:1:733
  |
1 | ...nt += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count...
  |                                                         ^^                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { println ! ("=== Log Analyzer ===") ; let log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") , success_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") , not_found_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") , error_percent . to_s ()) , "%)")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) ; }
1 + use std :: collections :: HashMap ; fn main () { println ! ("=== Log Analyzer ===") ; let log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { not_found_count += 1i32 } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") , success_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") , not_found_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") , error_percent . to_s ()) , "%)")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmplQH8pA/main.rs:1:801
  |
1 | ...ount += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i3...
  |                                                           ^^                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { println ! ("=== Log Analyzer ===") ; let log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") , success_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") , not_found_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") , error_percent . to_s ()) , "%)")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) ; }
1 + use std :: collections :: HashMap ; fn main () { println ! ("=== Log Analyzer ===") ; let log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { error_count += 1i32 } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") , success_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") , not_found_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") , error_percent . to_s ()) , "%)")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmplQH8pA/main.rs:1:1786
  |
1 | ... { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ...
  |       ^^                                                                                                                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { println ! ("=== Log Analyzer ===") ; let log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") , success_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") , not_found_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") , error_percent . to_s ()) , "%)")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) ; }
1 + use std :: collections :: HashMap ; fn main () { println ! ("=== Log Analyzer ===") ; let log_file = { print ! ("{}" , "Enter log file path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! ("\n=== Analysis Results ===") ; println ! ("{:?}" , format ! ("{}{}" , "Total Requests: " , total_requests . to_s ())) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") , success_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") , not_found_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") , error_percent . to_s ()) , "%)")) ; let hour_counts = () ; ; for line in lines { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "Busiest Hour: " , busiest_hour . to_s ()) , ":00")) ; }
  |

error[E0425]: cannot find function `read_lines` in this scope
 --> /tmp/.tmplQH8pA/main.rs:1:461
  |
1 | ...') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count ...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmplQH8pA/main.rs:1:1299
  |
1 | ...mat ! ("{}{}" , "Success (200): " , success_count . to_s ()) , " (") , success_percent . to_s ()) , "%)")) ; println ! ("{:?}" , forma...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmplQH8pA/main.rs:1:1336
  |
1 | ...uccess_count . to_s ()) , " (") , success_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , form...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmplQH8pA/main.rs:1:1492
  |
1 | ...! ("{}{}" , "Not Found (404): " , not_found_count . to_s ()) , " (") , not_found_percent . to_s ()) , "%)")) ; println ! ("{:?}" , for...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmplQH8pA/main.rs:1:1531
  |
1 | ...ound_count . to_s ()) , " (") , not_found_percent . to_s ()) , "%)")) ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , form...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmplQH8pA/main.rs:1:1686
  |
1 | ... ! ("{}{}" , "Server Error (500): " , error_count . to_s ()) , " (") , error_percent . to_s ()) , "%)")) ; let hour_counts = () ; ; fo...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmplQH8pA/main.rs:1:1721
  |
1 | ... , error_count . to_s ()) , " (") , error_percent . to_s ()) , "%)")) ; let hour_counts = () ; ; for line in lines { { { let timestamp...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `extract_hour` in this scope
 --> /tmp/.tmplQH8pA/main.rs:1:1806
  |
1 | ...= () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `get` found for unit type `()` in the current scope
    --> /tmp/.tmplQH8pA/main.rs:1:1877
     |
1    | ...t_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = ...
     |                                                                     ^^^
     |
help: there is a method `ge` with a similar name, but with different arguments
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1438:5
     |
1438 |     fn ge(&self, other: &Rhs) -> bool {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `max_by_value` found for unit type `()` in the current scope
 --> /tmp/.tmplQH8pA/main.rs:1:1960
  |
1 | ...+ 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "B...
  |                                                    ^^^^^^^^^^^^ method not found in `()`

error: aborting due to 10 previous errors; 17 warnings emitted

Some errors have detailed explanations: E0425, E0599.
For more information about an error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 7 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpeN5fg1/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { println ! ("=== Batch File Renamer ===") ; let directory = { print ! ("{}" , "Enter dire...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpeN5fg1/main.rs:1:455
  |
1 | .... ends_with ('\r') { input . pop () ; } } input } ; ; let pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write ...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpeN5fg1/main.rs:1:818
  |
1 | .... ends_with ('\r') { input . pop () ; } } input } ; ; let replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpeN5fg1/main.rs:1:1181
  |
1 | .... ends_with ('\r') { input . pop () ; } } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpeN5fg1/main.rs:1:1220
  |
1 | ... } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { { if file . contains (pattern) ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpeN5fg1/main.rs:1:1249
  |
1 | ...st_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { { if file . contains (pattern) { { { let new_name = file . r...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpeN5fg1/main.rs:1:1271
  |
1 | ... { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") , new_name)) ; renamed_count += 1i32 } } else { { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { println ! ("=== Batch File Renamer ===") ; let directory = { print ! ("{}" , "Enter directory path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") , new_name)) ; renamed_count += 1i32 } } else { { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) ; }
1 + use std :: collections :: HashMap ; fn main () { println ! ("=== Batch File Renamer ===") ; let directory = { print ! ("{}" , "Enter directory path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") , new_name)) ; renamed_count += 1i32 } } else { { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpeN5fg1/main.rs:1:1304
  |
1 | ... { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") , new_name)) ; renamed_count += 1i32 } } else { { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { println ! ("=== Batch File Renamer ===") ; let directory = { print ! ("{}" , "Enter directory path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") , new_name)) ; renamed_count += 1i32 } } else { { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) ; }
1 + use std :: collections :: HashMap ; fn main () { println ! ("=== Batch File Renamer ===") ; let directory = { print ! ("{}" , "Enter directory path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { { if file . contains (pattern) { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") , new_name)) ; renamed_count += 1i32 } } else { { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpeN5fg1/main.rs:1:1412
  |
1 | ...) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , n...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpeN5fg1/main.rs:1:1464
  |
1 | ...; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpeN5fg1/main.rs:1:1662
  |
1 | ...named_count += 1i32 } } else { { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ; println ! ("{:...
  |                                   ^^                                                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { println ! ("=== Batch File Renamer ===") ; let directory = { print ! ("{}" , "Enter directory path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") , new_name)) ; renamed_count += 1i32 } } else { { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) ; }
1 + use std :: collections :: HashMap ; fn main () { println ! ("=== Batch File Renamer ===") ; let directory = { print ! ("{}" , "Enter directory path: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let pattern = { print ! ("{}" , "Enter pattern to find: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let replacement = { print ! ("{}" , "Enter replacement: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Renamed: " , file) , " -> ") , new_name)) ; renamed_count += 1i32 } } else { println ! ("{:?}" , format ! ("{}{}" , "Failed to rename: " , file)) } } } } } } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) ; }
  |

error[E0425]: cannot find function `list_files` in this scope
 --> /tmp/.tmpeN5fg1/main.rs:1:1195
  |
1 | ...') { input . pop () ; } } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { { if fil...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpeN5fg1/main.rs:1:1381
  |
1 | ...eplace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ;...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpeN5fg1/main.rs:1:1429
  |
1 | ...ory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! ("{:?}" , forma...
  |                                   ^^^^^^^^^ help: a local variable with a similar name exists: `old_path`

error[E0425]: cannot find function `rename_file` in this scope
 --> /tmp/.tmpeN5fg1/main.rs:1:1469
  |
1 | ...w_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! ("{:?}" , format ! ("{}{}" , format !...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpeN5fg1/main.rs:1:1840
  |
1 | ..., format ! ("{}{}" , "\nRenamed " , renamed_count . to_s ()) , " files")) ; }
  |                                                        ^^^^ method not found in `i32`

error: aborting due to 5 previous errors; 11 warnings emitted

Some errors have detailed explanations: E0425, E0599.
For more information about an error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 8 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch04-00-command-line-tools example 9 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `sleep` in this scope
 --> /tmp/.tmpVnH4Pi/main.rs:1:860
  |
1 | ... to_s ()) , "%] ") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } ...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::sleep;
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpVnH4Pi/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ;...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpVnH4Pi/main.rs:1:542
  |
1 | ... { { { let total = files . len () ; { let mut i = 0i32 ; ; while i < total { { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress (files : String) { { { let total = files . len () ; { let mut i = 0i32 ; ; while i < total { { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress (files : String) { { let total = files . len () ; { let mut i = 0i32 ; ; while i < total { { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } fn main () { }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpVnH4Pi/main.rs:1:596
  |
1 | ...{ let total = files . len () ; { let mut i = 0i32 ; ; while i < total { { { let file = files [i as usize] ; { let progress = (i + 1i32...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpVnH4Pi/main.rs:1:616
  |
1 | ... { { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress (files : String) { { { let total = files . len () ; { let mut i = 0i32 ; ; while i < total { { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } } fn main () { }
1 + use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress (files : String) { { { let total = files . len () ; { let mut i = 0i32 ; ; while i < total { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } ; println ! ("\n✅ All files processed!") } } } } fn main () { }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpVnH4Pi/main.rs:1:699
  |
1 | ...e] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "\rPr...
  |                                                        ^ help: remove this semicolon

error[E0308]: mismatched types
 --> /tmp/.tmpVnH4Pi/main.rs:1:608
  |
1 | ... files . len () ; { let mut i = 0i32 ; ; while i < total { { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / ...
  |                                                   -   ^^^^^ expected `i32`, found `usize`
  |                                                   |
  |                                                   expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress (files : String) { { { let total = files . len () ; { let mut i = 0i32 ; ; while i < total.try_into().unwrap() { { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ++++++++++++++++++++

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpVnH4Pi/main.rs:1:638
  |
1 | ... ; while i < total { { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! ("{:?}" , format ! (...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0308]: mismatched types
 --> /tmp/.tmpVnH4Pi/main.rs:1:691
  |
1 | ... usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , ...
  |                                                     ^^^^^ expected `i32`, found `usize`

error[E0277]: cannot divide `i32` by `usize`
 --> /tmp/.tmpVnH4Pi/main.rs:1:689
  |
1 | ...s usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" ,...
  |                                                    ^ no implementation for `i32 / usize`
  |
  = help: the trait `Div<usize>` is not implemented for `i32`
  = help: the following other types implement trait `Div<Rhs>`:
            `&i32` implements `Div<i32>`
            `&i32` implements `Div`
            `i32` implements `Div<&i32>`
            `i32` implements `Div`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpVnH4Pi/main.rs:1:809
  |
1 | ...format ! ("{}{}" , "\rProcessing... [" , progress . to_s ()) , "%] ") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 }...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `process_file` in this scope
 --> /tmp/.tmpVnH4Pi/main.rs:1:838
  |
1 | ...... [" , progress . to_s ()) , "%] ") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All file...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error: aborting due to 7 previous errors; 5 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0425, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch04-00-command-line-tools example 10 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp5kL0Kr/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; ; l...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp5kL0Kr/main.rs:1:50
  |
1 | ... { { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {:?} {}" , "File has" , lines , "lines") } } } }
  |       ^^                                                                                                                                                                                                                                                                                      ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {:?} {}" , "File has" , lines , "lines") } } } }
1 + use std :: collections :: HashMap ; fn main () { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {:?} {}" , "File has" , lines , "lines") } } }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmp5kL0Kr/main.rs:1:135
  |
1 | ...\nline 3" . to_string () ; { let mut lines = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len () { { if content [i as usize] == '...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmp5kL0Kr/main.rs:1:156
  |
1 | ... () ; { let mut lines = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len () { { if content [i as usize] == '\n' { { lines = lines...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmp5kL0Kr/main.rs:1:223
  |
1 | ...content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {:?} {}" , "File...
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {:?} {}" , "File has" , lines , "lines") } } } }
1 + use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len () { { if content [i as usize] == '\n' { lines = lines + 1i32 } ; i = i + 1i32 } } ; println ! ("{} {:?} {}" , "File has" , lines , "lines") } } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp5kL0Kr/main.rs:1:168
  |
1 | ...nes = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = ...
  |                                              -   ^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                              |
  |                                              expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn main () { { { let content = "line 1\nline 2\nline 3" . to_string () ; { let mut lines = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len ().try_into().unwrap() { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {:?} {}" , "File has" , lines , "lines") } } } }
  |                                                                                                                                                                                        ++++++++++++++++++++

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmp5kL0Kr/main.rs:1:201
  |
1 | ...while i < content . len () { { if content [i as usize] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {:?} {...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error: aborting due to 2 previous errors; 5 warnings emitted

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.



=== ch04-00-command-line-tools example 11 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `TASK_FILE` in this scope
 --> /tmp/.tmpCiTakd/main.rs:1:288
  |
1 | ...) } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `TASK_FILE` in this scope
 --> /tmp/.tmpCiTakd/main.rs:1:322
  |
1 | ...if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `TASK_FILE` in this scope
 --> /tmp/.tmpCiTakd/main.rs:1:453
  |
1 | ...let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty ()...
  |                                                      ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpCiTakd/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpCiTakd/main.rs:1:301
  |
1 | ..._tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : Str...
  |                                                      ^^                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { return read_lines (TASK_FILE) } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpCiTakd/main.rs:1:399
  |
1 | ...s (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : St...
  |                                ^^                                                                          ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpCiTakd/main.rs:1:730
  |
1 | ...n () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpCiTakd/main.rs:1:759
  |
1 | ... { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } }...
  |       ^^                                                                                                                                                                                                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpCiTakd/main.rs:1:878
  |
1 | ..._with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , "....
  |                                                         ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpCiTakd/main.rs:1:840
  |
1 | ...s [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}...
  |                                                                   ^^      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { "DONE" } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpCiTakd/main.rs:1:860
  |
1 | ... status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}"...
  |                                                                 ^^         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { "PENDING" } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpCiTakd/main.rs:1:1029
  |
1 | ... { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpCiTakd/main.rs:1:2141
  |
1 | ...) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" ...
  |                                                    ^^                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { println ! ("❌ Invalid task number") } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpCiTakd/main.rs:1:2247
  |
1 | ...n () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! (...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpCiTakd/main.rs:1:2277
  |
1 | ...txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; ...
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpCiTakd/main.rs:1:275
  |
1 | ...! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } f...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_lines` in this scope
 --> /tmp/.tmpCiTakd/main.rs:1:310
  |
1 | ... -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0599]: no method named `join` found for struct `String` in the current scope
 --> /tmp/.tmpCiTakd/main.rs:1:425
  |
1 | ...asks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String...
  |                                                      ^^^^ method not found in `String`

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpCiTakd/main.rs:1:441
  |
1 | ...> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks ....
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0599]: no method named `to_s` found for type `usize` in the current scope
 --> /tmp/.tmpCiTakd/main.rs:1:685
  |
1 | ... ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let ta...
  |                                                        ^^^^ method not found in `usize`

error[E0308]: mismatched types
 --> /tmp/.tmpCiTakd/main.rs:1:742
  |
1 | ... " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_wi...
  |                                               -   ^^^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                               |
  |                                               expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len ().try_into().unwrap() { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ++++++++++++++++++++

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpCiTakd/main.rs:1:781
  |
1 | ...i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" }...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpCiTakd/main.rs:1:949
  |
1 | ... , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { ...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `push` found for type `i32` in the current scope
 --> /tmp/.tmpCiTakd/main.rs:1:1409
  |
1 | ...h ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task...
  |                                                        ^^^^ method not found in `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpCiTakd/main.rs:1:1466
  |
1 | ...! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (...
  |                                     ----------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                     |           |
  |                                     |           expected `String`, found `i32`
  |                                     arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpCiTakd/main.rs:1:362
  |
1 | ... read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; wr...
  |                                                         ^^^^^^^^^^  --------------

error[E0308]: mismatched types
 --> /tmp/.tmpCiTakd/main.rs:1:1558
  |
1 | ...complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: ...
  |                                    ----------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                    |           |
  |                                    |           expected `String`, found `i32`
  |                                    arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpCiTakd/main.rs:1:483
  |
1 | ...(& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No task...
  |                                                         ^^^^^^^^^^  --------------

error[E0599]: no method named `to_i` found for struct `String` in the current scope
 --> /tmp/.tmpCiTakd/main.rs:1:1941
  |
1 | ...ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usiz...
  |                                                      ^^^^ method not found in `String`

error[E0599]: no method named `len` found for type `i32` in the current scope
    --> /tmp/.tmpCiTakd/main.rs:1:1994
     |
1    | ...} input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (...
     |                                                                     ^^^
     |
help: there is a method `le` with a similar name, but with different arguments
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1402:5
     |
1402 |     fn le(&self, other: &Rhs) -> bool {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
 --> /tmp/.tmpCiTakd/main.rs:1:2089
  |
1 | ... usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } ...
  |                                      ----------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                      |           |
  |                                      |           expected `String`, found `i32`
  |                                      arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpCiTakd/main.rs:1:362
  |
1 | ... read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; wr...
  |                                                         ^^^^^^^^^^  --------------

error[E0308]: mismatched types
 --> /tmp/.tmpCiTakd/main.rs:1:2674
  |
1 | ...'\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (task...
  |                                                 ------   ^^^ expected `String`, found `&str`
  |                                                 |
  |                                                 this expression has type `String`

error[E0308]: mismatched types
 --> /tmp/.tmpCiTakd/main.rs:1:2702
  |
1 | .... pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { ...
  |                                   ------                               ^^^ expected `String`, found `&str`
  |                                   |
  |                                   this expression has type `String`

error[E0308]: mismatched types
 --> /tmp/.tmpCiTakd/main.rs:1:2728
  |
1 | ...} input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (t...
  |                      ------ this expression has type `String`                       ^^^ expected `String`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpCiTakd/main.rs:1:2759
  |
1 | ...nput } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (task...
  |                   ------ this expression has type `String`                                                      ^^^ expected `String`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpCiTakd/main.rs:1:3318
  |
1 | ...ch choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" =>...
  |       ------ this expression has type `String`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^^^ expected `String`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpCiTakd/main.rs:1:2693
  |
1 | ...input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tas...
  |                                    ----------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                    |           |
  |                                    |           expected `String`, found `i32`
  |                                    arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpCiTakd/main.rs:1:483
  |
1 | ...(& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No task...
  |                                                         ^^^^^^^^^^  --------------

error[E0308]: mismatched types
 --> /tmp/.tmpCiTakd/main.rs:1:2780
  |
1 | ...omplete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :...
  |                                    ----------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                    |           |
  |                                    |           expected `String`, found `i32`
  |                                    arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpCiTakd/main.rs:1:483
  |
1 | ...(& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No task...
  |                                                         ^^^^^^^^^^  --------------

error[E0599]: no method named `to_i` found for struct `String` in the current scope
 --> /tmp/.tmpCiTakd/main.rs:1:3159
  |
1 | ...ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (inde...
  |                                                      ^^^^ method not found in `String`

error[E0599]: no method named `len` found for type `i32` in the current scope
    --> /tmp/.tmpCiTakd/main.rs:1:3212
     |
1    | ...} input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("...
     |                                                                     ^^^
     |
help: there is a method `le` with a similar name, but with different arguments
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1402:5
     |
1402 |     fn le(&self, other: &Rhs) -> bool {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `remove` found for type `i32` in the current scope
 --> /tmp/.tmpCiTakd/main.rs:1:3231
  |
1 | ...- 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task dele...
  |                                                                    ^^^^^^
  |
help: there is a method `rem` with a similar name
  |
1 - use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + use std :: collections :: HashMap ; fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , "\n📋 Your Tasks (" , tasks . len () . to_s ()) , " items):")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , i + 1i32 . to_s () , ". ") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! ("{}" , "\nWhat do you want to add? ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; { tasks . push (format ! ("{}{}" , "📌 " , new_task)) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! ("{}" , "\nWhich task to complete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! ("{}" , "\nChoose option: ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = { print ! ("{}" , "Which task to delete? (number): ") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect ("Failed to read input") ; if input . ends_with ('\n') { input . pop () ; if input . ends_with ('\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . rem (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpCiTakd/main.rs:1:3260
  |
1 | ...() { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!")...
  |                                    ----------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                    |           |
  |                                    |           expected `String`, found `i32`
  |                                    arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpCiTakd/main.rs:1:362
  |
1 | ... read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& "\n") ; wr...
  |                                                         ^^^^^^^^^^  --------------

error: aborting due to 28 previous errors; 12 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0425, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch04-00-command-line-tools example 14 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found `let` statement
 --> /tmp/.tmpF16Sfc/main.rs:1:63
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let data = read_file ("/Users/noah/Desktop/data.txt" . to_string ()) ; ; if...
  |                                                               ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpF16Sfc/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let data = read_file ("/Users/noah/Desktop/data.txt" . to_string ()) ; ; if...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpF16Sfc/main.rs:1:134
  |
1 | ...e ("/Users/noah/Desktop/data.txt" . to_string ()) ; ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < Stri...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpF16Sfc/main.rs:1:74
  |
1 | use std :: collections :: HashMap ; fn main () { let result = let data = read_file ("/Users/noah/Desktop/data.txt" . to_string ()) ; ; if...
  |                                                                          ^^^^^^^^^ not found in this scope

error: aborting due to 2 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch12-00-traits-generics example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch03-00-functions-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `return_type` in this scope
 --> /tmp/.tmpHW3caK/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }
  |                                                                               ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `return_expression` in this scope
 --> /tmp/.tmpHW3caK/main.rs:1:95
  |
1 | use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }
  |                                                                                               ^^^^^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpHW3caK/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpHW3caK/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }
  |                                                                                             ^^                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }
1 + use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { return_expression } fn main () { }
  |

error: aborting due to 2 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch11-00-file-operations-tdd example 4 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `DataType` in this scope
 --> /tmp/.tmpsb9n53/main.rs:1:56
  |
1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
  |                                                        ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `default_value` in this scope
 --> /tmp/.tmpsb9n53/main.rs:1:76
  |
1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
  |                                                                            ^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpsb9n53/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpsb9n53/main.rs:1:67
  |
1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
  |                                                                   ^^                    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }
1 + use std :: collections :: HashMap ; fn read_data () -> DataType { return default_value } fn main () { }
  |

error: aborting due to 2 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch11-00-file-operations-tdd example 5 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `DataType` in this scope
 --> /tmp/.tmpNKaH0o/main.rs:1:60
  |
1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...
  |                                                            ^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpNKaH0o/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpNKaH0o/main.rs:1:101
  |
1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...
  |                                                                                                     ^^           ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } fn main () { }
1 + use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { return true } ; return false } } fn main () { }
  |

error[E0425]: cannot find function `valid` in this scope
 --> /tmp/.tmpNKaH0o/main.rs:1:85
  |
1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...
  |                                                                                     ^^^^^ not found in this scope

error: aborting due to 2 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch11-00-file-operations-tdd example 6 ===
✗ Compilation failed: Compilation failed:
error[E0412]: cannot find type `ConfigType` in this scope
 --> /tmp/.tmpFCGXJh/main.rs:1:58
  |
1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...
  |                                                          ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `default_config` in this scope
 --> /tmp/.tmpFCGXJh/main.rs:1:80
  |
1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...
  |                                                                                ^^^^^^^^^^^^^^ not found in this scope

error[E0412]: cannot find type `ConfigType` in this scope
 --> /tmp/.tmpFCGXJh/main.rs:1:124
  |
1 | ...eturn default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
  |                                                      ^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpFCGXJh/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpFCGXJh/main.rs:1:71
  |
1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...
  |                                                                       ^^                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
1 + use std :: collections :: HashMap ; fn load_config () -> ConfigType { return default_config } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpFCGXJh/main.rs:1:146
  |
1 | ...g } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
  |                                                         ^^                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
1 + use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { return validate (config) } fn main () { }
  |

error[E0425]: cannot find function `validate` in this scope
 --> /tmp/.tmpFCGXJh/main.rs:1:155
  |
1 | ...ve_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }
  |                                                       ^^^^^^^^ not found in this scope

error: aborting due to 4 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0412, E0425.
For more information about an error, try `rustc --explain E0412`.



=== ch11-00-file-operations-tdd example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-control-flow-tdd example 8 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `condition` in this scope
 --> /tmp/.tmpBEOaFd/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if condition { () } else { if other_condition { () } else { () } } ; if let...
  |                                                                  ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `other_condition` in this scope
 --> /tmp/.tmpBEOaFd/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if condition { () } else { if other_condition { () } else { () } } ; if let...
  |                                                                                             ^^^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpBEOaFd/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if condition { () } else { if other_condition { () } else { () } } ; if let...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 9 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `condition` in this scope
 --> /tmp/.tmp6twYMo/main.rs:1:56
  |
1 | use std :: collections :: HashMap ; fn main () { while condition { () } ; for variable in start .. end { () } ; }
  |                                                        ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `start` in this scope
 --> /tmp/.tmp6twYMo/main.rs:1:91
  |
1 | use std :: collections :: HashMap ; fn main () { while condition { () } ; for variable in start .. end { () } ; }
  |                                                                                           ^^^^^ not found in this scope

error[E0425]: cannot find value `end` in this scope
 --> /tmp/.tmp6twYMo/main.rs:1:100
  |
1 | use std :: collections :: HashMap ; fn main () { while condition { () } ; for variable in start .. end { () } ; }
  |                                                                                                    ^^^ not found in this scope
  |
help: you might have meant to write `.` instead of `..`
  |
1 - use std :: collections :: HashMap ; fn main () { while condition { () } ; for variable in start .. end { () } ; }
1 + use std :: collections :: HashMap ; fn main () { while condition { () } ; for variable in start.end { () } ; }
  |

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp6twYMo/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { while condition { () } ; for variable in start .. end { () } ; }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 3 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 10 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `value` in this scope
 --> /tmp/.tmpFkfAkr/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match value { pattern1 => action1 , pattern2 => action2 , _ => default_acti...
  |                                                                     ^^^^^ not found in this scope

error[E0425]: cannot find value `action1` in this scope
 --> /tmp/.tmpFkfAkr/main.rs:1:89
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match value { pattern1 => action1 , pattern2 => action2 , _ => default_acti...
  |                                                                                         ^^^^^^^ not found in this scope

error[E0425]: cannot find value `action2` in this scope
 --> /tmp/.tmpFkfAkr/main.rs:1:111
  |
1 | ... = match value { pattern1 => action1 , pattern2 => action2 , _ => default_action , } ; if let Some (s) = (& result as & dyn std :: any...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `default_action` in this scope
 --> /tmp/.tmpFkfAkr/main.rs:1:126
  |
1 | ...attern1 => action1 , pattern2 => action2 , _ => default_action , } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcas...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpFkfAkr/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match value { pattern1 => action1 , pattern2 => action2 , _ => default_acti...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 4 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 11 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `user_input` in this scope
 --> /tmp/.tmpUTSZoM/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...
  |                                                                  ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `threshold` in this scope
 --> /tmp/.tmpUTSZoM/main.rs:1:79
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...
  |                                                                               ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpUTSZoM/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpUTSZoM/main.rs:1:91
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...
  |                                                                                           ^^                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { process_high_value () } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpUTSZoM/main.rs:1:126
  |
1 | ...put > threshold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :...
  |                                                         ^^                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { process_normal_value () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `process_high_value` in this scope
 --> /tmp/.tmpUTSZoM/main.rs:1:93
  |
1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...
  |                                                                                             ^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `process_normal_value` in this scope
 --> /tmp/.tmpUTSZoM/main.rs:1:128
  |
1 | ...shold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . d...
  |                                                 ^^^^^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 4 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 12 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpnXAiXF/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let mut count = 0i32 ; ; while count < 10i32 { { do_something () ; count = count + 1i32 ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpnXAiXF/main.rs:1:73
  |
1 | use std :: collections :: HashMap ; fn main () { let mut count = 0i32 ; ; while count < 10i32 { { do_something () ; count = count + 1i32 ...
  |                                                                         ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error[E0425]: cannot find function `do_something` in this scope
 --> /tmp/.tmpnXAiXF/main.rs:1:99
  |
1 | use std :: collections :: HashMap ; fn main () { let mut count = 0i32 ; ; while count < 10i32 { { do_something () ; count = count + 1i32 ...
  |                                                                                                   ^^^^^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 14 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `status_code` in this scope
 --> /tmp/.tmpDINxaZ/main.rs:1:69
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match status_code { 200i32 => println ! ("Success") , 404i32 => println ! (...
  |                                                                     ^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpDINxaZ/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let result = match status_code { 200i32 => println ! ("Success") , 404i32 => println ! (...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== appendix-c-troubleshooting example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 6 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp1g1f50/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let s = String :: from ("hello" . to_string ()) ; ; takes_ownership (s) ; println ! ("{:...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmp1g1f50/main.rs:1:100
  |
1 | use std :: collections :: HashMap ; fn main () { let s = String :: from ("hello" . to_string ()) ; ; takes_ownership (s) ; println ! ("{:...
  |                                                                                                    ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmp1g1f50/main.rs:1:199
  |
1 | ...; let s = String :: from ("hello" . to_string ()) ; ; takes_ownership (s . clone ()) ; println ! ("{:?}" , s) ; let s = String :: from...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmp1g1f50/main.rs:1:309
  |
1 | ...; let s = String :: from ("hello" . to_string ()) ; ; borrows_value (& s) ; println ! ("{:?}" , s) ; }
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `takes_ownership` in this scope
 --> /tmp/.tmp1g1f50/main.rs:1:102
  |
1 | ... = String :: from ("hello" . to_string ()) ; ; takes_ownership (s) ; println ! ("{:?}" , s) ; let s = String :: from ("hello" . to_str...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `takes_ownership` in this scope
 --> /tmp/.tmp1g1f50/main.rs:1:201
  |
1 | ... = String :: from ("hello" . to_string ()) ; ; takes_ownership (s . clone ()) ; println ! ("{:?}" , s) ; let s = String :: from ("hell...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `borrows_value` in this scope
 --> /tmp/.tmp1g1f50/main.rs:1:311
  |
1 | ...s = String :: from ("hello" . to_string ()) ; ; borrows_value (& s) ; println ! ("{:?}" , s) ; }
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors; 4 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== appendix-c-troubleshooting example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 9 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpGWkyy9/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let v = vec ! [1i32 , 2i32 , 3i32] ; ; let item = v [5i32 as usize] ; ; let v = vec ! [1...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpGWkyy9/main.rs:1:87
  |
1 | use std :: collections :: HashMap ; fn main () { let v = vec ! [1i32 , 2i32 , 3i32] ; ; let item = v [5i32 as usize] ; ; let v = vec ! [1...
  |                                                                                       ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpGWkyy9/main.rs:1:120
  |
1 | ...2 , 2i32 , 3i32] ; ; let item = v [5i32 as usize] ; ; let v = vec ! [1i32 , 2i32 , 3i32] ; ; match v . get (5i32) . cloned () { Some (...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpGWkyy9/main.rs:1:159
  |
1 | ... as usize] ; ; let v = vec ! [1i32 , 2i32 , 3i32] ; ; match v . get (5i32) . cloned () { Some (item) => println ! ("{:?} {:?}" , forma...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpGWkyy9/main.rs:1:381
  |
1 | ...item) = v . get (5i32) . cloned () { { println ! ("{:?} {:?}" , format ! ("Item: {{}}") , item) } } ; match std :: any :: type_name_of...
  |                                         ^^                                                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { let v = vec ! [1i32 , 2i32 , 3i32] ; ; let item = v [5i32 as usize] ; ; let v = vec ! [1i32 , 2i32 , 3i32] ; ; match v . get (5i32) . cloned () { Some (item) => println ! ("{:?} {:?}" , format ! ("Item: {{}}") , item) , None => println ! ("Index out of bounds") , } ; let result = if let Some (item) = v . get (5i32) . cloned () { { println ! ("{:?} {:?}" , format ! ("Item: {{}}") , item) } } ; match std :: any :: type_name_of_val (& result) { name if name . contains ("String") || name . contains ("&str") => println ! ("{}" , result) , _ => println ! ("{:?}" , result) } }
1 + use std :: collections :: HashMap ; fn main () { let v = vec ! [1i32 , 2i32 , 3i32] ; ; let item = v [5i32 as usize] ; ; let v = vec ! [1i32 , 2i32 , 3i32] ; ; match v . get (5i32) . cloned () { Some (item) => println ! ("{:?} {:?}" , format ! ("Item: {{}}") , item) , None => println ! ("Index out of bounds") , } ; let result = if let Some (item) = v . get (5i32) . cloned () { println ! ("{:?} {:?}" , format ! ("Item: {{}}") , item) } ; match std :: any :: type_name_of_val (& result) { name if name . contains ("String") || name . contains ("&str") => println ! ("{}" , result) , _ => println ! ("{:?}" , result) } }
  |

error[E0277]: the type `[i32]` cannot be indexed by `i32`
   --> /tmp/.tmpGWkyy9/main.rs:1:176
    |
1   | ...[1i32 , 2i32 , 3i32] ; ; match v . get (5i32) . cloned () { Some (item) => println ! ("{:?} {:?}" , format ! ("Item: {{}}") , item) , ...
    |                                       ---  ^^^^ slice indices are of type `usize` or ranges of `usize`
    |                                       |
    |                                       required by a bound introduced by this call
    |
    = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
    = help: the following other types implement trait `SliceIndex<T>`:
              `usize` implements `SliceIndex<ByteStr>`
              `usize` implements `SliceIndex<[T]>`
note: required by a bound in `core::slice::<impl [T]>::get`
   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:573:12
    |
571 |     pub fn get<I>(&self, index: I) -> Option<&I::Output>
    |            --- required by a bound in this associated function
572 |     where
573 |         I: SliceIndex<Self>,
    |            ^^^^^^^^^^^^^^^^ required by this bound in `core::slice::<impl [T]>::get`

error[E0277]: the type `[i32]` cannot be indexed by `i32`
   --> /tmp/.tmpGWkyy9/main.rs:1:361
    |
1   | ... result = if let Some (item) = v . get (5i32) . cloned () { { println ! ("{:?} {:?}" , format ! ("Item: {{}}") , item) } } ; match std...
    |                                       ---  ^^^^ slice indices are of type `usize` or ranges of `usize`
    |                                       |
    |                                       required by a bound introduced by this call
    |
    = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
    = help: the following other types implement trait `SliceIndex<T>`:
              `usize` implements `SliceIndex<ByteStr>`
              `usize` implements `SliceIndex<[T]>`
note: required by a bound in `core::slice::<impl [T]>::get`
   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:573:12
    |
571 |     pub fn get<I>(&self, index: I) -> Option<&I::Output>
    |            --- required by a bound in this associated function
572 |     where
573 |         I: SliceIndex<Self>,
    |            ^^^^^^^^^^^^^^^^ required by this bound in `core::slice::<impl [T]>::get`

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpGWkyy9/main.rs:1:580
  |
1 | .... contains ("&str") => println ! ("{}" , result) , _ => println ! ("{:?}" , result) } }
  |                                       --    ^^^^^^ `()` cannot be formatted with the default formatter
  |                                       |
  |                                       required by this formatting parameter
  |
  = help: the trait `std::fmt::Display` is not implemented for `()`
  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 3 previous errors; 5 warnings emitted

For more information about this error, try `rustc --explain E0277`.



=== appendix-c-troubleshooting example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 13 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 14 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 15 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 16 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpI0ruMA/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .....
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpI0ruMA/main.rs:1:87
  |
1 | use std :: collections :: HashMap ; fn main () { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .....
  |                                                                                       ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpI0ruMA/main.rs:1:120
  |
1 | ...ions :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecD...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpI0ruMA/main.rs:1:219
  |
1 | ...i32 , i) } } ; let mut deque = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } ; }
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpI0ruMA/main.rs:1:149
  |
1 | ... list = Vec :: new () ; ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; ; for i in ...
  |                                                         ^^                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } ; }
1 + use std :: collections :: HashMap ; fn main () { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .. 1000i32 { list . insert (0i32 , i) } ; let mut deque = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpI0ruMA/main.rs:1:248
  |
1 | ...e = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } ; }
  |                                                          ^^                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } ; }
1 + use std :: collections :: HashMap ; fn main () { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { deque . push_front (i) } ; }
  |

error[E0308]: mismatched types
    --> /tmp/.tmpI0ruMA/main.rs:1:166
     |
1    | ... () ; ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { ...
     |                                                ------  ^^^^ expected `usize`, found `i32`
     |                                                |
     |                                                arguments to this method are incorrect
     |
note: method defined here
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2034:12
     |
2034 |     pub fn insert(&mut self, index: usize, element: T) {
     |            ^^^^^^
help: change the type of the numeric literal from `i32` to `usize`
     |
1    - use std :: collections :: HashMap ; fn main () { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } ; }
1    + use std :: collections :: HashMap ; fn main () { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .. 1000i32 { { list . insert (0usize , i) } } ; let mut deque = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } ; }
     |

error: aborting due to 1 previous error; 6 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== appendix-c-troubleshooting example 17 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `url` in this scope
 --> /tmp/.tmpTuRtzI/main.rs:1:81
  |
1 | use std :: collections :: HashMap ; fn main () { let response = reqwest :: get (url) . await ? ; ; let data = response . json () . await ...
  |                                                                                 ^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpTuRtzI/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let response = reqwest :: get (url) . await ? ; ; let data = response . json () . await ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpTuRtzI/main.rs:1:98
  |
1 | use std :: collections :: HashMap ; fn main () { let response = reqwest :: get (url) . await ? ; ; let data = response . json () . await ...
  |                                                                                                  ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpTuRtzI/main.rs:1:142
  |
1 | ...ait ? ; ; let data = response . json () . await ? ; ; }
  |                                                        ^ help: remove this semicolon

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
 --> /tmp/.tmpTuRtzI/main.rs:1:65
  |
1 | use std :: collections :: HashMap ; fn main () { let response = reqwest :: get (url) . await ? ; ; let data = response . json () . await ...
  |                                                                 ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
  |
  = help: you might be missing a crate named `reqwest`

error: aborting due to 2 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0425, E0433.
For more information about an error, try `rustc --explain E0425`.



=== appendix-c-troubleshooting example 18 ===
✗ Compilation failed: Failed to transpile to Rust


=== appendix-c-troubleshooting example 19 ===
✗ Compilation failed: Failed to transpile to Rust


=== appendix-c-troubleshooting example 20 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 3 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpeKnlB3/main.rs:1:356
  |
1 | ...} ; return groups } } } } fn main () { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maxi...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpeKnlB3/main.rs:1:391
  |
1 | ...) { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let mini...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpeKnlB3/main.rs:1:410
  |
1 | ...bers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpeKnlB3/main.rs:1:445
  |
1 | ...bers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactio...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpeKnlB3/main.rs:1:480
  |
1 | ...; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `transactions` in this scope
 --> /tmp/.tmpeKnlB3/main.rs:1:518
  |
1 | ... minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec <...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `transactions` in this scope
 --> /tmp/.tmpeKnlB3/main.rs:1:635
  |
1 | ...ollect :: < Vec < _ >> () ; ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; ; le...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `transactions` in this scope
 --> /tmp/.tmpeKnlB3/main.rs:1:737
  |
1 | ...ollect :: < Vec < _ >> () ; ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; ; }
  |                                                     ^^^^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpeKnlB3/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpeKnlB3/main.rs:1:100
  |
1 | ... { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } ...
  |       ^^                                                                                                                                                                                                                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; ; }
1 + use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } fn main () { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpeKnlB3/main.rs:1:148
  |
1 | ... { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ...
  |       ^^                                                                                                                                                        ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; ; }
1 + use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } ; return groups } } } } fn main () { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpeKnlB3/main.rs:1:220
  |
1 | ...ield as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } ...
  |                                                     ^^                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; ; }
1 + use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { groups [key as usize] = vec ! [] } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpeKnlB3/main.rs:1:375
  |
1 | ...} } } } fn main () { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . ma...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpeKnlB3/main.rs:1:429
  |
1 | ...let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_v...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpeKnlB3/main.rs:1:464
  |
1 | ...mbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpeKnlB3/main.rs:1:499
  |
1 | ...mbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpeKnlB3/main.rs:1:614
  |
1 | ...t . amount > 100i32) . collect :: < Vec < _ >> () ; ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpeKnlB3/main.rs:1:716
  |
1 | ...(| t | t . customer) . collect :: < Vec < _ >> () ; ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: ...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpeKnlB3/main.rs:1:816
  |
1 | ...p (| t | t . amount) . collect :: < Vec < _ >> () ; ; }
  |                                                        ^ help: remove this semicolon

error[E0277]: `String` is not an iterator
 --> /tmp/.tmpeKnlB3/main.rs:1:138
  |
1 | ...groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize...
  |                                  ^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`
  |
  = help: the trait `Iterator` is not implemented for `String`
  = note: required for `String` to implement `IntoIterator`

error[E0599]: no method named `has_key` found for unit type `()` in the current scope
 --> /tmp/.tmpeKnlB3/main.rs:1:204
  |
1 | ...et key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . pu...
  |                                                       ^^^^^^^ method not found in `()`

error[E0308]: mismatched types
 --> /tmp/.tmpeKnlB3/main.rs:1:316
  |
1 | ...-> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } ...
  |       --- expected `i32` because of return type                                                                                                                                                                                     ^^^^^^ expected `i32`, found `()`

error[E0605]: non-primitive cast: `String` as `usize`
 --> /tmp/.tmpeKnlB3/main.rs:1:170
  |
1 | ...rd [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) }...
  |        ^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error: aborting due to 12 previous errors; 11 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0425, E0599, E0605.
For more information about an error, try `rustc --explain E0277`.



=== ch05-00-data-processing example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 8 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpbSooXL/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) { { println ! ("{:?}" , format ! ("{}{}" , "\n" , ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpbSooXL/main.rs:1:268
  |
1 | ... values () . max () ; { let max_bar_width = 50i32 ; ; for (key , value) in data . iter () . map (| (k , v) | (k . clone () , v . clone...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpbSooXL/main.rs:1:358
  |
1 | ... { { { let bar_width = value * max_bar_width / max_value ; { let bar = "█" * bar_width . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") , bar) , " ") , value . to_s ())) } } } } ...
  |       ^^                                                                                                                                                                                                                                                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) { { println ! ("{:?}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{:?}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; ; for (key , value) in data . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let bar_width = value * max_bar_width / max_value ; { let bar = "█" * bar_width . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") , bar) , " ") , value . to_s ())) } } } } } } } } fn main () { let monthly_sales = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("January" . to_string () , (45000i32) . to_string ()) ; map . insert ("February" . to_string () , (52000i32) . to_string ()) ; map . insert ("March" . to_string () , (48000i32) . to_string ()) ; map . insert ("April" . to_string () , (61000i32) . to_string ()) ; map . insert ("May" . to_string () , (58000i32) . to_string ()) ; map } ; ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
1 + use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) { { println ! ("{:?}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{:?}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; ; for (key , value) in data . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { let bar_width = value * max_bar_width / max_value ; { let bar = "█" * bar_width . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") , bar) , " ") , value . to_s ())) } } } } } } } fn main () { let monthly_sales = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("January" . to_string () , (45000i32) . to_string ()) ; map . insert ("February" . to_string () , (52000i32) . to_string ()) ; map . insert ("March" . to_string () , (48000i32) . to_string ()) ; map . insert ("April" . to_string () , (61000i32) . to_string ()) ; map . insert ("May" . to_string () , (58000i32) . to_string ()) ; map } ; ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpbSooXL/main.rs:1:454
  |
1 | ...max_value ; { let bar = "█" * bar_width . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , for...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpbSooXL/main.rs:1:1108
  |
1 | ...to_string () , (58000i32) . to_string ()) ; map } ; ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
  |                                                        ^ help: remove this semicolon

error[E0369]: cannot multiply `&str` by `usize`
 --> /tmp/.tmpbSooXL/main.rs:1:172
  |
1 | ...rmat ! ("{}{}" , "\n" , title)) ; println ! ("{:?}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let max_...
  |                                                          --- ^ -------------- usize
  |                                                          |
  |                                                          &str

error[E0599]: no method named `values` found for struct `String` in the current scope
 --> /tmp/.tmpbSooXL/main.rs:1:217
  |
1 | ..."=" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; ; for (key , value) in data . iter...
  |                                                     ^^^^^^ method not found in `String`

error[E0599]: no method named `iter` found for struct `String` in the current scope
 --> /tmp/.tmpbSooXL/main.rs:1:298
  |
1 | ...bar_width = 50i32 ; ; for (key , value) in data . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let bar_width = valu...
  |                                                      ^^^^ method not found in `String`
  |
help: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`
  |
1 - use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) { { println ! ("{:?}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{:?}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; ; for (key , value) in data . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let bar_width = value * max_bar_width / max_value ; { let bar = "█" * bar_width . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") , bar) , " ") , value . to_s ())) } } } } } } } } fn main () { let monthly_sales = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("January" . to_string () , (45000i32) . to_string ()) ; map . insert ("February" . to_string () , (52000i32) . to_string ()) ; map . insert ("March" . to_string () , (48000i32) . to_string ()) ; map . insert ("April" . to_string () , (61000i32) . to_string ()) ; map . insert ("May" . to_string () , (58000i32) . to_string ()) ; map } ; ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
1 + use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) { { println ! ("{:?}" , format ! ("{}{}" , "\n" , title)) ; println ! ("{:?}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; ; for (key , value) in data . chars () . map (| (k , v) | (k . clone () , v . clone ())) { { { let bar_width = value * max_bar_width / max_value ; { let bar = "█" * bar_width . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") , bar) , " ") , value . to_s ())) } } } } } } } } fn main () { let monthly_sales = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert ("January" . to_string () , (45000i32) . to_string ()) ; map . insert ("February" . to_string () , (52000i32) . to_string ()) ; map . insert ("March" . to_string () , (48000i32) . to_string ()) ; map . insert ("April" . to_string () , (61000i32) . to_string ()) ; map . insert ("May" . to_string () , (58000i32) . to_string ()) ; map } ; ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
  |

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpbSooXL/main.rs:1:420
  |
1 | ...= value * max_bar_width / max_value ; { let bar = "█" * bar_width . to_i () ; ; println ! ("{:?}" , format ! ("{}{}" , format ! ("{}{}...
  |                                                ^^^ doesn't have a size known at compile-time
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: all local variables must have a statically known size

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpbSooXL/main.rs:1:566
  |
1 | ...! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , key , " │") , bar) , " ") , value . to_s ())) } } } } } } } } fn main () { let month...
  |                             --                                     ^^^ doesn't have a size known at compile-time
  |                             |
  |                             required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
 --> /tmp/.tmpbSooXL/main.rs:1:1126
  |
1 | ... to_string ()) ; map } ; ; draw_bar_chart (monthly_sales , "Monthly Sales Report" . to_string ()) ; }
  |                               --------------  ^^^^^^^^^^^^^ expected `String`, found `HashMap<String, String>`
  |                               |
  |                               arguments to this function are incorrect
  |
  = note: expected struct `String`
             found struct `HashMap<String, String>`
note: function defined here
 --> /tmp/.tmpbSooXL/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) { { println ! ("{:?}" , format ! ("{}{}" , "\n" , ...
  |                                        ^^^^^^^^^^^^^^  -------------

error: aborting due to 6 previous errors; 5 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0369, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch05-00-data-processing example 9 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpNzGQPf/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { let sales_data = load_csv ("sales.csv" . to_string ()) ; ; let total = sales_data . iter...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpNzGQPf/main.rs:1:107
  |
1 | ...ales_data = load_csv ("sales.csv" . to_string ()) ; ; let total = sales_data . iter () . map (| row | row . amount . to_f ()) . collec...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpNzGQPf/main.rs:1:221
  |
1 | ... . to_f ()) . collect :: < Vec < _ >> () . sum () ; ; let average = total / sales_data . len () ; ; println ! ("{:?}" , format ! ("{}{...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpNzGQPf/main.rs:1:267
  |
1 | ... () ; ; let average = total / sales_data . len () ; ; println ! ("{:?}" , format ! ("{}{}" , "Average sale: $" , average . to_s ())) ; }
  |                                                        ^ help: remove this semicolon

error[E0425]: cannot find function `load_csv` in this scope
 --> /tmp/.tmpNzGQPf/main.rs:1:67
  |
1 | use std :: collections :: HashMap ; fn main () { let sales_data = load_csv ("sales.csv" . to_string ()) ; ; let total = sales_data . iter...
  |                                                                   ^^^^^^^^ not found in this scope

error: aborting due to 1 previous error; 4 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-data-processing example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch02-00-variables-types example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `user_name` in this scope
 --> /tmp/.tmp584fBl/main.rs:1:52
  |
1 | use std :: collections :: HashMap ; fn main () { { user_name = "Alice" } }
  |                                                    ^^^^^^^^^ not found in this scope

warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp584fBl/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { user_name = "Alice" } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp584fBl/main.rs:1:50
  |
1 | use std :: collections :: HashMap ; fn main () { { user_name = "Alice" } }
  |                                                  ^^                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { user_name = "Alice" } }
1 + use std :: collections :: HashMap ; fn main () { user_name = "Alice" }
  |

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch02-00-variables-types example 6 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmptHW6tw/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn main () { { { let age = "25" . to_string () ; let next_year = age + 1i32 ; } } }
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmptHW6tw/main.rs:1:50
  |
1 | use std :: collections :: HashMap ; fn main () { { { let age = "25" . to_string () ; let next_year = age + 1i32 ; } } }
  |                                                  ^^                                                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn main () { { { let age = "25" . to_string () ; let next_year = age + 1i32 ; } } }
1 + use std :: collections :: HashMap ; fn main () { { let age = "25" . to_string () ; let next_year = age + 1i32 ; } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmptHW6tw/main.rs:1:108
  |
1 | use std :: collections :: HashMap ; fn main () { { { let age = "25" . to_string () ; let next_year = age + 1i32 ; } } }
  |                                                                                                            ^^^^ expected `&str`, found `i32`

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 5 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpkIXHFb/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpkIXHFb/main.rs:1:66
  |
1 | use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f...
  |                                                                  ^^     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , first_name , "_") , last_name) } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}" , "Circle area:" , area) ; println ! ("{} {:?}" , "Username:" , username) ; println ! ("{:?}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { x * x } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , first_name , "_") , last_name) } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}" , "Circle area:" , area) ; println ! ("{} {:?}" , "Username:" , username) ; println ! ("{:?}" , excited) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpkIXHFb/main.rs:1:117
  |
1 | ... } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , la...
  |                                              ^^                                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , first_name , "_") , last_name) } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}" , "Circle area:" , area) ; println ! ("{} {:?}" , "Username:" , username) ; println ! ("{:?}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { let pi = 3.14159f64 ; pi * square (radius) } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , first_name , "_") , last_name) } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}" , "Circle area:" , area) ; println ! ("{} {:?}" , "Username:" , username) ; println ! ("{:?}" , excited) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpkIXHFb/main.rs:1:233
  |
1 | ...32 , last_name : i32) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , first_name , "_") , last_name) } } fn shout (message : String) ...
  |                                   ^^                                                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , first_name , "_") , last_name) } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}" , "Circle area:" , area) ; println ! ("{} {:?}" , "Username:" , username) ; println ! ("{:?}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { format ! ("{}{}" , format ! ("{}{}" , first_name , "_") , last_name) } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}" , "Circle area:" , area) ; println ! ("{} {:?}" , "Username:" , username) ; println ! ("{:?}" , excited) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpkIXHFb/main.rs:1:345
  |
1 | ...name) } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32...
  |                                                   ^^                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , first_name , "_") , last_name) } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}" , "Circle area:" , area) ; println ! ("{} {:?}" , "Username:" , username) ; println ! ("{:?}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , first_name , "_") , last_name) } } fn shout (message : String) -> i32 { format ! ("{}{}" , message , "!!!") } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}" , "Circle area:" , area) ; println ! ("{} {:?}" , "Username:" , username) ; println ! ("{:?}" , excited) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpkIXHFb/main.rs:1:400
  |
1 | ... { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}" , "Circle area:" , area) ; println ! ("{} {:?}" , "Username:" , username) ; println ! ("{:?}" , excited) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , first_name , "_") , last_name) } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}" , "Circle area:" , area) ; println ! ("{} {:?}" , "Username:" , username) ; println ! ("{:?}" , excited) } } } }
1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , first_name , "_") , last_name) } } fn shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { let area = circle_area (5i32) ; { let username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}" , "Circle area:" , area) ; println ! ("{} {:?}" , "Username:" , username) ; println ! ("{:?}" , excited) } } }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpkIXHFb/main.rs:1:521
  |
1 | ...Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}"...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpkIXHFb/main.rs:1:581
  |
1 | ...cited = shout ("I love functions" . to_string ()) ; ; println ! ("{} {:?}" , "Circle area:" , area) ; println ! ("{} {:?}" , "Username...
  |                                                        ^ help: remove this semicolon

error[E0277]: cannot multiply `f64` by `i32`
 --> /tmp/.tmpkIXHFb/main.rs:1:146
  |
1 | ...ius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 ...
  |                                                     ^ no implementation for `f64 * i32`
  |
  = help: the trait `Mul<i32>` is not implemented for `f64`
  = help: the following other types implement trait `Mul<Rhs>`:
            `&f64` implements `Mul<f64>`
            `&f64` implements `Mul`
            `f64` implements `Mul<&f64>`
            `f64` implements `Mul`

error[E0308]: mismatched types
 --> /tmp/.tmpkIXHFb/main.rs:1:235
  |
1 | ...me : i32) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , first_name , "_") , last_name) } } fn shout (message : String) -> i32 { { f...
  |                 ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`
  |                 |
  |                 expected `i32` because of return type
  |
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
 --> /tmp/.tmpkIXHFb/main.rs:1:347
  |
1 | ...n shout (message : String) -> i32 { { format ! ("{}{}" , message , "!!!") } } fn main () { { { let area = circle_area (5i32) ; { let u...
  |                                  ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`
  |                                  |
  |                                  expected `i32` because of return type
  |
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpkIXHFb/main.rs:1:453
  |
1 | ...; { let username = make_username ("Alice" . to_string () , "Johnson" . to_string ()) ; ; let excited = shout ("I love functions" . to_...
  |                       ^^^^^^^^^^^^^  ----------------------   ------------------------ expected `i32`, found `String`
  |                                      |
  |                                      expected `i32`, found `String`
  |
note: function defined here
 --> /tmp/.tmpkIXHFb/main.rs:1:173
  |
1 | ....14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! ("{}{}" , format ! ("...
  |                                              ^^^^^^^^^^^^^  ----------------   ---------------

error: aborting due to 4 previous errors; 8 warnings emitted

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.



=== ch03-00-functions example 6 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpDyrTRp/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i3...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpDyrTRp/main.rs:1:72
  |
1 | use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i3...
  |                                                                        ^^                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { number % 2i32 == 0i32 } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpDyrTRp/main.rs:1:142
  |
1 | ... { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } ...
  |       ^^                                                                                                                                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpDyrTRp/main.rs:1:164
  |
1 | ...n grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { "A" } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpDyrTRp/main.rs:1:201
  |
1 | ...2 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { "B" } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpDyrTRp/main.rs:1:238
  |
1 | ...lse { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } }...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { "C" } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpDyrTRp/main.rs:1:275
  |
1 | ...lse { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i3...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { "D" } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpDyrTRp/main.rs:1:292
  |
1 | ... 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { "F" } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpDyrTRp/main.rs:1:350
  |
1 | ... { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpDyrTRp/main.rs:1:386
  |
1 | ...number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large"...
  |                                                                  ^^      ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { "even" } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpDyrTRp/main.rs:1:406
  |
1 | ...i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small...
  |                                                                  ^^     ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { "odd" } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpDyrTRp/main.rs:1:486
  |
1 | ...f n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , form...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpDyrTRp/main.rs:1:449
  |
1 | ..."even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}...
  |                                                                 ^^       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { "large" } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpDyrTRp/main.rs:1:470
  |
1 | ...odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" ...
  |                                                                 ^^       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { "small" } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } } } } fn main () { { println ! ("{:?}" , describe_number (42i32)) ; println ! ("{:?}" , describe_number (150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpDyrTRp/main.rs:1:74
  |
1 | use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i3...
  |                                                                  ---     ^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `bool`
  |                                                                  |
  |                                                                  expected `i32` because of return type

error[E0308]: mismatched types
 --> /tmp/.tmpDyrTRp/main.rs:1:156
  |
1 | ...er (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } }...
  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`
  |                                      |        |
  |                                      |        expected `String`, found `i32`
  |                                      expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmpDyrTRp/main.rs:1:166
  |
1 | ...fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i3...
  |                                        ---                           ^^^ expected `i32`, found `&str`
  |                                        |
  |                                        expected `i32` because of return type

error[E0308]: mismatched types
 --> /tmp/.tmpDyrTRp/main.rs:1:193
  |
1 | ...re >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } }...
  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`
  |                                      |        |
  |                                      |        expected `String`, found `i32`
  |                                      expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmpDyrTRp/main.rs:1:203
  |
1 | ...ore : String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else ...
  |                     --- expected `i32` because of return type                          ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpDyrTRp/main.rs:1:230
  |
1 | ...re >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn descri...
  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`
  |                                      |        |
  |                                      |        expected `String`, found `i32`
  |                                      expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmpDyrTRp/main.rs:1:240
  |
1 | ...String) -> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if s...
  |               --- expected `i32` because of return type                                                               ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpDyrTRp/main.rs:1:267
  |
1 | ...re >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number (n : i32) -> i32 { { { let ...
  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`
  |                                      |        |
  |                                      |        expected `String`, found `i32`
  |                                      expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmpDyrTRp/main.rs:1:277
  |
1 | ...-> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } ...
  |       --- expected `i32` because of return type                                                                                                    ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpDyrTRp/main.rs:1:294
  |
1 | ...-> i32 { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } ...
  |       --- expected `i32` because of return type                                                                                                                     ^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpDyrTRp/main.rs:1:372
  |
1 | ...umber (n : i32) -> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" ...
  |                                                   ^^^^^^^^^^^ expected `bool`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpDyrTRp/main.rs:1:488
  |
1 | ...-> i32 { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; ; format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , n , " is a ") , size) , " ") , even_odd) , " number") } ...
  |       --- expected `i32` because of return type                                                                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`
  |
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
 --> /tmp/.tmpDyrTRp/main.rs:1:789
  |
1 | ...150i32)) ; println ! ("{:?}" , grade_letter (85i32)) } }
  |                                   ------------  ^^^^^- help: try using a conversion method: `.to_string()`
  |                                   |             |
  |                                   |             expected `String`, found `i32`
  |                                   arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpDyrTRp/main.rs:1:103
  |
1 | use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i3...
  |                                                                                                       ^^^^^^^^^^^^  --------------

error: aborting due to 13 previous errors; 14 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 7 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpB3n72U/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpB3n72U/main.rs:1:108
  |
1 | ...(prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as ...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpB3n72U/main.rs:1:129
  |
1 | ...i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpB3n72U/main.rs:1:314
  |
1 | ...i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > ma...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpB3n72U/main.rs:1:335
  |
1 | ...al = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = n...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpB3n72U/main.rs:1:404
  |
1 | ... . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words...
  |                                                      ^^                              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = "Functions make code reusable and testable" . to_string () ; ; println ! ("{} {:?}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {:?}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {:?}" , "Word count:" , count_words (essay)) } } } }
1 + use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { max_val = numbers [i as usize] } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = "Functions make code reusable and testable" . to_string () ; ; println ! ("{} {:?}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {:?}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {:?}" , "Word count:" , count_words (essay)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpB3n72U/main.rs:1:514
  |
1 | ...n count_words (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = ...
  |                                           ^^                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = "Functions make code reusable and testable" . to_string () ; ; println ! ("{} {:?}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {:?}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {:?}" , "Word count:" , count_words (essay)) } } } }
1 + use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { let words = text . split (" ") ; words . len () } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = "Functions make code reusable and testable" . to_string () ; ; println ! ("{} {:?}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {:?}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {:?}" , "Word count:" , count_words (essay)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpB3n72U/main.rs:1:585
  |
1 | ... { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = "Functions make code reusable and testable" . to_string () ; ; println ! ("{} {:?}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {:?}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {:?}" , "Word count:" , count_words (essay)) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                    ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = "Functions make code reusable and testable" . to_string () ; ; println ! ("{} {:?}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {:?}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {:?}" , "Word count:" , count_words (essay)) } } } }
1 + use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = "Functions make code reusable and testable" . to_string () ; ; println ! ("{} {:?}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {:?}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {:?}" , "Word count:" , count_words (essay)) } } }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpB3n72U/main.rs:1:723
  |
1 | ...s = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = "Functions make code reusable and testable" . to_string () ; ; print...
  |                                                        ^ help: remove this semicolon

warning: unnecessary trailing semicolon
 --> /tmp/.tmpB3n72U/main.rs:1:798
  |
1 | ...s make code reusable and testable" . to_string () ; ; println ! ("{} {:?}" , "Total cost: $" , calculate_total (shopping_cart)) ; prin...
  |                                                        ^ help: remove this semicolon

error[E0308]: mismatched types
 --> /tmp/.tmpB3n72U/main.rs:1:141
  |
1 | ...tal = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } f...
  |                                              -   ^^^^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                              |
  |                                              expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len ().try_into().unwrap() { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = "Functions make code reusable and testable" . to_string () ; ; println ! ("{} {:?}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {:?}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {:?}" , "Word count:" , count_words (essay)) } } } }
  |                                                                                                                                                            ++++++++++++++++++++

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpB3n72U/main.rs:1:185
  |
1 | ...rices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mu...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0308]: mismatched types
 --> /tmp/.tmpB3n72U/main.rs:1:218
  |
1 | ...-> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } ...
  |       --- expected `i32` because of return type                                                                                                    ^^^^^ expected `i32`, found `f64`

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpB3n72U/main.rs:1:297
  |
1 | ...ng) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usiz...
  |                                              ^^^^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0308]: mismatched types
 --> /tmp/.tmpB3n72U/main.rs:1:347
  |
1 | ... as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize...
  |                                              -   ^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                              |
  |                                              expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len ().try_into().unwrap() { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = "Functions make code reusable and testable" . to_string () ; ; println ! ("{} {:?}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {:?}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {:?}" , "Word count:" , count_words (essay)) } } } }
  |                                                                                                                                                                                                                                                                                                                                                                           ++++++++++++++++++++

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpB3n72U/main.rs:1:380
  |
1 | ...while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val }...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0277]: the type `str` cannot be indexed by `usize`
 --> /tmp/.tmpB3n72U/main.rs:1:425
  |
1 | ...as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { ...
  |                                               ^^^^^^^^^^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `usize`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `String` to implement `Index<usize>`

error[E0599]: no method named `len` found for struct `std::str::Split` in the current scope
    --> /tmp/.tmpB3n72U/main.rs:1:559
     |
1    | ... : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5...
     |                                                                     ^^^
     |
help: there is a method `le` with a similar name, but with different arguments
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:3877:5
     |
3877 | /     fn le<I>(self, other: I) -> bool
3878 | |     where
3879 | |         I: IntoIterator,
3880 | |         Self::Item: PartialOrd<I::Item>,
3881 | |         Self: Sized,
     | |____________________^

error[E0308]: mismatched types
 --> /tmp/.tmpB3n72U/main.rs:1:858
  |
1 | ... ! ("{} {:?}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {:?}" , "Highest score:" , find_max (test_scores))...
  |                                      ---------------  ^^^^^^^^^^^^^ expected `String`, found `Vec<f64>`
  |                                      |
  |                                      arguments to this function are incorrect
  |
  = note: expected struct `String`
             found struct `Vec<f64>`
note: function defined here
 --> /tmp/.tmpB3n72U/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i...
  |                                        ^^^^^^^^^^^^^^^  ---------------

error[E0308]: mismatched types
 --> /tmp/.tmpB3n72U/main.rs:1:928
  |
1 | ...tln ! ("{} {:?}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {:?}" , "Word count:" , count_words (essay)) } } } }
  |                                          --------  ^^^^^^^^^^^ expected `String`, found `Vec<i32>`
  |                                          |
  |                                          arguments to this function are incorrect
  |
  = note: expected struct `String`
             found struct `Vec<i32>`
note: function defined here
 --> /tmp/.tmpB3n72U/main.rs:1:231
  |
1 | ...rices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ...
  |                                                         ^^^^^^^^  ----------------

error: aborting due to 10 previous errors; 10 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch03-00-functions example 9 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmp8fMb5H/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn greet (name : String , age : String) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmp8fMb5H/main.rs:1:86
  |
1 | ... { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") , age) , " years old") } } ...
  |       ^^                                                                                                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn greet (name : String , age : String) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") , age) , " years old") } } fn main () { { let msg = greet ("Alice" . to_string ()) ; } }
1 + use std :: collections :: HashMap ; fn greet (name : String , age : String) -> i32 { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") , age) , " years old") } fn main () { { let msg = greet ("Alice" . to_string ()) ; } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp8fMb5H/main.rs:1:88
  |
1 | ...-> i32 { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") , age) , " years old") } ...
  |       ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`
  |       |
  |       expected `i32` because of return type
  |
  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0061]: this function takes 2 arguments but 1 argument was supplied
 --> /tmp/.tmp8fMb5H/main.rs:1:245
  |
1 | ...") } } fn main () { { let msg = greet ("Alice" . to_string ()) ; } }
  |                                    ^^^^^------------------------- argument #2 of type `String` is missing
  |
note: function defined here
 --> /tmp/.tmp8fMb5H/main.rs:1:40
  |
1 | use std :: collections :: HashMap ; fn greet (name : String , age : String) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{...
  |                                        ^^^^^                  ------------
help: provide the argument
  |
1 | use std :: collections :: HashMap ; fn greet (name : String , age : String) -> i32 { { format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , format ! ("{}{}" , "Hi " , name) , ", you're ") , age) , " years old") } } fn main () { { let msg = greet("Alice" . to_string (), /* String */) ; } }
  |                                                                                                                                                                                                                                                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

error: aborting due to 2 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0061, E0308.
For more information about an error, try `rustc --explain E0061`.



=== ch03-00-functions example 10 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpDX0Gbt/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { ...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpDX0Gbt/main.rs:1:134
  |
1 | ...i32 ; x } } fn good_function (x : i32) -> i32 { { { let result = x + 1i32 ; result } } } fn main () { { println ! ("{:?}" , good_funct...
  |                                                    ^^                                  ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { let result = x + 1i32 ; result } } } fn main () { { println ! ("{:?}" , good_function (5i32)) } }
1 + use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { let result = x + 1i32 ; result } } fn main () { { println ! ("{:?}" , good_function (5i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpDX0Gbt/main.rs:1:188
  |
1 | ...sult = x + 1i32 ; result } } } fn main () { { println ! ("{:?}" , good_function (5i32)) } }
  |                                                ^^                                         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { let result = x + 1i32 ; result } } } fn main () { { println ! ("{:?}" , good_function (5i32)) } }
1 + use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { let result = x + 1i32 ; result } } } fn main () { println ! ("{:?}" , good_function (5i32)) }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpDX0Gbt/main.rs:1:85
  |
1 | use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { ...
  |                                                                                     ^^^^ expected `&str`, found `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpDX0Gbt/main.rs:1:92
  |
1 | use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { ...
  |                                                                     ---                    ^ expected `i32`, found `String`
  |                                                                     |
  |                                                                     expected `i32` because of return type

error: aborting due to 2 previous errors; 3 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 12 ===
✗ Compilation failed: Compilation failed:
warning: unused import: `std :: collections :: HashMap`
 --> /tmp/.tmpiw09AY/main.rs:1:5
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bm...
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpiw09AY/main.rs:1:87
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bm...
  |                                                                                       ^^                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { celsius * 9i32 / 5i32 + 32i32 } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpiw09AY/main.rs:1:184
  |
1 | ..._bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_perce...
  |                                                     ^^                               ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { weight_kg / height_m * height_m } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpiw09AY/main.rs:1:288
  |
1 | ...ount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : Strin...
  |                                 ^^                                                                       ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { let discount = price * discount_percent / 100i32 ; price - discount } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpiw09AY/main.rs:1:405
  |
1 | ...fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) ...
  |                                           ^^                                                   ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { let words = text . split (" ") ; words . len () } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpiw09AY/main.rs:1:509
  |
1 | ... { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } ...
  |       ^^                                                                                                                                                                                                                                                         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpiw09AY/main.rs:1:592
  |
1 | ...it (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpiw09AY/main.rs:1:613
  |
1 | ...initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = init...
  |                                                        ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpiw09AY/main.rs:1:642
  |
1 | ...ords . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } }...
  |                    ^^                                                                                                 ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpiw09AY/main.rs:1:846
  |
1 | ... { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } ...
  |       ^^                                                                                                                                                                                                                            ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpiw09AY/main.rs:1:899
  |
1 | ...f energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time...
  |                                                      ^^                              ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { "Go for a run or hit the gym!" } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpiw09AY/main.rs:1:994
  |
1 | ... if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn ...
  |                                                        ^^                         ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { "Perfect time for a walk" } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpiw09AY/main.rs:1:1033
  |
1 | ...e > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_...
  |                                                       ^^                           ^^
  |
help: remove these braces
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { "Maybe just relax and read" } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

error[E0599]: no method named `len` found for struct `std::str::Split` in the current scope
    --> /tmp/.tmpiw09AY/main.rs:1:450
     |
1    | ... : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let wo...
     |                                                                     ^^^
     |
help: there is a method `le` with a similar name, but with different arguments
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:3877:5
     |
3877 | /     fn le<I>(self, other: I) -> bool
3878 | |     where
3879 | |         I: IntoIterator,
3880 | |         Self::Item: PartialOrd<I::Item>,
3881 | |         Self: Sized,
     | |____________________^

error[E0599]: no method named `len` found for struct `std::str::Split` in the current scope
    --> /tmp/.tmpiw09AY/main.rs:1:633
     |
1    | ...s = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + ...
     |                                                                     ^^^
     |
help: there is a method `le` with a similar name, but with different arguments
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:3877:5
     |
3877 | /     fn le<I>(self, other: I) -> bool
3878 | |     where
3879 | |         I: IntoIterator,
3880 | |         Self::Item: PartialOrd<I::Item>,
3881 | |         Self: Sized,
     | |____________________^

error[E0608]: cannot index into a value of type `std::str::Split<'_, &str>`
 --> /tmp/.tmpiw09AY/main.rs:1:663
  |
1 | ...i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i3...
  |                                                                 ^^^^^^^^^^^^

error[E0308]: mismatched types
 --> /tmp/.tmpiw09AY/main.rs:1:748
  |
1 | ...-> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } ...
  |       --- expected `i32` because of return type                                                                                                                                                                                                            ^^^^^^^^ expected `i32`, found `String`

error[E0308]: mismatched types
 --> /tmp/.tmpiw09AY/main.rs:1:866
  |
1 | ...e_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_l...
  |                                   ------------   ^^^^- help: try using a conversion method: `.to_string()`
  |                                   |              |
  |                                   |              expected `String`, found `i32`
  |                                   expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmpiw09AY/main.rs:1:891
  |
1 | ...{ { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available...
  |                                  --------------   ^^^^^- help: try using a conversion method: `.to_string()`
  |                                  |                |
  |                                  |                expected `String`, found `i32`
  |                                  expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmpiw09AY/main.rs:1:901
  |
1 | ...ng) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 &...
  |           --- expected `i32` because of return type                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpiw09AY/main.rs:1:961
  |
1 | ...or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just re...
  |                                   ------------   ^^^^- help: try using a conversion method: `.to_string()`
  |                                   |              |
  |                                   |              expected `String`, found `i32`
  |                                   expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmpiw09AY/main.rs:1:986
  |
1 | ...e { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } ...
  |                                  --------------   ^^^^^- help: try using a conversion method: `.to_string()`
  |                                  |                |
  |                                  |                expected `String`, found `i32`
  |                                  expected because this is `String`

error[E0308]: mismatched types
 --> /tmp/.tmpiw09AY/main.rs:1:996
  |
1 | ...-> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } ...
  |       --- expected `i32` because of return type                                                                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpiw09AY/main.rs:1:1035
  |
1 | ...-> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } ...
  |       --- expected `i32` because of return type                                                                                                                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&str`

error[E0308]: mismatched types
 --> /tmp/.tmpiw09AY/main.rs:1:1184
  |
1 | ...enheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string...
  |                                          -------------          ^^^^^^^ expected `i32`, found `f64`
  |                                          |
  |                                          arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpiw09AY/main.rs:1:126
  |
1 | ...2 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m...
  |                                               ^^^^^^^^^^^^^                    --------------
help: change the type of the numeric literal from `f64` to `i32`
  |
1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1i32)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpiw09AY/main.rs:1:1285
  |
1 | ..._string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32)) } }
  |                                       ^^^^^^^^^^^^^^^^^^  ----   ----- expected `String`, found `i32`
  |                                                           |
  |                                                           expected `String`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpiw09AY/main.rs:1:768
  |
1 | ...32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i3...
  |                                     ^^^^^^^^^^^^^^^^^^  ---------------------   -----------------------
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32.to_string() , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ++++++++++++
help: try using a conversion method
  |
1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (" ") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (" ") ; { let mut initials = "" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{:?}" , celsius_to_fahrenheit (20i32)) ; println ! ("{:?}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{:?}" , get_initials ("Alice Johnson" . to_string ())) ; println ! ("{:?}" , recommend_activity (8i32 , 45i32.to_string())) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ++++++++++++

error: aborting due to 13 previous errors; 13 warnings emitted

Some errors have detailed explanations: E0308, E0599, E0608.
For more information about an error, try `rustc --explain E0308`.


