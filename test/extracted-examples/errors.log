=== ch16-00-testing-quality-assurance example 5 ===
âœ— Compilation failed: Compilation failed:
error[E0425]: cannot find function `add` in this scope
 --> /tmp/.tmpaW7LDi/main.rs:1:36
  |
1 | fn test_addition () { assert_eq ! (add (2 , 3) , 5 , "{}" , "Basic addition") ; assert_eq ! (add (- 1 , 1) , 0 , "{}" , "Adding negative ...
  |                                    ^^^ not found in this scope
  |
help: use the `.` operator to call the method `Add::add` on `{integer}`
  |
1 - fn test_addition () { assert_eq ! (add (2 , 3) , 5 , "{}" , "Basic addition") ; assert_eq ! (add (- 1 , 1) , 0 , "{}" , "Adding negative numbers") ; assert_eq ! (add (0 , 0) , 0 , "{}" , "Adding zeros") ; println ! ("âœ… Addition tests pass") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2 , 3) , - 6 , "{}" , "Negative multiplication") ; assert_eq ! (multiply (0 , 100) , 0 , "{}" , "Multiply by zero") ; println ! ("âœ… Multiplication tests pass") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! ("ðŸŽ‰ Calculator test suite complete!") ; } fn main () { run_all_tests () }
1 + fn test_addition () { assert_eq ! (2.add(3) , 5 , "{}" , "Basic addition") ; assert_eq ! (add (- 1 , 1) , 0 , "{}" , "Adding negative numbers") ; assert_eq ! (add (0 , 0) , 0 , "{}" , "Adding zeros") ; println ! ("âœ… Addition tests pass") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2 , 3) , - 6 , "{}" , "Negative multiplication") ; assert_eq ! (multiply (0 , 100) , 0 , "{}" , "Multiply by zero") ; println ! ("âœ… Multiplication tests pass") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! ("ðŸŽ‰ Calculator test suite complete!") ; } fn main () { run_all_tests () }
  |

error[E0425]: cannot find function `add` in this scope
 --> /tmp/.tmpaW7LDi/main.rs:1:94
  |
1 | fn test_addition () { assert_eq ! (add (2 , 3) , 5 , "{}" , "Basic addition") ; assert_eq ! (add (- 1 , 1) , 0 , "{}" , "Adding negative ...
  |                                                                                              ^^^ not found in this scope
  |
help: use the `.` operator to call the method `Add::add` on `{integer}`
  |
1 - fn test_addition () { assert_eq ! (add (2 , 3) , 5 , "{}" , "Basic addition") ; assert_eq ! (add (- 1 , 1) , 0 , "{}" , "Adding negative numbers") ; assert_eq ! (add (0 , 0) , 0 , "{}" , "Adding zeros") ; println ! ("âœ… Addition tests pass") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2 , 3) , - 6 , "{}" , "Negative multiplication") ; assert_eq ! (multiply (0 , 100) , 0 , "{}" , "Multiply by zero") ; println ! ("âœ… Multiplication tests pass") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! ("ðŸŽ‰ Calculator test suite complete!") ; } fn main () { run_all_tests () }
1 + fn test_addition () { assert_eq ! (add (2 , 3) , 5 , "{}" , "Basic addition") ; assert_eq ! ((- 1).add(1) , 0 , "{}" , "Adding negative numbers") ; assert_eq ! (add (0 , 0) , 0 , "{}" , "Adding zeros") ; println ! ("âœ… Addition tests pass") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2 , 3) , - 6 , "{}" , "Negative multiplication") ; assert_eq ! (multiply (0 , 100) , 0 , "{}" , "Multiply by zero") ; println ! ("âœ… Multiplication tests pass") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! ("ðŸŽ‰ Calculator test suite complete!") ; } fn main () { run_all_tests () }
  |

error[E0425]: cannot find function `add` in this scope
 --> /tmp/.tmpaW7LDi/main.rs:1:163
  |
1 | ...0 , "{}" , "Adding negative numbers") ; assert_eq ! (add (0 , 0) , 0 , "{}" , "Adding zeros") ; println ! ("âœ… Addition tests pass") ; }...
  |                                                         ^^^ not found in this scope
  |
help: use the `.` operator to call the method `Add::add` on `{integer}`
  |
1 - fn test_addition () { assert_eq ! (add (2 , 3) , 5 , "{}" , "Basic addition") ; assert_eq ! (add (- 1 , 1) , 0 , "{}" , "Adding negative numbers") ; assert_eq ! (add (0 , 0) , 0 , "{}" , "Adding zeros") ; println ! ("âœ… Addition tests pass") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2 , 3) , - 6 , "{}" , "Negative multiplication") ; assert_eq ! (multiply (0 , 100) , 0 , "{}" , "Multiply by zero") ; println ! ("âœ… Multiplication tests pass") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! ("ðŸŽ‰ Calculator test suite complete!") ; } fn main () { run_all_tests () }
1 + fn test_addition () { assert_eq ! (add (2 , 3) , 5 , "{}" , "Basic addition") ; assert_eq ! (add (- 1 , 1) , 0 , "{}" , "Adding negative numbers") ; assert_eq ! (0.add(0) , 0 , "{}" , "Adding zeros") ; println ! ("âœ… Addition tests pass") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2 , 3) , - 6 , "{}" , "Negative multiplication") ; assert_eq ! (multiply (0 , 100) , 0 , "{}" , "Multiply by zero") ; println ! ("âœ… Multiplication tests pass") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! ("ðŸŽ‰ Calculator test suite complete!") ; } fn main () { run_all_tests () }
  |

error[E0425]: cannot find function `multiply` in this scope
 --> /tmp/.tmpaW7LDi/main.rs:1:287
  |
1 | ...ass") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `multiply` in this scope
 --> /tmp/.tmpaW7LDi/main.rs:1:357
  |
1 | ...12 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2 , 3) , - 6 , "{}" , "Negative multiplication") ; assert_eq ! (multipl...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `multiply` in this scope
 --> /tmp/.tmpaW7LDi/main.rs:1:433
  |
1 | ..., "{}" , "Negative multiplication") ; assert_eq ! (multiply (0 , 100) , 0 , "{}" , "Multiply by zero") ; println ! ("âœ… Multiplication t...
  |                                                       ^^^^^^^^ not found in this scope

error: aborting due to 6 previous errors

For more information about this error, try `rustc --explain E0425`.

Error: Compilation failed:
error[E0425]: cannot find function `add` in this scope
 --> /tmp/.tmpaW7LDi/main.rs:1:36
  |
1 | fn test_addition () { assert_eq ! (add (2 , 3) , 5 , "{}" , "Basic addition") ; assert_eq ! (add (- 1 , 1) , 0 , "{}" , "Adding negative ...
  |                                    ^^^ not found in this scope
  |
help: use the `.` operator to call the method `Add::add` on `{integer}`
  |
1 - fn test_addition () { assert_eq ! (add (2 , 3) , 5 , "{}" , "Basic addition") ; assert_eq ! (add (- 1 , 1) , 0 , "{}" , "Adding negative numbers") ; assert_eq ! (add (0 , 0) , 0 , "{}" , "Adding zeros") ; println ! ("âœ… Addition tests pass") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2 , 3) , - 6 , "{}" , "Negative multiplication") ; assert_eq ! (multiply (0 , 100) , 0 , "{}" , "Multiply by zero") ; println ! ("âœ… Multiplication tests pass") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! ("ðŸŽ‰ Calculator test suite complete!") ; } fn main () { run_all_tests () }
1 + fn test_addition () { assert_eq ! (2.add(3) , 5 , "{}" , "Basic addition") ; assert_eq ! (add (- 1 , 1) , 0 , "{}" , "Adding negative numbers") ; assert_eq ! (add (0 , 0) , 0 , "{}" , "Adding zeros") ; println ! ("âœ… Addition tests pass") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2 , 3) , - 6 , "{}" , "Negative multiplication") ; assert_eq ! (multiply (0 , 100) , 0 , "{}" , "Multiply by zero") ; println ! ("âœ… Multiplication tests pass") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! ("ðŸŽ‰ Calculator test suite complete!") ; } fn main () { run_all_tests () }
  |

error[E0425]: cannot find function `add` in this scope
 --> /tmp/.tmpaW7LDi/main.rs:1:94
  |
1 | fn test_addition () { assert_eq ! (add (2 , 3) , 5 , "{}" , "Basic addition") ; assert_eq ! (add (- 1 , 1) , 0 , "{}" , "Adding negative ...
  |                                                                                              ^^^ not found in this scope
  |
help: use the `.` operator to call the method `Add::add` on `{integer}`
  |
1 - fn test_addition () { assert_eq ! (add (2 , 3) , 5 , "{}" , "Basic addition") ; assert_eq ! (add (- 1 , 1) , 0 , "{}" , "Adding negative numbers") ; assert_eq ! (add (0 , 0) , 0 , "{}" , "Adding zeros") ; println ! ("âœ… Addition tests pass") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2 , 3) , - 6 , "{}" , "Negative multiplication") ; assert_eq ! (multiply (0 , 100) , 0 , "{}" , "Multiply by zero") ; println ! ("âœ… Multiplication tests pass") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! ("ðŸŽ‰ Calculator test suite complete!") ; } fn main () { run_all_tests () }
1 + fn test_addition () { assert_eq ! (add (2 , 3) , 5 , "{}" , "Basic addition") ; assert_eq ! ((- 1).add(1) , 0 , "{}" , "Adding negative numbers") ; assert_eq ! (add (0 , 0) , 0 , "{}" , "Adding zeros") ; println ! ("âœ… Addition tests pass") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2 , 3) , - 6 , "{}" , "Negative multiplication") ; assert_eq ! (multiply (0 , 100) , 0 , "{}" , "Multiply by zero") ; println ! ("âœ… Multiplication tests pass") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! ("ðŸŽ‰ Calculator test suite complete!") ; } fn main () { run_all_tests () }
  |

error[E0425]: cannot find function `add` in this scope
 --> /tmp/.tmpaW7LDi/main.rs:1:163
  |
1 | ...0 , "{}" , "Adding negative numbers") ; assert_eq ! (add (0 , 0) , 0 , "{}" , "Adding zeros") ; println ! ("âœ… Addition tests pass") ; }...
  |                                                         ^^^ not found in this scope
  |
help: use the `.` operator to call the method `Add::add` on `{integer}`
  |
1 - fn test_addition () { assert_eq ! (add (2 , 3) , 5 , "{}" , "Basic addition") ; assert_eq ! (add (- 1 , 1) , 0 , "{}" , "Adding negative numbers") ; assert_eq ! (add (0 , 0) , 0 , "{}" , "Adding zeros") ; println ! ("âœ… Addition tests pass") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2 , 3) , - 6 , "{}" , "Negative multiplication") ; assert_eq ! (multiply (0 , 100) , 0 , "{}" , "Multiply by zero") ; println ! ("âœ… Multiplication tests pass") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! ("ðŸŽ‰ Calculator test suite complete!") ; } fn main () { run_all_tests () }
1 + fn test_addition () { assert_eq ! (add (2 , 3) , 5 , "{}" , "Basic addition") ; assert_eq ! (add (- 1 , 1) , 0 , "{}" , "Adding negative numbers") ; assert_eq ! (0.add(0) , 0 , "{}" , "Adding zeros") ; println ! ("âœ… Addition tests pass") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2 , 3) , - 6 , "{}" , "Negative multiplication") ; assert_eq ! (multiply (0 , 100) , 0 , "{}" , "Multiply by zero") ; println ! ("âœ… Multiplication tests pass") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! ("ðŸŽ‰ Calculator test suite complete!") ; } fn main () { run_all_tests () }
  |

error[E0425]: cannot find function `multiply` in this scope
 --> /tmp/.tmpaW7LDi/main.rs:1:287
  |
1 | ...ass") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `multiply` in this scope
 --> /tmp/.tmpaW7LDi/main.rs:1:357
  |
1 | ...12 , "{}" , "Basic multiplication") ; assert_eq ! (multiply (- 2 , 3) , - 6 , "{}" , "Negative multiplication") ; assert_eq ! (multipl...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `multiply` in this scope
 --> /tmp/.tmpaW7LDi/main.rs:1:433
  |
1 | ..., "{}" , "Negative multiplication") ; assert_eq ! (multiply (0 , 100) , 0 , "{}" , "Multiply by zero") ; println ! ("âœ… Multiplication t...
  |                                                       ^^^^^^^^ not found in this scope

error: aborting due to 6 previous errors

For more information about this error, try `rustc --explain E0425`.



=== ch16-00-testing-quality-assurance example 7 ===
âœ— Compilation failed: Compilation failed:
error[E0425]: cannot find value `actual` in this scope
 --> /tmp/.tmp7nbnJy/main.rs:1:325
  |
1 | ...ement should be 4") } } } fn main () { assert_eq ! (actual , expected , "{}" , "Descriptive failure message") ; assert ! (condition , ...
  |                                                        ^^^^^^ not found in this scope

error[E0425]: cannot find value `expected` in this scope
 --> /tmp/.tmp7nbnJy/main.rs:1:334
  |
1 | ...ld be 4") } } } fn main () { assert_eq ! (actual , expected , "{}" , "Descriptive failure message") ; assert ! (condition , "{}" , "Ex...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `condition` in this scope
 --> /tmp/.tmp7nbnJy/main.rs:1:395
  |
1 | ..."{}" , "Descriptive failure message") ; assert ! (condition , "{}" , "Explain why this should be true") ; }
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `create_range` in this scope
 --> /tmp/.tmp7nbnJy/main.rs:1:44
  |
1 | fn test_range_function () { { let result = create_range (1 , 5) ; { assert_eq ! (len (result) , 4 , "{}" , "Range should have 4 elements"...
  |                                            ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `len` in this scope
 --> /tmp/.tmp7nbnJy/main.rs:1:82
  |
1 | fn test_range_function () { { let result = create_range (1 , 5) ; { assert_eq ! (len (result) , 4 , "{}" , "Range should have 4 elements"...
  |                                                                                  ^^^ not found in this scope

error: aborting due to 5 previous errors

For more information about this error, try `rustc --explain E0425`.

Error: Compilation failed:
error[E0425]: cannot find value `actual` in this scope
 --> /tmp/.tmp7nbnJy/main.rs:1:325
  |
1 | ...ement should be 4") } } } fn main () { assert_eq ! (actual , expected , "{}" , "Descriptive failure message") ; assert ! (condition , ...
  |                                                        ^^^^^^ not found in this scope

error[E0425]: cannot find value `expected` in this scope
 --> /tmp/.tmp7nbnJy/main.rs:1:334
  |
1 | ...ld be 4") } } } fn main () { assert_eq ! (actual , expected , "{}" , "Descriptive failure message") ; assert ! (condition , "{}" , "Ex...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `condition` in this scope
 --> /tmp/.tmp7nbnJy/main.rs:1:395
  |
1 | ..."{}" , "Descriptive failure message") ; assert ! (condition , "{}" , "Explain why this should be true") ; }
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `create_range` in this scope
 --> /tmp/.tmp7nbnJy/main.rs:1:44
  |
1 | fn test_range_function () { { let result = create_range (1 , 5) ; { assert_eq ! (len (result) , 4 , "{}" , "Range should have 4 elements"...
  |                                            ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `len` in this scope
 --> /tmp/.tmp7nbnJy/main.rs:1:82
  |
1 | fn test_range_function () { { let result = create_range (1 , 5) ; { assert_eq ! (len (result) , 4 , "{}" , "Range should have 4 elements"...
  |                                                                                  ^^^ not found in this scope

error: aborting due to 5 previous errors

For more information about this error, try `rustc --explain E0425`.



=== ch15-00-binary-compilation-deployment example 2 ===
âœ— Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Expected RightBrace, found LineComment(" Simple calculator - supports +, -, *, /")


=== ch15-00-binary-compilation-deployment example 4 ===
âœ— Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpSPCQgh/main.rs:1:301
  |
1 | ...a : i32 , b : i32) -> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! ("Mathematic...
  |                                               ^^                                           ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn factorial (n : i32) -> i64 { if n <= 1 { 1 } else { (n as i64) * factorial (n - 1) } } fn integer_sqrt (n : i32) -> i32 { if n < 2 { return n } ; let mut x = n / 2 ; let mut prev = 0 ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; { let n = 10 ; { println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48 ; let mut b = 18 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) } } }
1 + fn factorial (n : i32) -> i64 { if n <= 1 { 1 } else { (n as i64) * factorial (n - 1) } } fn integer_sqrt (n : i32) -> i32 { if n < 2 { return n } ; let mut x = n / 2 ; let mut prev = 0 ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0 { { let temp = b ; { b = a % b ; a = temp } } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; { let n = 10 ; { println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48 ; let mut b = 18 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) } } }
  |

error[E0384]: cannot assign to immutable argument `b`
 --> /tmp/.tmpSPCQgh/main.rs:1:322
  |
1 | ...> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! ("Mathematical Functions Demo") ...
  |                                                ^^^^^^^^^ cannot assign to immutable argument
  |
help: consider making this binding mutable
  |
1 | fn factorial (n : i32) -> i64 { if n <= 1 { 1 } else { (n as i64) * factorial (n - 1) } } fn integer_sqrt (n : i32) -> i32 { if n < 2 { return n } ; let mut x = n / 2 ; let mut prev = 0 ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (a : i32 , mut b : i32) -> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; { let n = 10 ; { println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48 ; let mut b = 18 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) } } }
  |                                                                                                                                                                                                                                                                            +++

error[E0384]: cannot assign to immutable argument `a`
 --> /tmp/.tmpSPCQgh/main.rs:1:334
  |
1 | ...le b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; { let n =...
  |                                                 ^^^^^^^^ cannot assign to immutable argument
  |
help: consider making this binding mutable
  |
1 | fn factorial (n : i32) -> i64 { if n <= 1 { 1 } else { (n as i64) * factorial (n - 1) } } fn integer_sqrt (n : i32) -> i32 { if n < 2 { return n } ; let mut x = n / 2 ; let mut prev = 0 ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (mut a : i32 , b : i32) -> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; { let n = 10 ; { println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48 ; let mut b = 18 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) } } }
  |                                                                                                                                                                                                                                                                  +++

warning: variable does not need to be mutable
 --> /tmp/.tmpSPCQgh/main.rs:1:491
  |
1 | ... ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut...
  |                                                         ----^
  |                                                         |
  |                                                         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

warning: variable does not need to be mutable
 --> /tmp/.tmpSPCQgh/main.rs:1:569
  |
1 | ...Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48 ; let mut b = 18 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a ...
  |                                                         ----^
  |                                                         |
  |                                                         help: remove this `mut`

warning: variable does not need to be mutable
 --> /tmp/.tmpSPCQgh/main.rs:1:586
  |
1 | ...: {}" , x , integer_sqrt (x)) ; let mut a = 48 ; let mut b = 18 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) } } }
  |                                                         ----^
  |                                                         |
  |                                                         help: remove this `mut`

error: aborting due to 2 previous errors; 4 warnings emitted

For more information about this error, try `rustc --explain E0384`.

Error: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpSPCQgh/main.rs:1:301
  |
1 | ...a : i32 , b : i32) -> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! ("Mathematic...
  |                                               ^^                                           ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn factorial (n : i32) -> i64 { if n <= 1 { 1 } else { (n as i64) * factorial (n - 1) } } fn integer_sqrt (n : i32) -> i32 { if n < 2 { return n } ; let mut x = n / 2 ; let mut prev = 0 ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; { let n = 10 ; { println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48 ; let mut b = 18 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) } } }
1 + fn factorial (n : i32) -> i64 { if n <= 1 { 1 } else { (n as i64) * factorial (n - 1) } } fn integer_sqrt (n : i32) -> i32 { if n < 2 { return n } ; let mut x = n / 2 ; let mut prev = 0 ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0 { { let temp = b ; { b = a % b ; a = temp } } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; { let n = 10 ; { println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48 ; let mut b = 18 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) } } }
  |

error[E0384]: cannot assign to immutable argument `b`
 --> /tmp/.tmpSPCQgh/main.rs:1:322
  |
1 | ...> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! ("Mathematical Functions Demo") ...
  |                                                ^^^^^^^^^ cannot assign to immutable argument
  |
help: consider making this binding mutable
  |
1 | fn factorial (n : i32) -> i64 { if n <= 1 { 1 } else { (n as i64) * factorial (n - 1) } } fn integer_sqrt (n : i32) -> i32 { if n < 2 { return n } ; let mut x = n / 2 ; let mut prev = 0 ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (a : i32 , mut b : i32) -> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; { let n = 10 ; { println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48 ; let mut b = 18 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) } } }
  |                                                                                                                                                                                                                                                                            +++

error[E0384]: cannot assign to immutable argument `a`
 --> /tmp/.tmpSPCQgh/main.rs:1:334
  |
1 | ...le b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; { let n =...
  |                                                 ^^^^^^^^ cannot assign to immutable argument
  |
help: consider making this binding mutable
  |
1 | fn factorial (n : i32) -> i64 { if n <= 1 { 1 } else { (n as i64) * factorial (n - 1) } } fn integer_sqrt (n : i32) -> i32 { if n < 2 { return n } ; let mut x = n / 2 ; let mut prev = 0 ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (mut a : i32 , b : i32) -> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! ("Mathematical Functions Demo") ; { let n = 10 ; { println ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48 ; let mut b = 18 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) } } }
  |                                                                                                                                                                                                                                                                  +++

warning: variable does not need to be mutable
 --> /tmp/.tmpSPCQgh/main.rs:1:491
  |
1 | ... ! ("Factorial of {}: {}" , n , factorial (n)) ; let mut x = 25 ; println ! ("Square root of {}: {}" , x , integer_sqrt (x)) ; let mut...
  |                                                         ----^
  |                                                         |
  |                                                         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

warning: variable does not need to be mutable
 --> /tmp/.tmpSPCQgh/main.rs:1:569
  |
1 | ...Square root of {}: {}" , x , integer_sqrt (x)) ; let mut a = 48 ; let mut b = 18 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a ...
  |                                                         ----^
  |                                                         |
  |                                                         help: remove this `mut`

warning: variable does not need to be mutable
 --> /tmp/.tmpSPCQgh/main.rs:1:586
  |
1 | ...: {}" , x , integer_sqrt (x)) ; let mut a = 48 ; let mut b = 18 ; println ! ("GCD of {} and {}: {}" , a , b , gcd (a , b)) } } }
  |                                                         ----^
  |                                                         |
  |                                                         help: remove this `mut`

error: aborting due to 2 previous errors; 4 warnings emitted

For more information about this error, try `rustc --explain E0384`.



=== ch03-00-functions-tdd example 5 ===
âœ— Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Expected RightBrace, found Let


=== ch03-00-functions-tdd example 10 ===
âœ— Compilation failed: Cargo build failed:
    Updating crates.io index
     Locking 264 packages to latest compatible versions
      Adding polars v0.35.4 (available: v0.52.0)
   Compiling proc-macro2 v1.0.103
   Compiling unicode-ident v1.0.22
   Compiling quote v1.0.42
   Compiling libc v0.2.177
   Compiling version_check v0.9.5
   Compiling cfg-if v1.0.4
   Compiling once_cell v1.21.3
   Compiling memchr v2.7.6
   Compiling autocfg v1.5.0
   Compiling itoa v1.0.15
   Compiling smallvec v1.15.1
   Compiling libm v0.2.15
   Compiling zerocopy v0.8.27
   Compiling bytes v1.11.0
   Compiling crossbeam-utils v0.8.21
   Compiling bitflags v2.10.0
   Compiling equivalent v1.0.2
   Compiling hashbrown v0.16.0
   Compiling target-features v0.1.6
   Compiling rayon-core v1.13.0
   Compiling stable_deref_trait v1.2.1
   Compiling getrandom v0.3.4
   Compiling regex-syntax v0.8.8
   Compiling syn v1.0.109
   Compiling pin-project-lite v0.2.16
   Compiling thiserror v1.0.69
   Compiling parking_lot_core v0.9.12
   Compiling ryu v1.0.20
   Compiling either v1.15.0
   Compiling futures-core v0.3.31
   Compiling ahash v0.8.12
   Compiling polars-utils v0.35.4
   Compiling scopeguard v1.2.0
   Compiling iana-time-zone v0.1.64
   Compiling find-msvc-tools v0.1.5
   Compiling simdutf8 v0.1.5
   Compiling shlex v1.3.0
   Compiling static_assertions v1.1.0
   Compiling allocator-api2 v0.2.21
   Compiling rustix v1.1.2
   Compiling lock_api v0.4.14
   Compiling pkg-config v0.3.32
   Compiling futures-sink v0.3.31
   Compiling percent-encoding v2.3.2
   Compiling num-traits v0.2.19
   Compiling smartstring v1.0.1
   Compiling cc v1.2.46
   Compiling linux-raw-sys v0.11.0
   Compiling vcpkg v0.2.15
   Compiling litrs v1.0.0
   Compiling fast-float v0.2.0
   Compiling aho-corasick v1.1.4
   Compiling strength_reduce v0.2.4
   Compiling crossbeam-epoch v0.9.18
   Compiling streaming-iterator v0.1.9
   Compiling dyn-clone v1.0.20
   Compiling indexmap v2.12.0
   Compiling ethnum v1.5.2
   Compiling atoi_simd v0.15.6
   Compiling syn v2.0.110
   Compiling foreign_vec v0.1.0
   Compiling crossbeam-deque v0.8.6
   Compiling document-features v0.2.12
   Compiling fnv v1.0.7
   Compiling polars-core v0.35.4
   Compiling http v1.3.1
   Compiling litemap v0.8.1
   Compiling unicode-width v0.2.2
   Compiling getrandom v0.2.16
   Compiling socket2 v0.6.1
   Compiling mio v1.1.0
   Compiling rand_core v0.6.4
   Compiling slab v0.4.11
   Compiling unicode-segmentation v1.12.0
   Compiling writeable v0.6.2
   Compiling parking_lot v0.12.5
   Compiling tokio v1.48.0
   Compiling polars-ops v0.35.4
   Compiling icu_properties_data v2.1.1
   Compiling xxhash-rust v0.8.15
   Compiling serde_core v1.0.228
   Compiling rayon v1.11.0
   Compiling chrono v0.4.42
   Compiling crossterm v0.29.0
   Compiling regex-automata v0.4.13
   Compiling ppv-lite86 v0.2.21
   Compiling icu_normalizer_data v2.1.1
   Compiling pin-utils v0.1.0
   Compiling openssl-sys v0.9.111
   Compiling http-body v1.0.1
   Compiling argminmax v0.6.3
   Compiling tracing-core v0.1.34
   Compiling comfy-table v7.2.1
   Compiling httparse v1.10.1
   Compiling futures-task v0.3.31
   Compiling rustversion v1.0.22
   Compiling rand_chacha v0.3.1
   Compiling futures-io v0.3.31
   Compiling openssl v0.10.75
   Compiling foreign-types-shared v0.1.1
   Compiling foreign-types v0.3.2
   Compiling futures-util v0.3.31
   Compiling rand v0.8.5
   Compiling tracing v0.1.41
   Compiling atoi v2.0.0
   Compiling serde v1.0.228
   Compiling atomic-waker v1.1.2
   Compiling tower-service v0.3.3
   Compiling native-tls v0.2.14
   Compiling try-lock v0.2.5
   Compiling want v0.3.1
   Compiling now v0.1.3
   Compiling memmap2 v0.7.1
   Compiling futures-channel v0.3.31
   Compiling polars-plan v0.35.4
   Compiling rand_distr v0.4.3
   Compiling heck v0.4.1
   Compiling openssl-probe v0.1.6
   Compiling log v0.4.28
   Compiling home v0.5.12
   Compiling form_urlencoded v1.2.2
   Compiling sync_wrapper v1.0.2
   Compiling polars-lazy v0.35.4
   Compiling tower-layer v0.3.3
   Compiling base64 v0.22.1
   Compiling ipnet v2.11.0
   Compiling utf8_iter v1.0.4
   Compiling http-body-util v0.1.3
   Compiling polars v0.35.4
   Compiling serde_json v1.0.145
   Compiling glob v0.3.3
   Compiling zeroize v1.8.2
   Compiling iri-string v0.7.9
   Compiling encoding_rs v0.8.35
   Compiling mime v0.3.17
   Compiling rustls-pki-types v1.13.0
   Compiling hashbrown v0.14.5
   Compiling synstructure v0.13.2
   Compiling regex v1.12.2
   Compiling multiversion-macros v0.7.4
   Compiling zerofrom-derive v0.1.6
   Compiling yoke-derive v0.8.1
   Compiling thiserror-impl v1.0.69
   Compiling zerovec-derive v0.11.2
   Compiling bytemuck_derive v1.10.2
   Compiling displaydoc v0.2.5
   Compiling tokio-util v0.7.17
   Compiling openssl-macros v0.1.1
   Compiling multiversion v0.7.4
   Compiling serde_derive v1.0.228
   Compiling strum_macros v0.25.3
   Compiling tower v0.5.2
   Compiling h2 v0.4.12
   Compiling polars-error v0.35.4
   Compiling bytemuck v1.24.0
   Compiling zerofrom v0.1.6
   Compiling tower-http v0.6.6
   Compiling yoke v0.8.1
   Compiling zerovec v0.11.5
   Compiling zerotrie v0.2.3
   Compiling polars-arrow v0.35.4
   Compiling tinystr v0.8.2
   Compiling potential_utf v0.1.4
   Compiling icu_collections v2.1.1
   Compiling icu_locale_core v2.1.1
   Compiling icu_provider v2.1.1
   Compiling icu_normalizer v2.1.1
   Compiling icu_properties v2.1.1
   Compiling serde_urlencoded v0.7.1
   Compiling hyper v1.8.1
   Compiling tokio-native-tls v0.3.1
   Compiling idna_adapter v1.2.1
   Compiling idna v1.1.0
   Compiling url v2.5.7
   Compiling hyper-util v0.1.18
   Compiling hyper-tls v0.6.0
   Compiling reqwest v0.12.24
   Compiling polars-row v0.35.4
   Compiling polars-time v0.35.4
   Compiling polars-io v0.35.4
   Compiling ruchy_binary v0.1.0 (/tmp/.tmpWBF7A8)
error[E0599]: no method named `groupby` found for struct `polars::prelude::DataFrame` in the current scope
 --> src/main.rs:1:84
  |
1 | use polars :: prelude :: * ; fn analyze_sales (df : DataFrame) -> DataFrame { df . groupby (& []) . expect ("Failed to group DataFrame") ...
  |                                                                                    ^^^^^^^
  |
help: there is a method `group_by` with a similar name
  |
1 | use polars :: prelude :: * ; fn analyze_sales (df : DataFrame) -> DataFrame { df . group_by (& []) . expect ("Failed to group DataFrame") . agg ("revenue" , "sum") . sort_by ("revenue_sum" , { let mut map : std :: collections :: BTreeMap < String , String > = std :: collections :: BTreeMap :: new () ; map . insert ("descending" . to_string () , (true) . to_string ()) ; map }) } fn filter_high_value (df : DataFrame , threshold : f64) -> DataFrame { df . lazy () . filter (move | row | row . get ("value") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) > threshold) . collect () . expect ("DataFrame lazy operation collection should not fail") } fn main () { { let sales = polars :: prelude :: CsvReader :: from_path ("sales.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; { let analysis = analyze_sales (sales) ; let top_items = filter_high_value (analysis , 10000f64) ; println ! ("Found {} high-value items" , top_items . rows ()) } } }
  |                                                                                         +

error[E0282]: type annotations needed
 --> src/main.rs:1:482
  |
1 | ... -> DataFrame { df . lazy () . filter (move | row | row . get ("value") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) > ...
  |                                                  ^^^   --- type must be known at this point
  |
help: consider giving this closure parameter an explicit type
  |
1 | use polars :: prelude :: * ; fn analyze_sales (df : DataFrame) -> DataFrame { df . groupby (& []) . expect ("Failed to group DataFrame") . agg ("revenue" , "sum") . sort_by ("revenue_sum" , { let mut map : std :: collections :: BTreeMap < String , String > = std :: collections :: BTreeMap :: new () ; map . insert ("descending" . to_string () , (true) . to_string ()) ; map }) } fn filter_high_value (df : DataFrame , threshold : f64) -> DataFrame { df . lazy () . filter (move | row: /* Type */ | row . get ("value") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) > threshold) . collect () . expect ("DataFrame lazy operation collection should not fail") } fn main () { { let sales = polars :: prelude :: CsvReader :: from_path ("sales.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; { let analysis = analyze_sales (sales) ; let top_items = filter_high_value (analysis , 10000f64) ; println ! ("Found {} high-value items" , top_items . rows ()) } } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ++++++++++++

error[E0599]: no method named `rows` found for struct `polars::prelude::DataFrame` in the current scope
 --> src/main.rs:1:986
  |
1 | ...ound {} high-value items" , top_items . rows ()) } } }
  |                                            ^^^^ method not found in `polars::prelude::DataFrame`

Some errors have detailed explanations: E0282, E0599.
For more information about an error, try `rustc --explain E0282`.
error: could not compile `ruchy_binary` (bin "ruchy_binary") due to 3 previous errors

Error: Cargo build failed:
    Updating crates.io index
     Locking 264 packages to latest compatible versions
      Adding polars v0.35.4 (available: v0.52.0)
   Compiling proc-macro2 v1.0.103
   Compiling unicode-ident v1.0.22
   Compiling quote v1.0.42
   Compiling libc v0.2.177
   Compiling version_check v0.9.5
   Compiling cfg-if v1.0.4
   Compiling once_cell v1.21.3
   Compiling memchr v2.7.6
   Compiling autocfg v1.5.0
   Compiling itoa v1.0.15
   Compiling smallvec v1.15.1
   Compiling libm v0.2.15
   Compiling zerocopy v0.8.27
   Compiling bytes v1.11.0
   Compiling crossbeam-utils v0.8.21
   Compiling bitflags v2.10.0
   Compiling equivalent v1.0.2
   Compiling hashbrown v0.16.0
   Compiling target-features v0.1.6
   Compiling rayon-core v1.13.0
   Compiling stable_deref_trait v1.2.1
   Compiling getrandom v0.3.4
   Compiling regex-syntax v0.8.8
   Compiling syn v1.0.109
   Compiling pin-project-lite v0.2.16
   Compiling thiserror v1.0.69
   Compiling parking_lot_core v0.9.12
   Compiling ryu v1.0.20
   Compiling either v1.15.0
   Compiling futures-core v0.3.31
   Compiling ahash v0.8.12
   Compiling polars-utils v0.35.4
   Compiling scopeguard v1.2.0
   Compiling iana-time-zone v0.1.64
   Compiling find-msvc-tools v0.1.5
   Compiling simdutf8 v0.1.5
   Compiling shlex v1.3.0
   Compiling static_assertions v1.1.0
   Compiling allocator-api2 v0.2.21
   Compiling rustix v1.1.2
   Compiling lock_api v0.4.14
   Compiling pkg-config v0.3.32
   Compiling futures-sink v0.3.31
   Compiling percent-encoding v2.3.2
   Compiling num-traits v0.2.19
   Compiling smartstring v1.0.1
   Compiling cc v1.2.46
   Compiling linux-raw-sys v0.11.0
   Compiling vcpkg v0.2.15
   Compiling litrs v1.0.0
   Compiling fast-float v0.2.0
   Compiling aho-corasick v1.1.4
   Compiling strength_reduce v0.2.4
   Compiling crossbeam-epoch v0.9.18
   Compiling streaming-iterator v0.1.9
   Compiling dyn-clone v1.0.20
   Compiling indexmap v2.12.0
   Compiling ethnum v1.5.2
   Compiling atoi_simd v0.15.6
   Compiling syn v2.0.110
   Compiling foreign_vec v0.1.0
   Compiling crossbeam-deque v0.8.6
   Compiling document-features v0.2.12
   Compiling fnv v1.0.7
   Compiling polars-core v0.35.4
   Compiling http v1.3.1
   Compiling litemap v0.8.1
   Compiling unicode-width v0.2.2
   Compiling getrandom v0.2.16
   Compiling socket2 v0.6.1
   Compiling mio v1.1.0
   Compiling rand_core v0.6.4
   Compiling slab v0.4.11
   Compiling unicode-segmentation v1.12.0
   Compiling writeable v0.6.2
   Compiling parking_lot v0.12.5
   Compiling tokio v1.48.0
   Compiling polars-ops v0.35.4
   Compiling icu_properties_data v2.1.1
   Compiling xxhash-rust v0.8.15
   Compiling serde_core v1.0.228
   Compiling rayon v1.11.0
   Compiling chrono v0.4.42
   Compiling crossterm v0.29.0
   Compiling regex-automata v0.4.13
   Compiling ppv-lite86 v0.2.21
   Compiling icu_normalizer_data v2.1.1
   Compiling pin-utils v0.1.0
   Compiling openssl-sys v0.9.111
   Compiling http-body v1.0.1
   Compiling argminmax v0.6.3
   Compiling tracing-core v0.1.34
   Compiling comfy-table v7.2.1
   Compiling httparse v1.10.1
   Compiling futures-task v0.3.31
   Compiling rustversion v1.0.22
   Compiling rand_chacha v0.3.1
   Compiling futures-io v0.3.31
   Compiling openssl v0.10.75
   Compiling foreign-types-shared v0.1.1
   Compiling foreign-types v0.3.2
   Compiling futures-util v0.3.31
   Compiling rand v0.8.5
   Compiling tracing v0.1.41
   Compiling atoi v2.0.0
   Compiling serde v1.0.228
   Compiling atomic-waker v1.1.2
   Compiling tower-service v0.3.3
   Compiling native-tls v0.2.14
   Compiling try-lock v0.2.5
   Compiling want v0.3.1
   Compiling now v0.1.3
   Compiling memmap2 v0.7.1
   Compiling futures-channel v0.3.31
   Compiling polars-plan v0.35.4
   Compiling rand_distr v0.4.3
   Compiling heck v0.4.1
   Compiling openssl-probe v0.1.6
   Compiling log v0.4.28
   Compiling home v0.5.12
   Compiling form_urlencoded v1.2.2
   Compiling sync_wrapper v1.0.2
   Compiling polars-lazy v0.35.4
   Compiling tower-layer v0.3.3
   Compiling base64 v0.22.1
   Compiling ipnet v2.11.0
   Compiling utf8_iter v1.0.4
   Compiling http-body-util v0.1.3
   Compiling polars v0.35.4
   Compiling serde_json v1.0.145
   Compiling glob v0.3.3
   Compiling zeroize v1.8.2
   Compiling iri-string v0.7.9
   Compiling encoding_rs v0.8.35
   Compiling mime v0.3.17
   Compiling rustls-pki-types v1.13.0
   Compiling hashbrown v0.14.5
   Compiling synstructure v0.13.2
   Compiling regex v1.12.2
   Compiling multiversion-macros v0.7.4
   Compiling zerofrom-derive v0.1.6
   Compiling yoke-derive v0.8.1
   Compiling thiserror-impl v1.0.69
   Compiling zerovec-derive v0.11.2
   Compiling bytemuck_derive v1.10.2
   Compiling displaydoc v0.2.5
   Compiling tokio-util v0.7.17
   Compiling openssl-macros v0.1.1
   Compiling multiversion v0.7.4
   Compiling serde_derive v1.0.228
   Compiling strum_macros v0.25.3
   Compiling tower v0.5.2
   Compiling h2 v0.4.12
   Compiling polars-error v0.35.4
   Compiling bytemuck v1.24.0
   Compiling zerofrom v0.1.6
   Compiling tower-http v0.6.6
   Compiling yoke v0.8.1
   Compiling zerovec v0.11.5
   Compiling zerotrie v0.2.3
   Compiling polars-arrow v0.35.4
   Compiling tinystr v0.8.2
   Compiling potential_utf v0.1.4
   Compiling icu_collections v2.1.1
   Compiling icu_locale_core v2.1.1
   Compiling icu_provider v2.1.1
   Compiling icu_normalizer v2.1.1
   Compiling icu_properties v2.1.1
   Compiling serde_urlencoded v0.7.1
   Compiling hyper v1.8.1
   Compiling tokio-native-tls v0.3.1
   Compiling idna_adapter v1.2.1
   Compiling idna v1.1.0
   Compiling url v2.5.7
   Compiling hyper-util v0.1.18
   Compiling hyper-tls v0.6.0
   Compiling reqwest v0.12.24
   Compiling polars-row v0.35.4
   Compiling polars-time v0.35.4
   Compiling polars-io v0.35.4
   Compiling ruchy_binary v0.1.0 (/tmp/.tmpWBF7A8)
error[E0599]: no method named `groupby` found for struct `polars::prelude::DataFrame` in the current scope
 --> src/main.rs:1:84
  |
1 | use polars :: prelude :: * ; fn analyze_sales (df : DataFrame) -> DataFrame { df . groupby (& []) . expect ("Failed to group DataFrame") ...
  |                                                                                    ^^^^^^^
  |
help: there is a method `group_by` with a similar name
  |
1 | use polars :: prelude :: * ; fn analyze_sales (df : DataFrame) -> DataFrame { df . group_by (& []) . expect ("Failed to group DataFrame") . agg ("revenue" , "sum") . sort_by ("revenue_sum" , { let mut map : std :: collections :: BTreeMap < String , String > = std :: collections :: BTreeMap :: new () ; map . insert ("descending" . to_string () , (true) . to_string ()) ; map }) } fn filter_high_value (df : DataFrame , threshold : f64) -> DataFrame { df . lazy () . filter (move | row | row . get ("value") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) > threshold) . collect () . expect ("DataFrame lazy operation collection should not fail") } fn main () { { let sales = polars :: prelude :: CsvReader :: from_path ("sales.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; { let analysis = analyze_sales (sales) ; let top_items = filter_high_value (analysis , 10000f64) ; println ! ("Found {} high-value items" , top_items . rows ()) } } }
  |                                                                                         +

error[E0282]: type annotations needed
 --> src/main.rs:1:482
  |
1 | ... -> DataFrame { df . lazy () . filter (move | row | row . get ("value") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) > ...
  |                                                  ^^^   --- type must be known at this point
  |
help: consider giving this closure parameter an explicit type
  |
1 | use polars :: prelude :: * ; fn analyze_sales (df : DataFrame) -> DataFrame { df . groupby (& []) . expect ("Failed to group DataFrame") . agg ("revenue" , "sum") . sort_by ("revenue_sum" , { let mut map : std :: collections :: BTreeMap < String , String > = std :: collections :: BTreeMap :: new () ; map . insert ("descending" . to_string () , (true) . to_string ()) ; map }) } fn filter_high_value (df : DataFrame , threshold : f64) -> DataFrame { df . lazy () . filter (move | row: /* Type */ | row . get ("value") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) > threshold) . collect () . expect ("DataFrame lazy operation collection should not fail") } fn main () { { let sales = polars :: prelude :: CsvReader :: from_path ("sales.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; { let analysis = analyze_sales (sales) ; let top_items = filter_high_value (analysis , 10000f64) ; println ! ("Found {} high-value items" , top_items . rows ()) } } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ++++++++++++

error[E0599]: no method named `rows` found for struct `polars::prelude::DataFrame` in the current scope
 --> src/main.rs:1:986
  |
1 | ...ound {} high-value items" , top_items . rows ()) } } }
  |                                            ^^^^ method not found in `polars::prelude::DataFrame`

Some errors have detailed explanations: E0282, E0599.
For more information about an error, try `rustc --explain E0282`.
error: could not compile `ruchy_binary` (bin "ruchy_binary") due to 3 previous errors



=== ch03-00-functions-tdd example 11 ===
âœ— Compilation failed: Cargo build failed:
    Updating crates.io index
     Locking 264 packages to latest compatible versions
      Adding polars v0.35.4 (available: v0.52.0)
   Compiling proc-macro2 v1.0.103
   Compiling unicode-ident v1.0.22
   Compiling quote v1.0.42
   Compiling libc v0.2.177
   Compiling version_check v0.9.5
   Compiling cfg-if v1.0.4
   Compiling once_cell v1.21.3
   Compiling memchr v2.7.6
   Compiling autocfg v1.5.0
   Compiling itoa v1.0.15
   Compiling smallvec v1.15.1
   Compiling zerocopy v0.8.27
   Compiling libm v0.2.15
   Compiling crossbeam-utils v0.8.21
   Compiling bytes v1.11.0
   Compiling bitflags v2.10.0
   Compiling hashbrown v0.16.0
   Compiling equivalent v1.0.2
   Compiling target-features v0.1.6
   Compiling stable_deref_trait v1.2.1
   Compiling getrandom v0.3.4
   Compiling rayon-core v1.13.0
   Compiling pin-project-lite v0.2.16
   Compiling regex-syntax v0.8.8
   Compiling syn v1.0.109
   Compiling thiserror v1.0.69
   Compiling parking_lot_core v0.9.12
   Compiling ryu v1.0.20
   Compiling futures-core v0.3.31
   Compiling either v1.15.0
   Compiling find-msvc-tools v0.1.5
   Compiling ahash v0.8.12
   Compiling polars-utils v0.35.4
   Compiling simdutf8 v0.1.5
   Compiling iana-time-zone v0.1.64
   Compiling shlex v1.3.0
   Compiling static_assertions v1.1.0
   Compiling num-traits v0.2.19
   Compiling smartstring v1.0.1
   Compiling allocator-api2 v0.2.21
   Compiling scopeguard v1.2.0
   Compiling rustix v1.1.2
   Compiling lock_api v0.4.14
   Compiling litrs v1.0.0
   Compiling cc v1.2.46
   Compiling futures-sink v0.3.31
   Compiling pkg-config v0.3.32
   Compiling percent-encoding v2.3.2
   Compiling vcpkg v0.2.15
   Compiling aho-corasick v1.1.4
   Compiling linux-raw-sys v0.11.0
   Compiling ethnum v1.5.2
   Compiling fnv v1.0.7
   Compiling crossbeam-epoch v0.9.18
   Compiling atoi_simd v0.15.6
   Compiling indexmap v2.12.0
   Compiling foreign_vec v0.1.0
   Compiling syn v2.0.110
   Compiling streaming-iterator v0.1.9
   Compiling dyn-clone v1.0.20
   Compiling fast-float v0.2.0
   Compiling document-features v0.2.12
   Compiling strength_reduce v0.2.4
   Compiling crossbeam-deque v0.8.6
   Compiling getrandom v0.2.16
   Compiling mio v1.1.0
   Compiling socket2 v0.6.1
   Compiling http v1.3.1
   Compiling rand_core v0.6.4
   Compiling polars-core v0.35.4
   Compiling parking_lot v0.12.5
   Compiling unicode-segmentation v1.12.0
   Compiling slab v0.4.11
   Compiling unicode-width v0.2.2
   Compiling litemap v0.8.1
   Compiling tokio v1.48.0
   Compiling writeable v0.6.2
   Compiling polars-ops v0.35.4
   Compiling icu_properties_data v2.1.1
   Compiling serde_core v1.0.228
   Compiling chrono v0.4.42
   Compiling rayon v1.11.0
   Compiling xxhash-rust v0.8.15
   Compiling crossterm v0.29.0
   Compiling pin-utils v0.1.0
   Compiling icu_normalizer_data v2.1.1
   Compiling argminmax v0.6.3
   Compiling tracing-core v0.1.34
   Compiling futures-io v0.3.31
   Compiling rustversion v1.0.22
   Compiling regex-automata v0.4.13
   Compiling httparse v1.10.1
   Compiling ppv-lite86 v0.2.21
   Compiling openssl-sys v0.9.111
   Compiling comfy-table v7.2.1
   Compiling http-body v1.0.1
   Compiling foreign-types-shared v0.1.1
   Compiling futures-task v0.3.31
   Compiling openssl v0.10.75
   Compiling foreign-types v0.3.2
   Compiling tracing v0.1.41
   Compiling futures-util v0.3.31
   Compiling atoi v2.0.0
   Compiling serde v1.0.228
   Compiling tower-service v0.3.3
   Compiling rand_chacha v0.3.1
   Compiling try-lock v0.2.5
   Compiling native-tls v0.2.14
   Compiling atomic-waker v1.1.2
   Compiling want v0.3.1
   Compiling rand v0.8.5
   Compiling memmap2 v0.7.1
   Compiling futures-channel v0.3.31
   Compiling now v0.1.3
   Compiling polars-plan v0.35.4
   Compiling log v0.4.28
   Compiling home v0.5.12
   Compiling heck v0.4.1
   Compiling openssl-probe v0.1.6
   Compiling form_urlencoded v1.2.2
   Compiling polars-lazy v0.35.4
   Compiling sync_wrapper v1.0.2
   Compiling ipnet v2.11.0
   Compiling base64 v0.22.1
   Compiling utf8_iter v1.0.4
   Compiling tower-layer v0.3.3
   Compiling http-body-util v0.1.3
   Compiling rand_distr v0.4.3
   Compiling polars v0.35.4
   Compiling iri-string v0.7.9
   Compiling zeroize v1.8.2
   Compiling glob v0.3.3
   Compiling serde_json v1.0.145
   Compiling rustls-pki-types v1.13.0
   Compiling encoding_rs v0.8.35
   Compiling mime v0.3.17
   Compiling hashbrown v0.14.5
   Compiling regex v1.12.2
   Compiling synstructure v0.13.2
   Compiling multiversion-macros v0.7.4
   Compiling tokio-util v0.7.17
   Compiling tower v0.5.2
   Compiling zerofrom-derive v0.1.6
   Compiling yoke-derive v0.8.1
   Compiling thiserror-impl v1.0.69
   Compiling zerovec-derive v0.11.2
   Compiling displaydoc v0.2.5
   Compiling bytemuck_derive v1.10.2
   Compiling openssl-macros v0.1.1
   Compiling h2 v0.4.12
   Compiling serde_derive v1.0.228
   Compiling multiversion v0.7.4
   Compiling strum_macros v0.25.3
   Compiling tower-http v0.6.6
   Compiling zerofrom v0.1.6
   Compiling yoke v0.8.1
   Compiling bytemuck v1.24.0
   Compiling polars-error v0.35.4
   Compiling zerovec v0.11.5
   Compiling zerotrie v0.2.3
   Compiling polars-arrow v0.35.4
   Compiling tinystr v0.8.2
   Compiling potential_utf v0.1.4
   Compiling icu_collections v2.1.1
   Compiling icu_locale_core v2.1.1
   Compiling icu_provider v2.1.1
   Compiling serde_urlencoded v0.7.1
   Compiling icu_normalizer v2.1.1
   Compiling icu_properties v2.1.1
   Compiling hyper v1.8.1
   Compiling idna_adapter v1.2.1
   Compiling idna v1.1.0
   Compiling tokio-native-tls v0.3.1
   Compiling url v2.5.7
   Compiling hyper-util v0.1.18
   Compiling hyper-tls v0.6.0
   Compiling reqwest v0.12.24
   Compiling polars-row v0.35.4
   Compiling polars-time v0.35.4
   Compiling polars-io v0.35.4
   Compiling ruchy_binary v0.1.0 (/tmp/.tmpAV4Z85)
error[E0277]: the trait bound `&str: IntoSeries` is not satisfied
    --> src/main.rs:1:101
     |
1    | ...ataFrame) -> DataFrame { df . with_column ("margin" , move | row | { (row . get ("revenue") . cloned () . unwrap_or_else (|| panic ! (...
     |                                  -----------  ^^^^^^^^ the trait `IntoSeries` is not implemented for `&str`
     |                                  |
     |                                  required by a bound introduced by this call
     |
     = help: the following other types implement trait `IntoSeries`:
               Arc<(dyn polars::prelude::SeriesTrait + 'static)>
               ChunkedArray<T>
               Logical<DateType, Int32Type>
               Logical<DatetimeType, Int64Type>
               Logical<DurationType, Int64Type>
               Logical<TimeType, Int64Type>
               implementations::null::NullChunked
               polars::prelude::Series
note: required by a bound in `polars::prelude::DataFrame::with_column`
    --> /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/polars-core-0.35.4/src/frame/mod.rs:1129:27
     |
1129 |     pub fn with_column<S: IntoSeries>(&mut self, column: S) -> PolarsResult<&mut Self> {
     |                           ^^^^^^^^^^ required by this bound in `DataFrame::with_column`

error[E0061]: this method takes 1 argument but 2 arguments were supplied
    --> src/main.rs:1:88
     |
1    | ... . with_column ("margin" , move | row | { (row . get ("revenue") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) - row . get ("cost") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) / row . get ("revenue") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) * 100f64 }) }...
     |       ^^^^^^^^^^^             ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- unexpected argument #2
     |
note: method defined here
    --> /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/polars-core-0.35.4/src/frame/mod.rs:1129:12
     |
1129 |     pub fn with_column<S: IntoSeries>(&mut self, column: S) -> PolarsResult<&mut Self> {
     |            ^^^^^^^^^^^
help: remove the extra argument
     |
1    - use polars :: prelude :: * ; fn add_profit_margin (df : DataFrame) -> DataFrame { df . with_column ("margin" , move | row | { (row . get ("revenue") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) - row . get ("cost") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) / row . get ("revenue") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) * 100f64 }) } fn summarize_by_category (df : DataFrame) -> DataFrame { df . groupby (& []) . expect ("Failed to group DataFrame") . agg ("quantity" , "sum") . agg ("revenue" , "mean") . agg ("margin" , "mean") } fn main () { }
1    + use polars :: prelude :: * ; fn add_profit_margin (df : DataFrame) -> DataFrame { df . with_column ("margin") } fn summarize_by_category (df : DataFrame) -> DataFrame { df . groupby (& []) . expect ("Failed to group DataFrame") . agg ("quantity" , "sum") . agg ("revenue" , "mean") . agg ("margin" , "mean") } fn main () { }
     |

error[E0308]: mismatched types
 --> src/main.rs:1:83
  |
1 | ...-> DataFrame { df . with_column ("margin" , move | row | { (row . get ("revenue") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) - row . get ("cost") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) / row . get ("revenue") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) * 100f64 }) } ...
  |       ---------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...aFrame`, found `Result<&mut DataFrame, PolarsError>`
  |       |
  |       expected `polars::prelude::DataFrame` because of return type
  |
  = note: expected struct `polars::prelude::DataFrame`
               found enum `Result<&mut polars::prelude::DataFrame, PolarsError>`

error[E0599]: no method named `groupby` found for struct `polars::prelude::DataFrame` in the current scope
 --> src/main.rs:1:452
  |
1 | ... fn summarize_by_category (df : DataFrame) -> DataFrame { df . groupby (& []) . expect ("Failed to group DataFrame") . agg ("quantity"...
  |                                                                   ^^^^^^^
  |
help: there is a method `group_by` with a similar name
  |
1 | use polars :: prelude :: * ; fn add_profit_margin (df : DataFrame) -> DataFrame { df . with_column ("margin" , move | row | { (row . get ("revenue") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) - row . get ("cost") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) / row . get ("revenue") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) * 100f64 }) } fn summarize_by_category (df : DataFrame) -> DataFrame { df . group_by (& []) . expect ("Failed to group DataFrame") . agg ("quantity" , "sum") . agg ("revenue" , "mean") . agg ("margin" , "mean") } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                         +

Some errors have detailed explanations: E0061, E0277, E0308, E0599.
For more information about an error, try `rustc --explain E0061`.
error: could not compile `ruchy_binary` (bin "ruchy_binary") due to 4 previous errors

Error: Cargo build failed:
    Updating crates.io index
     Locking 264 packages to latest compatible versions
      Adding polars v0.35.4 (available: v0.52.0)
   Compiling proc-macro2 v1.0.103
   Compiling unicode-ident v1.0.22
   Compiling quote v1.0.42
   Compiling libc v0.2.177
   Compiling version_check v0.9.5
   Compiling cfg-if v1.0.4
   Compiling once_cell v1.21.3
   Compiling memchr v2.7.6
   Compiling autocfg v1.5.0
   Compiling itoa v1.0.15
   Compiling smallvec v1.15.1
   Compiling zerocopy v0.8.27
   Compiling libm v0.2.15
   Compiling crossbeam-utils v0.8.21
   Compiling bytes v1.11.0
   Compiling bitflags v2.10.0
   Compiling hashbrown v0.16.0
   Compiling equivalent v1.0.2
   Compiling target-features v0.1.6
   Compiling stable_deref_trait v1.2.1
   Compiling getrandom v0.3.4
   Compiling rayon-core v1.13.0
   Compiling pin-project-lite v0.2.16
   Compiling regex-syntax v0.8.8
   Compiling syn v1.0.109
   Compiling thiserror v1.0.69
   Compiling parking_lot_core v0.9.12
   Compiling ryu v1.0.20
   Compiling futures-core v0.3.31
   Compiling either v1.15.0
   Compiling find-msvc-tools v0.1.5
   Compiling ahash v0.8.12
   Compiling polars-utils v0.35.4
   Compiling simdutf8 v0.1.5
   Compiling iana-time-zone v0.1.64
   Compiling shlex v1.3.0
   Compiling static_assertions v1.1.0
   Compiling num-traits v0.2.19
   Compiling smartstring v1.0.1
   Compiling allocator-api2 v0.2.21
   Compiling scopeguard v1.2.0
   Compiling rustix v1.1.2
   Compiling lock_api v0.4.14
   Compiling litrs v1.0.0
   Compiling cc v1.2.46
   Compiling futures-sink v0.3.31
   Compiling pkg-config v0.3.32
   Compiling percent-encoding v2.3.2
   Compiling vcpkg v0.2.15
   Compiling aho-corasick v1.1.4
   Compiling linux-raw-sys v0.11.0
   Compiling ethnum v1.5.2
   Compiling fnv v1.0.7
   Compiling crossbeam-epoch v0.9.18
   Compiling atoi_simd v0.15.6
   Compiling indexmap v2.12.0
   Compiling foreign_vec v0.1.0
   Compiling syn v2.0.110
   Compiling streaming-iterator v0.1.9
   Compiling dyn-clone v1.0.20
   Compiling fast-float v0.2.0
   Compiling document-features v0.2.12
   Compiling strength_reduce v0.2.4
   Compiling crossbeam-deque v0.8.6
   Compiling getrandom v0.2.16
   Compiling mio v1.1.0
   Compiling socket2 v0.6.1
   Compiling http v1.3.1
   Compiling rand_core v0.6.4
   Compiling polars-core v0.35.4
   Compiling parking_lot v0.12.5
   Compiling unicode-segmentation v1.12.0
   Compiling slab v0.4.11
   Compiling unicode-width v0.2.2
   Compiling litemap v0.8.1
   Compiling tokio v1.48.0
   Compiling writeable v0.6.2
   Compiling polars-ops v0.35.4
   Compiling icu_properties_data v2.1.1
   Compiling serde_core v1.0.228
   Compiling chrono v0.4.42
   Compiling rayon v1.11.0
   Compiling xxhash-rust v0.8.15
   Compiling crossterm v0.29.0
   Compiling pin-utils v0.1.0
   Compiling icu_normalizer_data v2.1.1
   Compiling argminmax v0.6.3
   Compiling tracing-core v0.1.34
   Compiling futures-io v0.3.31
   Compiling rustversion v1.0.22
   Compiling regex-automata v0.4.13
   Compiling httparse v1.10.1
   Compiling ppv-lite86 v0.2.21
   Compiling openssl-sys v0.9.111
   Compiling comfy-table v7.2.1
   Compiling http-body v1.0.1
   Compiling foreign-types-shared v0.1.1
   Compiling futures-task v0.3.31
   Compiling openssl v0.10.75
   Compiling foreign-types v0.3.2
   Compiling tracing v0.1.41
   Compiling futures-util v0.3.31
   Compiling atoi v2.0.0
   Compiling serde v1.0.228
   Compiling tower-service v0.3.3
   Compiling rand_chacha v0.3.1
   Compiling try-lock v0.2.5
   Compiling native-tls v0.2.14
   Compiling atomic-waker v1.1.2
   Compiling want v0.3.1
   Compiling rand v0.8.5
   Compiling memmap2 v0.7.1
   Compiling futures-channel v0.3.31
   Compiling now v0.1.3
   Compiling polars-plan v0.35.4
   Compiling log v0.4.28
   Compiling home v0.5.12
   Compiling heck v0.4.1
   Compiling openssl-probe v0.1.6
   Compiling form_urlencoded v1.2.2
   Compiling polars-lazy v0.35.4
   Compiling sync_wrapper v1.0.2
   Compiling ipnet v2.11.0
   Compiling base64 v0.22.1
   Compiling utf8_iter v1.0.4
   Compiling tower-layer v0.3.3
   Compiling http-body-util v0.1.3
   Compiling rand_distr v0.4.3
   Compiling polars v0.35.4
   Compiling iri-string v0.7.9
   Compiling zeroize v1.8.2
   Compiling glob v0.3.3
   Compiling serde_json v1.0.145
   Compiling rustls-pki-types v1.13.0
   Compiling encoding_rs v0.8.35
   Compiling mime v0.3.17
   Compiling hashbrown v0.14.5
   Compiling regex v1.12.2
   Compiling synstructure v0.13.2
   Compiling multiversion-macros v0.7.4
   Compiling tokio-util v0.7.17
   Compiling tower v0.5.2
   Compiling zerofrom-derive v0.1.6
   Compiling yoke-derive v0.8.1
   Compiling thiserror-impl v1.0.69
   Compiling zerovec-derive v0.11.2
   Compiling displaydoc v0.2.5
   Compiling bytemuck_derive v1.10.2
   Compiling openssl-macros v0.1.1
   Compiling h2 v0.4.12
   Compiling serde_derive v1.0.228
   Compiling multiversion v0.7.4
   Compiling strum_macros v0.25.3
   Compiling tower-http v0.6.6
   Compiling zerofrom v0.1.6
   Compiling yoke v0.8.1
   Compiling bytemuck v1.24.0
   Compiling polars-error v0.35.4
   Compiling zerovec v0.11.5
   Compiling zerotrie v0.2.3
   Compiling polars-arrow v0.35.4
   Compiling tinystr v0.8.2
   Compiling potential_utf v0.1.4
   Compiling icu_collections v2.1.1
   Compiling icu_locale_core v2.1.1
   Compiling icu_provider v2.1.1
   Compiling serde_urlencoded v0.7.1
   Compiling icu_normalizer v2.1.1
   Compiling icu_properties v2.1.1
   Compiling hyper v1.8.1
   Compiling idna_adapter v1.2.1
   Compiling idna v1.1.0
   Compiling tokio-native-tls v0.3.1
   Compiling url v2.5.7
   Compiling hyper-util v0.1.18
   Compiling hyper-tls v0.6.0
   Compiling reqwest v0.12.24
   Compiling polars-row v0.35.4
   Compiling polars-time v0.35.4
   Compiling polars-io v0.35.4
   Compiling ruchy_binary v0.1.0 (/tmp/.tmpAV4Z85)
error[E0277]: the trait bound `&str: IntoSeries` is not satisfied
    --> src/main.rs:1:101
     |
1    | ...ataFrame) -> DataFrame { df . with_column ("margin" , move | row | { (row . get ("revenue") . cloned () . unwrap_or_else (|| panic ! (...
     |                                  -----------  ^^^^^^^^ the trait `IntoSeries` is not implemented for `&str`
     |                                  |
     |                                  required by a bound introduced by this call
     |
     = help: the following other types implement trait `IntoSeries`:
               Arc<(dyn polars::prelude::SeriesTrait + 'static)>
               ChunkedArray<T>
               Logical<DateType, Int32Type>
               Logical<DatetimeType, Int64Type>
               Logical<DurationType, Int64Type>
               Logical<TimeType, Int64Type>
               implementations::null::NullChunked
               polars::prelude::Series
note: required by a bound in `polars::prelude::DataFrame::with_column`
    --> /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/polars-core-0.35.4/src/frame/mod.rs:1129:27
     |
1129 |     pub fn with_column<S: IntoSeries>(&mut self, column: S) -> PolarsResult<&mut Self> {
     |                           ^^^^^^^^^^ required by this bound in `DataFrame::with_column`

error[E0061]: this method takes 1 argument but 2 arguments were supplied
    --> src/main.rs:1:88
     |
1    | ... . with_column ("margin" , move | row | { (row . get ("revenue") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) - row . get ("cost") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) / row . get ("revenue") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) * 100f64 }) }...
     |       ^^^^^^^^^^^             ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- unexpected argument #2
     |
note: method defined here
    --> /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/polars-core-0.35.4/src/frame/mod.rs:1129:12
     |
1129 |     pub fn with_column<S: IntoSeries>(&mut self, column: S) -> PolarsResult<&mut Self> {
     |            ^^^^^^^^^^^
help: remove the extra argument
     |
1    - use polars :: prelude :: * ; fn add_profit_margin (df : DataFrame) -> DataFrame { df . with_column ("margin" , move | row | { (row . get ("revenue") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) - row . get ("cost") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) / row . get ("revenue") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) * 100f64 }) } fn summarize_by_category (df : DataFrame) -> DataFrame { df . groupby (& []) . expect ("Failed to group DataFrame") . agg ("quantity" , "sum") . agg ("revenue" , "mean") . agg ("margin" , "mean") } fn main () { }
1    + use polars :: prelude :: * ; fn add_profit_margin (df : DataFrame) -> DataFrame { df . with_column ("margin") } fn summarize_by_category (df : DataFrame) -> DataFrame { df . groupby (& []) . expect ("Failed to group DataFrame") . agg ("quantity" , "sum") . agg ("revenue" , "mean") . agg ("margin" , "mean") } fn main () { }
     |

error[E0308]: mismatched types
 --> src/main.rs:1:83
  |
1 | ...-> DataFrame { df . with_column ("margin" , move | row | { (row . get ("revenue") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) - row . get ("cost") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) / row . get ("revenue") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) * 100f64 }) } ...
  |       ---------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...aFrame`, found `Result<&mut DataFrame, PolarsError>`
  |       |
  |       expected `polars::prelude::DataFrame` because of return type
  |
  = note: expected struct `polars::prelude::DataFrame`
               found enum `Result<&mut polars::prelude::DataFrame, PolarsError>`

error[E0599]: no method named `groupby` found for struct `polars::prelude::DataFrame` in the current scope
 --> src/main.rs:1:452
  |
1 | ... fn summarize_by_category (df : DataFrame) -> DataFrame { df . groupby (& []) . expect ("Failed to group DataFrame") . agg ("quantity"...
  |                                                                   ^^^^^^^
  |
help: there is a method `group_by` with a similar name
  |
1 | use polars :: prelude :: * ; fn add_profit_margin (df : DataFrame) -> DataFrame { df . with_column ("margin" , move | row | { (row . get ("revenue") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) - row . get ("cost") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) / row . get ("revenue") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) * 100f64 }) } fn summarize_by_category (df : DataFrame) -> DataFrame { df . group_by (& []) . expect ("Failed to group DataFrame") . agg ("quantity" , "sum") . agg ("revenue" , "mean") . agg ("margin" , "mean") } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                         +

Some errors have detailed explanations: E0061, E0277, E0308, E0599.
For more information about an error, try `rustc --explain E0061`.
error: could not compile `ruchy_binary` (bin "ruchy_binary") due to 4 previous errors



=== ch17-00-error-handling-robustness example 1 ===
âœ— Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Expected RightBrace, found If


=== ch17-00-error-handling-robustness example 3 ===
âœ— Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpgExW9A/main.rs:1:582
  |
1 | ...factorial(20)") ; return safe_factorial (20) } ; if n <= 1 { { return 1 } ((n as i64)) * safe_factorial (n - 1) } } fn main () { { let...
  |                                                                 ^^        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn safe_sqrt (x : f64) -> f64 { if x < 0f64 { println ! ("Error: Cannot compute square root of negative number") ; return 0f64 } ; let mut guess = x / 2f64 ; let mut i = 0 ; while i < 10 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { return guess } ; guess = (guess + x / guess) / 2f64 ; i = i + 1 } } ; guess } fn safe_factorial (n : i32) -> i64 { if n < 0 { println ! ("Error: Factorial undefined for negative numbers") ; return 0 } ; if n > 20 { println ! ("Error: Factorial too large, computing factorial(20)") ; return safe_factorial (20) } ; if n <= 1 { { return 1 } ((n as i64)) * safe_factorial (n - 1) } } fn main () { { let sqrt1 = safe_sqrt (16f64) ; { let sqrt2 = safe_sqrt (- 4f64) ; let fact1 = safe_factorial (5) ; let fact2 = safe_factorial (- 3) ; let fact3 = safe_factorial (25) ; println ! ("{} {:?} {:?}" , "Square roots: {:.2}, {:.2}" , sqrt1 , sqrt2) ; println ! ("Factorials: {}, {}, {}" , fact1 , fact2 , fact3) } } }
1 + fn safe_sqrt (x : f64) -> f64 { if x < 0f64 { println ! ("Error: Cannot compute square root of negative number") ; return 0f64 } ; let mut guess = x / 2f64 ; let mut i = 0 ; while i < 10 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { return guess } ; guess = (guess + x / guess) / 2f64 ; i = i + 1 } } ; guess } fn safe_factorial (n : i32) -> i64 { if n < 0 { println ! ("Error: Factorial undefined for negative numbers") ; return 0 } ; if n > 20 { println ! ("Error: Factorial too large, computing factorial(20)") ; return safe_factorial (20) } ; if n <= 1 { return 1 ((n as i64)) * safe_factorial (n - 1) } } fn main () { { let sqrt1 = safe_sqrt (16f64) ; { let sqrt2 = safe_sqrt (- 4f64) ; let fact1 = safe_factorial (5) ; let fact2 = safe_factorial (- 3) ; let fact3 = safe_factorial (25) ; println ! ("{} {:?} {:?}" , "Square roots: {:.2}, {:.2}" , sqrt1 , sqrt2) ; println ! ("Factorials: {}, {}, {}" , fact1 , fact2 , fact3) } } }
  |

warning: unreachable expression
 --> /tmp/.tmpgExW9A/main.rs:1:595
  |
1 | ...ctorial (20) } ; if n <= 1 { { return 1 } ((n as i64)) * safe_factorial (n - 1) } } fn main () { { let sqrt1 = safe_sqrt (16f64) ; { l...
  |                                   --------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression
  |                                   |
  |                                   any code following this expression is unreachable
  |
  = note: `#[warn(unreachable_code)]` on by default

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpgExW9A/main.rs:1:570
  |
1 | ...-> i64 { if n < 0 { println ! ("Error: Factorial undefined for negative numbers") ; return 0 } ; if n > 20 { println ! ("Error: Factorial too large, computing factorial(20)") ; return safe_factorial (20) } ; if n <= 1 { { return 1 } ((n as i64)) * safe_factorial (n - 1) } } ...
  |       --- expected `i64` because of this return type                                                                                                                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0317`.

Error: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpgExW9A/main.rs:1:582
  |
1 | ...factorial(20)") ; return safe_factorial (20) } ; if n <= 1 { { return 1 } ((n as i64)) * safe_factorial (n - 1) } } fn main () { { let...
  |                                                                 ^^        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn safe_sqrt (x : f64) -> f64 { if x < 0f64 { println ! ("Error: Cannot compute square root of negative number") ; return 0f64 } ; let mut guess = x / 2f64 ; let mut i = 0 ; while i < 10 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { return guess } ; guess = (guess + x / guess) / 2f64 ; i = i + 1 } } ; guess } fn safe_factorial (n : i32) -> i64 { if n < 0 { println ! ("Error: Factorial undefined for negative numbers") ; return 0 } ; if n > 20 { println ! ("Error: Factorial too large, computing factorial(20)") ; return safe_factorial (20) } ; if n <= 1 { { return 1 } ((n as i64)) * safe_factorial (n - 1) } } fn main () { { let sqrt1 = safe_sqrt (16f64) ; { let sqrt2 = safe_sqrt (- 4f64) ; let fact1 = safe_factorial (5) ; let fact2 = safe_factorial (- 3) ; let fact3 = safe_factorial (25) ; println ! ("{} {:?} {:?}" , "Square roots: {:.2}, {:.2}" , sqrt1 , sqrt2) ; println ! ("Factorials: {}, {}, {}" , fact1 , fact2 , fact3) } } }
1 + fn safe_sqrt (x : f64) -> f64 { if x < 0f64 { println ! ("Error: Cannot compute square root of negative number") ; return 0f64 } ; let mut guess = x / 2f64 ; let mut i = 0 ; while i < 10 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { return guess } ; guess = (guess + x / guess) / 2f64 ; i = i + 1 } } ; guess } fn safe_factorial (n : i32) -> i64 { if n < 0 { println ! ("Error: Factorial undefined for negative numbers") ; return 0 } ; if n > 20 { println ! ("Error: Factorial too large, computing factorial(20)") ; return safe_factorial (20) } ; if n <= 1 { return 1 ((n as i64)) * safe_factorial (n - 1) } } fn main () { { let sqrt1 = safe_sqrt (16f64) ; { let sqrt2 = safe_sqrt (- 4f64) ; let fact1 = safe_factorial (5) ; let fact2 = safe_factorial (- 3) ; let fact3 = safe_factorial (25) ; println ! ("{} {:?} {:?}" , "Square roots: {:.2}, {:.2}" , sqrt1 , sqrt2) ; println ! ("Factorials: {}, {}, {}" , fact1 , fact2 , fact3) } } }
  |

warning: unreachable expression
 --> /tmp/.tmpgExW9A/main.rs:1:595
  |
1 | ...ctorial (20) } ; if n <= 1 { { return 1 } ((n as i64)) * safe_factorial (n - 1) } } fn main () { { let sqrt1 = safe_sqrt (16f64) ; { l...
  |                                   --------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression
  |                                   |
  |                                   any code following this expression is unreachable
  |
  = note: `#[warn(unreachable_code)]` on by default

error[E0317]: `if` may be missing an `else` clause
 --> /tmp/.tmpgExW9A/main.rs:1:570
  |
1 | ...-> i64 { if n < 0 { println ! ("Error: Factorial undefined for negative numbers") ; return 0 } ; if n > 20 { println ! ("Error: Factorial too large, computing factorial(20)") ; return safe_factorial (20) } ; if n <= 1 { { return 1 } ((n as i64)) * safe_factorial (n - 1) } } ...
  |       --- expected `i64` because of this return type                                                                                                                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `()`
  |
  = note: `if` expressions without `else` evaluate to `()`
  = help: consider adding an `else` block that evaluates to the expected type

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0317`.



=== ch17-00-error-handling-robustness example 4 ===
âœ— Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Expected RightBrace, found If


=== ch17-00-error-handling-robustness example 6 ===
âœ— Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Expected RightBrace, found LineComment(" Simulate configuration lookup")


=== ch17-00-error-handling-robustness example 8 ===

thread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ruchy-3.89.0/src/backend/transpiler/expressions.rs:40:18:
internal error: entered unreachable code
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


=== ch17-00-error-handling-robustness example 9 ===
âœ— Compilation failed: Compilation failed:
error[E0425]: cannot find function `safe_divide` in this scope
 --> /tmp/.tmpjlW2z1/main.rs:1:103
  |
1 | ...ing division error handling...") ; let result1 = safe_divide (10 , 2) ; if result1 == 5 { println ! ("âœ… Normal division test passed") }...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `safe_divide` in this scope
 --> /tmp/.tmpjlW2z1/main.rs:1:259
  |
1 | ... Normal division test failed") } ; let result2 = safe_divide (10 , 0) ; if result2 == 0 { println ! ("âœ… Division by zero handling passed...
  |                                                      ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `safe_divide` in this scope
 --> /tmp/.tmpjlW2z1/main.rs:1:425
  |
1 | ...sion by zero handling failed") } ; let result3 = safe_divide (- 10 , 2) ; if result3 == - 5 { println ! ("âœ… Negative number handling pa...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `validate_age` in this scope
 --> /tmp/.tmpjlW2z1/main.rs:1:666
  |
1 | ...n ! ("Testing input validation...") ; let age1 = validate_age (25) ; if age1 == 25 { println ! ("âœ… Valid age test passed") } else { pri...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `validate_age` in this scope
 --> /tmp/.tmpjlW2z1/main.rs:1:802
  |
1 | ...tln ! ("âŒ Valid age test failed") } ; let age2 = validate_age (- 5) ; if age2 == 0 { println ! ("âœ… Negative age handling passed") } else...
  |                                                      ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `validate_age` in this scope
 --> /tmp/.tmpjlW2z1/main.rs:1:952
  |
1 | ..."âŒ Negative age handling failed") } ; let age3 = validate_age (200) ; if age3 == 150 { println ! ("âœ… Extreme age handling passed") } els...
  |                                                      ^^^^^^^^^^^^ not found in this scope

error: aborting due to 6 previous errors

For more information about this error, try `rustc --explain E0425`.

Error: Compilation failed:
error[E0425]: cannot find function `safe_divide` in this scope
 --> /tmp/.tmpjlW2z1/main.rs:1:103
  |
1 | ...ing division error handling...") ; let result1 = safe_divide (10 , 2) ; if result1 == 5 { println ! ("âœ… Normal division test passed") }...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `safe_divide` in this scope
 --> /tmp/.tmpjlW2z1/main.rs:1:259
  |
1 | ... Normal division test failed") } ; let result2 = safe_divide (10 , 0) ; if result2 == 0 { println ! ("âœ… Division by zero handling passed...
  |                                                      ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `safe_divide` in this scope
 --> /tmp/.tmpjlW2z1/main.rs:1:425
  |
1 | ...sion by zero handling failed") } ; let result3 = safe_divide (- 10 , 2) ; if result3 == - 5 { println ! ("âœ… Negative number handling pa...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `validate_age` in this scope
 --> /tmp/.tmpjlW2z1/main.rs:1:666
  |
1 | ...n ! ("Testing input validation...") ; let age1 = validate_age (25) ; if age1 == 25 { println ! ("âœ… Valid age test passed") } else { pri...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `validate_age` in this scope
 --> /tmp/.tmpjlW2z1/main.rs:1:802
  |
1 | ...tln ! ("âŒ Valid age test failed") } ; let age2 = validate_age (- 5) ; if age2 == 0 { println ! ("âœ… Negative age handling passed") } else...
  |                                                      ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `validate_age` in this scope
 --> /tmp/.tmpjlW2z1/main.rs:1:952
  |
1 | ..."âŒ Negative age handling failed") } ; let age3 = validate_age (200) ; if age3 == 150 { println ! ("âœ… Extreme age handling passed") } els...
  |                                                      ^^^^^^^^^^^^ not found in this scope

error: aborting due to 6 previous errors

For more information about this error, try `rustc --explain E0425`.



=== ch05-00-control-flow-tdd example 15 ===
âœ— Compilation failed: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpwmD4Gn/main.rs:1:23
  |
1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path ("sales.csv") . expect ("Failed to open CSV file") . finish () . expect...
  |                       ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error: aborting due to 1 previous error

For more information about this error, try `rustc --explain E0433`.

Error: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpwmD4Gn/main.rs:1:23
  |
1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path ("sales.csv") . expect ("Failed to open CSV file") . finish () . expect...
  |                       ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error: aborting due to 1 previous error

For more information about this error, try `rustc --explain E0433`.



=== ch05-00-control-flow-tdd example 16 ===
âœ— Compilation failed: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpFYmxBg/main.rs:1:23
  |
1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . ex...
  |                       ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

warning: unnecessary braces around block return value
 --> /tmp/.tmpFYmxBg/main.rs:1:204
  |
1 | ... { { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10 { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; for row in df . iter_rows () { { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10 { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } ; let mut total = 0f64 ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! ("Total positive prices: {}" , total) ; }
1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; for row in df . iter_rows () { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10 { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } ; let mut total = 0f64 ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! ("Total positive prices: {}" , total) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpFYmxBg/main.rs:1:642
  |
1 | ... (|| panic ! ("Key not found")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! ("Total positive prices: {}" ,...
  |                                                ^^                                         ^^
  |
help: remove these braces
  |
1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; for row in df . iter_rows () { { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10 { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } ; let mut total = 0f64 ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! ("Total positive prices: {}" , total) ; }
1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; for row in df . iter_rows () { { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10 { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } ; let mut total = 0f64 ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) . iter () { if value > 0f64 { total = total + value } } ; println ! ("Total positive prices: {}" , total) ; }
  |

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0433`.

Error: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpFYmxBg/main.rs:1:23
  |
1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . ex...
  |                       ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

warning: unnecessary braces around block return value
 --> /tmp/.tmpFYmxBg/main.rs:1:204
  |
1 | ... { { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10 { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; for row in df . iter_rows () { { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10 { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } ; let mut total = 0f64 ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! ("Total positive prices: {}" , total) ; }
1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; for row in df . iter_rows () { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10 { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } ; let mut total = 0f64 ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! ("Total positive prices: {}" , total) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpFYmxBg/main.rs:1:642
  |
1 | ... (|| panic ! ("Key not found")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! ("Total positive prices: {}" ,...
  |                                                ^^                                         ^^
  |
help: remove these braces
  |
1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; for row in df . iter_rows () { { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10 { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } ; let mut total = 0f64 ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! ("Total positive prices: {}" , total) ; }
1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path ("inventory.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; for row in df . iter_rows () { { if row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) < 10 { println ! ("Low stock alert: {} ({})" , row . get ("product") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , row . get ("quantity") . cloned () . unwrap_or_else (|| panic ! ("Key not found"))) } } } ; let mut total = 0f64 ; for value in df . get ("price") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) . iter () { if value > 0f64 { total = total + value } } ; println ! ("Total positive prices: {}" , total) ; }
  |

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0433`.



=== ch05-00-control-flow-tdd example 17 ===
âœ— Compilation failed: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpGH6hUW/main.rs:1:23
  |
1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path ("customers.csv") . expect ("Failed to open CSV file") . finish () . ex...
  |                       ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

warning: unnecessary braces around block return value
 --> /tmp/.tmpGH6hUW/main.rs:1:204
  |
1 | ... { { { let category = match row . get ("total_purchases") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) { v if v > 10000 => "Platinum" , v if v > 5000 => "Gold" , v if v > 1000 => "Silver" , _ => "Bronze" , } ; println ! ("Customer {} is {} tier" , row . get ("name") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , category) } } } ; }
  |       ^^                                                                                                                                                                                                                                                                                                                                                              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path ("customers.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; for row in df . iter_rows () { { { let category = match row . get ("total_purchases") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) { v if v > 10000 => "Platinum" , v if v > 5000 => "Gold" , v if v > 1000 => "Silver" , _ => "Bronze" , } ; println ! ("Customer {} is {} tier" , row . get ("name") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , category) } } } ; }
1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path ("customers.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; for row in df . iter_rows () { { let category = match row . get ("total_purchases") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) { v if v > 10000 => "Platinum" , v if v > 5000 => "Gold" , v if v > 1000 => "Silver" , _ => "Bronze" , } ; println ! ("Customer {} is {} tier" , row . get ("name") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , category) } } ; }
  |

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0433`.

Error: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpGH6hUW/main.rs:1:23
  |
1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path ("customers.csv") . expect ("Failed to open CSV file") . finish () . ex...
  |                       ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

warning: unnecessary braces around block return value
 --> /tmp/.tmpGH6hUW/main.rs:1:204
  |
1 | ... { { { let category = match row . get ("total_purchases") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) { v if v > 10000 => "Platinum" , v if v > 5000 => "Gold" , v if v > 1000 => "Silver" , _ => "Bronze" , } ; println ! ("Customer {} is {} tier" , row . get ("name") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , category) } } } ; }
  |       ^^                                                                                                                                                                                                                                                                                                                                                              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path ("customers.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; for row in df . iter_rows () { { { let category = match row . get ("total_purchases") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) { v if v > 10000 => "Platinum" , v if v > 5000 => "Gold" , v if v > 1000 => "Silver" , _ => "Bronze" , } ; println ! ("Customer {} is {} tier" , row . get ("name") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , category) } } } ; }
1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path ("customers.csv") . expect ("Failed to open CSV file") . finish () . expect ("Failed to read CSV file") ; for row in df . iter_rows () { { let category = match row . get ("total_purchases") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) { v if v > 10000 => "Platinum" , v if v > 5000 => "Gold" , v if v > 1000 => "Silver" , _ => "Bronze" , } ; println ! ("Customer {} is {} tier" , row . get ("name") . cloned () . unwrap_or_else (|| panic ! ("Key not found")) , category) } } ; }
  |

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0433`.



=== ch02-00-variables-types-tdd example 5 ===
âœ— Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Unexpected end of input - expected expression


=== ch02-00-variables-types-tdd example 6 ===
âœ— Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Expected RightBrace, found Let


=== ch02-00-variables-types-tdd example 7 ===
âœ— Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Expected RightBrace, found Let


=== ch19-00-structs-oop example 1 ===
âœ— Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Unexpected end of input - expected expression


=== ch19-00-structs-oop example 2 ===
âœ— Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Unexpected end of input - expected expression


=== ch19-00-structs-oop example 3 ===
âœ— Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Unexpected end of input - expected expression


=== ch19-00-structs-oop example 4 ===
âœ— Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Unexpected end of input - expected expression


=== ch19-00-structs-oop example 5 ===
âœ— Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Unexpected end of input - expected expression


=== ch19-00-structs-oop example 6 ===
âœ— Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Unexpected end of input - expected expression


=== ch19-00-structs-oop example 7 ===
âœ— Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Expected field name in struct


=== ch19-00-structs-oop example 8 ===
âœ— Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Unexpected end of input - expected expression


=== ch19-00-structs-oop example 9 ===
âœ— Compilation failed: Compilation failed:
error[E0425]: cannot find value `point` in this scope
 --> /tmp/.tmpiXDJpZ/main.rs:1:33
  |
1 | fn main () { let result = match point { Point { x : 0 , y : 0 } => println ! ("Origin") , Point { x : 0 , y } => println ! ("On Y axis") ...
  |                                 ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmpiXDJpZ/main.rs:1:41
  |
1 | fn main () { let result = match point { Point { x : 0 , y : 0 } => println ! ("Origin") , Point { x : 0 , y } => println ! ("On Y axis") ...
  |                                         ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmpiXDJpZ/main.rs:1:91
  |
1 | fn main () { let result = match point { Point { x : 0 , y : 0 } => println ! ("Origin") , Point { x : 0 , y } => println ! ("On Y axis") ...
  |                                                                                           ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmpiXDJpZ/main.rs:1:140
  |
1 | ... , Point { x : 0 , y } => println ! ("On Y axis") , Point { x , y : 0 } => println ! ("On X axis") , Point { x , y } => println ! ("Ge...
  |                                                        ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmpiXDJpZ/main.rs:1:189
  |
1 | ... , Point { x , y : 0 } => println ! ("On X axis") , Point { x , y } => println ! ("General point") , } ; if std :: any :: type_name_of...
  |                                                        ^^^^^ not found in this scope

error: aborting due to 5 previous errors

Some errors have detailed explanations: E0422, E0425.
For more information about an error, try `rustc --explain E0422`.

Error: Compilation failed:
error[E0425]: cannot find value `point` in this scope
 --> /tmp/.tmpiXDJpZ/main.rs:1:33
  |
1 | fn main () { let result = match point { Point { x : 0 , y : 0 } => println ! ("Origin") , Point { x : 0 , y } => println ! ("On Y axis") ...
  |                                 ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmpiXDJpZ/main.rs:1:41
  |
1 | fn main () { let result = match point { Point { x : 0 , y : 0 } => println ! ("Origin") , Point { x : 0 , y } => println ! ("On Y axis") ...
  |                                         ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmpiXDJpZ/main.rs:1:91
  |
1 | fn main () { let result = match point { Point { x : 0 , y : 0 } => println ! ("Origin") , Point { x : 0 , y } => println ! ("On Y axis") ...
  |                                                                                           ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmpiXDJpZ/main.rs:1:140
  |
1 | ... , Point { x : 0 , y } => println ! ("On Y axis") , Point { x , y : 0 } => println ! ("On X axis") , Point { x , y } => println ! ("Ge...
  |                                                        ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmpiXDJpZ/main.rs:1:189
  |
1 | ... , Point { x , y : 0 } => println ! ("On X axis") , Point { x , y } => println ! ("General point") , } ; if std :: any :: type_name_of...
  |                                                        ^^^^^ not found in this scope

error: aborting due to 5 previous errors

Some errors have detailed explanations: E0422, E0425.
For more information about an error, try `rustc --explain E0422`.



=== ch04-00-practical-patterns-tdd example 5 ===
âœ— Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Expected RightBrace, found Let


=== ch04-00-practical-patterns-tdd example 6 ===
âœ— Compilation failed: Compilation failed:
error[E0106]: missing lifetime specifier
 --> /tmp/.tmpmoB5dK/main.rs:1:1228
  |
1 | ... return "error" } } } } } } fn track_order () -> & str { let mut state = "pending" ; println ! ("Order tracking simulation:") ; printl...
  |                                                     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime, but this is uncommon unless you're returning a borrowed value from a `const` or a `static`
  |
1 | fn process_order_state < 'a > (current_state : & 'a str , action : & 'a str) -> & 'a str { if current_state == "pending" { if action == "pay" { println ! ("Payment received, order confirmed") ; return "confirmed" } else { if action == "cancel" { println ! ("Order cancelled") ; return "cancelled" } else { println ! ("Invalid action '{}' for pending order" , action) ; return current_state } } } else { if current_state == "confirmed" { if action == "ship" { println ! ("Order shipped") ; return "shipped" } else { if action == "cancel" { println ! ("Confirmed order cancelled, refund processed") ; return "cancelled" } else { println ! ("Invalid action '{}' for confirmed order" , action) ; return current_state } } } else { if current_state == "shipped" { if action == "deliver" { println ! ("Order delivered") ; return "delivered" } else { println ! ("Cannot modify shipped order") ; return current_state } } else { if current_state == "delivered" { println ! ("Order already completed") ; return current_state } else { if current_state == "cancelled" { println ! ("Order was cancelled") ; return current_state } else { println ! ("Unknown order state: {}" , current_state) ; return "error" } } } } } } fn track_order () -> &'static  str { let mut state = "pending" ; println ! ("Order tracking simulation:") ; println ! ("Initial state: {}" , state) ; state = process_order_state (state , "pay") ; println ! ("Current state: {}" , state) ; state = process_order_state (state , "ship") ; println ! ("Current state: {}" , state) ; state = process_order_state (state , "deliver") ; println ! ("Current state: {}" , state) ; state } fn main () { { let final_state = track_order () ; println ! ("Final order state: {}" , final_state) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             +++++++
help: instead, you are more likely to want to return an owned value
  |
1 - fn process_order_state < 'a > (current_state : & 'a str , action : & 'a str) -> & 'a str { if current_state == "pending" { if action == "pay" { println ! ("Payment received, order confirmed") ; return "confirmed" } else { if action == "cancel" { println ! ("Order cancelled") ; return "cancelled" } else { println ! ("Invalid action '{}' for pending order" , action) ; return current_state } } } else { if current_state == "confirmed" { if action == "ship" { println ! ("Order shipped") ; return "shipped" } else { if action == "cancel" { println ! ("Confirmed order cancelled, refund processed") ; return "cancelled" } else { println ! ("Invalid action '{}' for confirmed order" , action) ; return current_state } } } else { if current_state == "shipped" { if action == "deliver" { println ! ("Order delivered") ; return "delivered" } else { println ! ("Cannot modify shipped order") ; return current_state } } else { if current_state == "delivered" { println ! ("Order already completed") ; return current_state } else { if current_state == "cancelled" { println ! ("Order was cancelled") ; return current_state } else { println ! ("Unknown order state: {}" , current_state) ; return "error" } } } } } } fn track_order () -> & str { let mut state = "pending" ; println ! ("Order tracking simulation:") ; println ! ("Initial state: {}" , state) ; state = process_order_state (state , "pay") ; println ! ("Current state: {}" , state) ; state = process_order_state (state , "ship") ; println ! ("Current state: {}" , state) ; state = process_order_state (state , "deliver") ; println ! ("Current state: {}" , state) ; state } fn main () { { let final_state = track_order () ; println ! ("Final order state: {}" , final_state) } }
1 + fn process_order_state < 'a > (current_state : & 'a str , action : & 'a str) -> & 'a str { if current_state == "pending" { if action == "pay" { println ! ("Payment received, order confirmed") ; return "confirmed" } else { if action == "cancel" { println ! ("Order cancelled") ; return "cancelled" } else { println ! ("Invalid action '{}' for pending order" , action) ; return current_state } } } else { if current_state == "confirmed" { if action == "ship" { println ! ("Order shipped") ; return "shipped" } else { if action == "cancel" { println ! ("Confirmed order cancelled, refund processed") ; return "cancelled" } else { println ! ("Invalid action '{}' for confirmed order" , action) ; return current_state } } } else { if current_state == "shipped" { if action == "deliver" { println ! ("Order delivered") ; return "delivered" } else { println ! ("Cannot modify shipped order") ; return current_state } } else { if current_state == "delivered" { println ! ("Order already completed") ; return current_state } else { if current_state == "cancelled" { println ! ("Order was cancelled") ; return current_state } else { println ! ("Unknown order state: {}" , current_state) ; return "error" } } } } } } fn track_order () -> String { let mut state = "pending" ; println ! ("Order tracking simulation:") ; println ! ("Initial state: {}" , state) ; state = process_order_state (state , "pay") ; println ! ("Current state: {}" , state) ; state = process_order_state (state , "ship") ; println ! ("Current state: {}" , state) ; state = process_order_state (state , "deliver") ; println ! ("Current state: {}" , state) ; state } fn main () { { let final_state = track_order () ; println ! ("Final order state: {}" , final_state) } }
  |

error: aborting due to 1 previous error

For more information about this error, try `rustc --explain E0106`.

Error: Compilation failed:
error[E0106]: missing lifetime specifier
 --> /tmp/.tmpmoB5dK/main.rs:1:1228
  |
1 | ... return "error" } } } } } } fn track_order () -> & str { let mut state = "pending" ; println ! ("Order tracking simulation:") ; printl...
  |                                                     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime, but this is uncommon unless you're returning a borrowed value from a `const` or a `static`
  |
1 | fn process_order_state < 'a > (current_state : & 'a str , action : & 'a str) -> & 'a str { if current_state == "pending" { if action == "pay" { println ! ("Payment received, order confirmed") ; return "confirmed" } else { if action == "cancel" { println ! ("Order cancelled") ; return "cancelled" } else { println ! ("Invalid action '{}' for pending order" , action) ; return current_state } } } else { if current_state == "confirmed" { if action == "ship" { println ! ("Order shipped") ; return "shipped" } else { if action == "cancel" { println ! ("Confirmed order cancelled, refund processed") ; return "cancelled" } else { println ! ("Invalid action '{}' for confirmed order" , action) ; return current_state } } } else { if current_state == "shipped" { if action == "deliver" { println ! ("Order delivered") ; return "delivered" } else { println ! ("Cannot modify shipped order") ; return current_state } } else { if current_state == "delivered" { println ! ("Order already completed") ; return current_state } else { if current_state == "cancelled" { println ! ("Order was cancelled") ; return current_state } else { println ! ("Unknown order state: {}" , current_state) ; return "error" } } } } } } fn track_order () -> &'static  str { let mut state = "pending" ; println ! ("Order tracking simulation:") ; println ! ("Initial state: {}" , state) ; state = process_order_state (state , "pay") ; println ! ("Current state: {}" , state) ; state = process_order_state (state , "ship") ; println ! ("Current state: {}" , state) ; state = process_order_state (state , "deliver") ; println ! ("Current state: {}" , state) ; state } fn main () { { let final_state = track_order () ; println ! ("Final order state: {}" , final_state) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             +++++++
help: instead, you are more likely to want to return an owned value
  |
1 - fn process_order_state < 'a > (current_state : & 'a str , action : & 'a str) -> & 'a str { if current_state == "pending" { if action == "pay" { println ! ("Payment received, order confirmed") ; return "confirmed" } else { if action == "cancel" { println ! ("Order cancelled") ; return "cancelled" } else { println ! ("Invalid action '{}' for pending order" , action) ; return current_state } } } else { if current_state == "confirmed" { if action == "ship" { println ! ("Order shipped") ; return "shipped" } else { if action == "cancel" { println ! ("Confirmed order cancelled, refund processed") ; return "cancelled" } else { println ! ("Invalid action '{}' for confirmed order" , action) ; return current_state } } } else { if current_state == "shipped" { if action == "deliver" { println ! ("Order delivered") ; return "delivered" } else { println ! ("Cannot modify shipped order") ; return current_state } } else { if current_state == "delivered" { println ! ("Order already completed") ; return current_state } else { if current_state == "cancelled" { println ! ("Order was cancelled") ; return current_state } else { println ! ("Unknown order state: {}" , current_state) ; return "error" } } } } } } fn track_order () -> & str { let mut state = "pending" ; println ! ("Order tracking simulation:") ; println ! ("Initial state: {}" , state) ; state = process_order_state (state , "pay") ; println ! ("Current state: {}" , state) ; state = process_order_state (state , "ship") ; println ! ("Current state: {}" , state) ; state = process_order_state (state , "deliver") ; println ! ("Current state: {}" , state) ; state } fn main () { { let final_state = track_order () ; println ! ("Final order state: {}" , final_state) } }
1 + fn process_order_state < 'a > (current_state : & 'a str , action : & 'a str) -> & 'a str { if current_state == "pending" { if action == "pay" { println ! ("Payment received, order confirmed") ; return "confirmed" } else { if action == "cancel" { println ! ("Order cancelled") ; return "cancelled" } else { println ! ("Invalid action '{}' for pending order" , action) ; return current_state } } } else { if current_state == "confirmed" { if action == "ship" { println ! ("Order shipped") ; return "shipped" } else { if action == "cancel" { println ! ("Confirmed order cancelled, refund processed") ; return "cancelled" } else { println ! ("Invalid action '{}' for confirmed order" , action) ; return current_state } } } else { if current_state == "shipped" { if action == "deliver" { println ! ("Order delivered") ; return "delivered" } else { println ! ("Cannot modify shipped order") ; return current_state } } else { if current_state == "delivered" { println ! ("Order already completed") ; return current_state } else { if current_state == "cancelled" { println ! ("Order was cancelled") ; return current_state } else { println ! ("Unknown order state: {}" , current_state) ; return "error" } } } } } } fn track_order () -> String { let mut state = "pending" ; println ! ("Order tracking simulation:") ; println ! ("Initial state: {}" , state) ; state = process_order_state (state , "pay") ; println ! ("Current state: {}" , state) ; state = process_order_state (state , "ship") ; println ! ("Current state: {}" , state) ; state = process_order_state (state , "deliver") ; println ! ("Current state: {}" , state) ; state } fn main () { { let final_state = track_order () ; println ! ("Final order state: {}" , final_state) } }
  |

error: aborting due to 1 previous error

For more information about this error, try `rustc --explain E0106`.



=== ch04-00-practical-patterns-tdd example 9 ===
âœ— Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Expected RightBrace, found If


=== ch04-00-practical-patterns-tdd example 10 ===

thread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ruchy-3.89.0/src/backend/transpiler/expressions.rs:40:18:
internal error: entered unreachable code
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


=== conclusion example 1 ===
âœ— Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Expected RightBrace, found Let


=== ch18-00-dataframes-data-processing example 1 ===
âœ— Compilation failed: Failed to parse Ruchy source
Error: Failed to parse Ruchy source

Caused by:
    Expected RightBrace, found Let


=== ch18-00-dataframes-data-processing example 2 ===
âœ— Compilation failed: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmp5p1Dnd/main.rs:1:5
  |
1 | use polars :: prelude :: * ; fn analyze_sales (df : DataFrame) { println ! ("Analyzing {} sales records" , df . height ()) ; println ! ("...
  |     ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmp5p1Dnd/main.rs:1:207
  |
1 | ...th ()) ; } fn main () { { let sales = polars :: prelude :: DataFrame :: new (vec ! [polars :: prelude :: Series :: new ("product" , & ...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmp5p1Dnd/main.rs:1:253
  |
1 | ...: prelude :: DataFrame :: new (vec ! [polars :: prelude :: Series :: new ("product" , & ["Widget" , "Gadget" , "Gizmo"]) , polars :: p...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmp5p1Dnd/main.rs:1:338
  |
1 | ... & ["Widget" , "Gadget" , "Gizmo"]) , polars :: prelude :: Series :: new ("quantity" , & [100 , 150 , 200]) , polars :: prelude :: Ser...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmp5p1Dnd/main.rs:1:410
  |
1 | ... ("quantity" , & [100 , 150 , 200]) , polars :: prelude :: Series :: new ("revenue" , & [999f64 , 1499f64 , 1999f64])]) . expect ("Fai...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0412]: cannot find type `DataFrame` in this scope
 --> /tmp/.tmp5p1Dnd/main.rs:1:53
  |
1 | use polars :: prelude :: * ; fn analyze_sales (df : DataFrame) { println ! ("Analyzing {} sales records" , df . height ()) ; println ! ("...
  |                                                     ^^^^^^^^^ not found in this scope

error: aborting due to 6 previous errors

Some errors have detailed explanations: E0412, E0433.
For more information about an error, try `rustc --explain E0412`.

Error: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmp5p1Dnd/main.rs:1:5
  |
1 | use polars :: prelude :: * ; fn analyze_sales (df : DataFrame) { println ! ("Analyzing {} sales records" , df . height ()) ; println ! ("...
  |     ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmp5p1Dnd/main.rs:1:207
  |
1 | ...th ()) ; } fn main () { { let sales = polars :: prelude :: DataFrame :: new (vec ! [polars :: prelude :: Series :: new ("product" , & ...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmp5p1Dnd/main.rs:1:253
  |
1 | ...: prelude :: DataFrame :: new (vec ! [polars :: prelude :: Series :: new ("product" , & ["Widget" , "Gadget" , "Gizmo"]) , polars :: p...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmp5p1Dnd/main.rs:1:338
  |
1 | ... & ["Widget" , "Gadget" , "Gizmo"]) , polars :: prelude :: Series :: new ("quantity" , & [100 , 150 , 200]) , polars :: prelude :: Ser...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmp5p1Dnd/main.rs:1:410
  |
1 | ... ("quantity" , & [100 , 150 , 200]) , polars :: prelude :: Series :: new ("revenue" , & [999f64 , 1499f64 , 1999f64])]) . expect ("Fai...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0412]: cannot find type `DataFrame` in this scope
 --> /tmp/.tmp5p1Dnd/main.rs:1:53
  |
1 | use polars :: prelude :: * ; fn analyze_sales (df : DataFrame) { println ! ("Analyzing {} sales records" , df . height ()) ; println ! ("...
  |                                                     ^^^^^^^^^ not found in this scope

error: aborting due to 6 previous errors

Some errors have detailed explanations: E0412, E0433.
For more information about an error, try `rustc --explain E0412`.



=== ch18-00-dataframes-data-processing example 3 ===
âœ— Compilation failed: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpPNMbrO/main.rs:1:5
  |
1 | use polars :: prelude :: * ; fn work_with_multiple_dataframes () { { let customers = polars :: prelude :: DataFrame :: new (vec ! [polars...
  |     ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpPNMbrO/main.rs:1:86
  |
1 | ...ple_dataframes () { { let customers = polars :: prelude :: DataFrame :: new (vec ! [polars :: prelude :: Series :: new ("customer_id" ...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpPNMbrO/main.rs:1:132
  |
1 | ...: prelude :: DataFrame :: new (vec ! [polars :: prelude :: Series :: new ("customer_id" , & [1 , 2 , 3]) , polars :: prelude :: Series...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpPNMbrO/main.rs:1:201
  |
1 | ...new ("customer_id" , & [1 , 2 , 3]) , polars :: prelude :: Series :: new ("name" , & ["Alice" , "Bob" , "Charlie"]) , polars :: prelud...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpPNMbrO/main.rs:1:281
  |
1 | ... , & ["Alice" , "Bob" , "Charlie"]) , polars :: prelude :: Series :: new ("city" , & ["New York" , "Los Angeles" , "Chicago"])]) . exp...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpPNMbrO/main.rs:1:429
  |
1 | ...o create DataFrame") ; { let orders = polars :: prelude :: DataFrame :: new (vec ! [polars :: prelude :: Series :: new ("order_id" , &...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpPNMbrO/main.rs:1:475
  |
1 | ...: prelude :: DataFrame :: new (vec ! [polars :: prelude :: Series :: new ("order_id" , & [101 , 102 , 103]) , polars :: prelude :: Ser...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpPNMbrO/main.rs:1:547
  |
1 | ... ("order_id" , & [101 , 102 , 103]) , polars :: prelude :: Series :: new ("customer_id" , & [1 , 2 , 1]) , polars :: prelude :: Series...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpPNMbrO/main.rs:1:616
  |
1 | ...new ("customer_id" , & [1 , 2 , 1]) , polars :: prelude :: Series :: new ("amount" , & [99.99f64 , 149.99f64 , 79.99f64])]) . expect (...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error: aborting due to 9 previous errors

For more information about this error, try `rustc --explain E0433`.

Error: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpPNMbrO/main.rs:1:5
  |
1 | use polars :: prelude :: * ; fn work_with_multiple_dataframes () { { let customers = polars :: prelude :: DataFrame :: new (vec ! [polars...
  |     ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpPNMbrO/main.rs:1:86
  |
1 | ...ple_dataframes () { { let customers = polars :: prelude :: DataFrame :: new (vec ! [polars :: prelude :: Series :: new ("customer_id" ...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpPNMbrO/main.rs:1:132
  |
1 | ...: prelude :: DataFrame :: new (vec ! [polars :: prelude :: Series :: new ("customer_id" , & [1 , 2 , 3]) , polars :: prelude :: Series...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpPNMbrO/main.rs:1:201
  |
1 | ...new ("customer_id" , & [1 , 2 , 3]) , polars :: prelude :: Series :: new ("name" , & ["Alice" , "Bob" , "Charlie"]) , polars :: prelud...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpPNMbrO/main.rs:1:281
  |
1 | ... , & ["Alice" , "Bob" , "Charlie"]) , polars :: prelude :: Series :: new ("city" , & ["New York" , "Los Angeles" , "Chicago"])]) . exp...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpPNMbrO/main.rs:1:429
  |
1 | ...o create DataFrame") ; { let orders = polars :: prelude :: DataFrame :: new (vec ! [polars :: prelude :: Series :: new ("order_id" , &...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpPNMbrO/main.rs:1:475
  |
1 | ...: prelude :: DataFrame :: new (vec ! [polars :: prelude :: Series :: new ("order_id" , & [101 , 102 , 103]) , polars :: prelude :: Ser...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpPNMbrO/main.rs:1:547
  |
1 | ... ("order_id" , & [101 , 102 , 103]) , polars :: prelude :: Series :: new ("customer_id" , & [1 , 2 , 1]) , polars :: prelude :: Series...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpPNMbrO/main.rs:1:616
  |
1 | ...new ("customer_id" , & [1 , 2 , 1]) , polars :: prelude :: Series :: new ("amount" , & [99.99f64 , 149.99f64 , 79.99f64])]) . expect (...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error: aborting due to 9 previous errors

For more information about this error, try `rustc --explain E0433`.



=== ch18-00-dataframes-data-processing example 4 ===
âœ— Compilation failed: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpM4GDaf/main.rs:1:5
  |
1 | use polars :: prelude :: * ; fn conditional_processing () { let df = polars :: prelude :: DataFrame :: new (vec ! [polars :: prelude :: S...
  |     ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpM4GDaf/main.rs:1:70
  |
1 | use polars :: prelude :: * ; fn conditional_processing () { let df = polars :: prelude :: DataFrame :: new (vec ! [polars :: prelude :: S...
  |                                                                      ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpM4GDaf/main.rs:1:116
  |
1 | ...: prelude :: DataFrame :: new (vec ! [polars :: prelude :: Series :: new ("status" , & ["active" , "pending" , "closed"]) , polars :: ...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpM4GDaf/main.rs:1:202
  |
1 | ... ["active" , "pending" , "closed"]) , polars :: prelude :: Series :: new ("value" , & [1000 , 500 , 1500])]) . expect ("Failed to crea...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

warning: unnecessary braces around block return value
 --> /tmp/.tmpM4GDaf/main.rs:1:486
  |
1 | ...2 columns") } ; for i in 0 .. df . height () { { println ! ("Processing row {}" , i) } } ; } fn main () { }
  |                                                   ^^                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use polars :: prelude :: * ; fn conditional_processing () { let df = polars :: prelude :: DataFrame :: new (vec ! [polars :: prelude :: Series :: new ("status" , & ["active" , "pending" , "closed"]) , polars :: prelude :: Series :: new ("value" , & [1000 , 500 , 1500])]) . expect ("Failed to create DataFrame") ; if df . height () > 0 { println ! ("DataFrame contains data") } ; if df . width () == 2 { println ! ("DataFrame has exactly 2 columns") } ; for i in 0 .. df . height () { { println ! ("Processing row {}" , i) } } ; } fn main () { }
1 + use polars :: prelude :: * ; fn conditional_processing () { let df = polars :: prelude :: DataFrame :: new (vec ! [polars :: prelude :: Series :: new ("status" , & ["active" , "pending" , "closed"]) , polars :: prelude :: Series :: new ("value" , & [1000 , 500 , 1500])]) . expect ("Failed to create DataFrame") ; if df . height () > 0 { println ! ("DataFrame contains data") } ; if df . width () == 2 { println ! ("DataFrame has exactly 2 columns") } ; for i in 0 .. df . height () { println ! ("Processing row {}" , i) } ; } fn main () { }
  |

error: aborting due to 4 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0433`.

Error: Compilation failed:
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpM4GDaf/main.rs:1:5
  |
1 | use polars :: prelude :: * ; fn conditional_processing () { let df = polars :: prelude :: DataFrame :: new (vec ! [polars :: prelude :: S...
  |     ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpM4GDaf/main.rs:1:70
  |
1 | use polars :: prelude :: * ; fn conditional_processing () { let df = polars :: prelude :: DataFrame :: new (vec ! [polars :: prelude :: S...
  |                                                                      ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpM4GDaf/main.rs:1:116
  |
1 | ...: prelude :: DataFrame :: new (vec ! [polars :: prelude :: Series :: new ("status" , & ["active" , "pending" , "closed"]) , polars :: ...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`
 --> /tmp/.tmpM4GDaf/main.rs:1:202
  |
1 | ... ["active" , "pending" , "closed"]) , polars :: prelude :: Series :: new ("value" , & [1000 , 500 , 1500])]) . expect ("Failed to crea...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`
  |
  = help: you might be missing a crate named `polars`

warning: unnecessary braces around block return value
 --> /tmp/.tmpM4GDaf/main.rs:1:486
  |
1 | ...2 columns") } ; for i in 0 .. df . height () { { println ! ("Processing row {}" , i) } } ; } fn main () { }
  |                                                   ^^                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - use polars :: prelude :: * ; fn conditional_processing () { let df = polars :: prelude :: DataFrame :: new (vec ! [polars :: prelude :: Series :: new ("status" , & ["active" , "pending" , "closed"]) , polars :: prelude :: Series :: new ("value" , & [1000 , 500 , 1500])]) . expect ("Failed to create DataFrame") ; if df . height () > 0 { println ! ("DataFrame contains data") } ; if df . width () == 2 { println ! ("DataFrame has exactly 2 columns") } ; for i in 0 .. df . height () { { println ! ("Processing row {}" , i) } } ; } fn main () { }
1 + use polars :: prelude :: * ; fn conditional_processing () { let df = polars :: prelude :: DataFrame :: new (vec ! [polars :: prelude :: Series :: new ("status" , & ["active" , "pending" , "closed"]) , polars :: prelude :: Series :: new ("value" , & [1000 , 500 , 1500])]) . expect ("Failed to create DataFrame") ; if df . height () > 0 { println ! ("DataFrame contains data") } ; if df . width () == 2 { println ! ("DataFrame has exactly 2 columns") } ; for i in 0 .. df . height () { println ! ("Processing row {}" , i) } ; } fn main () { }
  |

error: aborting due to 4 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0433`.



=== ch24-00-nasa-optimization-deployment example 1 ===
Error: Evaluation error: Runtime error: Object is missing __type marker


=== ch19-00-structs-oop example 8 ===
âœ— Syntax error: Expected field name
Error: Syntax error: Expected field name


=== ch19-00-structs-oop example 9 ===
âœ— Syntax error: impl blocks are not supported. In Ruchy, methods should be defined inside the struct body. 

Example:
struct Point {
    x: i32,
    y: i32,

    fun new(x: i32, y: i32) -> Point {
        Point { x, y }
    }
}
Error: Syntax error: impl blocks are not supported. In Ruchy, methods should be defined inside the struct body. 

Example:
struct Point {
    x: i32,
    y: i32,

    fun new(x: i32, y: i32) -> Point {
        Point { x, y }
    }
}


=== ch19-00-structs-oop example 10 ===
âœ— Syntax error: impl blocks are not supported. In Ruchy, methods should be defined inside the struct body. 

Example:
struct Point {
    x: i32,
    y: i32,

    fun new(x: i32, y: i32) -> Point {
        Point { x, y }
    }
}
Error: Syntax error: impl blocks are not supported. In Ruchy, methods should be defined inside the struct body. 

Example:
struct Point {
    x: i32,
    y: i32,

    fun new(x: i32, y: i32) -> Point {
        Point { x, y }
    }
}


=== ch19-00-structs-oop example 11 ===
âœ— Syntax error: impl blocks are not supported. In Ruchy, methods should be defined inside the struct body. 

Example:
struct Point {
    x: i32,
    y: i32,

    fun new(x: i32, y: i32) -> Point {
        Point { x, y }
    }
}
Error: Syntax error: impl blocks are not supported. In Ruchy, methods should be defined inside the struct body. 

Example:
struct Point {
    x: i32,
    y: i32,

    fun new(x: i32, y: i32) -> Point {
        Point { x, y }
    }
}

