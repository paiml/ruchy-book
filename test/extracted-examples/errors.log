=== ch10-00-performance-optimization example 1 ===
✗ Compilation failed: Compilation failed:
error[E0432]: unresolved import `std::perf`
 --> /tmp/.tmpKe8ITW/main.rs:1:934
  |
1 | ...okup . values () } } } } fn main () { use std :: perf :: perf ; ; use std :: parallel :: parallel ; ; let data = generate_test_data (1...
  |                                                     ^^^^ could not find `perf` in `std`

error[E0432]: unresolved import `std::parallel`
 --> /tmp/.tmpKe8ITW/main.rs:1:962
  |
1 | ... () { use std :: perf :: perf ; ; use std :: parallel :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf...
  |                                                 ^^^^^^^^ could not find `parallel` in `std`

warning: unnecessary braces around block return value
 --> /tmp/.tmpKe8ITW/main.rs:1:171
  |
1 | ... { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } ...
  |       ^^                                                                                                                                                                                                                                                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf :: perf ; ; use std :: parallel :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
1 + fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf :: perf ; ; use std :: parallel :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpKe8ITW/main.rs:1:221
  |
1 | ... { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ...
  |       ^^                                                                                                                                                                                        ^^
  |
help: remove these braces
  |
1 - fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf :: perf ; ; use std :: parallel :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
1 + fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf :: perf ; ; use std :: parallel :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpKe8ITW/main.rs:1:298
  |
1 | ...; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed...
  |                                  ^^                                                                      ^^
  |
help: remove these braces
  |
1 - fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf :: perf ; ; use std :: parallel :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
1 + fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { if similar (processed , existing) { { processed . merge (existing) } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf :: perf ; ; use std :: parallel :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpKe8ITW/main.rs:1:336
  |
1 | ...in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; retur...
  |                                                       ^^                            ^^
  |
help: remove these braces
  |
1 - fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf :: perf ; ; use std :: parallel :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
1 + fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { processed . merge (existing) } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf :: perf ; ; use std :: parallel :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpKe8ITW/main.rs:1:611
  |
1 | ... { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                    ^^
  |
help: remove these braces
  |
1 - fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf :: perf ; ; use std :: parallel :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
1 + fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } fn main () { use std :: perf :: perf ; ; use std :: parallel :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpKe8ITW/main.rs:1:738
  |
1 | ... { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ...
  |       ^^                                                                                                                                 ^^
  |
help: remove these braces
  |
1 - fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf :: perf ; ; use std :: parallel :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
1 + fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } ; return lookup . values () } } } } fn main () { use std :: perf :: perf ; ; use std :: parallel :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpKe8ITW/main.rs:1:801
  |
1 | ...= item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return l...
  |                                                       ^^                           ^^
  |
help: remove these braces
  |
1 - fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf :: perf ; ; use std :: parallel :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
1 + fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { lookup [key] . merge (item) } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf :: perf ; ; use std :: parallel :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpKe8ITW/main.rs:1:842
  |
1 | ...s_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () ...
  |                                                           ^^                   ^^
  |
help: remove these braces
  |
1 - fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf :: perf ; ; use std :: parallel :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
1 + fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { lookup [key] = item } } } } ; return lookup . values () } } } } fn main () { use std :: perf :: perf ; ; use std :: parallel :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpKe8ITW/main.rs:1:949
  |
1 | ...s () } } } } fn main () { use std :: perf :: perf ; ; use std :: parallel :: parallel ; ; let data = generate_test_data (10000i32) ; l...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpKe8ITW/main.rs:1:985
  |
1 | ... perf :: perf ; ; use std :: parallel :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { ...
  |                                                        ^ help: remove this semicolon

error[E0277]: `T` is not an iterator
 --> /tmp/.tmpKe8ITW/main.rs:1:214
  |
1 | ...T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results...
  |                                                         ^^^^ `T` is not an iterator
  |
  = note: required for `T` to implement `IntoIterator`
help: consider further restricting type parameter `T` with trait `Iterator`
  |
1 | fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf :: perf ; ; use std :: parallel :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! ("Naive: {}ms" , naive_time) ; println ! ("Optimized: {}ms" , optimized_time) ; println ! ("Speedup: {{naive_time / optimized_time:.1}}x") ; }
  |                                                                                                                                                       +++++++++++++++++++++

error[E0425]: cannot find function `expensive_transform` in this scope
 --> /tmp/.tmpKe8ITW/main.rs:1:241
  |
1 | ...] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existi...
  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `similar` in this scope
 --> /tmp/.tmpKe8ITW/main.rs:1:303
  |
1 | ...ransform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results ....
  |                                                       ^^^^^^^ not found in this scope

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `parallel`
 --> /tmp/.tmpKe8ITW/main.rs:1:629
  |
1 | ...(data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in...
  |                                        ^^^^^^^^ use of unresolved module or unlinked crate `parallel`
  |
  = help: you might be missing a crate named `parallel`

error[E0425]: cannot find function `expensive_transform` in this scope
 --> /tmp/.tmpKe8ITW/main.rs:1:664
  |
1 | ...results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = i...
  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `has_key` found for unit type `()` in the current scope
 --> /tmp/.tmpKe8ITW/main.rs:1:785
  |
1 | ...s { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } ...
  |                                                       ^^^^^^^ method not found in `()`

error[E0599]: no method named `values` found for unit type `()` in the current scope
 --> /tmp/.tmpKe8ITW/main.rs:1:892
  |
1 | ... { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf :: perf ; ; use std :: parallel :: p...
  |                                                       ^^^^^^ method not found in `()`

error[E0425]: cannot find function `generate_test_data` in this scope
 --> /tmp/.tmpKe8ITW/main.rs:1:998
  |
1 | ...se std :: parallel :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive ...
  |                                                  ^^^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 10 previous errors; 10 warnings emitted

Some errors have detailed explanations: E0277, E0425, E0432, E0433, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch10-00-performance-optimization example 2 ===

thread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:
"perf::CpuProfiler" is not a valid Ident
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


=== ch10-00-performance-optimization example 3 ===

thread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:
"string builder" is not a valid Ident
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


=== ch10-00-performance-optimization example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `fibonacci_cache` in this scope
 --> /tmp/.tmpIY1rJt/main.rs:1:169
  |
1 | ... :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n ...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `fibonacci_cache` in this scope
 --> /tmp/.tmpIY1rJt/main.rs:1:210
  |
1 | ... { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `fibonacci_cache` in this scope
 --> /tmp/.tmpIY1rJt/main.rs:1:345
  |
1 | ...(n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmpIY1rJt/main.rs:1:615
  |
1 | ...) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmpIY1rJt/main.rs:1:651
  |
1 | ...[] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . p...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpIY1rJt/main.rs:1:1380
  |
1 | ...> (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Ad...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpIY1rJt/main.rs:1:1594
  |
1 | ...d :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add <...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `null` in this scope
 --> /tmp/.tmpIY1rJt/main.rs:1:1894
  |
1 | ...if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::ptr::null;
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpIY1rJt/main.rs:1:201
  |
1 | ...(n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { ...
  |                                                        ^^                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
1 + fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { return fibonacci_cache [n] } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpIY1rJt/main.rs:1:266
  |
1 | ... return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32)...
  |                                                                    ^^ ^^
  |
help: remove these braces
  |
1 - fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
1 + fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { n } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpIY1rJt/main.rs:1:281
  |
1 | ...esult = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; r...
  |                                          ^^                                                     ^^
  |
help: remove these braces
  |
1 - fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
1 + fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpIY1rJt/main.rs:1:572
  |
1 | ... { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } ...
  |       ^^                                                                                                                                                                                                                  ^^
  |
help: remove these braces
  |
1 - fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
1 + fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpIY1rJt/main.rs:1:640
  |
1 | ...n ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; ret...
  |            ^^                                                                                                                  ^^
  |
help: remove these braces
  |
1 - fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
1 + fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpIY1rJt/main.rs:1:687
  |
1 | ...ge (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } }...
  |                                     ^^                                                               ^^
  |
help: remove these braces
  |
1 - fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
1 + fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpIY1rJt/main.rs:1:717
  |
1 | ..., items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_dupl...
  |                                                      ^^                             ^^
  |
help: remove these braces
  |
1 - fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
1 + fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { duplicates . push (items [i]) } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpIY1rJt/main.rs:1:967
  |
1 | ... { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } ...
  |       ^^                                                                                                                                                                                                             ^^
  |
help: remove these braces
  |
1 - fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
1 + fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpIY1rJt/main.rs:1:1083
  |
1 | ... ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_ar...
  |                                                         ^^                       ^^
  |
help: remove these braces
  |
1 - fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
1 + fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { duplicates . add (item) } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpIY1rJt/main.rs:1:1352
  |
1 | ...Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : st...
  |                                         ^^                                                        ^^
  |
help: remove these braces
  |
1 - fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
1 + fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { for record in records { { database . insert (record) } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpIY1rJt/main.rs:1:1378
  |
1 | ...ne > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops ::...
  |                                                        ^^                          ^^
  |
help: remove these braces
  |
1 - fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
1 + fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { database . insert (record) } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpIY1rJt/main.rs:1:1592
  |
1 | ... :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < ...
  |                                                    ^^                                 ^^
  |
help: remove these braces
  |
1 - fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
1 + fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { database . insert_batch (records) } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpIY1rJt/main.rs:1:1839
  |
1 | ... predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacc...
  |                                                 ^^                                       ^^
  |
help: remove these braces
  |
1 - fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
1 + fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { if predicate (item) { { return item } } } ; return null } } fn main () { let fibonacci_cache = () ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpIY1rJt/main.rs:1:1863
  |
1 | ... : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = ...
  |                                                               ^^           ^^
  |
help: remove these braces
  |
1 - fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
1 + fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { return item } } } ; return null } } fn main () { let fibonacci_cache = () ; }
  |

error[E0369]: binary operation `<=` cannot be applied to type `T`
 --> /tmp/.tmpIY1rJt/main.rs:1:256
  |
1 | ... (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n...
  |                                                                - ^^ ---- i32
  |                                                                |
  |                                                                T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
  |                                                                                                                                                   +++++++++++++++++++++++++++

error[E0369]: cannot subtract `i32` from `T`
 --> /tmp/.tmpIY1rJt/main.rs:1:301
  |
1 | ...let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = resul...
  |                                                                 - ^ ---- i32
  |                                                                 |
  |                                                                 T
  |
help: consider further restricting type parameter `T` with trait `Sub`
  |
1 | fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Sub<i32> > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
  |                                                                                                                                                   ++++++++++++++++++++

error[E0369]: cannot subtract `i32` from `T`
 --> /tmp/.tmpIY1rJt/main.rs:1:329
  |
1 | ...{ n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn...
  |                                                                 - ^ ---- i32
  |                                                                 |
  |                                                                 T
  |
help: consider further restricting type parameter `T` with trait `Sub`
  |
1 | fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Sub<i32, Output = T> > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
  |                                                                                                                                                   ++++++++++++++++++++++++++++++++

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpIY1rJt/main.rs:1:630
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                             ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       +++++++++++++++++++

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpIY1rJt/main.rs:1:677
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                                                                            ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       +++++++++++++++++++

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpIY1rJt/main.rs:1:698
  |
1 | ... ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; retu...
  |                                                                     ^^^

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpIY1rJt/main.rs:1:711
  |
1 | ...j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates...
  |                                                                     ^^^

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpIY1rJt/main.rs:1:744
  |
1 | ...n ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optim...
  |                                                                     ^^^

error[E0433]: failed to resolve: use of undeclared type `Set`
 --> /tmp/.tmpIY1rJt/main.rs:1:982
  |
1 | ... Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . ...
  |                                                       ^^^ use of undeclared type `Set`

error[E0433]: failed to resolve: use of undeclared type `Set`
 --> /tmp/.tmpIY1rJt/main.rs:1:1017
  |
1 | ... { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . ad...
  |                                                       ^^^ use of undeclared type `Set`

error[E0277]: `T` is not an iterator
 --> /tmp/.tmpIY1rJt/main.rs:1:1045
  |
1 | ... () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add ...
  |                                                         ^^^^^ `T` is not an iterator
  |
  = note: required for `T` to implement `IntoIterator`
help: consider further restricting type parameter `T` with trait `Iterator`
  |
1 | fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  +++++++++++++++++++++

error[E0277]: `T` is not an iterator
 --> /tmp/.tmpIY1rJt/main.rs:1:1368
  |
1 | ...ebug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std...
  |                                                        ^^^^^^^ `T` is not an iterator
  |
  = note: required for `T` to implement `IntoIterator`
help: consider further restricting type parameter `T` with trait `Iterator`
  |
1 | fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 +++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpIY1rJt/main.rs:1:1354
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } ...
  |       -                                                                                                                                                -     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |       |                                                                                                                                                |
  |       expected this type parameter                                                                                                                     expected `T` because of return type
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: the caller chooses a type for `T` which can be different from `()`
  = note: `for` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } /* `T` value */ } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   +++++++++++++++

error[E0277]: `T` is not an iterator
 --> /tmp/.tmpIY1rJt/main.rs:1:1831
  |
1 | ...e > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main (...
  |                                                         ^^^^^ `T` is not an iterator
  |
  = note: required for `T` to implement `IntoIterator`
help: consider further restricting type parameter `T` with trait `Iterator`
  |
1 | fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    +++++++++++++++++++++

error[E0618]: expected function, found `T`
 --> /tmp/.tmpIY1rJt/main.rs:1:1844
  |
1 | ...e > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main (...
  |                     ---------                                        ^^^^^^^^^-------
  |                     |                                                |
  |                     `predicate` has type `T`                         call expression requires function

warning: unused variable: `fibonacci_cache`
 --> /tmp/.tmpIY1rJt/main.rs:1:1920
  |
1 | ... } fn main () { let fibonacci_cache = () ; }
  |                        ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_fibonacci_cache`
  |
  = note: `#[warn(unused_variables)]` on by default

error: aborting due to 23 previous errors; 15 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0369, E0425, E0433, E0599, E0608, E0618.
For more information about an error, try `rustc --explain E0277`.



=== ch10-00-performance-optimization example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 8 ===
✗ Compilation failed: Compilation failed:
error[E0432]: unresolved import `std::db`
 --> /tmp/.tmpXa1l8K/main.rs:1:1408
  |
1 | ...pby (& []) . unwrap () } } fn main () { use std :: db :: db ; ; use std :: perf :: perf ; ; let database = db :: connect ("postgres://...
  |                                                       ^^ could not find `db` in `std`

error[E0432]: unresolved import `std::perf`
 --> /tmp/.tmpXa1l8K/main.rs:1:1432
  |
1 | ... fn main () { use std :: db :: db ; ; use std :: perf :: perf ; ; let database = db :: connect ("postgres://localhost/myapp") ; databa...
  |                                                     ^^^^ could not find `perf` in `std`

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpXa1l8K/main.rs:1:180
  |
1 | ...:: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , "Query: " + sql) ; println ! ("{}" ,...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpXa1l8K/main.rs:1:591
  |
1 | ..., where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ;...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpXa1l8K/main.rs:1:956
  |
1 | ...fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = d...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpXa1l8K/main.rs:1:1038
  |
1 | ...M users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `database` in this scope
 --> /tmp/.tmpXa1l8K/main.rs:1:1192
  |
1 | ... } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JO...
  |                                                       ^^^^^^^^ not found in this scope

warning: unnecessary braces around block return value
 --> /tmp/.tmpXa1l8K/main.rs:1:165
  |
1 | ... { { { let plan = database . explain (sql) ; { println ! ("{}" , "Query: " + sql) ; println ! ("{}" , "Execution plan: " + plan) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , "⚠\u{fe0f}  N+1 query pattern detected: " + pattern . example) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , "Query: " + sql) ; println ! ("{}" , "Execution plan: " + plan) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , "⚠\u{fe0f}  N+1 query pattern detected: " + pattern . example) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db :: db ; ; use std :: perf :: perf ; ; let database = db :: connect ("postgres://localhost/myapp") ; database . log_queries (true) ; let naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
1 + fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { let plan = database . explain (sql) ; { println ! ("{}" , "Query: " + sql) ; println ! ("{}" , "Execution plan: " + plan) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , "⚠\u{fe0f}  N+1 query pattern detected: " + pattern . example) ; println ! ("Consider using JOIN or batch loading") } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db :: db ; ; use std :: perf :: perf ; ; let database = db :: connect ("postgres://localhost/myapp") ; database . log_queries (true) ; let naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXa1l8K/main.rs:1:701
  |
1 | ... { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , "⚠\u{fe0f}  N+1 query pattern detected: " + pattern . example) ; println ! ("Consider using JOIN or batch loading") } } } } ...
  |       ^^                                                                                                                                                                                             ^^
  |
help: remove these braces
  |
1 - fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , "Query: " + sql) ; println ! ("{}" , "Execution plan: " + plan) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , "⚠\u{fe0f}  N+1 query pattern detected: " + pattern . example) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db :: db ; ; use std :: perf :: perf ; ; let database = db :: connect ("postgres://localhost/myapp") ; database . log_queries (true) ; let naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
1 + fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , "Query: " + sql) ; println ! ("{}" , "Execution plan: " + plan) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , "⚠\u{fe0f}  N+1 query pattern detected: " + pattern . example) ; println ! ("Consider using JOIN or batch loading") } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db :: db ; ; use std :: perf :: perf ; ; let database = db :: connect ("postgres://localhost/myapp") ; database . log_queries (true) ; let naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXa1l8K/main.rs:1:940
  |
1 | ... { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } ...
  |       ^^                                                                                                                                                                                                     ^^
  |
help: remove these braces
  |
1 - fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , "Query: " + sql) ; println ! ("{}" , "Execution plan: " + plan) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , "⚠\u{fe0f}  N+1 query pattern detected: " + pattern . example) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db :: db ; ; use std :: perf :: perf ; ; let database = db :: connect ("postgres://localhost/myapp") ; database . log_queries (true) ; let naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
1 + fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , "Query: " + sql) ; println ! ("{}" , "Execution plan: " + plan) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , "⚠\u{fe0f}  N+1 query pattern detected: " + pattern . example) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db :: db ; ; use std :: perf :: perf ; ; let database = db :: connect ("postgres://localhost/myapp") ; database . log_queries (true) ; let naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXa1l8K/main.rs:1:1021
  |
1 | ...r user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users }...
  |                      ^^                                                                                             ^^
  |
help: remove these braces
  |
1 - fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , "Query: " + sql) ; println ! ("{}" , "Execution plan: " + plan) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , "⚠\u{fe0f}  N+1 query pattern detected: " + pattern . example) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db :: db ; ; use std :: perf :: perf ; ; let database = db :: connect ("postgres://localhost/myapp") ; database . log_queries (true) ; let naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
1 + fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , "Query: " + sql) ; println ! ("{}" , "Execution plan: " + plan) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , "⚠\u{fe0f}  N+1 query pattern detected: " + pattern . example) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db :: db ; ; use std :: perf :: perf ; ; let database = db :: connect ("postgres://localhost/myapp") ; database . log_queries (true) ; let naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXa1l8K/main.rs:1:1183
  |
1 | ... { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } ...
  |       ^^                                                                                                                                                                                                  ^^
  |
help: remove these braces
  |
1 - fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , "Query: " + sql) ; println ! ("{}" , "Execution plan: " + plan) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , "⚠\u{fe0f}  N+1 query pattern detected: " + pattern . example) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db :: db ; ; use std :: perf :: perf ; ; let database = db :: connect ("postgres://localhost/myapp") ; database . log_queries (true) ; let naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
1 + fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , "Query: " + sql) ; println ! ("{}" , "Execution plan: " + plan) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , "⚠\u{fe0f}  N+1 query pattern detected: " + pattern . example) ; println ! ("Consider using JOIN or batch loading") } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } fn main () { use std :: db :: db ; ; use std :: perf :: perf ; ; let database = db :: connect ("postgres://localhost/myapp") ; database . log_queries (true) ; let naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpXa1l8K/main.rs:1:1419
  |
1 | ... . unwrap () } } fn main () { use std :: db :: db ; ; use std :: perf :: perf ; ; let database = db :: connect ("postgres://localhost/...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpXa1l8K/main.rs:1:1447
  |
1 | ...{ use std :: db :: db ; ; use std :: perf :: perf ; ; let database = db :: connect ("postgres://localhost/myapp") ; database . log_que...
  |                                                        ^ help: remove this semicolon

error[E0369]: cannot add `T` to `&str`
 --> /tmp/.tmpXa1l8K/main.rs:1:237
  |
1 | ...let plan = database . explain (sql) ; { println ! ("{}" , "Query: " + sql) ; println ! ("{}" , "Execution plan: " + plan) ; if plan . ...
  |                                                              --------- ^ --- T
  |                                                              |
  |                                                              &str

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpXa1l8K/main.rs:1:264
  |
1 | ...Query: " + sql) ; println ! ("{}" , "Execution plan: " + plan) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential...
  |                                  --    ^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                                  |
  |                                  required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `extract_table` in this scope
 --> /tmp/.tmpXa1l8K/main.rs:1:419
  |
1 | ...ected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! ("Suggested...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `extract_where` in this scope
 --> /tmp/.tmpXa1l8K/main.rs:1:462
  |
1 | ...le = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `find_patterns` in this scope
 --> /tmp/.tmpXa1l8K/main.rs:1:647
  |
1 | ... . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && ...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpXa1l8K/main.rs:1:773
  |
1 | ...println ! ("{}" , "⚠\u{fe0f}  N+1 query pattern detected: " + pattern . example) ; println ! ("Consider using JOIN or batch loading") ...
  |                --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                |
  |                required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
 --> /tmp/.tmpXa1l8K/main.rs:1:675
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , "Query: " + sql) ; println ! ("{}" , "Execution plan: " + plan) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , "⚠\u{fe0f}  N+1 query pattern detected: " + pattern . example) ; println ! ("Consider using JOIN or batch loading") } } } } } ...
  |       - expected this type parameter                                                                                                               - expected `T` because of return type                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: the caller chooses a type for `T` which can be different from `()`
  = note: `for` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! ("{}" , "Query: " + sql) ; println ! ("{}" , "Execution plan: " + plan) ; if plan . contains ("Seq Scan") { { println ! ("⚠\u{fe0f}  Sequential scan detected - consider adding index") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! ("Suggested: CREATE INDEX ON {} ({})" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! ("{}" , "⚠\u{fe0f}  N+1 query pattern detected: " + pattern . example) ; println ! ("Consider using JOIN or batch loading") } } } } /* `T` value */ } } } } fn get_users_with_posts_naive () { { { let users = database . query ("SELECT * FROM users") ; { for user in users { { user . posts = database . query ("SELECT * FROM posts WHERE user_id = ?" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query ("\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    ") . groupby (& []) . unwrap () } } fn main () { use std :: db :: db ; ; use std :: perf :: perf ; ; let database = db :: connect ("postgres://localhost/myapp") ; database . log_queries (true) ; let naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! ("Improvement: {{naive_time / optimized_time:.1}}x faster") ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 +++++++++++++++

error: aborting due to 14 previous errors; 7 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0369, E0425, E0432.
For more information about an error, try `rustc --explain E0277`.



=== ch10-00-performance-optimization example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch10-00-performance-optimization example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch19-00-real-world-projects example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch19-00-real-world-projects example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch19-00-real-world-projects example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch19-00-real-world-projects example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch11-00-advanced-patterns example 12 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 3 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `xFF` in this scope
 --> /tmp/.tmpo5A9Hh/main.rs:1:44
  |
1 | fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f64 ; 2f64 ; 1i32 ; e6 ; 0.00000000015...
  |                                            ^^^ not found in this scope

error[E0425]: cannot find value `o77` in this scope
 --> /tmp/.tmpo5A9Hh/main.rs:1:57
  |
1 | fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f64 ; 2f64 ; 1i32 ; e6 ; 0.00000000015...
  |                                                         ^^^ not found in this scope

error[E0425]: cannot find value `b1010` in this scope
 --> /tmp/.tmpo5A9Hh/main.rs:1:70
  |
1 | fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f64 ; 2f64 ; 1i32 ; e6 ; 0.00000000015...
  |                                                                      ^^^^^ not found in this scope

error[E0425]: cannot find value `_000_000` in this scope
 --> /tmp/.tmpo5A9Hh/main.rs:1:85
  |
1 | fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f64 ; 2f64 ; 1i32 ; e6 ; 0.00000000015...
  |                                                                                     ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `e6` in this scope
 --> /tmp/.tmpo5A9Hh/main.rs:1:120
  |
1 | ...2 ; b1010 ; 1i32 ; _000_000 ; 3.14f64 ; 2f64 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; i32 ; 3.14f64 ; f64 ; 100i32 ; u8 } ; if let Som...
  |                                                          ^^ not found in this scope

error[E0423]: expected value, found builtin type `i32`
 --> /tmp/.tmpo5A9Hh/main.rs:1:152
  |
1 | ... ; 3.14f64 ; 2f64 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; i32 ; 3.14f64 ; f64 ; 100i32 ; u8 } ; if let Some (s) = (& result as & dyn ...
  |                                                               ^^^ not a value

error[E0423]: expected value, found builtin type `f64`
 --> /tmp/.tmpo5A9Hh/main.rs:1:168
  |
1 | ...4 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; i32 ; 3.14f64 ; f64 ; 100i32 ; u8 } ; if let Some (s) = (& result as & dyn std :: any :: An...
  |                                                               ^^^ not a value

error[E0423]: expected value, found builtin type `u8`
 --> /tmp/.tmpo5A9Hh/main.rs:1:183
  |
1 | ...; 0.00000000015f64 ; 42i32 ; i32 ; 3.14f64 ; f64 ; 100i32 ; u8 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_...
  |                                                                ^^ not a value

error: aborting due to 8 previous errors

Some errors have detailed explanations: E0423, E0425.
For more information about an error, try `rustc --explain E0423`.



=== appendix-b-syntax-reference example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 6 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found `let` statement
 --> /tmp/.tmpx26J4L/main.rs:1:207
  |
1 | ...nt = - 2147483648i64 ; let uint = 4294967295i64 ; let long = - ! let ulong = ! let size = - 1i32 ; let usize = 1i32 ; let single = 3.1...
  |                                                                     ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

error: expected expression, found `let` statement
 --> /tmp/.tmpx26J4L/main.rs:1:221
  |
1 | ...648i64 ; let uint = 4294967295i64 ; let long = - ! let ulong = ! let size = - 1i32 ; let usize = 1i32 ; let single = 3.14f64 ; let dou...
  |                                                                     ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpx26J4L/main.rs:1:369
  |
1 | ...t text = "hello" ; let owned = "world" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error: aborting due to 3 previous errors




=== appendix-b-syntax-reference example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 11 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `value` in this scope
 --> /tmp/.tmpVCP2v3/main.rs:1:35
  |
1 | fn main () { let result = { match value { 0i32 => "zero" , 1i32 | 2i32 => "one or two" , 3i32 ..= 10i32 => "three through ten" , n if n >...
  |                                   ^^^^^ not found in this scope

error[E0425]: cannot find value `point` in this scope
 --> /tmp/.tmpVCP2v3/main.rs:1:198
  |
1 | ...=> "big number" , _ => "something else" , } ; match point { Point { x : 0i32 , y : 0i32 } => "origin" , Point { x , y : 0i32 } => "on ...
  |                                                        ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmpVCP2v3/main.rs:1:206
  |
1 | ...number" , _ => "something else" , } ; match point { Point { x : 0i32 , y : 0i32 } => "origin" , Point { x , y : 0i32 } => "on x-axis a...
  |                                                        ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmpVCP2v3/main.rs:1:250
  |
1 | ...point { Point { x : 0i32 , y : 0i32 } => "origin" , Point { x , y : 0i32 } => "on x-axis at " + x . to_s () + "," , Point { x : 0i32 ,...
  |                                                        ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmpVCP2v3/main.rs:1:314
  |
1 | ...y : 0i32 } => "on x-axis at " + x . to_s () + "," , Point { x : 0i32 , y } => "on y-axis at " + y . to_s () + "," , Point { x , y } =>...
  |                                                        ^^^^^ not found in this scope

error[E0422]: cannot find struct, variant or union type `Point` in this scope
 --> /tmp/.tmpVCP2v3/main.rs:1:378
  |
1 | ...0i32 , y } => "on y-axis at " + y . to_s () + "," , Point { x , y } => "point at (" + x . to_s () + ", " + y . to_s () + ")" , } ; mat...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `number` in this scope
 --> /tmp/.tmpVCP2v3/main.rs:1:463
  |
1 | ... x . to_s () + ", " + y . to_s () + ")" , } ; match number { n if n < 0i32 => "negative" , n if n > 0i32 => "positive" , _ => "zero" ,...
  |                                                        ^^^^^^ not found in this scope

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpVCP2v3/main.rs:1:306
  |
1 | ...0i32 } => "origin" , Point { x , y : 0i32 } => "on x-axis at " + x . to_s () + "," , Point { x : 0i32 , y } => "on y-axis at " + y . t...
  |                                                   ----------------------------- ^ --- &str
  |                                                   |
  |                                                   str

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpVCP2v3/main.rs:1:370
  |
1 | ... x . to_s () + "," , Point { x : 0i32 , y } => "on y-axis at " + y . to_s () + "," , Point { x , y } => "point at (" + x . to_s () + "...
  |                                                   ----------------------------- ^ --- &str
  |                                                   |
  |                                                   str

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpVCP2v3/main.rs:1:424
  |
1 | ...s at " + y . to_s () + "," , Point { x , y } => "point at (" + x . to_s () + ", " + y . to_s () + ")" , } ; match number { n if n < 0i...
  |                                                    -------------------------- ^ ---- &str
  |                                                    |
  |                                                    str

error: aborting due to 10 previous errors

Some errors have detailed explanations: E0369, E0422, E0425.
For more information about an error, try `rustc --explain E0369`.



=== appendix-b-syntax-reference example 12 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 13 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 14 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 15 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 16 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 17 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 18 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 19 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 20 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 21 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 22 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 23 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 24 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 25 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 26 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 27 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 28 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 29 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 30 ===
✗ Compilation failed: Failed to transpile to Rust


=== appendix-b-syntax-reference example 31 ===
✗ Compilation failed: Failed to transpile to Rust


=== appendix-b-syntax-reference example 32 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 33 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 34 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-b-syntax-reference example 35 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch18-00-deployment-devops example 1 ===
✗ Compilation failed: Compilation failed:
error[E0432]: unresolved import `std::deploy`
 --> /tmp/.tmpplQuH7/main.rs:1:40
  |
1 | fn main () { let result = { use std :: deploy :: deploy ; ; let config = DeployConfig { app : "my-app" . to_string () , environment : env...
  |                                        ^^^^^^ could not find `deploy` in `std`

error[E0422]: cannot find struct, variant or union type `DeployConfig` in this scope
 --> /tmp/.tmpplQuH7/main.rs:1:74
  |
1 | fn main () { let result = { use std :: deploy :: deploy ; ; let config = DeployConfig { app : "my-app" . to_string () , environment : env...
  |                                                                          ^^^^^^^^^^^^ not found in this scope

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `env`
 --> /tmp/.tmpplQuH7/main.rs:1:135
  |
1 | ... "my-app" . to_string () , environment : env :: var ("DEPLOY_ENV") , strategy : BlueGreen , health_check : "/health" . to_string () , ...
  |                                             ^^^ use of unresolved module or unlinked crate `env`
  |
  = help: you might be missing a crate named `env`
help: consider importing this module
  |
1 + use std::env;
  |

error[E0425]: cannot find value `BlueGreen` in this scope
 --> /tmp/.tmpplQuH7/main.rs:1:174
  |
1 | ...ironment : env :: var ("DEPLOY_ENV") , strategy : BlueGreen , health_check : "/health" . to_string () , rollback_on_failure : true , }...
  |                                                      ^^^^^^^^^ not found in this scope

warning: unnecessary trailing semicolon
 --> /tmp/.tmpplQuH7/main.rs:1:59
  |
1 | fn main () { let result = { use std :: deploy :: deploy ; ; let config = DeployConfig { app : "my-app" . to_string () , environment : env...
  |                                                           ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error: aborting due to 4 previous errors; 1 warning emitted

Some errors have detailed explanations: E0422, E0425, E0432, E0433.
For more information about an error, try `rustc --explain E0422`.



=== ch18-00-deployment-devops example 2 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch18-00-deployment-devops example 3 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch18-00-deployment-devops example 4 ===
✗ Compilation failed: Compilation failed:
error[E0432]: unresolved import `feature_flags`
 --> /tmp/.tmpBzWpDK/main.rs:1:33
  |
1 | fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let flags = Client :: new ("api_key") ; let new_algorithm = Flag :...
  |                                 ^^^^^^^^^^^^^ use of unresolved module or unlinked crate `feature_flags`
  |
help: you might be missing a crate named `feature_flags`, add it to your project and import it in your code
  |
1 + extern crate feature_flags;
  |

error[E0425]: cannot find value `user` in this scope
 --> /tmp/.tmpBzWpDK/main.rs:1:352
  |
1 | ..." , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percen...
  |                                                         ^^^^ not found in this scope

warning: unnecessary trailing semicolon
 --> /tmp/.tmpBzWpDK/main.rs:1:70
  |
1 | fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let flags = Client :: new ("api_key") ; let new_algorithm = Flag :...
  |                                                                      ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpBzWpDK/main.rs:1:360
  |
1 | ...ue)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage i...
  |                                                           ^^                    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let flags = Client :: new ("api_key") ; let new_algorithm = Flag :: new ("new-algorithm") . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new ("beta_users" , true) , Rule :: new ("internal_users" , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let flags = Client :: new ("api_key") ; let new_algorithm = Flag :: new ("new-algorithm") . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new ("beta_users" , true) , Rule :: new ("internal_users" , true)]) ; if flags . is_enabled (new_algorithm , user) { use_new_algorithm () } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpBzWpDK/main.rs:1:394
  |
1 | ..._algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 7...
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let flags = Client :: new ("api_key") ; let new_algorithm = Flag :: new ("new-algorithm") . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new ("beta_users" , true) , Rule :: new ("internal_users" , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let flags = Client :: new ("api_key") ; let new_algorithm = Flag :: new ("new-algorithm") . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new ("beta_users" , true) , Rule :: new ("internal_users" , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { use_old_algorithm () } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0433]: failed to resolve: use of undeclared type `Rule`
 --> /tmp/.tmpBzWpDK/main.rs:1:235
  |
1 | ...lout_percentage (10i32) . targeting_rules (vec ! [Rule :: new ("beta_users" , true) , Rule :: new ("internal_users" , true)]) ; if fla...
  |                                                      ^^^^ use of undeclared type `Rule`

error[E0433]: failed to resolve: use of undeclared type `Rule`
 --> /tmp/.tmpBzWpDK/main.rs:1:271
  |
1 | ...rules (vec ! [Rule :: new ("beta_users" , true) , Rule :: new ("internal_users" , true)]) ; if flags . is_enabled (new_algorithm , use...
  |                                                      ^^^^ use of undeclared type `Rule`

error[E0425]: cannot find function `use_new_algorithm` in this scope
 --> /tmp/.tmpBzWpDK/main.rs:1:362
  |
1 | ...ew_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 ,...
  |                             ^^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists: `new_algorithm`

error[E0425]: cannot find function `use_old_algorithm` in this scope
 --> /tmp/.tmpBzWpDK/main.rs:1:396
  |
1 | ..., user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `monitor_metrics` in this scope
 --> /tmp/.tmpBzWpDK/main.rs:1:543
  |
1 | ...s . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `metrics_degraded` in this scope
 --> /tmp/.tmpBzWpDK/main.rs:1:567
  |
1 | ...orithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 8 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0425, E0432, E0433.
For more information about an error, try `rustc --explain E0425`.



=== ch18-00-deployment-devops example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch18-00-deployment-devops example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch18-00-deployment-devops example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch18-00-deployment-devops example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch01-03-interpreter-scripting example 1 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `ruchy` in this scope
 --> /tmp/.tmpc1I0gD/main.rs:1:29
  |
1 | fn main () { let result = { ruchy - e ; "2 + 2" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > ...
  |                             ^^^^^ not found in this scope

error[E0425]: cannot find value `e` in this scope
 --> /tmp/.tmpc1I0gD/main.rs:1:37
  |
1 | fn main () { let result = { ruchy - e ; "2 + 2" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > ...
  |                                     ^ not found in this scope

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 2 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `ruchy` in this scope
 --> /tmp/.tmpeHj4Vt/main.rs:1:29
  |
1 | fn main () { let result = { ruchy - e ; "let name = \"World\"; \"Hello \" + name + \"!\"" } ; if let Some (s) = (& result as & dyn std ::...
  |                             ^^^^^ not found in this scope

error[E0425]: cannot find value `e` in this scope
 --> /tmp/.tmpeHj4Vt/main.rs:1:37
  |
1 | fn main () { let result = { ruchy - e ; "let name = \"World\"; \"Hello \" + name + \"!\"" } ; if let Some (s) = (& result as & dyn std ::...
  |                                     ^ not found in this scope

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 3 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `ruchy` in this scope
 --> /tmp/.tmpNKYshi/main.rs:1:29
  |
1 | fn main () { let result = { ruchy - e ; "let nums = [1, 2, 3]; nums[1]" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . dow...
  |                             ^^^^^ not found in this scope

error[E0425]: cannot find value `e` in this scope
 --> /tmp/.tmpNKYshi/main.rs:1:37
  |
1 | fn main () { let result = { ruchy - e ; "let nums = [1, 2, 3]; nums[1]" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . dow...
  |                                     ^ not found in this scope

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 4 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpImSIAI/main.rs:1:14
  |
1 | ... { { { let small_int = 42i32 ; { let result = small_int * 2i32 ; let pi = 3.14159f64 ; let area = pi * 5f64 * 5f64 ; let greeting = "Hello" ; let name = "Ruchy" ; let data = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32] ; println ! ("{}" , data [2i32]) } } } }
  |       ^^                                                                                                                                                                                                                                                      ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { { { let small_int = 42i32 ; { let result = small_int * 2i32 ; let pi = 3.14159f64 ; let area = pi * 5f64 * 5f64 ; let greeting = "Hello" ; let name = "Ruchy" ; let data = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32] ; println ! ("{}" , data [2i32]) } } } }
1 + fn main () { { let small_int = 42i32 ; { let result = small_int * 2i32 ; let pi = 3.14159f64 ; let area = pi * 5f64 * 5f64 ; let greeting = "Hello" ; let name = "Ruchy" ; let data = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32] ; println ! ("{}" , data [2i32]) } } }
  |

error[E0277]: the type `[i32]` cannot be indexed by `i32`
 --> /tmp/.tmpImSIAI/main.rs:1:252
  |
1 | ...32 , 5i32] ; println ! ("{}" , data [2i32]) } } } }
  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`
  |
  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `Vec<i32>` to implement `Index<i32>`

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0277`.



=== ch01-03-interpreter-scripting example 5 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmplS59p0/main.rs:1:161
  |
1 | ...isplay + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ...
  |                                                                  ^^     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
1 + fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { a + b } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmplS59p0/main.rs:1:338
  |
1 | ...isplay + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ...
  |                                                                  ^^     ^^
  |
help: remove these braces
  |
1 - fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
1 + fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { a - b } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmplS59p0/main.rs:1:515
  |
1 | ...isplay + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: op...
  |                                                                  ^^     ^^
  |
help: remove these braces
  |
1 - fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
1 + fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { a * b } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmplS59p0/main.rs:1:690
  |
1 | ...(a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let...
  |                           ^^                                                                                    ^^
  |
help: remove these braces
  |
1 - fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
1 + fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmplS59p0/main.rs:1:765
  |
1 | ...2 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; printl...
  |                                                                  ^^     ^^
  |
help: remove these braces
  |
1 - fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
1 + fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { a / b } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmplS59p0/main.rs:1:794
  |
1 | ... { { { let x = 10i32 ; { let y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                      ^^
  |
help: remove these braces
  |
1 - fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
1 + fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { let x = 10i32 ; { let y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } }
  |

error[E0369]: cannot subtract `T` from `T`
 --> /tmp/.tmplS59p0/main.rs:1:342
  |
1 | ...splay + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: o...
  |                                                                   - ^ - T
  |                                                                   |
  |                                                                   T
  |
help: consider further restricting type parameter `T` with trait `Sub`
  |
1 | fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Sub<Output = T> > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
  |                                                                                                                                                                                                                                                                                                                         +++++++++++++++++++++++++++

error[E0369]: binary operation `==` cannot be applied to type `T`
 --> /tmp/.tmplS59p0/main.rs:1:697
  |
1 | ...+ std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a ...
  |                                                                - ^^ ---- i32
  |                                                                |
  |                                                                T
  |
help: consider further restricting type parameter `T` with trait `PartialEq`
  |
1 | fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialEq<i32> > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmplS59p0/main.rs:1:749
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } ...
  |       - expected this type parameter                                                                                                                     - expected `T` because of return type                          ^^^^ expected type parameter `T`, found `i32`
  |
  = note: expected type parameter `T`
                       found type `i32`
  = note: the caller chooses a type for `T` which can be different from `i32`

error[E0369]: cannot divide `T` by `T`
 --> /tmp/.tmplS59p0/main.rs:1:769
  |
1 | ... { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println...
  |                                                                   - ^ - T
  |                                                                   |
  |                                                                   T
  |
help: consider further restricting type parameter `T` with trait `Div`
  |
1 | fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Div<Output = T> > (a : T , b : T) -> T { { if b == 0i32 { { println ! ("Error: Division by zero") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! ("Addition:") ; println ! ("{}" , add (x , y)) ; println ! ("Subtraction:") ; println ! ("{}" , subtract (x , y)) ; println ! ("Multiplication:") ; println ! ("{}" , multiply (x , y)) ; println ! ("Division:") ; println ! ("{}" , divide (x , y)) } } } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         +++++++++++++++++++++++++++

error: aborting due to 4 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0308, E0369.
For more information about an error, try `rustc --explain E0308`.



=== ch01-03-interpreter-scripting example 6 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpa4ruy0/main.rs:1:14
  |
1 | ... { { { let numbers = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32 , 6i32 , 7i32 , 8i32 , 9i32 , 10i32] ; { println ! ("First:") ; println ! ("{}" , numbers [0i32]) ; println ! ("Last:") ; println ! ("{}" , numbers [9i32]) ; let mut sum = 0i32 ; let mut i = 0i32 ; while i < 10i32 { { sum = sum + numbers [i] ; i = i + 1i32 } } ; println ! ("Sum:") ; println ! ("{}" , sum) ; let average = sum / 10i32 ; println ! ("Average:") ; println ! ("{}" , average) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { { { let numbers = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32 , 6i32 , 7i32 , 8i32 , 9i32 , 10i32] ; { println ! ("First:") ; println ! ("{}" , numbers [0i32]) ; println ! ("Last:") ; println ! ("{}" , numbers [9i32]) ; let mut sum = 0i32 ; let mut i = 0i32 ; while i < 10i32 { { sum = sum + numbers [i] ; i = i + 1i32 } } ; println ! ("Sum:") ; println ! ("{}" , sum) ; let average = sum / 10i32 ; println ! ("Average:") ; println ! ("{}" , average) } } } }
1 + fn main () { { let numbers = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32 , 6i32 , 7i32 , 8i32 , 9i32 , 10i32] ; { println ! ("First:") ; println ! ("{}" , numbers [0i32]) ; println ! ("Last:") ; println ! ("{}" , numbers [9i32]) ; let mut sum = 0i32 ; let mut i = 0i32 ; while i < 10i32 { { sum = sum + numbers [i] ; i = i + 1i32 } } ; println ! ("Sum:") ; println ! ("{}" , sum) ; let average = sum / 10i32 ; println ! ("Average:") ; println ! ("{}" , average) } } }
  |

error[E0277]: the type `[i32]` cannot be indexed by `i32`
 --> /tmp/.tmpa4ruy0/main.rs:1:163
  |
1 | ...irst:") ; println ! ("{}" , numbers [0i32]) ; println ! ("Last:") ; println ! ("{}" , numbers [9i32]) ; let mut sum = 0i32 ; let mut i...
  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`
  |
  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `Vec<i32>` to implement `Index<i32>`

error[E0277]: the type `[i32]` cannot be indexed by `i32`
 --> /tmp/.tmpa4ruy0/main.rs:1:221
  |
1 | ...Last:") ; println ! ("{}" , numbers [9i32]) ; let mut sum = 0i32 ; let mut i = 0i32 ; while i < 10i32 { { sum = sum + numbers [i] ; i ...
  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`
  |
  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `Vec<i32>` to implement `Index<i32>`

error[E0277]: the type `[i32]` cannot be indexed by `i32`
 --> /tmp/.tmpa4ruy0/main.rs:1:311
  |
1 | ...ile i < 10i32 { { sum = sum + numbers [i] ; i = i + 1i32 } } ; println ! ("Sum:") ; println ! ("{}" , sum) ; let average = sum / 10i32...
  |                                           ^ slice indices are of type `usize` or ranges of `usize`
  |
  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `Vec<i32>` to implement `Index<i32>`

error: aborting due to 3 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0277`.



=== ch01-03-interpreter-scripting example 7 ===
✗ Compilation failed: Compilation failed:
error[E0434]: can't capture dynamic environment in a fn item
 --> /tmp/.tmpcZauCX/main.rs:1:193
  |
1 | ...sted () { { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; { let nested_var = "I'm nested" ; println ! ("{}" , nested_...
  |                                                                  ^^^^^^^^^
  |
  = help: use the `|| { ... }` closure form instead

error[E0425]: cannot find value `global_var` in this scope
 --> /tmp/.tmpcZauCX/main.rs:1:81
  |
1 | ... local" ; { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; fn nested () { { println ! ("{}" , global_var) ; println ! ...
  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `local_var`

error[E0425]: cannot find value `global_var` in this scope
 --> /tmp/.tmpcZauCX/main.rs:1:161
  |
1 | ...sted () { { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; { let nested_var = "I'm nested" ; println ! ("{}" , nested_...
  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `local_var`

warning: unnecessary braces around block return value
 --> /tmp/.tmpcZauCX/main.rs:1:27
  |
1 | ... { { { let local_var = "I'm local" ; { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; fn nested () { { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; { let nested_var = "I'm nested" ; println ! ("{}" , nested_var) } } } ; nested () } } } } ...
  |       ^^                                                                                                                                                                                                                                                                      ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn demonstrate_scope () { { { let local_var = "I'm local" ; { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; fn nested () { { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; { let nested_var = "I'm nested" ; println ! ("{}" , nested_var) } } } ; nested () } } } } fn main () { let global_var = "I'm global" ; { demonstrate_scope () } }
1 + fn demonstrate_scope () { { let local_var = "I'm local" ; { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; fn nested () { { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; { let nested_var = "I'm nested" ; println ! ("{}" , nested_var) } } } ; nested () } } } fn main () { let global_var = "I'm global" ; { demonstrate_scope () } }
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpcZauCX/main.rs:1:276
  |
1 | ... "I'm nested" ; println ! ("{}" , nested_var) } } } ; nested () } } } } fn main () { let global_var = "I'm global" ; { demonstrate_sco...
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpcZauCX/main.rs:1:341
  |
1 | ...) } } } } fn main () { let global_var = "I'm global" ; { demonstrate_scope () } }
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - fn demonstrate_scope () { { { let local_var = "I'm local" ; { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; fn nested () { { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; { let nested_var = "I'm nested" ; println ! ("{}" , nested_var) } } } ; nested () } } } } fn main () { let global_var = "I'm global" ; { demonstrate_scope () } }
1 + fn demonstrate_scope () { { { let local_var = "I'm local" ; { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; fn nested () { { println ! ("{}" , global_var) ; println ! ("{}" , local_var) ; { let nested_var = "I'm nested" ; println ! ("{}" , nested_var) } } } ; nested () } } } } fn main () { let global_var = "I'm global" ; demonstrate_scope () }
  |

warning: unused variable: `global_var`
 --> /tmp/.tmpcZauCX/main.rs:1:313
  |
1 | ...} } } } fn main () { let global_var = "I'm global" ; { demonstrate_scope () } }
  |                             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_global_var`
  |
  = note: `#[warn(unused_variables)]` on by default

error: aborting due to 3 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0425, E0434.
For more information about an error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 8 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpXXNcRL/main.rs:1:14
  |
1 | ... { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , arr [5i32]) } } else { { println ! ("Index out of bounds") } } } } }
  |       ^^                                                                                                                                                      ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , arr [5i32]) } } else { { println ! ("Index out of bounds") } } } } }
1 + fn main () { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , arr [5i32]) } } else { { println ! ("Index out of bounds") } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXXNcRL/main.rs:1:82
  |
1 | fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , arr [5i32]) } } else { { println ! (...
  |                                                                                  ^^                             ^^
  |
help: remove these braces
  |
1 - fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , arr [5i32]) } } else { { println ! ("Index out of bounds") } } } } }
1 + fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { println ! ("{}" , arr [5i32]) } else { { println ! ("Index out of bounds") } } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXXNcRL/main.rs:1:125
  |
1 | ...() { { println ! ("{}" , arr [5i32]) } } else { { println ! ("Index out of bounds") } } } } }
  |                                                    ^^                                 ^^
  |
help: remove these braces
  |
1 - fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , arr [5i32]) } } else { { println ! ("Index out of bounds") } } } } }
1 + fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , arr [5i32]) } } else { println ! ("Index out of bounds") } } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpXXNcRL/main.rs:1:67
  |
1 | fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! ("{}" , arr [5i32]) } } else { { println ! (...
  |                                                            ----   ^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                                            |
  |                                                            expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len ().try_into().unwrap() { { println ! ("{}" , arr [5i32]) } } else { { println ! ("Index out of bounds") } } } } }
  |                                                                               ++++++++++++++++++++

error[E0277]: the type `[i32]` cannot be indexed by `i32`
 --> /tmp/.tmpXXNcRL/main.rs:1:107
  |
1 | ... . len () { { println ! ("{}" , arr [5i32]) } } else { { println ! ("Index out of bounds") } } } } }
  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`
  |
  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `Vec<i32>` to implement `Index<i32>`

error: aborting due to 2 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.



=== ch01-03-interpreter-scripting example 10 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpwhRFyi/main.rs:1:160
  |
1 | ...mt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } } fn process_and_print < T : std :: ops :: Add < Output = T ...
  |                                                                 ^^        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn get_double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } } fn process_and_print < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; { println ! ("Doubled:") ; println ! ("{}" , doubled) } } } } fn main () { }
1 + fn get_double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { x * 2i32 } fn process_and_print < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; { println ! ("Doubled:") ; println ! ("{}" , doubled) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpwhRFyi/main.rs:1:341
  |
1 | ...Clone > (x : T) -> T { { { let doubled = x * 2i32 ; { println ! ("Doubled:") ; println ! ("{}" , doubled) } } } } fn main () { }
  |                           ^^                                                                                    ^^
  |
help: remove these braces
  |
1 - fn get_double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } } fn process_and_print < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; { println ! ("Doubled:") ; println ! ("{}" , doubled) } } } } fn main () { }
1 + fn get_double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } } fn process_and_print < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { let doubled = x * 2i32 ; { println ! ("Doubled:") ; println ! ("{}" , doubled) } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpwhRFyi/main.rs:1:166
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } ...
  |       -                                                                                                                                                -   ^^^^ expected type parameter `T`, found `i32`
  |       |                                                                                                                                                |
  |       expected this type parameter                                                                                                                     expected because this is `T`
  |
  = note: expected type parameter `T`
                       found type `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpwhRFyi/main.rs:1:363
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; ...
  |       -                                                                                                                                                                -   ^^^^ expected type parameter `T`, found `i32`
  |       |                                                                                                                                                                |
  |       expected this type parameter                                                                                                                                     expected because this is `T`
  |
  = note: expected type parameter `T`
                       found type `i32`

error[E0308]: mismatched types
 --> /tmp/.tmpwhRFyi/main.rs:1:397
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; { println ! ("Doubled:") ; println ! ("{}" , doubled) } ...
  |       - expected this type parameter                                                                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 3 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch01-03-interpreter-scripting example 12 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmprlvQm4/main.rs:1:131
  |
1 | ...ms) ; let x = 42i32 ; let y = calc (z) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0425]: cannot find value `items` in this scope
 --> /tmp/.tmprlvQm4/main.rs:1:89
  |
1 | fn main () { let result = { let user_count = 42i32 ; let total_price = calculate_price (items) ; let x = 42i32 ; let y = calc (z) } ; if ...
  |                                                                                         ^^^^^ not found in this scope

error[E0425]: cannot find function `calculate_price` in this scope
 --> /tmp/.tmprlvQm4/main.rs:1:72
  |
1 | fn main () { let result = { let user_count = 42i32 ; let total_price = calculate_price (items) ; let x = 42i32 ; let y = calc (z) } ; if ...
  |                                                                        ^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors

For more information about this error, try `rustc --explain E0425`.



=== ch01-03-interpreter-scripting example 13 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpo6xjU0/main.rs:1:146
  |
1 | ...0i32] ; let last_grade = grades [4i32] } } } }
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unnecessary braces around block return value
 --> /tmp/.tmpo6xjU0/main.rs:1:14
  |
1 | ... { { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let first_grade = grades [0i32] ; let last_grade = grades [4i32] } } } }
  |       ^^                                                                                                                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let first_grade = grades [0i32] ; let last_grade = grades [4i32] } } } }
1 + fn main () { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let first_grade = grades [0i32] ; let last_grade = grades [4i32] } } }
  |

error[E0277]: the type `[i32]` cannot be indexed by `i32`
 --> /tmp/.tmpo6xjU0/main.rs:1:107
  |
1 | ...89i32] ; { let first_grade = grades [0i32] ; let last_grade = grades [4i32] } } } }
  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`
  |
  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `Vec<i32>` to implement `Index<i32>`

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0277`.



=== ch01-03-interpreter-scripting example 14 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmp9Fp8Fi/main.rs:1:156
  |
1 | ...mt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } } fn main () { { { let x = 5i32 ; { let result = double (x) ...
  |                                                                 ^^        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } } fn main () { { { let x = 5i32 ; { let result = double (x) ; println ! ("{}" , result) } } } }
1 + fn double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { n * 2i32 } fn main () { { { let x = 5i32 ; { let result = double (x) ; println ! ("{}" , result) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp9Fp8Fi/main.rs:1:184
  |
1 | ...{ n * 2i32 } } fn main () { { { let x = 5i32 ; { let result = double (x) ; println ! ("{}" , result) } } } }
  |                                ^^                                                                          ^^
  |
help: remove these braces
  |
1 - fn double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } } fn main () { { { let x = 5i32 ; { let result = double (x) ; println ! ("{}" , result) } } } }
1 + fn double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } } fn main () { { let x = 5i32 ; { let result = double (x) ; println ! ("{}" , result) } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp9Fp8Fi/main.rs:1:162
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } ...
  |       -                                                                                                                                                -   ^^^^ expected type parameter `T`, found `i32`
  |       |                                                                                                                                                |
  |       expected this type parameter                                                                                                                     expected because this is `T`
  |
  = note: expected type parameter `T`
                       found type `i32`

error: aborting due to 1 previous error; 2 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch17-00-documentation example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 5 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch17-00-documentation example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch17-00-documentation example 9 ===
✗ Compilation failed: Compilation failed:
error[E0670]: `async fn` is not permitted in Rust 2015
 --> /tmp/.tmp0YVavI/main.rs:1:1
  |
1 | async fn request_flow () { { client . send_request () ; server . validate () ; server . process () ; server . respond () } } fn main () {...
  | ^^^^^ to use `async fn`, switch to Rust 2018 or later
  |
  = help: pass `--edition 2024` to `rustc`
  = note: for more on editions, read https://doc.rust-lang.org/edition-guide

error[E0425]: cannot find value `client` in this scope
 --> /tmp/.tmp0YVavI/main.rs:1:30
  |
1 | async fn request_flow () { { client . send_request () ; server . validate () ; server . process () ; server . respond () } } fn main () {...
  |                              ^^^^^^ not found in this scope

error[E0425]: cannot find value `server` in this scope
 --> /tmp/.tmp0YVavI/main.rs:1:57
  |
1 | async fn request_flow () { { client . send_request () ; server . validate () ; server . process () ; server . respond () } } fn main () {...
  |                                                         ^^^^^^ not found in this scope

error[E0425]: cannot find value `server` in this scope
 --> /tmp/.tmp0YVavI/main.rs:1:80
  |
1 | async fn request_flow () { { client . send_request () ; server . validate () ; server . process () ; server . respond () } } fn main () {...
  |                                                                                ^^^^^^ not found in this scope

error[E0425]: cannot find value `server` in this scope
 --> /tmp/.tmp0YVavI/main.rs:1:102
  |
1 | async fn request_flow () { { client . send_request () ; server . validate () ; server . process () ; server . respond () } } fn main () {...
  |                                                                                                      ^^^^^^ not found in this scope

error[E0412]: cannot find type `ConfigBuilder` in this scope
 --> /tmp/.tmp0YVavI/main.rs:1:144
  |
1 | ... () ; server . respond () } } fn main () { impl ConfigBuilder { } ; }
  |                                                    ^^^^^^^^^^^^^ not found in this scope

warning: unnecessary trailing semicolon
 --> /tmp/.tmp0YVavI/main.rs:1:162
  |
1 | ... respond () } } fn main () { impl ConfigBuilder { } ; }
  |                                                        ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

error: aborting due to 6 previous errors; 1 warning emitted

Some errors have detailed explanations: E0412, E0425, E0670.
For more information about an error, try `rustc --explain E0412`.



=== ch17-00-documentation example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch06-00-file-operations example 1 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmprnCPQY/main.rs:1:93
  |
1 | ... = { Documents : vec ! [".pdf" , ".doc" , ".docx" , ".txt"] , Images : vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"] , Videos : vec ! [".mp4" , ".avi" , ".mov" , ".mkv"] , Code : vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"] , Data : vec ! [".csv" , ".json" , ".xml" , ".xlsx"] , } ; ...
  |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | fn main () { let result = { println ! ("=== Desktop Organizer ===") ; let file_categories = { SomeStruct { Documents : vec ! [".pdf" , ".doc" , ".docx" , ".txt"] , Images : vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"] , Videos : vec ! [".mp4" , ".avi" , ".mov" , ".mkv"] , Code : vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"] , Data : vec ! [".csv" , ".json" , ".xml" , ".xlsx"] , } } ; let source_dir = "~/Desktop" ; let files = list_files (source_dir) ; println ! ("{}" , "Found " + files . len () . to_s () + " files to organize") ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , "Created folder: " + category) } } ; let source = join_path (source_dir , file) ; let destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , "  Moved " + file + " -> " + category + "/") ; break } } } } } } } } } ; println ! ("✅ Desktop organized!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |                                                                                             ++++++++++++                                                                                                                                                                                                                                                                                                  +

error[E0425]: cannot find function `create_dir` in this scope
 --> /tmp/.tmprnCPQY/main.rs:1:800
  |
1 | ... , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , "Created folder: " + category) } } ; let...
  |                                                      ^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::create_dir;
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmprnCPQY/main.rs:1:553
  |
1 | ... { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , "Created folder: " + category) } } ; let source = join_path (source_dir , file) ; let destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , "  Moved " + file + " -> " + category + "/") ; break } } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { let result = { println ! ("=== Desktop Organizer ===") ; let file_categories = { Documents : vec ! [".pdf" , ".doc" , ".docx" , ".txt"] , Images : vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"] , Videos : vec ! [".mp4" , ".avi" , ".mov" , ".mkv"] , Code : vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"] , Data : vec ! [".csv" , ".json" , ".xml" , ".xlsx"] , } ; let source_dir = "~/Desktop" ; let files = list_files (source_dir) ; println ! ("{}" , "Found " + files . len () . to_s () + " files to organize") ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , "Created folder: " + category) } } ; let source = join_path (source_dir , file) ; let destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , "  Moved " + file + " -> " + category + "/") ; break } } } } } } } } } ; println ! ("✅ Desktop organized!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { println ! ("=== Desktop Organizer ===") ; let file_categories = { Documents : vec ! [".pdf" , ".doc" , ".docx" , ".txt"] , Images : vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"] , Videos : vec ! [".mp4" , ".avi" , ".mov" , ".mkv"] , Code : vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"] , Data : vec ! [".csv" , ".json" , ".xml" , ".xlsx"] , } ; let source_dir = "~/Desktop" ; let files = list_files (source_dir) ; println ! ("{}" , "Found " + files . len () . to_s () + " files to organize") ; for file in files { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , "Created folder: " + category) } } ; let source = join_path (source_dir , file) ; let destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , "  Moved " + file + " -> " + category + "/") ; break } } } } } } } } ; println ! ("✅ Desktop organized!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmprnCPQY/main.rs:1:667
  |
1 | ... { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , "Created folder: " + category) } } ; let source = join_path (source_dir , file) ; let destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , "  Moved " + file + " -> " + category + "/") ; break } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                    ^^
  |
help: remove these braces
  |
1 - fn main () { let result = { println ! ("=== Desktop Organizer ===") ; let file_categories = { Documents : vec ! [".pdf" , ".doc" , ".docx" , ".txt"] , Images : vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"] , Videos : vec ! [".mp4" , ".avi" , ".mov" , ".mkv"] , Code : vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"] , Data : vec ! [".csv" , ".json" , ".xml" , ".xlsx"] , } ; let source_dir = "~/Desktop" ; let files = list_files (source_dir) ; println ! ("{}" , "Found " + files . len () . to_s () + " files to organize") ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , "Created folder: " + category) } } ; let source = join_path (source_dir , file) ; let destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , "  Moved " + file + " -> " + category + "/") ; break } } } } } } } } } ; println ! ("✅ Desktop organized!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { println ! ("=== Desktop Organizer ===") ; let file_categories = { Documents : vec ! [".pdf" , ".doc" , ".docx" , ".txt"] , Images : vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"] , Videos : vec ! [".mp4" , ".avi" , ".mov" , ".mkv"] , Code : vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"] , Data : vec ! [".csv" , ".json" , ".xml" , ".xlsx"] , } ; let source_dir = "~/Desktop" ; let files = list_files (source_dir) ; println ! ("{}" , "Found " + files . len () . to_s () + " files to organize") ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , "Created folder: " + category) } } ; let source = join_path (source_dir , file) ; let destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , "  Moved " + file + " -> " + category + "/") ; break } } } } } } } } ; println ! ("✅ Desktop organized!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmprnCPQY/main.rs:1:708
  |
1 | ... { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , "Created folder: " + category) } } ; let source = join_path (source_dir , file) ; let destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , "  Moved " + file + " -> " + category + "/") ; break } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                       ^^
  |
help: remove these braces
  |
1 - fn main () { let result = { println ! ("=== Desktop Organizer ===") ; let file_categories = { Documents : vec ! [".pdf" , ".doc" , ".docx" , ".txt"] , Images : vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"] , Videos : vec ! [".mp4" , ".avi" , ".mov" , ".mkv"] , Code : vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"] , Data : vec ! [".csv" , ".json" , ".xml" , ".xlsx"] , } ; let source_dir = "~/Desktop" ; let files = list_files (source_dir) ; println ! ("{}" , "Found " + files . len () . to_s () + " files to organize") ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , "Created folder: " + category) } } ; let source = join_path (source_dir , file) ; let destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , "  Moved " + file + " -> " + category + "/") ; break } } } } } } } } } ; println ! ("✅ Desktop organized!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { println ! ("=== Desktop Organizer ===") ; let file_categories = { Documents : vec ! [".pdf" , ".doc" , ".docx" , ".txt"] , Images : vec ! [".jpg" , ".jpeg" , ".png" , ".gif" , ".svg"] , Videos : vec ! [".mp4" , ".avi" , ".mov" , ".mkv"] , Code : vec ! [".py" , ".js" , ".rs" , ".ruchy" , ".cpp"] , Data : vec ! [".csv" , ".json" , ".xml" , ".xlsx"] , } ; let source_dir = "~/Desktop" ; let files = list_files (source_dir) ; println ! ("{}" , "Found " + files . len () . to_s () + " files to organize") ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , "Created folder: " + category) } } ; let source = join_path (source_dir , file) ; let destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , "  Moved " + file + " -> " + category + "/") ; break } } } } } } } } ; println ! ("✅ Desktop organized!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `list_files` in this scope
 --> /tmp/.tmprnCPQY/main.rs:1:427
  |
1 | ... , } ; let source_dir = "~/Desktop" ; let files = list_files (source_dir) ; println ! ("{}" , "Found " + files . len () . to_s () + " ...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmprnCPQY/main.rs:1:507
  |
1 | ...s (source_dir) ; println ! ("{}" , "Found " + files . len () . to_s () + " files to organize") ; for file in files { { { let extension...
  |                                       ----------------------------------- ^ -------------------- &str
  |                                       |
  |                                       str

error[E0425]: cannot find function `get_extension` in this scope
 --> /tmp/.tmprnCPQY/main.rs:1:573
  |
1 | ...ize") ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . ite...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmprnCPQY/main.rs:1:729
  |
1 | ...ons . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (t...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `dir_exists` in this scope
 --> /tmp/.tmprnCPQY/main.rs:1:772
  |
1 | ..._dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! ("{}" , "Created fol...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0369]: cannot add `_` to `&str`
 --> /tmp/.tmprnCPQY/main.rs:1:863
  |
1 | ...r) { { create_dir (target_dir) ; println ! ("{}" , "Created folder: " + category) } } ; let source = join_path (source_dir , file) ; l...
  |                                                       ------------------ ^ -------- _
  |                                                       |
  |                                                       &str

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmprnCPQY/main.rs:1:894
  |
1 | ..."Created folder: " + category) } } ; let source = join_path (source_dir , file) ; let destination = join_path (target_dir , file) ; mo...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmprnCPQY/main.rs:1:944
  |
1 | ...join_path (source_dir , file) ; let destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" ,...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `move_file` in this scope
 --> /tmp/.tmprnCPQY/main.rs:1:976
  |
1 | ...let destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! ("{}" , "  Moved " + file + " -> " + ca...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0369]: cannot add `_` to `&str`
 --> /tmp/.tmprnCPQY/main.rs:1:1040
  |
1 | ...) ; move_file (source , destination) ; println ! ("{}" , "  Moved " + file + " -> " + category + "/") ; break } } } } } } } } } ; prin...
  |                                                             ---------- ^ ---- _
  |                                                             |
  |                                                             &str

error: aborting due to 12 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0369, E0425.
For more information about an error, try `rustc --explain E0369`.



=== ch06-00-file-operations example 2 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpjL1ebs/main.rs:1:402
  |
1 | ...normalize_path (".././data//file.txt") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0425]: cannot find function `set_current_dir` in this scope
 --> /tmp/.tmpjL1ebs/main.rs:1:68
  |
1 | fn main () { let result = { let current_dir = get_current_dir () ; set_current_dir ("/home/user/projects") ; let full_path = absolute_pat...
  |                                                                    ^^^^^^^^^^^^^^^
  |
help: a local variable with a similar name exists
  |
1 - fn main () { let result = { let current_dir = get_current_dir () ; set_current_dir ("/home/user/projects") ; let full_path = absolute_path ("data.txt") ; let parent = parent_dir (full_path) ; let filename = file_name (full_path) ; let extension = file_extension (full_path) ; let project_path = join_path (home_dir () , "projects" , "my_app") ; let clean_path = normalize_path (".././data//file.txt") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { let current_dir = get_current_dir () ; current_dir ("/home/user/projects") ; let full_path = absolute_path ("data.txt") ; let parent = parent_dir (full_path) ; let filename = file_name (full_path) ; let extension = file_extension (full_path) ; let project_path = join_path (home_dir () , "projects" , "my_app") ; let clean_path = normalize_path (".././data//file.txt") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |
help: consider importing this function
  |
1 + use std::env::set_current_dir;
  |

error[E0425]: cannot find function `home_dir` in this scope
 --> /tmp/.tmpjL1ebs/main.rs:1:307
  |
1 | ...ension (full_path) ; let project_path = join_path (home_dir () , "projects" , "my_app") ; let clean_path = normalize_path (".././data/...
  |                                                       ^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::env::home_dir;
  |

error[E0425]: cannot find function `get_current_dir` in this scope
 --> /tmp/.tmpjL1ebs/main.rs:1:47
  |
1 | fn main () { let result = { let current_dir = get_current_dir () ; set_current_dir ("/home/user/projects") ; let full_path = absolute_pat...
  |                                               ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `absolute_path` in this scope
 --> /tmp/.tmpjL1ebs/main.rs:1:126
  |
1 | ...t_dir ("/home/user/projects") ; let full_path = absolute_path ("data.txt") ; let parent = parent_dir (full_path) ; let filename = file...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `parent_dir` in this scope
 --> /tmp/.tmpjL1ebs/main.rs:1:168
  |
1 | ... ("data.txt") ; let parent = parent_dir (full_path) ; let filename = file_name (full_path) ; let extension = file_extension (full_path...
  |                                 ^^^^^^^^^^ help: a local variable with a similar name exists: `current_dir`

error[E0425]: cannot find function `file_name` in this scope
 --> /tmp/.tmpjL1ebs/main.rs:1:208
  |
1 | ... parent = parent_dir (full_path) ; let filename = file_name (full_path) ; let extension = file_extension (full_path) ; let project_pat...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_extension` in this scope
 --> /tmp/.tmpjL1ebs/main.rs:1:248
  |
1 | ...ename = file_name (full_path) ; let extension = file_extension (full_path) ; let project_path = join_path (home_dir () , "projects" , ...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpjL1ebs/main.rs:1:296
  |
1 | ...= file_extension (full_path) ; let project_path = join_path (home_dir () , "projects" , "my_app") ; let clean_path = normalize_path ("...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 9 previous errors

For more information about this error, try `rustc --explain E0425`.



=== ch06-00-file-operations example 3 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpYsUDrB/main.rs:1:426
  |
1 | ...let can_execute = is_executable (path) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpYsUDrB/main.rs:1:228
  |
1 | ...nly = is_readonly ("system.conf") ; let is_file = is_file (path) ; let is_dir = is_directory (path) ; let is_symlink = is_symbolic_lin...
  |                                                               ^^^^ not a value

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpYsUDrB/main.rs:1:263
  |
1 | ... let is_file = is_file (path) ; let is_dir = is_directory (path) ; let is_symlink = is_symbolic_link (path) ; let can_read = is_readab...
  |                                                               ^^^^ not a value

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpYsUDrB/main.rs:1:306
  |
1 | ...= is_directory (path) ; let is_symlink = is_symbolic_link (path) ; let can_read = is_readable (path) ; let can_write = is_writable (pa...
  |                                                               ^^^^ not a value

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpYsUDrB/main.rs:1:342
  |
1 | ...nk = is_symbolic_link (path) ; let can_read = is_readable (path) ; let can_write = is_writable (path) ; let can_execute = is_executabl...
  |                                                               ^^^^ not a value

error[E0423]: expected value, found built-in attribute `path`
 --> /tmp/.tmpYsUDrB/main.rs:1:379
  |
1 | ...n_read = is_readable (path) ; let can_write = is_writable (path) ; let can_execute = is_executable (path) } ; if let Some (s) = (& res...
  |                                                               ^^^^ not a value

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpYsUDrB/main.rs:1:42
  |
1 | fn main () { let result = { let exists = file_exists ("config.json") ; let size = file_size ("data.csv") ; let modified = file_modified_t...
  |                                          ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_size` in this scope
 --> /tmp/.tmpYsUDrB/main.rs:1:83
  |
1 | fn main () { let result = { let exists = file_exists ("config.json") ; let size = file_size ("data.csv") ; let modified = file_modified_t...
  |                                                                                   ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_modified_time` in this scope
 --> /tmp/.tmpYsUDrB/main.rs:1:123
  |
1 | ...ize = file_size ("data.csv") ; let modified = file_modified_time ("log.txt") ; let is_read_only = is_readonly ("system.conf") ; let is...
  |                                                  ^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_readonly` in this scope
 --> /tmp/.tmpYsUDrB/main.rs:1:175
  |
1 | ...e_modified_time ("log.txt") ; let is_read_only = is_readonly ("system.conf") ; let is_file = is_file (path) ; let is_dir = is_director...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_file` in this scope
 --> /tmp/.tmpYsUDrB/main.rs:1:219
  |
1 | ...only = is_readonly ("system.conf") ; let is_file = is_file (path) ; let is_dir = is_directory (path) ; let is_symlink = is_symbolic_li...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_directory` in this scope
 --> /tmp/.tmpYsUDrB/main.rs:1:249
  |
1 | ...") ; let is_file = is_file (path) ; let is_dir = is_directory (path) ; let is_symlink = is_symbolic_link (path) ; let can_read = is_re...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_symbolic_link` in this scope
 --> /tmp/.tmpYsUDrB/main.rs:1:288
  |
1 | ...s_dir = is_directory (path) ; let is_symlink = is_symbolic_link (path) ; let can_read = is_readable (path) ; let can_write = is_writab...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_readable` in this scope
 --> /tmp/.tmpYsUDrB/main.rs:1:329
  |
1 | ...mlink = is_symbolic_link (path) ; let can_read = is_readable (path) ; let can_write = is_writable (path) ; let can_execute = is_execut...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_writable` in this scope
 --> /tmp/.tmpYsUDrB/main.rs:1:366
  |
1 | ... can_read = is_readable (path) ; let can_write = is_writable (path) ; let can_execute = is_executable (path) } ; if let Some (s) = (& ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error: aborting due to 15 previous errors

Some errors have detailed explanations: E0423, E0425.
For more information about an error, try `rustc --explain E0423`.



=== ch06-00-file-operations example 4 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `create_dir` in this scope
 --> /tmp/.tmpfwlGp6/main.rs:1:370
  |
1 | ... process_file (path) } } } } } } } } fn main () { create_dir ("new_folder") ; create_dir_all ("path/to/nested/folder") ; remove_dir ("...
  |                                                      ^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::create_dir;
  |

error[E0425]: cannot find function `create_dir_all` in this scope
 --> /tmp/.tmpfwlGp6/main.rs:1:398
  |
1 | ... } } } fn main () { create_dir ("new_folder") ; create_dir_all ("path/to/nested/folder") ; remove_dir ("empty_folder") ; remove_dir_al...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::create_dir_all;
  |

error[E0425]: cannot find function `remove_dir` in this scope
 --> /tmp/.tmpfwlGp6/main.rs:1:441
  |
1 | ...er") ; create_dir_all ("path/to/nested/folder") ; remove_dir ("empty_folder") ; remove_dir_all ("folder_with_contents") ; let all_item...
  |                                                      ^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_dir;
  |

error[E0425]: cannot find function `remove_dir_all` in this scope
 --> /tmp/.tmpfwlGp6/main.rs:1:471
  |
1 | ...nested/folder") ; remove_dir ("empty_folder") ; remove_dir_all ("folder_with_contents") ; let all_items = list_dir (".") ; let files_o...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_dir_all;
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpfwlGp6/main.rs:1:166
  |
1 | ... { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } ...
  |       ^^                                                                                                                                                                                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder") ; create_dir_all ("path/to/nested/folder") ; remove_dir ("empty_folder") ; remove_dir_all ("folder_with_contents") ; let all_items = list_dir (".") ; let files_only = list_files (".") ; let dirs_only = list_directories (".") ; }
1 + fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } fn main () { create_dir ("new_folder") ; create_dir_all ("path/to/nested/folder") ; remove_dir ("empty_folder") ; remove_dir_all ("folder_with_contents") ; let all_items = list_dir (".") ; let files_only = list_files (".") ; let dirs_only = list_directories (".") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpfwlGp6/main.rs:1:219
  |
1 | ... { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } ...
  |       ^^                                                                                                                             ^^
  |
help: remove these braces
  |
1 - fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder") ; create_dir_all ("path/to/nested/folder") ; remove_dir ("empty_folder") ; remove_dir_all ("folder_with_contents") ; let all_items = list_dir (".") ; let files_only = list_files (".") ; let dirs_only = list_directories (".") ; }
1 + fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } fn main () { create_dir ("new_folder") ; create_dir_all ("path/to/nested/folder") ; remove_dir ("empty_folder") ; remove_dir_all ("folder_with_contents") ; let all_items = list_dir (".") ; let files_only = list_files (".") ; let dirs_only = list_directories (".") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpfwlGp6/main.rs:1:284
  |
1 | ...h = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder") ; create_dir_all ("path/to/nested/folder") ; remove_dir ("empty_folder") ; remove_dir_all ("folder_with_contents") ; let all_items = list_dir (".") ; let files_only = list_files (".") ; let dirs_only = list_directories (".") ; }
1 + fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { walk_directory (path) } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder") ; create_dir_all ("path/to/nested/folder") ; remove_dir ("empty_folder") ; remove_dir_all ("folder_with_contents") ; let all_items = list_dir (".") ; let files_only = list_files (".") ; let dirs_only = list_directories (".") ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpfwlGp6/main.rs:1:319
  |
1 | ..._directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder") ; ...
  |                                                           ^^                   ^^
  |
help: remove these braces
  |
1 - fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder") ; create_dir_all ("path/to/nested/folder") ; remove_dir ("empty_folder") ; remove_dir_all ("folder_with_contents") ; let all_items = list_dir (".") ; let files_only = list_files (".") ; let dirs_only = list_directories (".") ; }
1 + fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { process_file (path) } } } } } } } fn main () { create_dir ("new_folder") ; create_dir_all ("path/to/nested/folder") ; remove_dir ("empty_folder") ; remove_dir_all ("folder_with_contents") ; let all_items = list_dir (".") ; let files_only = list_files (".") ; let dirs_only = list_directories (".") ; }
  |

error[E0425]: cannot find function `list_dir` in this scope
 --> /tmp/.tmpfwlGp6/main.rs:1:182
  |
1 | ...: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpfwlGp6/main.rs:1:234
  |
1 | ...st_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else {...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_directory` in this scope
 --> /tmp/.tmpfwlGp6/main.rs:1:262
  |
1 | ...ems { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } ...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0277]: cannot add `()` to `()`
 --> /tmp/.tmpfwlGp6/main.rs:1:302
  |
1 | ... , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (...
  |                                          --------------  ^^^^ no implementation for `() + ()`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `()`
note: required by a bound in `walk_directory`
 --> /tmp/.tmpfwlGp6/main.rs:1:25
  |
1 | fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug...
  |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `walk_directory`

error[E0277]: cannot multiply `()` by `()`
 --> /tmp/.tmpfwlGp6/main.rs:1:302
  |
1 | ... , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (...
  |                                          --------------  ^^^^ no implementation for `() * ()`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `()`
note: required by a bound in `walk_directory`
 --> /tmp/.tmpfwlGp6/main.rs:1:60
  |
1 | fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug...
  |                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `walk_directory`

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpfwlGp6/main.rs:1:302
  |
1 | ... if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folde...
  |                                --------------  ^^^^ the trait `std::fmt::Display` is not implemented for `()`
  |                                |
  |                                required by a bound introduced by this call
  |
note: required by a bound in `walk_directory`
 --> /tmp/.tmpfwlGp6/main.rs:1:95
  |
1 | ...std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (di...
  |                                       ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `walk_directory`

error[E0425]: cannot find function `process_file` in this scope
 --> /tmp/.tmpfwlGp6/main.rs:1:321
  |
1 | ...ry (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ("new_folder") ; create_d...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpfwlGp6/main.rs:1:199
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } ...
  |       -                                                                                                                                            -                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |       |                                                                                                                                            |
  |       expected this type parameter                                                                                                                 expected `T` because of return type
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: the caller chooses a type for `T` which can be different from `()`
  = note: `for` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } /* `T` value */ } } } fn main () { create_dir ("new_folder") ; create_dir_all ("path/to/nested/folder") ; remove_dir ("empty_folder") ; remove_dir_all ("folder_with_contents") ; let all_items = list_dir (".") ; let files_only = list_files (".") ; let dirs_only = list_directories (".") ; }
  |                                                                                                                                                                                                                                                                                                                                                               +++++++++++++++

error[E0425]: cannot find function `list_dir` in this scope
 --> /tmp/.tmpfwlGp6/main.rs:1:529
  |
1 | ...dir_all ("folder_with_contents") ; let all_items = list_dir (".") ; let files_only = list_files (".") ; let dirs_only = list_directori...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `list_files` in this scope
 --> /tmp/.tmpfwlGp6/main.rs:1:563
  |
1 | ...let all_items = list_dir (".") ; let files_only = list_files (".") ; let dirs_only = list_directories (".") ; }
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `list_directories` in this scope
 --> /tmp/.tmpfwlGp6/main.rs:1:598
  |
1 | ...iles_only = list_files (".") ; let dirs_only = list_directories (".") ; }
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 15 previous errors; 4 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0425.
For more information about an error, try `rustc --explain E0277`.



=== ch06-00-file-operations example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch06-00-file-operations example 6 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmpWcVaTu/main.rs:1:713
  |
1 | ...h) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes...
  |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ SomeStruct { original : file_hashes [hash] , duplicate : path , size : size , hash : hash , } }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = input ("Enter directory to search: ") ; let min_size = input ("Minimum file size (bytes, 0 for all): ") . to_i () ; println ! ("{}" , "\nScanning " + search_dir + "...") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , "\n⚠\u{fe0f}  Found " + duplicates . len () . to_s () + " duplicate files:") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , "\nOriginal: " + dup . original) ; println ! ("{}" , "Duplicate: " + dup . duplicate) ; println ! ("{}" , "Size: " + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! ("{}" , "\nTotal space wasted: " + format_size (total_wasted)) ; let action = input ("\nDelete duplicates? (y/n): ") ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , "Deleted: " + dup . duplicate) } } ; println ! ("{}" , "\n✅ Freed " + format_size (total_wasted) + " of space!") } } } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ++++++++++++                                                                                    +

error[E0425]: cannot find value `min_size` in this scope
 --> /tmp/.tmpWcVaTu/main.rs:1:613
  |
1 | ...th) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { du...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `file_hashes` in this scope
 --> /tmp/.tmpWcVaTu/main.rs:1:661
  |
1 | ... min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] ,...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `duplicates` in this scope
 --> /tmp/.tmpWcVaTu/main.rs:1:694
  |
1 | ...file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size ...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `file_hashes` in this scope
 --> /tmp/.tmpWcVaTu/main.rs:1:810
  |
1 | ...th , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `remove_file` in this scope
 --> /tmp/.tmpWcVaTu/main.rs:1:1820
  |
1 | ... . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , "Deleted: " + dup . duplicate) } } ...
  |                                                     ^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_file;
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpWcVaTu/main.rs:1:162
  |
1 | ...Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: o...
  |                                      ^^                                                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = input ("Enter directory to search: ") ; let min_size = input ("Minimum file size (bytes, 0 for all): ") . to_i () ; println ! ("{}" , "\nScanning " + search_dir + "...") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , "\n⚠\u{fe0f}  Found " + duplicates . len () . to_s () + " duplicate files:") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , "\nOriginal: " + dup . original) ; println ! ("{}" , "Duplicate: " + dup . duplicate) ; println ! ("{}" , "Size: " + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! ("{}" , "\nTotal space wasted: " + format_size (total_wasted)) ; let action = input ("\nDelete duplicates? (y/n): ") ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , "Deleted: " + dup . duplicate) } } ; println ! ("{}" , "\n✅ Freed " + format_size (total_wasted) + " of space!") } } } } } } ; }
1 + fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { let content = read_bytes (path) ; return sha256 (content) } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = input ("Enter directory to search: ") ; let min_size = input ("Minimum file size (bytes, 0 for all): ") . to_i () ; println ! ("{}" , "\nScanning " + search_dir + "...") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , "\n⚠\u{fe0f}  Found " + duplicates . len () . to_s () + " duplicate files:") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , "\nOriginal: " + dup . original) ; println ! ("{}" , "Duplicate: " + dup . duplicate) ; println ! ("{}" , "Size: " + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! ("{}" , "\nTotal space wasted: " + format_size (total_wasted)) ; let action = input ("\nDelete duplicates? (y/n): ") ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , "Deleted: " + dup . duplicate) } } ; println ! ("{}" , "\n✅ Freed " + format_size (total_wasted) + " of space!") } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpWcVaTu/main.rs:1:395
  |
1 | ... { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^
  |
help: remove these braces
  |
1 - fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = input ("Enter directory to search: ") ; let min_size = input ("Minimum file size (bytes, 0 for all): ") . to_i () ; println ! ("{}" , "\nScanning " + search_dir + "...") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , "\n⚠\u{fe0f}  Found " + duplicates . len () . to_s () + " duplicate files:") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , "\nOriginal: " + dup . original) ; println ! ("{}" , "Duplicate: " + dup . duplicate) ; println ! ("{}" , "Size: " + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! ("{}" , "\nTotal space wasted: " + format_size (total_wasted)) ; let action = input ("\nDelete duplicates? (y/n): ") ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , "Deleted: " + dup . duplicate) } } ; println ! ("{}" , "\n✅ Freed " + format_size (total_wasted) + " of space!") } } } } } } ; }
1 + fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = input ("Enter directory to search: ") ; let min_size = input ("Minimum file size (bytes, 0 for all): ") . to_i () ; println ! ("{}" , "\nScanning " + search_dir + "...") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , "\n⚠\u{fe0f}  Found " + duplicates . len () . to_s () + " duplicate files:") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , "\nOriginal: " + dup . original) ; println ! ("{}" , "Duplicate: " + dup . duplicate) ; println ! ("{}" , "Size: " + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! ("{}" , "\nTotal space wasted: " + format_size (total_wasted)) ; let action = input ("\nDelete duplicates? (y/n): ") ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , "Deleted: " + dup . duplicate) } } ; println ! ("{}" , "\n✅ Freed " + format_size (total_wasted) + " of space!") } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpWcVaTu/main.rs:1:448
  |
1 | ... { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                     ^^
  |
help: remove these braces
  |
1 - fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = input ("Enter directory to search: ") ; let min_size = input ("Minimum file size (bytes, 0 for all): ") . to_i () ; println ! ("{}" , "\nScanning " + search_dir + "...") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , "\n⚠\u{fe0f}  Found " + duplicates . len () . to_s () + " duplicate files:") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , "\nOriginal: " + dup . original) ; println ! ("{}" , "Duplicate: " + dup . duplicate) ; println ! ("{}" , "Size: " + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! ("{}" , "\nTotal space wasted: " + format_size (total_wasted)) ; let action = input ("\nDelete duplicates? (y/n): ") ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , "Deleted: " + dup . duplicate) } } ; println ! ("{}" , "\n✅ Freed " + format_size (total_wasted) + " of space!") } } } } } } ; }
1 + fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = input ("Enter directory to search: ") ; let min_size = input ("Minimum file size (bytes, 0 for all): ") . to_i () ; println ! ("{}" , "\nScanning " + search_dir + "...") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , "\n⚠\u{fe0f}  Found " + duplicates . len () . to_s () + " duplicate files:") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , "\nOriginal: " + dup . original) ; println ! ("{}" , "Duplicate: " + dup . duplicate) ; println ! ("{}" , "Size: " + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! ("{}" , "\nTotal space wasted: " + format_size (total_wasted)) ; let action = input ("\nDelete duplicates? (y/n): ") ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , "Deleted: " + dup . duplicate) } } ; println ! ("{}" , "\n✅ Freed " + format_size (total_wasted) + " of space!") } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpWcVaTu/main.rs:1:513
  |
1 | ...h = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size ...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = input ("Enter directory to search: ") ; let min_size = input ("Minimum file size (bytes, 0 for all): ") . to_i () ; println ! ("{}" , "\nScanning " + search_dir + "...") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , "\n⚠\u{fe0f}  Found " + duplicates . len () . to_s () + " duplicate files:") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , "\nOriginal: " + dup . original) ; println ! ("{}" , "Duplicate: " + dup . duplicate) ; println ! ("{}" , "Size: " + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! ("{}" , "\nTotal space wasted: " + format_size (total_wasted)) ; let action = input ("\nDelete duplicates? (y/n): ") ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , "Deleted: " + dup . duplicate) } } ; println ! ("{}" , "\n✅ Freed " + format_size (total_wasted) + " of space!") } } } } } } ; }
1 + fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { scan_directory (path) } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = input ("Enter directory to search: ") ; let min_size = input ("Minimum file size (bytes, 0 for all): ") . to_i () ; println ! ("{}" , "\nScanning " + search_dir + "...") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , "\n⚠\u{fe0f}  Found " + duplicates . len () . to_s () + " duplicate files:") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , "\nOriginal: " + dup . original) ; println ! ("{}" , "Duplicate: " + dup . duplicate) ; println ! ("{}" , "Size: " + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! ("{}" , "\nTotal space wasted: " + format_size (total_wasted)) ; let action = input ("\nDelete duplicates? (y/n): ") ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , "Deleted: " + dup . duplicate) } } ; println ! ("{}" , "\n✅ Freed " + format_size (total_wasted) + " of space!") } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpWcVaTu/main.rs:1:568
  |
1 | ... { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                     ^^
  |
help: remove these braces
  |
1 - fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = input ("Enter directory to search: ") ; let min_size = input ("Minimum file size (bytes, 0 for all): ") . to_i () ; println ! ("{}" , "\nScanning " + search_dir + "...") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , "\n⚠\u{fe0f}  Found " + duplicates . len () . to_s () + " duplicate files:") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , "\nOriginal: " + dup . original) ; println ! ("{}" , "Duplicate: " + dup . duplicate) ; println ! ("{}" , "Size: " + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! ("{}" , "\nTotal space wasted: " + format_size (total_wasted)) ; let action = input ("\nDelete duplicates? (y/n): ") ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , "Deleted: " + dup . duplicate) } } ; println ! ("{}" , "\n✅ Freed " + format_size (total_wasted) + " of space!") } } } } } } ; }
1 + fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = input ("Enter directory to search: ") ; let min_size = input ("Minimum file size (bytes, 0 for all): ") . to_i () ; println ! ("{}" , "\nScanning " + search_dir + "...") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , "\n⚠\u{fe0f}  Found " + duplicates . len () . to_s () + " duplicate files:") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , "\nOriginal: " + dup . original) ; println ! ("{}" , "Duplicate: " + dup . duplicate) ; println ! ("{}" , "Size: " + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! ("{}" , "\nTotal space wasted: " + format_size (total_wasted)) ; let action = input ("\nDelete duplicates? (y/n): ") ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , "Deleted: " + dup . duplicate) } } ; println ! ("{}" , "\n✅ Freed " + format_size (total_wasted) + " of space!") } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpWcVaTu/main.rs:1:624
  |
1 | ... { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } ...
  |       ^^                                                                                                                                                                                                                       ^^
  |
help: remove these braces
  |
1 - fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = input ("Enter directory to search: ") ; let min_size = input ("Minimum file size (bytes, 0 for all): ") . to_i () ; println ! ("{}" , "\nScanning " + search_dir + "...") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , "\n⚠\u{fe0f}  Found " + duplicates . len () . to_s () + " duplicate files:") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , "\nOriginal: " + dup . original) ; println ! ("{}" , "Duplicate: " + dup . duplicate) ; println ! ("{}" , "Size: " + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! ("{}" , "\nTotal space wasted: " + format_size (total_wasted)) ; let action = input ("\nDelete duplicates? (y/n): ") ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , "Deleted: " + dup . duplicate) } } ; println ! ("{}" , "\n✅ Freed " + format_size (total_wasted) + " of space!") } } } } } } ; }
1 + fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = input ("Enter directory to search: ") ; let min_size = input ("Minimum file size (bytes, 0 for all): ") . to_i () ; println ! ("{}" , "\nScanning " + search_dir + "...") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , "\n⚠\u{fe0f}  Found " + duplicates . len () . to_s () + " duplicate files:") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , "\nOriginal: " + dup . original) ; println ! ("{}" , "Duplicate: " + dup . duplicate) ; println ! ("{}" , "Size: " + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! ("{}" , "\nTotal space wasted: " + format_size (total_wasted)) ; let action = input ("\nDelete duplicates? (y/n): ") ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , "Deleted: " + dup . duplicate) } } ; println ! ("{}" , "\n✅ Freed " + format_size (total_wasted) + " of space!") } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpWcVaTu/main.rs:1:692
  |
1 | ..._key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { fi...
  |                  ^^                                                                                                      ^^
  |
help: remove these braces
  |
1 - fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = input ("Enter directory to search: ") ; let min_size = input ("Minimum file size (bytes, 0 for all): ") . to_i () ; println ! ("{}" , "\nScanning " + search_dir + "...") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , "\n⚠\u{fe0f}  Found " + duplicates . len () . to_s () + " duplicate files:") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , "\nOriginal: " + dup . original) ; println ! ("{}" , "Duplicate: " + dup . duplicate) ; println ! ("{}" , "Size: " + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! ("{}" , "\nTotal space wasted: " + format_size (total_wasted)) ; let action = input ("\nDelete duplicates? (y/n): ") ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , "Deleted: " + dup . duplicate) } } ; println ! ("{}" , "\n✅ Freed " + format_size (total_wasted) + " of space!") } } } } } } ; }
1 + fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = input ("Enter directory to search: ") ; let min_size = input ("Minimum file size (bytes, 0 for all): ") . to_i () ; println ! ("{}" , "\nScanning " + search_dir + "...") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , "\n⚠\u{fe0f}  Found " + duplicates . len () . to_s () + " duplicate files:") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , "\nOriginal: " + dup . original) ; println ! ("{}" , "Duplicate: " + dup . duplicate) ; println ! ("{}" , "Size: " + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! ("{}" , "\nTotal space wasted: " + format_size (total_wasted)) ; let action = input ("\nDelete duplicates? (y/n): ") ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , "Deleted: " + dup . duplicate) } } ; println ! ("{}" , "\n✅ Freed " + format_size (total_wasted) + " of space!") } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpWcVaTu/main.rs:1:808
  |
1 | ... : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (...
  |                                                        ^^                         ^^
  |
help: remove these braces
  |
1 - fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = input ("Enter directory to search: ") ; let min_size = input ("Minimum file size (bytes, 0 for all): ") . to_i () ; println ! ("{}" , "\nScanning " + search_dir + "...") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , "\n⚠\u{fe0f}  Found " + duplicates . len () . to_s () + " duplicate files:") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , "\nOriginal: " + dup . original) ; println ! ("{}" , "Duplicate: " + dup . duplicate) ; println ! ("{}" , "Size: " + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! ("{}" , "\nTotal space wasted: " + format_size (total_wasted)) ; let action = input ("\nDelete duplicates? (y/n): ") ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , "Deleted: " + dup . duplicate) } } ; println ! ("{}" , "\n✅ Freed " + format_size (total_wasted) + " of space!") } } } } } } ; }
1 + fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { file_hashes [hash] = path } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = input ("Enter directory to search: ") ; let min_size = input ("Minimum file size (bytes, 0 for all): ") . to_i () ; println ! ("{}" , "\nScanning " + search_dir + "...") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , "\n⚠\u{fe0f}  Found " + duplicates . len () . to_s () + " duplicate files:") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , "\nOriginal: " + dup . original) ; println ! ("{}" , "Duplicate: " + dup . duplicate) ; println ! ("{}" , "Size: " + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! ("{}" , "\nTotal space wasted: " + format_size (total_wasted)) ; let action = input ("\nDelete duplicates? (y/n): ") ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , "Deleted: " + dup . duplicate) } } ; println ! ("{}" , "\n✅ Freed " + format_size (total_wasted) + " of space!") } } } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpWcVaTu/main.rs:1:1225
  |
1 | ...earch_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , "\n⚠\u{fe0f}  F...
  |                                               ^^                                            ^^
  |
help: remove these braces
  |
1 - fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = input ("Enter directory to search: ") ; let min_size = input ("Minimum file size (bytes, 0 for all): ") . to_i () ; println ! ("{}" , "\nScanning " + search_dir + "...") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , "\n⚠\u{fe0f}  Found " + duplicates . len () . to_s () + " duplicate files:") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , "\nOriginal: " + dup . original) ; println ! ("{}" , "Duplicate: " + dup . duplicate) ; println ! ("{}" , "Size: " + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! ("{}" , "\nTotal space wasted: " + format_size (total_wasted)) ; let action = input ("\nDelete duplicates? (y/n): ") ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , "Deleted: " + dup . duplicate) } } ; println ! ("{}" , "\n✅ Freed " + format_size (total_wasted) + " of space!") } } } } } } ; }
1 + fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = input ("Enter directory to search: ") ; let min_size = input ("Minimum file size (bytes, 0 for all): ") . to_i () ; println ! ("{}" , "\nScanning " + search_dir + "...") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { println ! ("\n✅ No duplicate files found!") } else { { println ! ("{}" , "\n⚠\u{fe0f}  Found " + duplicates . len () . to_s () + " duplicate files:") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , "\nOriginal: " + dup . original) ; println ! ("{}" , "Duplicate: " + dup . duplicate) ; println ! ("{}" , "Size: " + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! ("{}" , "\nTotal space wasted: " + format_size (total_wasted)) ; let action = input ("\nDelete duplicates? (y/n): ") ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , "Deleted: " + dup . duplicate) } } ; println ! ("{}" , "\n✅ Freed " + format_size (total_wasted) + " of space!") } } } } } } ; }
  |

error[E0425]: cannot find function `read_bytes` in this scope
 --> /tmp/.tmpWcVaTu/main.rs:1:180
  |
1 | ...bug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `sha256` in this scope
 --> /tmp/.tmpWcVaTu/main.rs:1:207
  |
1 | ...-> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + ...
  |                                                        ^^^^^^ not found in this scope

error[E0425]: cannot find function `list_dir` in this scope
 --> /tmp/.tmpWcVaTu/main.rs:1:411
  |
1 | ...: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpWcVaTu/main.rs:1:463
  |
1 | ...st_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else {...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `is_directory` in this scope
 --> /tmp/.tmpWcVaTu/main.rs:1:491
  |
1 | ...ems { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let ...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0277]: cannot add `()` to `()`
 --> /tmp/.tmpWcVaTu/main.rs:1:531
  |
1 | ... , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >...
  |                                          --------------  ^^^^ no implementation for `() + ()`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `()`
note: required by a bound in `scan_directory`
 --> /tmp/.tmpWcVaTu/main.rs:1:254
  |
1 | ... } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt ...
  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `scan_directory`

error[E0277]: cannot multiply `()` by `()`
 --> /tmp/.tmpWcVaTu/main.rs:1:531
  |
1 | ... , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >...
  |                                          --------------  ^^^^ no implementation for `() * ()`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `()`
note: required by a bound in `scan_directory`
 --> /tmp/.tmpWcVaTu/main.rs:1:289
  |
1 | ... ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T {...
  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `scan_directory`

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpWcVaTu/main.rs:1:531
  |
1 | ... if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size...
  |                                --------------  ^^^^ the trait `std::fmt::Display` is not implemented for `()`
  |                                |
  |                                required by a bound introduced by this call
  |
note: required by a bound in `scan_directory`
 --> /tmp/.tmpWcVaTu/main.rs:1:324
  |
1 | ...std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (di...
  |                                       ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `scan_directory`

error[E0425]: cannot find function `is_file` in this scope
 --> /tmp/.tmpWcVaTu/main.rs:1:551
  |
1 | ...ory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let ha...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_size` in this scope
 --> /tmp/.tmpWcVaTu/main.rs:1:583
  |
1 | ...th) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_h...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpWcVaTu/main.rs:1:428
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } ...
  |       -                                                                                                                                            -                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |       |                                                                                                                                            |
  |       expected this type parameter                                                                                                                 expected `T` because of return type
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: the caller chooses a type for `T` which can be different from `()`
  = note: `for` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } /* `T` value */ } } } fn main () { println ! ("=== Duplicate File Finder ===") ; let search_dir = input ("Enter directory to search: ") ; let min_size = input ("Minimum file size (bytes, 0 for all): ") . to_i () ; println ! ("{}" , "\nScanning " + search_dir + "...") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! ("\n✅ No duplicate files found!") } } else { { println ! ("{}" , "\n⚠\u{fe0f}  Found " + duplicates . len () . to_s () + " duplicate files:") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! ("{}" , "\nOriginal: " + dup . original) ; println ! ("{}" , "Duplicate: " + dup . duplicate) ; println ! ("{}" , "Size: " + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! ("{}" , "\nTotal space wasted: " + format_size (total_wasted)) ; let action = input ("\nDelete duplicates? (y/n): ") ; if action . lower () == "y" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! ("{}" , "Deleted: " + dup . duplicate) } } ; println ! ("{}" , "\n✅ Freed " + format_size (total_wasted) + " of space!") } } } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            +++++++++++++++

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpWcVaTu/main.rs:1:942
  |
1 | ..."=== Duplicate File Finder ===") ; let search_dir = input ("Enter directory to search: ") ; let min_size = input ("Minimum file size (...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpWcVaTu/main.rs:1:997
  |
1 | ...ut ("Enter directory to search: ") ; let min_size = input ("Minimum file size (bytes, 0 for all): ") . to_i () ; println ! ("{}" , "\n...
  |                                                        ^^^^^ not found in this scope

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpWcVaTu/main.rs:1:1103
  |
1 | ..., 0 for all): ") . to_i () ; println ! ("{}" , "\nScanning " + search_dir + "...") ; let file_hashes = () ; let duplicates = vec ! [] ...
  |                                                   -------------------------- ^ ----- &str
  |                                                   |
  |                                                   str

error[E0599]: no method named `to_s` found for type `usize` in the current scope
 --> /tmp/.tmpWcVaTu/main.rs:1:1348
  |
1 | ...}" , "\n⚠\u{fe0f}  Found " + duplicates . len () . to_s () + " duplicate files:") ; { let total_wasted = 0i32 ; { for dup in duplicate...
  |                                                       ^^^^ method not found in `usize`

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpWcVaTu/main.rs:1:1356
  |
1 | ...else { { println ! ("{}" , "\n⚠\u{fe0f}  Found " + duplicates . len () . to_s () + " duplicate files:") ; { let total_wasted = 0i32 ; ...
  |                               ----------------------------------------------------- ^ ------------------- &str
  |                               |
  |                               str

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpWcVaTu/main.rs:1:1455
  |
1 | ...duplicates { { println ! ("{}" , "\nOriginal: " + dup . original) ; println ! ("{}" , "Duplicate: " + dup . duplicate) ; println ! ("{...
  |                               --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                               |
  |                               required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpWcVaTu/main.rs:1:1508
  |
1 | ... . original) ; println ! ("{}" , "Duplicate: " + dup . duplicate) ; println ! ("{}" , "Size: " + format_size (dup . size)) ; total_was...
  |                               --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                               |
  |                               required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpWcVaTu/main.rs:1:1572
  |
1 | ... dup . duplicate) ; println ! ("{}" , "Size: " + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! ("{}" , "\nTot...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpWcVaTu/main.rs:1:1561
  |
1 | ...duplicate) ; println ! ("{}" , "Size: " + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! ("{}" , "\nTotal spac...
  |                             --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                             |
  |                             required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpWcVaTu/main.rs:1:1678
  |
1 | ...} ; println ! ("{}" , "\nTotal space wasted: " + format_size (total_wasted)) ; let action = input ("\nDelete duplicates? (y/n): ") ; i...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpWcVaTu/main.rs:1:1651
  |
1 | ...} ; println ! ("{}" , "\nTotal space wasted: " + format_size (total_wasted)) ; let action = input ("\nDelete duplicates? (y/n): ") ; i...
  |                    --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                    |
  |                    required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpWcVaTu/main.rs:1:1721
  |
1 | ...ted: " + format_size (total_wasted)) ; let action = input ("\nDelete duplicates? (y/n): ") ; if action . lower () == "y" { { for dup i...
  |                                                        ^^^^^ not found in this scope

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpWcVaTu/main.rs:1:1870
  |
1 | ... . duplicate) ; println ! ("{}" , "Deleted: " + dup . duplicate) } } ; println ! ("{}" , "\n✅ Freed " + format_size (total_wasted) + " ...
  |                                --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                                |
  |                                required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpWcVaTu/main.rs:1:1940
  |
1 | ...uplicate) } } ; println ! ("{}" , "\n✅ Freed " + format_size (total_wasted) + " of space!") } } } } } } ; }
  |                                                      ^^^^^^^^^^^ not found in this scope

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpWcVaTu/main.rs:1:1967
  |
1 | ... duplicate) } } ; println ! ("{}" , "\n✅ Freed " + format_size (total_wasted) + " of space!") } } } } } } ; }
  |                                        ------------------------------------------ ^ ------------ &str
  |                                        |
  |                                        str

error: aborting due to 32 previous errors; 9 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0369, E0425, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch06-00-file-operations example 7 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmpd7r7Wj/main.rs:1:90
  |
1 | ... ===") ; let log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let log_dir = "/var/log/...
  |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | fn main () { let result = { println ! ("=== Log Rotation System ===") ; let log_config = { SomeStruct { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } } ; let log_dir = "/var/log/myapp" ; let log_files = glob (join_path (log_dir , "*.log")) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , "Rotating " + log_file + " (" + format_size (size) + ")...") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = log_file + "." + i . to_s () ; { let new_backup = log_file + "." + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = log_file + ".1" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + ".gz") ; remove_file (backup_path) ; println ! ("{}" , "  Compressed to " + backup_path + ".gz") } } ; write_file (log_file , "") ; println ! ("{}" , "  Created new " + log_file) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |                                                                                          ++++++++++++                                                                                   +

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmpd7r7Wj/main.rs:1:454
  |
1 | ...le + " (" + format_size (size) + ")...") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = log...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0425]: cannot find function `remove_file` in this scope
 --> /tmp/.tmpd7r7Wj/main.rs:1:697
  |
1 | ... { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } }...
  |                                                     ^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_file;
  |

error[E0425]: cannot find function `remove_file` in this scope
 --> /tmp/.tmpd7r7Wj/main.rs:1:951
  |
1 | ...press_file (backup_path , backup_path + ".gz") ; remove_file (backup_path) ; println ! ("{}" , "  Compressed to " + backup_path + ".gz...
  |                                                     ^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_file;
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpd7r7Wj/main.rs:1:290
  |
1 | ... { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , "Rotating " + log_file + " (" + format_size (size) + ")...") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = log_file + "." + i . to_s () ; { let new_backup = log_file + "." + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = log_file + ".1" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + ".gz") ; remove_file (backup_path) ; println ! ("{}" , "  Compressed to " + backup_path + ".gz") } } ; write_file (log_file , "") ; println ! ("{}" , "  Created new " + log_file) } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { let result = { println ! ("=== Log Rotation System ===") ; let log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let log_dir = "/var/log/myapp" ; let log_files = glob (join_path (log_dir , "*.log")) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , "Rotating " + log_file + " (" + format_size (size) + ")...") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = log_file + "." + i . to_s () ; { let new_backup = log_file + "." + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = log_file + ".1" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + ".gz") ; remove_file (backup_path) ; println ! ("{}" , "  Compressed to " + backup_path + ".gz") } } ; write_file (log_file , "") ; println ! ("{}" , "  Created new " + log_file) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { println ! ("=== Log Rotation System ===") ; let log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let log_dir = "/var/log/myapp" ; let log_files = glob (join_path (log_dir , "*.log")) ; for log_file in log_files { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , "Rotating " + log_file + " (" + format_size (size) + ")...") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = log_file + "." + i . to_s () ; { let new_backup = log_file + "." + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = log_file + ".1" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + ".gz") ; remove_file (backup_path) ; println ! ("{}" , "  Compressed to " + backup_path + ".gz") } } ; write_file (log_file , "") ; println ! ("{}" , "  Created new " + log_file) } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpd7r7Wj/main.rs:1:512
  |
1 | ... { { { let old_backup = log_file + "." + i . to_s () ; { let new_backup = log_file + "." + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                              ^^
  |
help: remove these braces
  |
1 - fn main () { let result = { println ! ("=== Log Rotation System ===") ; let log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let log_dir = "/var/log/myapp" ; let log_files = glob (join_path (log_dir , "*.log")) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , "Rotating " + log_file + " (" + format_size (size) + ")...") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = log_file + "." + i . to_s () ; { let new_backup = log_file + "." + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = log_file + ".1" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + ".gz") ; remove_file (backup_path) ; println ! ("{}" , "  Compressed to " + backup_path + ".gz") } } ; write_file (log_file , "") ; println ! ("{}" , "  Created new " + log_file) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { println ! ("=== Log Rotation System ===") ; let log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let log_dir = "/var/log/myapp" ; let log_files = glob (join_path (log_dir , "*.log")) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , "Rotating " + log_file + " (" + format_size (size) + ")...") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { let old_backup = log_file + "." + i . to_s () ; { let new_backup = log_file + "." + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } ; { let backup_path = log_file + ".1" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + ".gz") ; remove_file (backup_path) ; println ! ("{}" , "  Compressed to " + backup_path + ".gz") } } ; write_file (log_file , "") ; println ! ("{}" , "  Created new " + log_file) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpd7r7Wj/main.rs:1:651
  |
1 | ... { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } }...
  |       ^^                                                                                                                           ^^
  |
help: remove these braces
  |
1 - fn main () { let result = { println ! ("=== Log Rotation System ===") ; let log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let log_dir = "/var/log/myapp" ; let log_files = glob (join_path (log_dir , "*.log")) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , "Rotating " + log_file + " (" + format_size (size) + ")...") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = log_file + "." + i . to_s () ; { let new_backup = log_file + "." + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = log_file + ".1" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + ".gz") ; remove_file (backup_path) ; println ! ("{}" , "  Compressed to " + backup_path + ".gz") } } ; write_file (log_file , "") ; println ! ("{}" , "  Created new " + log_file) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { println ! ("=== Log Rotation System ===") ; let log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let log_dir = "/var/log/myapp" ; let log_files = glob (join_path (log_dir , "*.log")) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , "Rotating " + log_file + " (" + format_size (size) + ")...") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = log_file + "." + i . to_s () ; { let new_backup = log_file + "." + i + 1i32 . to_s () ; if file_exists (old_backup) { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } ; { let backup_path = log_file + ".1" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + ".gz") ; remove_file (backup_path) ; println ! ("{}" , "  Compressed to " + backup_path + ".gz") } } ; write_file (log_file , "") ; println ! ("{}" , "  Created new " + log_file) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpd7r7Wj/main.rs:1:695
  |
1 | ...ackup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } }...
  |                                                         ^^                        ^^
  |
help: remove these braces
  |
1 - fn main () { let result = { println ! ("=== Log Rotation System ===") ; let log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let log_dir = "/var/log/myapp" ; let log_files = glob (join_path (log_dir , "*.log")) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , "Rotating " + log_file + " (" + format_size (size) + ")...") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = log_file + "." + i . to_s () ; { let new_backup = log_file + "." + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = log_file + ".1" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + ".gz") ; remove_file (backup_path) ; println ! ("{}" , "  Compressed to " + backup_path + ".gz") } } ; write_file (log_file , "") ; println ! ("{}" , "  Created new " + log_file) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { println ! ("=== Log Rotation System ===") ; let log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let log_dir = "/var/log/myapp" ; let log_files = glob (join_path (log_dir , "*.log")) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , "Rotating " + log_file + " (" + format_size (size) + ")...") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = log_file + "." + i . to_s () ; { let new_backup = log_file + "." + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { remove_file (old_backup) } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = log_file + ".1" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + ".gz") ; remove_file (backup_path) ; println ! ("{}" , "  Compressed to " + backup_path + ".gz") } } ; write_file (log_file , "") ; println ! ("{}" , "  Created new " + log_file) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpd7r7Wj/main.rs:1:733
  |
1 | ... 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = log_file +...
  |                                                  ^^                                     ^^
  |
help: remove these braces
  |
1 - fn main () { let result = { println ! ("=== Log Rotation System ===") ; let log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let log_dir = "/var/log/myapp" ; let log_files = glob (join_path (log_dir , "*.log")) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , "Rotating " + log_file + " (" + format_size (size) + ")...") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = log_file + "." + i . to_s () ; { let new_backup = log_file + "." + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = log_file + ".1" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + ".gz") ; remove_file (backup_path) ; println ! ("{}" , "  Compressed to " + backup_path + ".gz") } } ; write_file (log_file , "") ; println ! ("{}" , "  Created new " + log_file) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { println ! ("=== Log Rotation System ===") ; let log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let log_dir = "/var/log/myapp" ; let log_files = glob (join_path (log_dir , "*.log")) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , "Rotating " + log_file + " (" + format_size (size) + ")...") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = log_file + "." + i . to_s () ; { let new_backup = log_file + "." + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { rename_file (old_backup , new_backup) } } } } } } } ; { let backup_path = log_file + ".1" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + ".gz") ; remove_file (backup_path) ; println ! ("{}" , "  Compressed to " + backup_path + ".gz") } } ; write_file (log_file , "") ; println ! ("{}" , "  Created new " + log_file) } } } } } } } ; println ! ("\n✅ Log rotation complete!") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpd7r7Wj/main.rs:1:229
  |
1 | ...og_dir = "/var/log/myapp" ; let log_files = glob (join_path (log_dir , "*.log")) ; for log_file in log_files { { { let size = file_siz...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `glob` in this scope
 --> /tmp/.tmpd7r7Wj/main.rs:1:223
  |
1 | ...} ; let log_dir = "/var/log/myapp" ; let log_files = glob (join_path (log_dir , "*.log")) ; for log_file in log_files { { { let size =...
  |                                                         ^^^^ not found in this scope

error[E0425]: cannot find function `file_size` in this scope
 --> /tmp/.tmpd7r7Wj/main.rs:1:305
  |
1 | ...g")) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! ("{}" , "Rotati...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0369]: cannot add `_` to `&str`
 --> /tmp/.tmpd7r7Wj/main.rs:1:394
  |
1 | ... if size > log_config . max_size { { println ! ("{}" , "Rotating " + log_file + " (" + format_size (size) + ")...") ; for i in range (...
  |                                                           ----------- ^ -------- _
  |                                                           |
  |                                                           &str

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpd7r7Wj/main.rs:1:414
  |
1 | ...rintln ! ("{}" , "Rotating " + log_file + " (" + format_size (size) + ")...") ; for i in range (log_config . max_backups - 1i32 , 0i32...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpd7r7Wj/main.rs:1:611
  |
1 | ...() ; { let new_backup = log_file + "." + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 ...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpd7r7Wj/main.rs:1:624
  |
1 | ...ackup = log_file + "." + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `rename_file` in this scope
 --> /tmp/.tmpd7r7Wj/main.rs:1:735
  |
1 | ...- 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = log_file ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `rename_file` in this scope
 --> /tmp/.tmpd7r7Wj/main.rs:1:831
  |
1 | ... } } } ; { let backup_path = log_file + ".1" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (ba...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `compress_file` in this scope
 --> /tmp/.tmpd7r7Wj/main.rs:1:899
  |
1 | ...e , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + ".gz") ; remove_file (backup_path) ; printl...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0369]: cannot add `_` to `&str`
 --> /tmp/.tmpd7r7Wj/main.rs:1:1016
  |
1 | ...) ; remove_file (backup_path) ; println ! ("{}" , "  Compressed to " + backup_path + ".gz") } } ; write_file (log_file , "") ; println...
  |                                                      ------------------ ^ ----------- _
  |                                                      |
  |                                                      &str

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpd7r7Wj/main.rs:1:1045
  |
1 | ..., "  Compressed to " + backup_path + ".gz") } } ; write_file (log_file , "") ; println ! ("{}" , "  Created new " + log_file) } } } } ...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0369]: cannot add `_` to `&str`
 --> /tmp/.tmpd7r7Wj/main.rs:1:1109
  |
1 | ... } ; write_file (log_file , "") ; println ! ("{}" , "  Created new " + log_file) } } } } } } } ; println ! ("\n✅ Log rotation complete!...
  |                                                        ---------------- ^ -------- _
  |                                                        |
  |                                                        &str

error: aborting due to 17 previous errors; 5 warnings emitted

Some errors have detailed explanations: E0369, E0425, E0599.
For more information about an error, try `rustc --explain E0369`.



=== ch06-00-file-operations example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch06-00-file-operations example 9 ===
✗ Compilation failed: Compilation failed:
error[E0423]: expected value, found macro `try`
 --> /tmp/.tmpvzt3V1/main.rs:1:384
  |
1 | ...or: No read permission for: " + path) ; return false } } ; try ; { { let content = read_file (path) ; { process_content (content) ; re...
  |                                                               ^^^ not a value

error[E0425]: cannot find value `catch` in this scope
 --> /tmp/.tmpvzt3V1/main.rs:1:477
  |
1 | ...; { process_content (content) ; return true } } } ; catch ; error ; { println ! ("{}" , "Error processing file: " + error . to_s ()) ;...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpvzt3V1/main.rs:1:485
  |
1 | ...ess_content (content) ; return true } } } ; catch ; error ; { println ! ("{}" , "Error processing file: " + error . to_s ()) ; { let e...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpvzt3V1/main.rs:1:541
  |
1 | ...r ; { println ! ("{}" , "Error processing file: " + error . to_s ()) ; { let error_log = "errors.log" ; { let timestamp = current_date...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpvzt3V1/main.rs:1:702
  |
1 | ...r_log , timestamp . to_s () + ": " + path + " - " + error . to_s () + "\n") ; return false } } } } } fn main () { }
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpvzt3V1/main.rs:1:179
  |
1 | ... fmt :: Debug + Clone > (path : T) -> T { { if ! file_exists (path) { { println ! ("{}" , "Error: File not found: " + path) ; return f...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0369]: cannot add `T` to `&str`
 --> /tmp/.tmpvzt3V1/main.rs:1:246
  |
1 | ...{ { if ! file_exists (path) { { println ! ("{}" , "Error: File not found: " + path) ; return false } } ; if ! is_readable (path) { { p...
  |                                                      ------------------------- ^ ---- T
  |                                                      |
  |                                                      &str

error[E0308]: mismatched types
 --> /tmp/.tmpvzt3V1/main.rs:1:263
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { if ! file_exists (path) { { println ! ("{}" , "Error: File not found: " + path) ; return false } ...
  |       - expected this type parameter                                                                                                                - expected `T` because of return type                                                          ^^^^^ expected type parameter `T`, found `bool`
  |
  = note: expected type parameter `T`
                       found type `bool`
  = note: the caller chooses a type for `T` which can be different from `bool`

error[E0425]: cannot find function `is_readable` in this scope
 --> /tmp/.tmpvzt3V1/main.rs:1:280
  |
1 | ...e not found: " + path) ; return false } } ; if ! is_readable (path) { { println ! ("{}" , "Error: No read permission for: " + path) ; ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0369]: cannot add `T` to `&str`
 --> /tmp/.tmpvzt3V1/main.rs:1:355
  |
1 | ...if ! is_readable (path) { { println ! ("{}" , "Error: No read permission for: " + path) ; return false } } ; try ; { { let content = r...
  |                                                  --------------------------------- ^ ---- T
  |                                                  |
  |                                                  &str

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpvzt3V1/main.rs:1:408
  |
1 | ...ath) ; return false } } ; try ; { { let content = read_file (path) ; { process_content (content) ; return true } } } ; catch ; error ;...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `process_content` in this scope
 --> /tmp/.tmpvzt3V1/main.rs:1:429
  |
1 | ...; try ; { { let content = read_file (path) ; { process_content (content) ; return true } } } ; catch ; error ; { println ! ("{}" , "Er...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

warning: unreachable statement
 --> /tmp/.tmpvzt3V1/main.rs:1:477
  |
1 | ...th) ; { process_content (content) ; return true } } } ; catch ; error ; { println ! ("{}" , "Error processing file: " + error . to_s (...
  |                                        -----------         ^^^^^^^ unreachable statement
  |                                        |
  |                                        any code following this expression is unreachable
  |
  = note: `#[warn(unreachable_code)]` on by default

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpvzt3V1/main.rs:1:513
  |
1 | ...rror ; { println ! ("{}" , "Error processing file: " + error . to_s ()) ; { let error_log = "errors.log" ; { let timestamp = current_d...
  |                         --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                         |
  |                         required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `current_datetime` in this scope
 --> /tmp/.tmpvzt3V1/main.rs:1:611
  |
1 | ...t error_log = "errors.log" ; { let timestamp = current_datetime () ; append_file (error_log , timestamp . to_s () + ": " + path + " - ...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpvzt3V1/main.rs:1:680
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { if ! file_exists (path) { { println ! ("{}" , "Error: File not found: " + path) ; return false } } ; if ! is_readable (path) { { println ! ("{}" , "Error: No read permission for: " + path) ; return false } } ; try ; { { let content = read_file (path) ; { process_content (content) ; return true } } } ; catch ; error ; { println ! ("{}" , "Error processing file: " + error . to_s ()) ; { let error_log = "errors.log" ; { let timestamp = current_datetime () ; append_file (error_log , timestamp . to_s () + ": " + ...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`

error[E0308]: mismatched types
 --> /tmp/.tmpvzt3V1/main.rs:1:694
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { if ! file_exists (path) { { println ! ("{}" , "Error: File not found: " + path) ; return false } } ; if ! is_readable (path) { { println ! ("{}" , "Error: No read permission for: " + path) ; return false } } ; try ; { { let content = read_file (path) ; { process_content (content) ; return true } } } ; catch ; error ; { println ! ("{}" , "Error processing file: " + error . to_s ()) ; { let error_log = "errors.log" ; { let timestamp = current_datetime () ; append_file (error_log , timestamp . to_s () + ": " + path + " - " + ...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^^^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`

error[E0308]: mismatched types
 --> /tmp/.tmpvzt3V1/main.rs:1:720
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { if ! file_exists (path) { { println ! ("{}" , "Error: File not found: " + path) ; return false } } ; if ! is_readable (path) { { println ! ("{}" , "Error: No read permission for: " + path) ; return false } } ; try ; { { let content = read_file (path) ; { process_content (content) ; return true } } } ; catch ; error ; { println ! ("{}" , "Error processing file: " + error . to_s ()) ; { let error_log = "errors.log" ; { let timestamp = current_datetime () ; append_file (error_log , timestamp . to_s () + ": " + path + " - " + error . to_s () + "\n") ;...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`

error[E0425]: cannot find function `append_file` in this scope
 --> /tmp/.tmpvzt3V1/main.rs:1:633
  |
1 | ...s.log" ; { let timestamp = current_datetime () ; append_file (error_log , timestamp . to_s () + ": " + path + " - " + error . to_s () ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error: aborting due to 18 previous errors; 1 warning emitted

Some errors have detailed explanations: E0277, E0308, E0369, E0423, E0425.
For more information about an error, try `rustc --explain E0277`.



=== ch06-00-file-operations example 10 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpcFLfOp/main.rs:1:83
  |
1 | ...e in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , "large_files/" + file) } } } } } } ; if let ...
  |                 ^^                                                                                                       ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { let result = { let files = list_files ("data") ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , "large_files/" + file) } } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { let files = list_files ("data") ; for file in files { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , "large_files/" + file) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpcFLfOp/main.rs:1:140
  |
1 | ... = file_size (file) ; if size > 1000000i32 { { move_file (file , "large_files/" + file) } } } } } } ; if let Some (s) = (& result as &...
  |                                                 ^^                                        ^^
  |
help: remove these braces
  |
1 - fn main () { let result = { let files = list_files ("data") ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , "large_files/" + file) } } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { let files = list_files ("data") ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { move_file (file , "large_files/" + file) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `list_files` in this scope
 --> /tmp/.tmpcFLfOp/main.rs:1:41
  |
1 | fn main () { let result = { let files = list_files ("data") ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 ...
  |                                         ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_size` in this scope
 --> /tmp/.tmpcFLfOp/main.rs:1:98
  |
1 | fn main () { let result = { let files = list_files ("data") ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 ...
  |                                                                                                  ^^^^^^^^^ not found in this scope

error[E0369]: cannot add `_` to `&str`
 --> /tmp/.tmpcFLfOp/main.rs:1:175
  |
1 | ...ze (file) ; if size > 1000000i32 { { move_file (file , "large_files/" + file) } } } } } } ; if let Some (s) = (& result as & dyn std :...
  |                                                           -------------- ^ ---- _
  |                                                           |
  |                                                           &str

error[E0425]: cannot find function `move_file` in this scope
 --> /tmp/.tmpcFLfOp/main.rs:1:142
  |
1 | ...ize = file_size (file) ; if size > 1000000i32 { { move_file (file , "large_files/" + file) } } } } } } ; if let Some (s) = (& result a...
  |                                                      ^^^^^^^^^ not found in this scope

error: aborting due to 4 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0369, E0425.
For more information about an error, try `rustc --explain E0369`.



=== ch20-00-tooling example 1 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpaGLpIz/main.rs:1:36
  |
1 | fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let y = x + 1i32 ; return y } } } } fn main () { { { let result = calcu...
  |                                    ^^                                                            ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{}" , result) } } }
1 + fn calculate_something (x : i64) { { let unused_var = 42i32 ; { let y = x + 1i32 ; return y } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{}" , result) } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpaGLpIz/main.rs:1:116
  |
1 | ...eturn y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{}" , result) } } }
  |                                 ^^                                                                        ^^
  |
help: remove these braces
  |
1 - fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{}" , result) } } }
1 + fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let y = x + 1i32 ; return y } } } } fn main () { { let result = calculate_something (10i32) ; println ! ("{}" , result) } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpaGLpIz/main.rs:1:79
  |
1 | fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let y = x + 1i32 ; return y } } } } fn main () { { { let result = calcu...
  |                                                                               ^^^^ expected `i64`, found `i32`

error[E0277]: cannot add `i32` to `i64`
 --> /tmp/.tmpaGLpIz/main.rs:1:77
  |
1 | fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let y = x + 1i32 ; return y } } } } fn main () { { { let result = calcu...
  |                                                                             ^ no implementation for `i64 + i32`
  |
  = help: the trait `Add<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Add<Rhs>`:
            `&i64` implements `Add<i64>`
            `&i64` implements `Add`
            `i64` implements `Add<&i64>`
            `i64` implements `Add`

error[E0308]: mismatched types
 --> /tmp/.tmpaGLpIz/main.rs:1:93
  |
1 | fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let y = x + 1i32 ; return y } } } } fn main () { { { let result = calcu...
  |                                 - help: try adding a return type: `-> i64`                  ^ expected `()`, found `i64`

error[E0308]: mismatched types
 --> /tmp/.tmpaGLpIz/main.rs:1:154
  |
1 | ... } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{}" , result) } } }
  |                                         -------------------  ^^^^^ expected `i64`, found `i32`
  |                                         |
  |                                         arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmpaGLpIz/main.rs:1:4
  |
1 | fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let y = x + 1i32 ; return y } } } } fn main () { { { let result = calcu...
  |    ^^^^^^^^^^^^^^^^^^^  -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! ("{}" , result) } } }
1 + fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i64) ; println ! ("{}" , result) } } }
  |

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpaGLpIz/main.rs:1:181
  |
1 | ...te_something (10i32) ; println ! ("{}" , result) } } }
  |                                       --    ^^^^^^ `()` cannot be formatted with the default formatter
  |                                       |
  |                                       required by this formatting parameter
  |
  = help: the trait `std::fmt::Display` is not implemented for `()`
  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 5 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.



=== ch20-00-tooling example 2 ===
✗ Compilation failed: Compilation failed:
error[E0428]: the name `fibonacci` is defined multiple times
 --> /tmp/.tmp0HG3y0/main.rs:1:119
  |
1 | fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { ...
  | ----------------------------- previous definition of the value `fibonacci` here                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `fibonacci` redefined here
  |
  = note: `fibonacci` must be defined only once in the value namespace of this module

warning: unnecessary braces around block return value
 --> /tmp/.tmp0HG3y0/main.rs:1:33
  |
1 | fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i...
  |                                 ^^                                                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + fn fibonacci (n : i64) -> i64 { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp0HG3y0/main.rs:1:50
  |
1 | fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i...
  |                                                  ^^ ^^
  |
help: remove these braces
  |
1 - fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { n } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp0HG3y0/main.rs:1:65
  |
1 | fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i...
  |                                                                 ^^                                           ^^
  |
help: remove these braces
  |
1 - fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp0HG3y0/main.rs:1:151
  |
1 | ...nacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |                             ^^                                                                               ^^
  |
help: remove these braces
  |
1 - fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp0HG3y0/main.rs:1:168
  |
1 | ... 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } f...
  |                                                                    ^^ ^^
  |
help: remove these braces
  |
1 - fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { n } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp0HG3y0/main.rs:1:183
  |
1 | ...) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |                                               ^^                                           ^^
  |
help: remove these braces
  |
1 - fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp0HG3y0/main.rs:1:43
  |
1 | fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i...
  |                                      -    ^^^^ expected `i64`, found `i32`
  |                                      |
  |                                      expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + fn fibonacci (n : i64) -> i64 { { if n <= 1i64 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp0HG3y0/main.rs:1:82
  |
1 | fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i...
  |                                                                                  ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmp0HG3y0/main.rs:1:80
  |
1 | fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i...
  |                                                                                ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmp0HG3y0/main.rs:1:105
  |
1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fib...
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmp0HG3y0/main.rs:1:103
  |
1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fib...
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmp0HG3y0/main.rs:1:161
  |
1 | ...2) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn ma...
  |                                                    -    ^^^^ expected `i64`, found `i32`
  |                                                    |
  |                                                    expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
1 + fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i64 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp0HG3y0/main.rs:1:200
  |
1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmp0HG3y0/main.rs:1:198
  |
1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmp0HG3y0/main.rs:1:223
  |
1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmp0HG3y0/main.rs:1:221
  |
1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error: aborting due to 11 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0428.
For more information about an error, try `rustc --explain E0277`.



=== ch20-00-tooling example 3 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpwyn7Ob/main.rs:1:37
  |
1 | fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2...
  |                                     ^^     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + fn add (a : i64 , b : i64) -> i64 { a + b } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpwyn7Ob/main.rs:1:90
  |
1 | fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2...
  |                                                                                          ^^     ^^
  |
help: remove these braces
  |
1 - fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { a * b } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpwyn7Ob/main.rs:1:132
  |
1 | ... { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32...
  |                                                 ^^^  ----   ---- expected `i64`, found `i32`
  |                                                      |
  |                                                      expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpwyn7Ob/main.rs:1:4
  |
1 | fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2...
  |    ^^^  -------   -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i64 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i64) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0423]: expected function, found macro `assert_eq`
 --> /tmp/.tmpwyn7Ob/main.rs:1:121
  |
1 | ...i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ;...
  |                                                           ^^^^^^^^^ not a function
  |
help: use `!` to invoke the macro
  |
1 | fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq! (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                  +

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpwyn7Ob/main.rs:1:171
  |
1 | ..._eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply ()...
  |                                                ^^^  ------   ---- expected `i64`, found `i32`
  |                                                     |
  |                                                     expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpwyn7Ob/main.rs:1:4
  |
1 | fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2...
  |    ^^^  -------   -------
help: you can convert an `i32` to an `i64`
  |
1 | fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add ((- 1i32).into() , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                                                                +      ++++++++
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i64) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0423]: expected function, found macro `assert_eq`
 --> /tmp/.tmpwyn7Ob/main.rs:1:160
  |
1 | ...test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) }...
  |                                                           ^^^^^^^^^ not a function
  |
help: use `!` to invoke the macro
  |
1 | fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq! (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                                                         +

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpwyn7Ob/main.rs:1:212
  |
1 | ...eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) ,...
  |                                                 ^^^  ----   ---- expected `i64`, found `i32`
  |                                                      |
  |                                                      expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpwyn7Ob/main.rs:1:4
  |
1 | fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2...
  |    ^^^  -------   -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i64 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i64) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0423]: expected function, found macro `assert_eq`
 --> /tmp/.tmpwyn7Ob/main.rs:1:201
  |
1 | ...32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (mul...
  |                                                           ^^^^^^^^^ not a function
  |
help: use `!` to invoke the macro
  |
1 | fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                                                                                                  +

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpwyn7Ob/main.rs:1:277
  |
1 | ...2) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (...
  |                                              ^^^^^^^^  ----   ---- expected `i64`, found `i32`
  |                                                        |
  |                                                        expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpwyn7Ob/main.rs:1:52
  |
1 | fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2...
  |                                                    ^^^^^^^^  -------   -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i64 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i64) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0423]: expected function, found macro `assert_eq`
 --> /tmp/.tmpwyn7Ob/main.rs:1:266
  |
1 | ...(add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32)...
  |                                                           ^^^^^^^^^ not a function
  |
help: use `!` to invoke the macro
  |
1 | fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq! (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                                                                                                                                                                   +

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpwyn7Ob/main.rs:1:321
  |
1 | ...tiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main ...
  |                                             ^^^^^^^^  ------   ---- expected `i64`, found `i32`
  |                                                       |
  |                                                       expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpwyn7Ob/main.rs:1:52
  |
1 | fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2...
  |                                                    ^^^^^^^^  -------   -------
help: you can convert an `i32` to an `i64`
  |
1 | fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply ((- 1i32).into() , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                           +      ++++++++
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i64) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |

error[E0423]: expected function, found macro `assert_eq`
 --> /tmp/.tmpwyn7Ob/main.rs:1:310
  |
1 | ...ply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100...
  |                                                           ^^^^^^^^^ not a function
  |
help: use `!` to invoke the macro
  |
1 | fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                               +

error[E0308]: arguments to this function are incorrect
 --> /tmp/.tmpwyn7Ob/main.rs:1:369
  |
1 | ...y (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                             ^^^^^^^^  ----   ------ expected `i64`, found `i32`
  |                                                       |
  |                                                       expected `i64`, found `i32`
  |
note: function defined here
 --> /tmp/.tmpwyn7Ob/main.rs:1:52
  |
1 | fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2...
  |                                                    ^^^^^^^^  -------   -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i64 , 100i32) , 0i32) } } fn main () { }
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
1 + fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i64) , 0i32) } } fn main () { }
  |

error[E0423]: expected function, found macro `assert_eq`
 --> /tmp/.tmpwyn7Ob/main.rs:1:358
  |
1 | ...i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                           ^^^^^^^^^ not a function
  |
help: use `!` to invoke the macro
  |
1 | fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                               +

error: aborting due to 12 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0308, E0423.
For more information about an error, try `rustc --explain E0308`.



=== ch20-00-tooling example 4 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpvnsvzS/main.rs:1:44
  |
1 | fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq (re...
  |                                            ^^ ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } } fn main () { }
1 + fn reverse_string (s : String) -> String { s } fn property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpvnsvzS/main.rs:1:100
  |
1 | ...se_twice_is_identity () { { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } } fn main () { }
  |                              ^^                                                                             ^^
  |
help: remove these braces
  |
1 - fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } } fn main () { }
1 + fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } fn main () { }
  |

error[E0423]: expected function, found macro `assert_eq`
 --> /tmp/.tmpvnsvzS/main.rs:1:125
  |
1 | ...everse_twice_is_identity () { { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } } fn main () { }
  |                                                           ^^^^^^^^^ not a function
  |
help: use `!` to invoke the macro
  |
1 | fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq! (reverse_string (reverse_string (s)) , s) }) } } fn main () { }
  |                                                                                                                                      +

error[E0425]: cannot find function `property_test` in this scope
 --> /tmp/.tmpvnsvzS/main.rs:1:102
  |
1 | ... property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } } fn m...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error: aborting due to 2 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0423, E0425.
For more information about an error, try `rustc --explain E0423`.



=== ch20-00-tooling example 5 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmp1T9lxP/main.rs:1:49
  |
1 | fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 ...
  |                                                 ^^                                                      ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + fn factorial (n : i64) -> i64 { { if n < 0i32 { panic ! ("Factorial not defined for negative numbers") } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp1T9lxP/main.rs:1:140
  |
1 | ...fined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                                   ^^    ^^
  |
help: remove these braces
  |
1 - fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { 1i32 } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp1T9lxP/main.rs:1:158
  |
1 | ... } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                         ^^                        ^^
  |
help: remove these braces
  |
1 - fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { n * factorial (n - 1i32) } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp1T9lxP/main.rs:1:42
  |
1 | fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 ...
  |                                      -   ^^^^ expected `i64`, found `i32`
  |                                      |
  |                                      expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + fn factorial (n : i64) -> i64 { { if n < 0i64 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp1T9lxP/main.rs:1:120
  |
1 | ...ial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main ...
  |                                                    -    ^^^^ expected `i64`, found `i32`
  |                                                    |
  |                                                    expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i64 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp1T9lxP/main.rs:1:133
  |
1 | ...ed for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                    -    ^^^^ expected `i64`, found `i32`
  |                                                    |
  |                                                    expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i64 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp1T9lxP/main.rs:1:142
  |
1 | ...) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else ...
  |         --- expected `i64` because of return type                                                                          ^^^^ expected `i64`, found `i32`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
1 + fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! ("Factorial not defined for negative numbers") } } ; if n == 0i32 || n == 1i32 { { 1i64 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp1T9lxP/main.rs:1:179
  |
1 | ...n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmp1T9lxP/main.rs:1:177
  |
1 | ...n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error: aborting due to 6 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.



=== ch20-00-tooling example 6 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmp7rfoKu/main.rs:1:240
  |
1 | ... { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_rec...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7rfoKu/main.rs:1:43
  |
1 | ... i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_...
  |                   ^^                                                                                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" , || fibonacci_iterative (20i32)) } } fn main () { }
1 + fn fibonacci_recursive (n : i64) -> i64 { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7rfoKu/main.rs:1:60
  |
1 | fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i3...
  |                                                            ^^ ^^
  |
help: remove these braces
  |
1 - fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" , || fibonacci_iterative (20i32)) } } fn main () { }
1 + fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { n } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7rfoKu/main.rs:1:75
  |
1 | ... { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n :...
  |                                     ^^                                                               ^^
  |
help: remove these braces
  |
1 - fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" , || fibonacci_iterative (20i32)) } } fn main () { }
1 + fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7rfoKu/main.rs:1:252
  |
1 | ... ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { ben...
  |                                               ^^                                           ^^
  |
help: remove these braces
  |
1 - fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" , || fibonacci_iterative (20i32)) } } fn main () { }
1 + fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { let temp = a + b ; { a = b ; b = temp } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7rfoKu/main.rs:1:338
  |
1 | ...} } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { ...
  |                                    ^^                                                                 ^^
  |
help: remove these braces
  |
1 - fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" , || fibonacci_iterative (20i32)) } } fn main () { }
1 + fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { bench ("fibonacci_recursive_20" , || fibonacci_recursive (20i32)) } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" , || fibonacci_iterative (20i32)) } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp7rfoKu/main.rs:1:438
  |
1 | ...} } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" , || fibonacci_iterative (20i32)) } } fn main () { }
  |                                    ^^                                                                 ^^
  |
help: remove these braces
  |
1 - fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" , || fibonacci_iterative (20i32)) } } fn main () { }
1 + fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { bench ("fibonacci_iterative_20" , || fibonacci_iterative (20i32)) } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp7rfoKu/main.rs:1:53
  |
1 | fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i3...
  |                                                -    ^^^^ expected `i64`, found `i32`
  |                                                |
  |                                                expected because this is `i64`
  |
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" , || fibonacci_iterative (20i32)) } } fn main () { }
1 + fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i64 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" , || fibonacci_iterative (20i32)) } } fn main () { }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp7rfoKu/main.rs:1:102
  |
1 | fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i3...
  |                                                                                                      ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmp7rfoKu/main.rs:1:100
  |
1 | fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i3...
  |                                                                                                    ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmp7rfoKu/main.rs:1:135
  |
1 | ...ci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mu...
  |                                                       ^^^^ expected `i64`, found `i32`

error[E0277]: cannot subtract `i32` from `i64`
 --> /tmp/.tmp7rfoKu/main.rs:1:133
  |
1 | ...ci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mu...
  |                                                     ^ no implementation for `i64 - i32`
  |
  = help: the trait `Sub<i32>` is not implemented for `i64`
  = help: the following other types implement trait `Sub<Rhs>`:
            `&i64` implements `Sub<i64>`
            `&i64` implements `Sub`
            `i64` implements `Sub<&i64>`
            `i64` implements `Sub`

error[E0308]: mismatched types
 --> /tmp/.tmp7rfoKu/main.rs:1:304
  |
1 | ...) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn b...
  |         --- expected `i64` because of return type                                                                              ^ expected `i64`, found `i32`
  |
help: you can convert an `i32` to an `i64`
  |
1 | fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a.into() } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" , || fibonacci_iterative (20i32)) } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                 +++++++

error[E0308]: mismatched types
 --> /tmp/.tmp7rfoKu/main.rs:1:398
  |
1 | ...bench ("fibonacci_recursive_20" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" , ...
  |                                         -------------------  ^^^^^ expected `i64`, found `i32`
  |                                         |
  |                                         arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmp7rfoKu/main.rs:1:4
  |
1 | fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i3...
  |    ^^^^^^^^^^^^^^^^^^^  -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" , || fibonacci_iterative (20i32)) } } fn main () { }
1 + fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" , || fibonacci_recursive (20i64)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" , || fibonacci_iterative (20i32)) } } fn main () { }
  |

error[E0423]: expected function, found attribute macro `bench`
 --> /tmp/.tmp7rfoKu/main.rs:1:340
  |
1 | ...; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" , || fibonacci_recursive (20i32)) } } fn benc...
  |                                                             ^^^^^ not a function

error[E0308]: mismatched types
 --> /tmp/.tmp7rfoKu/main.rs:1:498
  |
1 | ...bench ("fibonacci_iterative_20" , || fibonacci_iterative (20i32)) } } fn main () { }
  |                                         -------------------  ^^^^^ expected `i64`, found `i32`
  |                                         |
  |                                         arguments to this function are incorrect
  |
note: function defined here
 --> /tmp/.tmp7rfoKu/main.rs:1:152
  |
1 | ...- 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for...
  |                                                        ^^^^^^^^^^^^^^^^^^^  -------
help: change the type of the numeric literal from `i32` to `i64`
  |
1 - fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" , || fibonacci_iterative (20i32)) } } fn main () { }
1 + fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench ("fibonacci_recursive_20" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" , || fibonacci_iterative (20i64)) } } fn main () { }
  |

error[E0423]: expected function, found attribute macro `bench`
 --> /tmp/.tmp7rfoKu/main.rs:1:440
  |
1 | ...cci_recursive (20i32)) } } fn bench_iterative_fib () { { bench ("fibonacci_iterative_20" , || fibonacci_iterative (20i32)) } } fn main...
  |                                                             ^^^^^ not a function

error: aborting due to 11 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0423, E0425.
For more information about an error, try `rustc --explain E0277`.



=== ch07-00-building-applications example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch07-00-building-applications example 2 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmpFCofcT/main.rs:1:649
  |
1 | ... = { name : "MyApp" , version : "1.0.0" , config_dir : "~/.config/myapp" , data_dir : "~/.local/share/myapp" , cache_dir : "~/.cache/myapp" , } ; ...
  |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | fn create_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , email : T) -> T { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{}" , "Member since: " + user . created) } } fn main () { let APP = { SomeStruct { name : "MyApp" , version : "1.0.0" , config_dir : "~/.config/myapp" , data_dir : "~/.local/share/myapp" , cache_dir : "~/.cache/myapp" , } } ; let User = { id : null , name : "" , email : "" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ++++++++++++                                                                                                                                              +

error: struct literal body without path
 --> /tmp/.tmpFCofcT/main.rs:1:803
  |
1 | ...r : "~/.cache/myapp" , } ; let User = { id : null , name : "" , email : "" , created : null , } ; { init_app () ; load_config () ; run...
  |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | fn create_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , email : T) -> T { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{}" , "Member since: " + user . created) } } fn main () { let APP = { name : "MyApp" , version : "1.0.0" , config_dir : "~/.config/myapp" , data_dir : "~/.local/share/myapp" , cache_dir : "~/.cache/myapp" , } ; let User = { SomeStruct { id : null , name : "" , email : "" , created : null , } } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ++++++++++++                                                           +

error[E0425]: cannot find value `User` in this scope
 --> /tmp/.tmpFCofcT/main.rs:1:191
  |
1 | ...Clone > (name : T , email : T) -> T { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . ema...
  |                                                         ^^^^ not found in this scope

warning: unnecessary braces around block return value
 --> /tmp/.tmpFCofcT/main.rs:1:176
  |
1 | ... { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } ...
  |       ^^                                                                                                                                                                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn create_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , email : T) -> T { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{}" , "Member since: " + user . created) } } fn main () { let APP = { name : "MyApp" , version : "1.0.0" , config_dir : "~/.config/myapp" , data_dir : "~/.local/share/myapp" , cache_dir : "~/.cache/myapp" , } ; let User = { id : null , name : "" , email : "" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
1 + fn create_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , email : T) -> T { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } fn display_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{}" , "Member since: " + user . created) } } fn main () { let APP = { name : "MyApp" , version : "1.0.0" , config_dir : "~/.config/myapp" , data_dir : "~/.local/share/myapp" , cache_dir : "~/.cache/myapp" , } ; let User = { id : null , name : "" , email : "" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |

error[E0425]: cannot find function `generate_uuid` in this scope
 --> /tmp/.tmpFCofcT/main.rs:1:222
  |
1 | ...{ { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = curren...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `current_datetime` in this scope
 --> /tmp/.tmpFCofcT/main.rs:1:302
  |
1 | ...name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user < T : std :: ops :: Add < Out...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0609]: no field `name` on type `T`
 --> /tmp/.tmpFCofcT/main.rs:1:546
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! ("User: {} ({})" , user . name , ...
  |       - type parameter 'T' declared here                                                                                                                                                      ^^^^ unknown field

error[E0609]: no field `email` on type `T`
 --> /tmp/.tmpFCofcT/main.rs:1:560
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! ("User: {} ({})" , user . name , user . email) ;...
  |       - type parameter 'T' declared here                                                                                                                                                                    ^^^^^ unknown field

error[E0609]: no field `created` on type `T`
 --> /tmp/.tmpFCofcT/main.rs:1:613
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{}" , "Member since: " + user . created) }...
  |       - type parameter 'T' declared here                                                                                                                                                                                                                         ^^^^^^^ unknown field

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpFCofcT/main.rs:1:587
  |
1 | ...er . email) ; println ! ("{}" , "Member since: " + user . created) } } fn main () { let APP = { name : "MyApp" , version : "1.0.0" , c...
  |                              --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                              |
  |                              required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
 --> /tmp/.tmpFCofcT/main.rs:1:569
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! ("User: {} ({})" , user . name , user . email) ; println ! ("{}" , "Member since: " + user . created) } ...
  |       - expected this type parameter                                                                                                                                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `init_app` in this scope
 --> /tmp/.tmpFCofcT/main.rs:1:865
  |
1 | ... , name : "" , email : "" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `load_config` in this scope
 --> /tmp/.tmpFCofcT/main.rs:1:879
  |
1 | ...mail : "" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `run_event_loop` in this scope
 --> /tmp/.tmpFCofcT/main.rs:1:896
  |
1 | ...d : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `cleanup` in this scope
 --> /tmp/.tmpFCofcT/main.rs:1:916
  |
1 | ...init_app () ; load_config () ; run_event_loop () ; cleanup () } }
  |                                                       ^^^^^^^ not found in this scope

error: aborting due to 14 previous errors; 1 warning emitted

Some errors have detailed explanations: E0277, E0308, E0425, E0609.
For more information about an error, try `rustc --explain E0277`.



=== ch07-00-building-applications example 3 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmpXm7ur2/main.rs:1:623
  |
1 | ...main () { let STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { SomeStruct { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ++++++++++++                                                                                           +

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpXm7ur2/main.rs:1:178
  |
1 | ...t :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () ...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpXm7ur2/main.rs:1:200
  |
1 | ...key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty {...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpXm7ur2/main.rs:1:267
  |
1 | ... true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json") ; {...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `APP` in this scope
 --> /tmp/.tmpXm7ur2/main.rs:1:315
  |
1 | ...{ if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json") ; { write_file (state_file , to_json (STATE)) ; ST...
  |                                                         ^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpXm7ur2/main.rs:1:384
  |
1 | ..."state.json") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file ...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpXm7ur2/main.rs:1:394
  |
1 | ...n") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_pat...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `APP` in this scope
 --> /tmp/.tmpXm7ur2/main.rs:1:479
  |
1 | ...} fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json") ; if file_exists (state_file) { { STATE = parse_js...
  |                                                         ^^^ not found in this scope

error[E0425]: cannot find value `STATE` in this scope
 --> /tmp/.tmpXm7ur2/main.rs:1:544
  |
1 | ...r , "state.json") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { u...
  |                                                        ^^^^^ not found in this scope

warning: unnecessary braces around block return value
 --> /tmp/.tmpXm7ur2/main.rs:1:262
  |
1 | ... { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } ...
  |       ^^                                                                                                                                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
1 + fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXm7ur2/main.rs:1:283
  |
1 | ... { { { let state_file = join_path (APP . data_dir , "state.json") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } ...
  |       ^^                                                                                                                                      ^^
  |
help: remove these braces
  |
1 - fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
1 + fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { let state_file = join_path (APP . data_dir , "state.json") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXm7ur2/main.rs:1:447
  |
1 | ... { { { let state_file = join_path (APP . data_dir , "state.json") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } ...
  |       ^^                                                                                                                                                ^^
  |
help: remove these braces
  |
1 - fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
1 + fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { let state_file = join_path (APP . data_dir , "state.json") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } fn main () { let STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpXm7ur2/main.rs:1:542
  |
1 | ...ate.json") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { users : ...
  |                                               ^^                                           ^^
  |
help: remove these braces
  |
1 - fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
1 + fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json") ; if file_exists (state_file) { STATE = parse_json (read_file (state_file)) } } } } fn main () { let STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }
  |

error[E0425]: cannot find function `trigger_save` in this scope
 --> /tmp/.tmpXm7ur2/main.rs:1:223
  |
1 | ...{ { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpXm7ur2/main.rs:1:304
  |
1 | ...te () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , "state.json") ; { write_file (state_file , to_json (STAT...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_json` in this scope
 --> /tmp/.tmpXm7ur2/main.rs:1:375
  |
1 | ...a_dir , "state.json") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let sta...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpXm7ur2/main.rs:1:350
  |
1 | ... data_dir , "state.json") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let...
  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `state_file`

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpXm7ur2/main.rs:1:468
  |
1 | ...} } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , "state.json") ; if file_exists (state_file) { { STATE = ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpXm7ur2/main.rs:1:515
  |
1 | ...= join_path (APP . data_dir , "state.json") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpXm7ur2/main.rs:1:564
  |
1 | ... file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { users : vec ! [] , curr...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `parse_json` in this scope
 --> /tmp/.tmpXm7ur2/main.rs:1:552
  |
1 | ....json") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { users : vec...
  |                                                      ^^^^^^^^^^ not found in this scope

error: aborting due to 17 previous errors; 4 warnings emitted

For more information about this error, try `rustc --explain E0425`.



=== ch07-00-building-applications example 4 ===
✗ Compilation failed: Compilation failed:
error[E0423]: expected value, found macro `try`
 --> /tmp/.tmpiQk8ES/main.rs:1:198
  |
1 | ...+ Clone > (operation_fn : T , fallback_value : T) -> T { { try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; re...
  |                                                               ^^^ not a value

error[E0425]: cannot find value `catch` in this scope
 --> /tmp/.tmpiQk8ES/main.rs:1:233
  |
1 | ...ue : T) -> T { { try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < ...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpiQk8ES/main.rs:1:241
  |
1 | ...-> T { { try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std ...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpiQk8ES/main.rs:1:262
  |
1 | ...rn operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Outpu...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `range` in this scope
 --> /tmp/.tmpiQk8ES/main.rs:1:505
  |
1 | ..._fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { try ; { return operation_fn () } ; catch ; error ; { if a...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::slice::range;
  |

error[E0423]: expected value, found macro `try`
 --> /tmp/.tmpiQk8ES/main.rs:1:530
  |
1 | ...mpts : T) -> T { { for attempt in range (max_attempts) { { try ; { return operation_fn () } ; catch ; error ; { if attempt == max_atte...
  |                                                               ^^^ not a value

error[E0425]: cannot find value `catch` in this scope
 --> /tmp/.tmpiQk8ES/main.rs:1:565
  |
1 | ...ax_attempts) { { try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , "❌ Failed...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpiQk8ES/main.rs:1:573
  |
1 | ...pts) { { try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , "❌ Failed after "...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpiQk8ES/main.rs:1:700
  |
1 | ... after " + max_attempts . to_s () + " attempts: " + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; ...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpiQk8ES/main.rs:1:728
  |
1 | ..._s () + " attempts: " + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Att...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `sleep` in this scope
 --> /tmp/.tmpiQk8ES/main.rs:1:878
  |
1 | ...retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::sleep;
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpiQk8ES/main.rs:1:488
  |
1 | ... { { for attempt in range (max_attempts) { { try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , "❌ Failed after " + max_attempts . to_s () + " attempts: " + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn safe_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , fallback_value : T) -> T { { try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , "❌ Failed after " + max_attempts . to_s () + " attempts: " + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }
1 + fn safe_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , fallback_value : T) -> T { { try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { for attempt in range (max_attempts) { { try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , "❌ Failed after " + max_attempts . to_s () + " attempts: " + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } fn main () { }
  |

error[E0618]: expected function, found `T`
 --> /tmp/.tmpiQk8ES/main.rs:1:213
  |
1 | ...+ Clone > (operation_fn : T , fallback_value : T) -> T { { try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; re...
  |               ------------                                                   ^^^^^^^^^^^^---
  |               |                                                              |
  |               `operation_fn` has type `T`                                    call expression requires function

warning: unreachable statement
 --> /tmp/.tmpiQk8ES/main.rs:1:233
  |
1 | ...ck_value : T) -> T { { try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_re...
  |                                   ----------------------     ^^^^^^^ unreachable statement
  |                                   |
  |                                   any code following this expression is unreachable
  |
  = note: `#[warn(unreachable_code)]` on by default

error[E0425]: cannot find function `log_error` in this scope
 --> /tmp/.tmpiQk8ES/main.rs:1:251
  |
1 | ... ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Ad...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0618]: expected function, found `T`
 --> /tmp/.tmpiQk8ES/main.rs:1:545
  |
1 | ...one > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { try ; { return operation_fn () } ; catch ...
  |           ------------                                                                                         ^^^^^^^^^^^^---
  |           |                                                                                                    |
  |           `operation_fn` has type `T`                                                                          call expression requires function

warning: unreachable statement
 --> /tmp/.tmpiQk8ES/main.rs:1:565
  |
1 | ...nge (max_attempts) { { try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , "❌ ...
  |                                   ----------------------     ^^^^^^^ unreachable statement
  |                                   |
  |                                   any code following this expression is unreachable

error[E0369]: cannot subtract `i32` from `T`
 --> /tmp/.tmpiQk8ES/main.rs:1:610
  |
1 | ...rn operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , "❌ Failed after " + max_attempts . to_...
  |                                                           ------------ ^ ---- i32
  |                                                           |
  |                                                           T
  |
help: consider further restricting type parameter `T` with trait `Sub`
  |
1 | fn safe_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , fallback_value : T) -> T { { try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Sub<i32> > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , "❌ Failed after " + max_attempts . to_s () + " attempts: " + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                         ++++++++++++++++++++

error[E0599]: no method named `to_s` found for type parameter `T` in the current scope
 --> /tmp/.tmpiQk8ES/main.rs:1:674
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , "❌ Failed after " + max_attempts . to_s () ...
  |       - method `to_s` not found for this type parameter                                                                                                                                                                                                                                                                                                                       ^^^^ method not found in `T`

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpiQk8ES/main.rs:1:682
  |
1 | ...empts - 1i32 { { println ! ("{}" , "❌ Failed after " + max_attempts . to_s () + " attempts: " + error . to_s ()) ; panic ! (error) } } ...
  |                                       ------------------------------------------- ^ ------------- &str
  |                                       |
  |                                       str

error[E0308]: mismatched types
 --> /tmp/.tmpiQk8ES/main.rs:1:858
  |
1 | ...Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }
  |                                                       ^^^^ expected `u32`, found `i32`

error[E0277]: cannot add `i32` to `u32`
 --> /tmp/.tmpiQk8ES/main.rs:1:856
  |
1 | ...Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }
  |                                                     ^ no implementation for `u32 + i32`
  |
  = help: the trait `Add<i32>` is not implemented for `u32`
  = help: the following other types implement trait `Add<Rhs>`:
            `&u32` implements `Add<u32>`
            `&u32` implements `Add`
            `u32` implements `Add<&u32>`
            `u32` implements `Add`

error[E0308]: mismatched types
 --> /tmp/.tmpiQk8ES/main.rs:1:490
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , "❌ Failed after " + max_attempts . to_s () + " attempts: " + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } }...
  |       -                                                                                                                                                                        -     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |       |                                                                                                                                                                        |
  |       expected this type parameter                                                                                                                                             expected `T` because of return type
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: the caller chooses a type for `T` which can be different from `()`
  = note: `for` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | fn safe_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , fallback_value : T) -> T { { try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! ("{}" , "❌ Failed after " + max_attempts . to_s () + " attempts: " + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! ("⚠\u{fe0f}  Attempt {} failed, retrying in {}s..." , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } /* `T` value */ } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     +++++++++++++++

error: aborting due to 20 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0369, E0423, E0425, E0599, E0618.
For more information about an error, try `rustc --explain E0277`.



=== ch07-00-building-applications example 5 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmpKA9vi9/main.rs:1:1096
  |
1 | ...swords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_password...
  |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { SomeStruct { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , "❌ No password found for " + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = "~/.passwords.enc" ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ++++++++++++                                                                                                        +

error[E0425]: cannot find value `MASTER_KEY` in this scope
 --> /tmp/.tmpKA9vi9/main.rs:1:1552
  |
1 | ...e] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboa...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `null` in this scope
 --> /tmp/.tmpKA9vi9/main.rs:1:1802
  |
1 | ...or " + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = "~/.passwords.enc" ; }
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::ptr::null;
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpKA9vi9/main.rs:1:170
  |
1 | ... { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } ...
  |       ^^                                                                                                                                                                                                                                 ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , "❌ No password found for " + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = "~/.passwords.enc" ; }
1 + fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , "❌ No password found for " + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = "~/.passwords.enc" ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpKA9vi9/main.rs:1:254
  |
1 | ... enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base...
  |                    ^^                                                                                                  ^^
  |
help: remove these braces
  |
1 - fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , "❌ No password found for " + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = "~/.passwords.enc" ; }
1 + fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , "❌ No password found for " + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = "~/.passwords.enc" ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpKA9vi9/main.rs:1:576
  |
1 | ... { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } ...
  |       ^^                                                                                                                                                                                                                                                                  ^^
  |
help: remove these braces
  |
1 - fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , "❌ No password found for " + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = "~/.passwords.enc" ; }
1 + fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , "❌ No password found for " + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = "~/.passwords.enc" ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpKA9vi9/main.rs:1:690
  |
1 | ...merate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return d...
  |                ^^                                                                                                         ^^
  |
help: remove these braces
  |
1 - fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , "❌ No password found for " + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = "~/.passwords.enc" ; }
1 + fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , "❌ No password found for " + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = "~/.passwords.enc" ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpKA9vi9/main.rs:1:1035
  |
1 | ... { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } ...
  |       ^^                                                                                                                                                                                                  ^^
  |
help: remove these braces
  |
1 - fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , "❌ No password found for " + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = "~/.passwords.enc" ; }
1 + fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , "❌ No password found for " + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = "~/.passwords.enc" ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpKA9vi9/main.rs:1:1400
  |
1 | ... { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , "❌ No password found for " + site) } } } } } fn...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                               ^^
  |
help: remove these braces
  |
1 - fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , "❌ No password found for " + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = "~/.passwords.enc" ; }
1 + fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , "❌ No password found for " + site) } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = "~/.passwords.enc" ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpKA9vi9/main.rs:1:1472
  |
1 | ... { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } e...
  |       ^^                                                                                                                                                                                                                              ^^
  |
help: remove these braces
  |
1 - fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , "❌ No password found for " + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = "~/.passwords.enc" ; }
1 + fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } else { { println ! ("{}" , "❌ No password found for " + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = "~/.passwords.enc" ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpKA9vi9/main.rs:1:1707
  |
1 | ... || clear_clipboard ()) } } } } else { { println ! ("{}" , "❌ No password found for " + site) } } } } } fn main () { let MASTER_KEY = n...
  |                                           ^^                                                     ^^
  |
help: remove these braces
  |
1 - fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , "❌ No password found for " + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = "~/.passwords.enc" ; }
1 + fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { println ! ("{}" , "❌ No password found for " + site) } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = "~/.passwords.enc" ; }
  |

error[E0599]: no method named `chars` found for type parameter `T` in the current scope
 --> /tmp/.tmpKA9vi9/main.rs:1:228
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars ()...
  |       - method `chars` not found for this type parameter                                                                                                                                                                    ^^^^^ method not found in `T`

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpKA9vi9/main.rs:1:288
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                  ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , "❌ No password found for " + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = "~/.passwords.enc" ; }
  |                                                                                                                                            +++++++++++++++++++

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpKA9vi9/main.rs:1:277
  |
1 | ...n text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) ...
  |                                                              ^^^^^^^^^^^^^^^^^^

error[E0425]: cannot find function `base64_encode` in this scope
 --> /tmp/.tmpKA9vi9/main.rs:1:368
  |
1 | ... . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + ...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `base64_decode` in this scope
 --> /tmp/.tmpKA9vi9/main.rs:1:592
  |
1 | ...encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enu...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpKA9vi9/main.rs:1:724
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                                                     ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , "❌ No password found for " + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = "~/.passwords.enc" ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             +++++++++++++++++++

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpKA9vi9/main.rs:1:713
  |
1 | ... , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . cod...
  |                                                              ^^^^^^^^^^^^^^^^^^

error[E0425]: cannot find function `char_from_code` in this scope
 --> /tmp/.tmpKA9vi9/main.rs:1:752
  |
1 | ...ar = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join ("") } } }...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `load_passwords` in this scope
 --> /tmp/.tmpKA9vi9/main.rs:1:1055
  |
1 | ... : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (p...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `save_passwords` in this scope
 --> /tmp/.tmpKA9vi9/main.rs:1:1201
  |
1 | ...STER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = ...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `load_passwords` in this scope
 --> /tmp/.tmpKA9vi9/main.rs:1:1420
  |
1 | ... } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords ()...
  |       ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- similarly named function `add_password` defined here                                                                                                                                                                                                                                                                                                                                               ^^^^^^^^^^^^^^ help: a function with a similar name exists: `add_password`

error[E0425]: cannot find function `copy_to_clipboard` in this scope
 --> /tmp/.tmpKA9vi9/main.rs:1:1566
  |
1 | ...d = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_afte...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `clear_clipboard` in this scope
 --> /tmp/.tmpKA9vi9/main.rs:1:1672
  |
1 | ...d to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , "❌ No password found for " + site...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `spawn_after` in this scope
 --> /tmp/.tmpKA9vi9/main.rs:1:1645
  |
1 | ... println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , "❌ No...
  |                                                      ^^^^^^^^^^^ not found in this scope

error[E0369]: cannot add `T` to `&str`
 --> /tmp/.tmpKA9vi9/main.rs:1:1754
  |
1 | ...clipboard ()) } } } } else { { println ! ("{}" , "❌ No password found for " + site) } } } } } fn main () { let MASTER_KEY = null ; let ...
  |                                                     --------------------------- ^ ---- T
  |                                                     |
  |                                                     &str

error[E0308]: mismatched types
 --> /tmp/.tmpKA9vi9/main.rs:1:1709
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! ("✅ Password copied to clipboard!") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! ("{}" , "❌ No password found for " + site) } } ...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 19 previous errors; 8 warnings emitted

Some errors have detailed explanations: E0308, E0369, E0425, E0599, E0608.
For more information about an error, try `rustc --explain E0308`.



=== ch07-00-building-applications example 6 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmp6ExeWU/main.rs:1:225
  |
1 | ... let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TR...
  |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { SomeStruct { date : current_date () , amount : amount , category : category , description : description , } } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , "Warning: " + category + " spending at $" + monthly_spent . to_s () + "/$" + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category") ; println ! ("{}" , "\n📊 Budget Report for " + month) ; println ! ("{}" , "=" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . map (| t | t . amount) . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , category + " $" + category_total . to_s () + " " + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , "Total:          $" + total . to_s ()) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , "\n📄 Report saved to " + report_file) } } } } fn main () { let TRANSACTIONS_FILE = "~/.budget/transactions.csv" ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
  |                                                                                                                                                                                                                                 ++++++++++++                                                                                                  +

error[E0425]: cannot find value `TRANSACTIONS_FILE` in this scope
 --> /tmp/.tmp6ExeWU/main.rs:1:338
  |
1 | ...description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; le...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `report_data` in this scope
 --> /tmp/.tmp6ExeWU/main.rs:1:1563
  |
1 | ...t_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , "\n📄 Report saved to " + report_file) } } } } fn main...
  |                                                     ^^^^^^^^^^^ not found in this scope

warning: unnecessary braces around block return value
 --> /tmp/.tmp6ExeWU/main.rs:1:203
  |
1 | ... { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , "Warning: " + category + " spending at $" + monthly_spent . to_s () + "/$" + budget_limit . to_s ()) } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , "Warning: " + category + " spending at $" + monthly_spent . to_s () + "/$" + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category") ; println ! ("{}" , "\n📊 Budget Report for " + month) ; println ! ("{}" , "=" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . map (| t | t . amount) . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , category + " $" + category_total . to_s () + " " + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , "Total:          $" + total . to_s ()) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , "\n📄 Report saved to " + report_file) } } } } fn main () { let TRANSACTIONS_FILE = "~/.budget/transactions.csv" ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
1 + fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , "Warning: " + category + " spending at $" + monthly_spent . to_s () + "/$" + budget_limit . to_s ()) } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category") ; println ! ("{}" , "\n📊 Budget Report for " + month) ; println ! ("{}" , "=" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . map (| t | t . amount) . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , category + " $" + category_total . to_s () + " " + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , "Total:          $" + total . to_s ()) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , "\n📄 Report saved to " + report_file) } } } } fn main () { let TRANSACTIONS_FILE = "~/.budget/transactions.csv" ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp6ExeWU/main.rs:1:884
  |
1 | ... { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category") ; println ! ("{}" , "\n📊 Budget Report for " + month) ; println ! ("{}" , "=" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . map (| t | t . amount) . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , category + " $" + category_total . to_s () + " " + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , "Total:          $" + total . to_s ()) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , "\n📄 Report saved to " + report_file) } } } } fn...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^^
  |
help: remove these braces
  |
1 - fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , "Warning: " + category + " spending at $" + monthly_spent . to_s () + "/$" + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category") ; println ! ("{}" , "\n📊 Budget Report for " + month) ; println ! ("{}" , "=" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . map (| t | t . amount) . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , category + " $" + category_total . to_s () + " " + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , "Total:          $" + total . to_s ()) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , "\n📄 Report saved to " + report_file) } } } } fn main () { let TRANSACTIONS_FILE = "~/.budget/transactions.csv" ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
1 + fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , "Warning: " + category + " spending at $" + monthly_spent . to_s () + "/$" + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category") ; println ! ("{}" , "\n📊 Budget Report for " + month) ; println ! ("{}" , "=" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . map (| t | t . amount) . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , category + " $" + category_total . to_s () + " " + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , "Total:          $" + total . to_s ()) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , "\n📄 Report saved to " + report_file) } } } fn main () { let TRANSACTIONS_FILE = "~/.budget/transactions.csv" ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp6ExeWU/main.rs:1:1151
  |
1 | ... { { { let category_total = items . map (| t | t . amount) . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , category + " $" + category_total . to_s () + " " + bar) } } } } ...
  |       ^^                                                                                                                                                                                                                             ^^
  |
help: remove these braces
  |
1 - fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , "Warning: " + category + " spending at $" + monthly_spent . to_s () + "/$" + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category") ; println ! ("{}" , "\n📊 Budget Report for " + month) ; println ! ("{}" , "=" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . map (| t | t . amount) . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , category + " $" + category_total . to_s () + " " + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , "Total:          $" + total . to_s ()) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , "\n📄 Report saved to " + report_file) } } } } fn main () { let TRANSACTIONS_FILE = "~/.budget/transactions.csv" ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
1 + fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , "Warning: " + category + " spending at $" + monthly_spent . to_s () + "/$" + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category") ; println ! ("{}" , "\n📊 Budget Report for " + month) ; println ! ("{}" , "=" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . items () { { let category_total = items . map (| t | t . amount) . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , category + " $" + category_total . to_s () + " " + bar) } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , "Total:          $" + total . to_s ()) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , "\n📄 Report saved to " + report_file) } } } } fn main () { let TRANSACTIONS_FILE = "~/.budget/transactions.csv" ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
  |

error[E0425]: cannot find function `append_csv` in this scope
 --> /tmp/.tmp6ExeWU/main.rs:1:326
  |
1 | ...ry : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `get_monthly_total` in this scope
 --> /tmp/.tmp6ExeWU/main.rs:1:393
  |
1 | ...ONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if month...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `get_budget_limit` in this scope
 --> /tmp/.tmp6ExeWU/main.rs:1:443
  |
1 | ..._monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (fo...
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `send_notification` in this scope
 --> /tmp/.tmp6ExeWU/main.rs:1:509
  |
1 | ...tegory) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("...
  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0369]: cannot add `T` to `&str`
 --> /tmp/.tmp6ExeWU/main.rs:1:615
  |
1 | ... Over budget for {}!" , category)) ; println ! ("{}" , "Warning: " + category + " spending at $" + monthly_spent . to_s () + "/$" + bu...
  |                                                           ----------- ^ -------- T
  |                                                           |
  |                                                           &str

error[E0308]: mismatched types
 --> /tmp/.tmp6ExeWU/main.rs:1:628
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , "Warning: " + category + " spending at $" + ...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^^^^^^^^^^^^^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`

error[E0308]: mismatched types
 --> /tmp/.tmp6ExeWU/main.rs:1:673
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , "Warning: " + category + " spending at $" + monthly_spent . to_s () + "/$" + ...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`

error[E0308]: mismatched types
 --> /tmp/.tmp6ExeWU/main.rs:1:585
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , "Warning: " + category + " spending at $" + monthly_spent . to_s () + "/$" + budget_limit . to_s ()) } ...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `load_transactions` in this scope
 --> /tmp/.tmp6ExeWU/main.rs:1:907
  |
1 | fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , "Warning: " + category + " spending at $" + monthly_spent . to_s () + "/$" + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (m...
  | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- similarly named function `add_transaction` defined here                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^^^^^^^^^^^^^^^^^ help: a function with a similar name exists: `add_transaction`

error[E0425]: cannot find function `group_by` in this scope
 --> /tmp/.tmp6ExeWU/main.rs:1:955
  |
1 | ... = load_transactions (month) ; { let by_category = group_by (transactions , "category") ; println ! ("{}" , "\n📊 Budget Report for " + ...
  |                                                       ^^^^^^^^ not found in this scope

error[E0369]: cannot add `T` to `&str`
 --> /tmp/.tmp6ExeWU/main.rs:1:1037
  |
1 | ...y (transactions , "category") ; println ! ("{}" , "\n📊 Budget Report for " + month) ; println ! ("{}" , "=" * 40i32) ; let total = 0i32...
  |                                                      ------------------------- ^ ----- T
  |                                                      |
  |                                                      &str

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmp6ExeWU/main.rs:1:1070
  |
1 | ...}" , "\n📊 Budget Report for " + month) ; println ! ("{}" , "=" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . it...
  |                                                                --- ^ ----- i32
  |                                                                |
  |                                                                &str

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmp6ExeWU/main.rs:1:1287
  |
1 | ...ry_total ; let bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , category + " $" + category_total . to_s () + " " + bar...
  |                                                        ^^^^ method not found in `i32`

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmp6ExeWU/main.rs:1:1250
  |
1 | ... . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , category + " $" + categor...
  |                                                ^^^ doesn't have a size known at compile-time
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: all local variables must have a statically known size

error[E0308]: mismatched types
 --> /tmp/.tmp6ExeWU/main.rs:1:1360
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category") ; println ! ("{}" , "\n📊 Budget Report for " + month) ; println ! ("{}" , "=" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . map (| t | t . amount) . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , category + " $" + category_total . to_s () + " " + b...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`

error[E0308]: mismatched types
 --> /tmp/.tmp6ExeWU/main.rs:1:1366
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category") ; println ! ("{}" , "\n📊 Budget Report for " + month) ; println ! ("{}" , "=" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . map (| t | t . amount) . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , category + " $" + category_total . to_s () + " " + bar) } ...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^^^ expected type parameter `T`, found `str`
  |
  = note: expected type parameter `T`
                       found type `str`

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmp6ExeWU/main.rs:1:1403
  |
1 | ...y_total . to_s () + " " + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , "Total:          $" + total . to_s ()) ; l...
  |                                                               --- ^ ----- i32
  |                                                               |
  |                                                               &str

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmp6ExeWU/main.rs:1:1462
  |
1 | ...) ; println ! ("{}" , "Total:          $" + total . to_s ()) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; generate_...
  |                                                        ^^^^ method not found in `i32`

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmp6ExeWU/main.rs:1:1432
  |
1 | ... * 40i32) ; println ! ("{}" , "Total:          $" + total . to_s ()) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; g...
  |                            --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                            |
  |                            required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `generate_pdf` in this scope
 --> /tmp/.tmp6ExeWU/main.rs:1:1535
  |
1 | ...le = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , "\n📄 Report saved to " + ...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0369]: cannot add `String` to `&str`
 --> /tmp/.tmp6ExeWU/main.rs:1:1619
  |
1 | ...ata) ; println ! ("{}" , "\n📄 Report saved to " + report_file) } } } } fn main () { let TRANSACTIONS_FILE = "~/.budget/transactions.csv...
  |                             ----------------------- ^ ----------- String
  |                             |                       |
  |                             |                       `+` cannot be used to concatenate a `&str` with a `String`
  |                             &str
  |
help: create an owned `String` on the left and add a borrow on the right
  |
1 | fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! ("⚠\u{fe0f} Over budget for {}!" , category)) ; println ! ("{}" , "Warning: " + category + " spending at $" + monthly_spent . to_s () + "/$" + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category") ; println ! ("{}" , "\n📊 Budget Report for " + month) ; println ! ("{}" , "=" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . map (| t | t . amount) . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , category + " $" + category_total . to_s () + " " + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , "Total:          $" + total . to_s ()) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , "\n📄 Report saved to ".to_owned() + &report_file) } } } } fn main () { let TRANSACTIONS_FILE = "~/.budget/transactions.csv" ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    +++++++++++   +

error[E0308]: mismatched types
 --> /tmp/.tmp6ExeWU/main.rs:1:1578
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , "category") ; println ! ("{}" , "\n📊 Budget Report for " + month) ; println ! ("{}" , "=" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . map (| t | t . amount) . sum () ; { total += category_total ; let bar = "█" * category_total / 50i32 . to_i () ; println ! ("{}" , category + " $" + category_total . to_s () + " " + bar) } } } } ; println ! ("{}" , "=" * 40i32) ; println ! ("{}" , "Total:          $" + total . to_s ()) ; let report_file = format ! ("budget_report_{}.pdf" , month) ; generate_pdf (report_file , report_data) ; println ! ("{}" , "\n📄 Report saved to " + report_file) } } ...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

warning: unused variable: `TRANSACTIONS_FILE`
 --> /tmp/.tmp6ExeWU/main.rs:1:1659
  |
1 | ... fn main () { let TRANSACTIONS_FILE = "~/.budget/transactions.csv" ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Enterta...
  |                      ^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_TRANSACTIONS_FILE`
  |
  = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `CATEGORIES`
 --> /tmp/.tmp6ExeWU/main.rs:1:1714
  |
1 | .../transactions.csv" ; let CATEGORIES = vec ! ["Food" , "Transport" , "Bills" , "Entertainment" , "Other"] ; }
  |                             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_CATEGORIES`

error: aborting due to 25 previous errors; 5 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0369, E0425, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch07-00-building-applications example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch07-00-building-applications example 8 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmpqwjaem/main.rs:1:375
  |
1 | ... } } } fn test_data_persistence () { { { let test_data = { test : "value" , } ; { let test_file = "test_data.json" ; save_json (test_f...
  |                                                             ^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | fn test_user_creation () { { { let user = create_user ("Alice" , "alice@example.com") ; { assert (user . name == "Alice" , "Name should be set") ; assert (user . email == "alice@example.com" , "Email should be set") ; assert (user . id != null , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } fn test_data_persistence () { { { let test_data = { SomeStruct { test : "value" , } } ; { let test_file = "test_data.json" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should be created") ; let loaded = load_json (test_file) ; assert (loaded . test == "value" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                        ++++++++++++                      +

error[E0425]: cannot find value `null` in this scope
 --> /tmp/.tmpqwjaem/main.rs:1:240
  |
1 | ...com" , "Email should be set") ; assert (user . id != null , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } }...
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::ptr::null;
  |

error[E0425]: cannot find function `remove_file` in this scope
 --> /tmp/.tmpqwjaem/main.rs:1:630
  |
1 | ...ded . test == "value" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_...
  |                                                     ^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::remove_file;
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpqwjaem/main.rs:1:28
  |
1 | ... { { { let user = create_user ("Alice" , "alice@example.com") ; { assert (user . name == "Alice" , "Name should be set") ; assert (user . email == "alice@example.com" , "Email should be set") ; assert (user . id != null , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn test_user_creation () { { { let user = create_user ("Alice" , "alice@example.com") ; { assert (user . name == "Alice" , "Name should be set") ; assert (user . email == "alice@example.com" , "Email should be set") ; assert (user . id != null , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } fn test_data_persistence () { { { let test_data = { test : "value" , } ; { let test_file = "test_data.json" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should be created") ; let loaded = load_json (test_file) ; assert (loaded . test == "value" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
1 + fn test_user_creation () { { let user = create_user ("Alice" , "alice@example.com") ; { assert (user . name == "Alice" , "Name should be set") ; assert (user . email == "alice@example.com" , "Email should be set") ; assert (user . id != null , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } fn test_data_persistence () { { { let test_data = { test : "value" , } ; { let test_file = "test_data.json" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should be created") ; let loaded = load_json (test_file) ; assert (loaded . test == "value" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpqwjaem/main.rs:1:355
  |
1 | ... { { { let test_data = { test : "value" , } ; { let test_file = "test_data.json" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should be created") ; let loaded = load_json (test_file) ; assert (loaded . test == "value" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                                            ^^
  |
help: remove these braces
  |
1 - fn test_user_creation () { { { let user = create_user ("Alice" , "alice@example.com") ; { assert (user . name == "Alice" , "Name should be set") ; assert (user . email == "alice@example.com" , "Email should be set") ; assert (user . id != null , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } fn test_data_persistence () { { { let test_data = { test : "value" , } ; { let test_file = "test_data.json" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should be created") ; let loaded = load_json (test_file) ; assert (loaded . test == "value" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
1 + fn test_user_creation () { { { let user = create_user ("Alice" , "alice@example.com") ; { assert (user . name == "Alice" , "Name should be set") ; assert (user . email == "alice@example.com" , "Email should be set") ; assert (user . id != null , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } fn test_data_persistence () { { let test_data = { test : "value" , } ; { let test_file = "test_data.json" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should be created") ; let loaded = load_json (test_file) ; assert (loaded . test == "value" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
  |

error[E0425]: cannot find function `create_user` in this scope
 --> /tmp/.tmpqwjaem/main.rs:1:43
  |
1 | fn test_user_creation () { { { let user = create_user ("Alice" , "alice@example.com") ; { assert (user . name == "Alice" , "Name should b...
  |                                           ^^^^^^^^^^^ not found in this scope

error[E0423]: expected function, found macro `assert`
 --> /tmp/.tmpqwjaem/main.rs:1:91
  |
1 | fn test_user_creation () { { { let user = create_user ("Alice" , "alice@example.com") ; { assert (user . name == "Alice" , "Name should b...
  |                                                                                           ^^^^^^ not a function
  |
help: use `!` to invoke the macro
  |
1 | fn test_user_creation () { { { let user = create_user ("Alice" , "alice@example.com") ; { assert! (user . name == "Alice" , "Name should be set") ; assert (user . email == "alice@example.com" , "Email should be set") ; assert (user . id != null , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } fn test_data_persistence () { { { let test_data = { test : "value" , } ; { let test_file = "test_data.json" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should be created") ; let loaded = load_json (test_file) ; assert (loaded . test == "value" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
  |                                                                                                 +

error[E0423]: expected function, found macro `assert`
 --> /tmp/.tmpqwjaem/main.rs:1:148
  |
1 | ...ssert (user . name == "Alice" , "Name should be set") ; assert (user . email == "alice@example.com" , "Email should be set") ; assert ...
  |                                                            ^^^^^^ not a function
  |
help: use `!` to invoke the macro
  |
1 | fn test_user_creation () { { { let user = create_user ("Alice" , "alice@example.com") ; { assert (user . name == "Alice" , "Name should be set") ; assert! (user . email == "alice@example.com" , "Email should be set") ; assert (user . id != null , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } fn test_data_persistence () { { { let test_data = { test : "value" , } ; { let test_file = "test_data.json" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should be created") ; let loaded = load_json (test_file) ; assert (loaded . test == "value" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
  |                                                                                                                                                          +

error[E0423]: expected function, found macro `assert`
 --> /tmp/.tmpqwjaem/main.rs:1:219
  |
1 | ...email == "alice@example.com" , "Email should be set") ; assert (user . id != null , "ID should be generated") ; println ! ("✅ test_user...
  |                                                            ^^^^^^ not a function
  |
help: use `!` to invoke the macro
  |
1 | fn test_user_creation () { { { let user = create_user ("Alice" , "alice@example.com") ; { assert (user . name == "Alice" , "Name should be set") ; assert (user . email == "alice@example.com" , "Email should be set") ; assert! (user . id != null , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } fn test_data_persistence () { { { let test_data = { test : "value" , } ; { let test_file = "test_data.json" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should be created") ; let loaded = load_json (test_file) ; assert (loaded . test == "value" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
  |                                                                                                                                                                                                                                 +

error[E0425]: cannot find function `save_json` in this scope
 --> /tmp/.tmpqwjaem/main.rs:1:435
  |
1 | ...value" , } ; { let test_file = "test_data.json" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should b...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpqwjaem/main.rs:1:479
  |
1 | ...n" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should be created") ; let loaded = load_json (test_fi...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0423]: expected function, found macro `assert`
 --> /tmp/.tmpqwjaem/main.rs:1:471
  |
1 | ... "test_data.json" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should be created") ; let loaded = loa...
  |                                                            ^^^^^^ not a function
  |
help: use `!` to invoke the macro
  |
1 | fn test_user_creation () { { { let user = create_user ("Alice" , "alice@example.com") ; { assert (user . name == "Alice" , "Name should be set") ; assert (user . email == "alice@example.com" , "Email should be set") ; assert (user . id != null , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } fn test_data_persistence () { { { let test_data = { test : "value" , } ; { let test_file = "test_data.json" ; save_json (test_file , test_data) ; assert! (file_exists (test_file) , "File should be created") ; let loaded = load_json (test_file) ; assert (loaded . test == "value" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              +

error[E0425]: cannot find function `load_json` in this scope
 --> /tmp/.tmpqwjaem/main.rs:1:546
  |
1 | ..._file) , "File should be created") ; let loaded = load_json (test_file) ; assert (loaded . test == "value" , "Data should persist") ; ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0423]: expected function, found macro `assert`
 --> /tmp/.tmpqwjaem/main.rs:1:570
  |
1 | ...uld be created") ; let loaded = load_json (test_file) ; assert (loaded . test == "value" , "Data should persist") ; remove_file (test_...
  |                                                            ^^^^^^ not a function
  |
help: use `!` to invoke the macro
  |
1 | fn test_user_creation () { { { let user = create_user ("Alice" , "alice@example.com") ; { assert (user . name == "Alice" , "Name should be set") ; assert (user . email == "alice@example.com" , "Email should be set") ; assert (user . id != null , "ID should be generated") ; println ! ("✅ test_user_creation passed") } } } } fn test_data_persistence () { { { let test_data = { test : "value" , } ; { let test_file = "test_data.json" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , "File should be created") ; let loaded = load_json (test_file) ; assert! (loaded . test == "value" , "Data should persist") ; remove_file (test_file) ; println ! ("✅ test_data_persistence passed") } } } } fn run_all_tests () { { println ! ("🧪 Running application tests...") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 +

error[E0425]: cannot find function `test_error_handling` in this scope
 --> /tmp/.tmpqwjaem/main.rs:1:831
  |
1 | ...ser_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn ...
  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `test_performance` in this scope
 --> /tmp/.tmpqwjaem/main.rs:1:856
  |
1 | ...data_persistence () ; test_error_handling () ; test_performance () ; println ! ("\n✅ All tests passed!") } } fn main () { }
  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 14 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0423, E0425.
For more information about an error, try `rustc --explain E0423`.



=== ch07-00-building-applications example 9 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `VERSION` in this scope
 --> /tmp/.tmptHdg0B/main.rs:1:119
  |
1 | ... ; run_tests () ; { let release_dir = "release_" + VERSION ; { create_dir_all (release_dir) ; copy_file ("main.ruchy" , join_path (rel...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find function `create_dir_all` in this scope
 --> /tmp/.tmptHdg0B/main.rs:1:131
  |
1 | ... ; { let release_dir = "release_" + VERSION ; { create_dir_all (release_dir) ; copy_file ("main.ruchy" , join_path (release_dir , APP_...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::fs::create_dir_all;
  |

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmptHdg0B/main.rs:1:213
  |
1 | ...copy_file ("main.ruchy" , join_path (release_dir , APP_NAME)) ; copy_dir ("resources" , join_path (release_dir , "resources")) ; gener...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmptHdg0B/main.rs:1:530
  |
1 | ...cho 'Installation complete! Run {} to start.'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (relea...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `VERSION` in this scope
 --> /tmp/.tmptHdg0B/main.rs:1:541
  |
1 | ...lation complete! Run {} to start.'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , "i...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmptHdg0B/main.rs:1:551
  |
1 | ...plete! Run {} to start.'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , "install.sh"...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmptHdg0B/main.rs:1:562
  |
1 | ...{} to start.'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , "install.sh") , install...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmptHdg0B/main.rs:1:573
  |
1 | ....'\n" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , "install.sh") , installer) ; creat...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmptHdg0B/main.rs:1:694
  |
1 | ...ller) ; create_archive (format ! ("{}-{}.tar.gz" , APP_NAME , VERSION) , release_dir) ; println ! ("✅ Release built: {}-{}.tar.gz" , AP...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `VERSION` in this scope
 --> /tmp/.tmptHdg0B/main.rs:1:705
  |
1 | ...ate_archive (format ! ("{}-{}.tar.gz" , APP_NAME , VERSION) , release_dir) ; println ! ("✅ Release built: {}-{}.tar.gz" , APP_NAME , VE...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `APP_NAME` in this scope
 --> /tmp/.tmptHdg0B/main.rs:1:776
  |
1 | ...ir) ; println ! ("✅ Release built: {}-{}.tar.gz" , APP_NAME , VERSION) } } } } fn main () { }
  |                                                        ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `VERSION` in this scope
 --> /tmp/.tmptHdg0B/main.rs:1:787
  |
1 | ...ln ! ("✅ Release built: {}-{}.tar.gz" , APP_NAME , VERSION) } } } } fn main () { }
  |                                                        ^^^^^^^ not found in this scope

error[E0425]: cannot find function `run_tests` in this scope
 --> /tmp/.tmptHdg0B/main.rs:1:71
  |
1 | fn build_release () { { println ! ("🔨 Building release version...") ; run_tests () ; { let release_dir = "release_" + VERSION ; { create_d...
  |                                                                        ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmptHdg0B/main.rs:1:188
  |
1 | ...dir_all (release_dir) ; copy_file ("main.ruchy" , join_path (release_dir , APP_NAME)) ; copy_dir ("resources" , join_path (release_dir...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `copy_file` in this scope
 --> /tmp/.tmptHdg0B/main.rs:1:162
  |
1 | ...se_" + VERSION ; { create_dir_all (release_dir) ; copy_file ("main.ruchy" , join_path (release_dir , APP_NAME)) ; copy_dir ("resources...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmptHdg0B/main.rs:1:250
  |
1 | ...elease_dir , APP_NAME)) ; copy_dir ("resources" , join_path (release_dir , "resources")) ; generate_docs (join_path (release_dir , "do...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `copy_dir` in this scope
 --> /tmp/.tmptHdg0B/main.rs:1:226
  |
1 | ...ain.ruchy" , join_path (release_dir , APP_NAME)) ; copy_dir ("resources" , join_path (release_dir , "resources")) ; generate_docs (joi...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmptHdg0B/main.rs:1:306
  |
1 | ...ath (release_dir , "resources")) ; generate_docs (join_path (release_dir , "docs")) ; let installer = format ! ("#!/bin/bash\necho 'In...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `generate_docs` in this scope
 --> /tmp/.tmptHdg0B/main.rs:1:291
  |
1 | ...ces" , join_path (release_dir , "resources")) ; generate_docs (join_path (release_dir , "docs")) ; let installer = format ! ("#!/bin/b...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmptHdg0B/main.rs:1:92
  |
1 | ...ase version...") ; run_tests () ; { let release_dir = "release_" + VERSION ; { create_dir_all (release_dir) ; copy_file ("main.ruchy" ...
  |                                            ^^^^^^^^^^^ doesn't have a size known at compile-time
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: all local variables must have a statically known size

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmptHdg0B/main.rs:1:597
  |
1 | ...N , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , "install.sh") , installer) ; create_archive (format ! ("{}-...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmptHdg0B/main.rs:1:585
  |
1 | ...AME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , "install.sh") , installer) ; create_archive (fo...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `create_archive` in this scope
 --> /tmp/.tmptHdg0B/main.rs:1:651
  |
1 | ...ath (release_dir , "install.sh") , installer) ; create_archive (format ! ("{}-{}.tar.gz" , APP_NAME , VERSION) , release_dir) ; printl...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 23 previous errors

Some errors have detailed explanations: E0277, E0425.
For more information about an error, try `rustc --explain E0277`.



=== ch15-00-macros-metaprogramming example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch15-00-macros-metaprogramming example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch15-00-macros-metaprogramming example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch15-00-macros-metaprogramming example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch15-00-macros-metaprogramming example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch15-00-macros-metaprogramming example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch15-00-macros-metaprogramming example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch15-00-macros-metaprogramming example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch15-00-macros-metaprogramming example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 2 ===

thread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:
"net::TcpListener" is not a valid Ident
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


=== ch09-00-network-programming example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch09-00-network-programming example 10 ===

thread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:
"net::PacketCapture" is not a valid Ident
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


=== ch08-00-systems-programming example 1 ===
✗ Compilation failed: Compilation failed:
error[E0432]: unresolved import `std::system`
 --> /tmp/.tmpdI3W5A/main.rs:1:40
  |
1 | fn main () { let result = { use std :: system :: system ; ; use std :: process :: process ; ; println ! ("=== System Monitor ===") ; let ...
  |                                        ^^^^^^ could not find `system` in `std`

error[E0432]: unresolved import `std::process::process`
 --> /tmp/.tmpdI3W5A/main.rs:1:65
  |
1 | fn main () { let result = { use std :: system :: system ; ; use std :: process :: process ; ; println ! ("=== System Monitor ===") ; let ...
  |                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^ no `process` in `process`
  |
help: consider importing one of these modules instead
  |
1 - fn main () { let result = { use std :: system :: system ; ; use std :: process :: process ; ; println ! ("=== System Monitor ===") ; let cpu_count = system :: cpu_count () ; let total_memory = system :: total_memory () ; let hostname = system :: hostname () ; let os_info = system :: os_info () ; println ! ("{}" , "Host: " + hostname) ; println ! ("{}" , "OS: " + os_info . name + " " + os_info . version) ; println ! ("{}" , "CPUs: " + cpu_count . to_s ()) ; println ! ("{}" , "Memory: " + format_size (total_memory)) ; println ! ("") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let memory_info = system :: memory_info () ; let disk_io = system :: disk_io_stats () ; let network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , "CPU: " + cpu_usage . to_s () + "% |" + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () + "|") ; let mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , "MEM: " + mem_percent . to_s () + "% |" + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () + "|") ; println ! ("{}" , "     " + format_size (memory_info . used) + " / " + format_size (memory_info . total)) ; println ! ("{}" , "Disk Read:  " + format_size (disk_io . read_bytes) + "/s") ; println ! ("{}" , "Disk Write: " + format_size (disk_io . write_bytes) + "/s") ; println ! ("{}" , "Net Down: " + format_size (network_stats . download_speed) + "/s") ; println ! ("{}" , "Net Up:   " + format_size (network_stats . upload_speed) + "/s") ; println ! ("\nTop Processes by CPU:") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , "  " + proc . pid . to_s () + " " + proc . name + " " + proc . cpu_percent . to_s () + "%") } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { use std :: system :: system ; ; use std::os::linux::process ; ; println ! ("=== System Monitor ===") ; let cpu_count = system :: cpu_count () ; let total_memory = system :: total_memory () ; let hostname = system :: hostname () ; let os_info = system :: os_info () ; println ! ("{}" , "Host: " + hostname) ; println ! ("{}" , "OS: " + os_info . name + " " + os_info . version) ; println ! ("{}" , "CPUs: " + cpu_count . to_s ()) ; println ! ("{}" , "Memory: " + format_size (total_memory)) ; println ! ("") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let memory_info = system :: memory_info () ; let disk_io = system :: disk_io_stats () ; let network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , "CPU: " + cpu_usage . to_s () + "% |" + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () + "|") ; let mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , "MEM: " + mem_percent . to_s () + "% |" + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () + "|") ; println ! ("{}" , "     " + format_size (memory_info . used) + " / " + format_size (memory_info . total)) ; println ! ("{}" , "Disk Read:  " + format_size (disk_io . read_bytes) + "/s") ; println ! ("{}" , "Disk Write: " + format_size (disk_io . write_bytes) + "/s") ; println ! ("{}" , "Net Down: " + format_size (network_stats . download_speed) + "/s") ; println ! ("{}" , "Net Up:   " + format_size (network_stats . upload_speed) + "/s") ; println ! ("\nTop Processes by CPU:") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , "  " + proc . pid . to_s () + " " + proc . name + " " + proc . cpu_percent . to_s () + "%") } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |
1 - fn main () { let result = { use std :: system :: system ; ; use std :: process :: process ; ; println ! ("=== System Monitor ===") ; let cpu_count = system :: cpu_count () ; let total_memory = system :: total_memory () ; let hostname = system :: hostname () ; let os_info = system :: os_info () ; println ! ("{}" , "Host: " + hostname) ; println ! ("{}" , "OS: " + os_info . name + " " + os_info . version) ; println ! ("{}" , "CPUs: " + cpu_count . to_s ()) ; println ! ("{}" , "Memory: " + format_size (total_memory)) ; println ! ("") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let memory_info = system :: memory_info () ; let disk_io = system :: disk_io_stats () ; let network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , "CPU: " + cpu_usage . to_s () + "% |" + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () + "|") ; let mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , "MEM: " + mem_percent . to_s () + "% |" + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () + "|") ; println ! ("{}" , "     " + format_size (memory_info . used) + " / " + format_size (memory_info . total)) ; println ! ("{}" , "Disk Read:  " + format_size (disk_io . read_bytes) + "/s") ; println ! ("{}" , "Disk Write: " + format_size (disk_io . write_bytes) + "/s") ; println ! ("{}" , "Net Down: " + format_size (network_stats . download_speed) + "/s") ; println ! ("{}" , "Net Up:   " + format_size (network_stats . upload_speed) + "/s") ; println ! ("\nTop Processes by CPU:") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , "  " + proc . pid . to_s () + " " + proc . name + " " + proc . cpu_percent . to_s () + "%") } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { use std :: system :: system ; ; use std::os::unix::process ; ; println ! ("=== System Monitor ===") ; let cpu_count = system :: cpu_count () ; let total_memory = system :: total_memory () ; let hostname = system :: hostname () ; let os_info = system :: os_info () ; println ! ("{}" , "Host: " + hostname) ; println ! ("{}" , "OS: " + os_info . name + " " + os_info . version) ; println ! ("{}" , "CPUs: " + cpu_count . to_s ()) ; println ! ("{}" , "Memory: " + format_size (total_memory)) ; println ! ("") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let memory_info = system :: memory_info () ; let disk_io = system :: disk_io_stats () ; let network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , "CPU: " + cpu_usage . to_s () + "% |" + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () + "|") ; let mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , "MEM: " + mem_percent . to_s () + "% |" + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () + "|") ; println ! ("{}" , "     " + format_size (memory_info . used) + " / " + format_size (memory_info . total)) ; println ! ("{}" , "Disk Read:  " + format_size (disk_io . read_bytes) + "/s") ; println ! ("{}" , "Disk Write: " + format_size (disk_io . write_bytes) + "/s") ; println ! ("{}" , "Net Down: " + format_size (network_stats . download_speed) + "/s") ; println ! ("{}" , "Net Up:   " + format_size (network_stats . upload_speed) + "/s") ; println ! ("\nTop Processes by CPU:") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , "  " + proc . pid . to_s () + " " + proc . name + " " + proc . cpu_percent . to_s () + "%") } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |
1 - fn main () { let result = { use std :: system :: system ; ; use std :: process :: process ; ; println ! ("=== System Monitor ===") ; let cpu_count = system :: cpu_count () ; let total_memory = system :: total_memory () ; let hostname = system :: hostname () ; let os_info = system :: os_info () ; println ! ("{}" , "Host: " + hostname) ; println ! ("{}" , "OS: " + os_info . name + " " + os_info . version) ; println ! ("{}" , "CPUs: " + cpu_count . to_s ()) ; println ! ("{}" , "Memory: " + format_size (total_memory)) ; println ! ("") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let memory_info = system :: memory_info () ; let disk_io = system :: disk_io_stats () ; let network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , "CPU: " + cpu_usage . to_s () + "% |" + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () + "|") ; let mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , "MEM: " + mem_percent . to_s () + "% |" + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () + "|") ; println ! ("{}" , "     " + format_size (memory_info . used) + " / " + format_size (memory_info . total)) ; println ! ("{}" , "Disk Read:  " + format_size (disk_io . read_bytes) + "/s") ; println ! ("{}" , "Disk Write: " + format_size (disk_io . write_bytes) + "/s") ; println ! ("{}" , "Net Down: " + format_size (network_stats . download_speed) + "/s") ; println ! ("{}" , "Net Up:   " + format_size (network_stats . upload_speed) + "/s") ; println ! ("\nTop Processes by CPU:") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , "  " + proc . pid . to_s () + " " + proc . name + " " + proc . cpu_percent . to_s () + "%") } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { use std :: system :: system ; ; use std::process ; ; println ! ("=== System Monitor ===") ; let cpu_count = system :: cpu_count () ; let total_memory = system :: total_memory () ; let hostname = system :: hostname () ; let os_info = system :: os_info () ; println ! ("{}" , "Host: " + hostname) ; println ! ("{}" , "OS: " + os_info . name + " " + os_info . version) ; println ! ("{}" , "CPUs: " + cpu_count . to_s ()) ; println ! ("{}" , "Memory: " + format_size (total_memory)) ; println ! ("") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let memory_info = system :: memory_info () ; let disk_io = system :: disk_io_stats () ; let network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , "CPU: " + cpu_usage . to_s () + "% |" + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () + "|") ; let mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , "MEM: " + mem_percent . to_s () + "% |" + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () + "|") ; println ! ("{}" , "     " + format_size (memory_info . used) + " / " + format_size (memory_info . total)) ; println ! ("{}" , "Disk Read:  " + format_size (disk_io . read_bytes) + "/s") ; println ! ("{}" , "Disk Write: " + format_size (disk_io . write_bytes) + "/s") ; println ! ("{}" , "Net Down: " + format_size (network_stats . download_speed) + "/s") ; println ! ("{}" , "Net Up:   " + format_size (network_stats . upload_speed) + "/s") ; println ! ("\nTop Processes by CPU:") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , "  " + proc . pid . to_s () + " " + proc . name + " " + proc . cpu_percent . to_s () + "%") } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `sleep` in this scope
 --> /tmp/.tmpdI3W5A/main.rs:1:1905
  |
1 | ...e + " " + proc . cpu_percent . to_s () + "%") } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::sleep;
  |

warning: unnecessary trailing semicolon
 --> /tmp/.tmpdI3W5A/main.rs:1:59
  |
1 | fn main () { let result = { use std :: system :: system ; ; use std :: process :: process ; ; println ! ("=== System Monitor ===") ; let ...
  |                                                           ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary trailing semicolon
 --> /tmp/.tmpdI3W5A/main.rs:1:93
  |
1 | fn main () { let result = { use std :: system :: system ; ; use std :: process :: process ; ; println ! ("=== System Monitor ===") ; let ...
  |                                                                                             ^ help: remove this semicolon

warning: unnecessary braces around block return value
 --> /tmp/.tmpdI3W5A/main.rs:1:547
  |
1 | ... { { { let cpu_usage = system :: cpu_usage () ; { let memory_info = system :: memory_info () ; let disk_io = system :: disk_io_stats () ; let network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , "CPU: " + cpu_usage . to_s () + "% |" + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () + "|") ; let mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , "MEM: " + mem_percent . to_s () + "% |" + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () + "|") ; println ! ("{}" , "     " + format_size (memory_info . used) + " / " + format_size (memory_info . total)) ; println ! ("{}" , "Disk Read:  " + format_size (disk_io . read_bytes) + "/s") ; println ! ("{}" , "Disk Write: " + format_size (disk_io . write_bytes) + "/s") ; println ! ("{}" , "Net Down: " + format_size (network_stats . download_speed) + "/s") ; println ! ("{}" , "Net Up:   " + format_size (network_stats . upload_speed) + "/s") ; println ! ("\nTop Processes by CPU:") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , "  " + proc . pid . to_s () + " " + proc . name + " " + proc . cpu_percent . to_s () + "%") } } ; sleep (1000i32) } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { let result = { use std :: system :: system ; ; use std :: process :: process ; ; println ! ("=== System Monitor ===") ; let cpu_count = system :: cpu_count () ; let total_memory = system :: total_memory () ; let hostname = system :: hostname () ; let os_info = system :: os_info () ; println ! ("{}" , "Host: " + hostname) ; println ! ("{}" , "OS: " + os_info . name + " " + os_info . version) ; println ! ("{}" , "CPUs: " + cpu_count . to_s ()) ; println ! ("{}" , "Memory: " + format_size (total_memory)) ; println ! ("") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let memory_info = system :: memory_info () ; let disk_io = system :: disk_io_stats () ; let network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , "CPU: " + cpu_usage . to_s () + "% |" + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () + "|") ; let mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , "MEM: " + mem_percent . to_s () + "% |" + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () + "|") ; println ! ("{}" , "     " + format_size (memory_info . used) + " / " + format_size (memory_info . total)) ; println ! ("{}" , "Disk Read:  " + format_size (disk_io . read_bytes) + "/s") ; println ! ("{}" , "Disk Write: " + format_size (disk_io . write_bytes) + "/s") ; println ! ("{}" , "Net Down: " + format_size (network_stats . download_speed) + "/s") ; println ! ("{}" , "Net Up:   " + format_size (network_stats . upload_speed) + "/s") ; println ! ("\nTop Processes by CPU:") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , "  " + proc . pid . to_s () + " " + proc . name + " " + proc . cpu_percent . to_s () + "%") } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { use std :: system :: system ; ; use std :: process :: process ; ; println ! ("=== System Monitor ===") ; let cpu_count = system :: cpu_count () ; let total_memory = system :: total_memory () ; let hostname = system :: hostname () ; let os_info = system :: os_info () ; println ! ("{}" , "Host: " + hostname) ; println ! ("{}" , "OS: " + os_info . name + " " + os_info . version) ; println ! ("{}" , "CPUs: " + cpu_count . to_s ()) ; println ! ("{}" , "Memory: " + format_size (total_memory)) ; println ! ("") ; loop { { let cpu_usage = system :: cpu_usage () ; { let memory_info = system :: memory_info () ; let disk_io = system :: disk_io_stats () ; let network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , "CPU: " + cpu_usage . to_s () + "% |" + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () + "|") ; let mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , "MEM: " + mem_percent . to_s () + "% |" + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () + "|") ; println ! ("{}" , "     " + format_size (memory_info . used) + " / " + format_size (memory_info . total)) ; println ! ("{}" , "Disk Read:  " + format_size (disk_io . read_bytes) + "/s") ; println ! ("{}" , "Disk Write: " + format_size (disk_io . write_bytes) + "/s") ; println ! ("{}" , "Net Down: " + format_size (network_stats . download_speed) + "/s") ; println ! ("{}" , "Net Up:   " + format_size (network_stats . upload_speed) + "/s") ; println ! ("\nTop Processes by CPU:") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , "  " + proc . pid . to_s () + " " + proc . name + " " + proc . cpu_percent . to_s () + "%") } } ; sleep (1000i32) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpdI3W5A/main.rs:1:1787
  |
1 | ...ocesses { { println ! ("{}" , "  " + proc . pid . to_s () + " " + proc . name + " " + proc . cpu_percent . to_s () + "%") } } ; sleep ...
  |              ^^                                                                                                             ^^
  |
help: remove these braces
  |
1 - fn main () { let result = { use std :: system :: system ; ; use std :: process :: process ; ; println ! ("=== System Monitor ===") ; let cpu_count = system :: cpu_count () ; let total_memory = system :: total_memory () ; let hostname = system :: hostname () ; let os_info = system :: os_info () ; println ! ("{}" , "Host: " + hostname) ; println ! ("{}" , "OS: " + os_info . name + " " + os_info . version) ; println ! ("{}" , "CPUs: " + cpu_count . to_s ()) ; println ! ("{}" , "Memory: " + format_size (total_memory)) ; println ! ("") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let memory_info = system :: memory_info () ; let disk_io = system :: disk_io_stats () ; let network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , "CPU: " + cpu_usage . to_s () + "% |" + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () + "|") ; let mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , "MEM: " + mem_percent . to_s () + "% |" + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () + "|") ; println ! ("{}" , "     " + format_size (memory_info . used) + " / " + format_size (memory_info . total)) ; println ! ("{}" , "Disk Read:  " + format_size (disk_io . read_bytes) + "/s") ; println ! ("{}" , "Disk Write: " + format_size (disk_io . write_bytes) + "/s") ; println ! ("{}" , "Net Down: " + format_size (network_stats . download_speed) + "/s") ; println ! ("{}" , "Net Up:   " + format_size (network_stats . upload_speed) + "/s") ; println ! ("\nTop Processes by CPU:") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , "  " + proc . pid . to_s () + " " + proc . name + " " + proc . cpu_percent . to_s () + "%") } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { use std :: system :: system ; ; use std :: process :: process ; ; println ! ("=== System Monitor ===") ; let cpu_count = system :: cpu_count () ; let total_memory = system :: total_memory () ; let hostname = system :: hostname () ; let os_info = system :: os_info () ; println ! ("{}" , "Host: " + hostname) ; println ! ("{}" , "OS: " + os_info . name + " " + os_info . version) ; println ! ("{}" , "CPUs: " + cpu_count . to_s ()) ; println ! ("{}" , "Memory: " + format_size (total_memory)) ; println ! ("") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let memory_info = system :: memory_info () ; let disk_io = system :: disk_io_stats () ; let network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , "CPU: " + cpu_usage . to_s () + "% |" + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () + "|") ; let mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , "MEM: " + mem_percent . to_s () + "% |" + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () + "|") ; println ! ("{}" , "     " + format_size (memory_info . used) + " / " + format_size (memory_info . total)) ; println ! ("{}" , "Disk Read:  " + format_size (disk_io . read_bytes) + "/s") ; println ! ("{}" , "Disk Write: " + format_size (disk_io . write_bytes) + "/s") ; println ! ("{}" , "Net Down: " + format_size (network_stats . download_speed) + "/s") ; println ! ("{}" , "Net Up:   " + format_size (network_stats . upload_speed) + "/s") ; println ! ("\nTop Processes by CPU:") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { println ! ("{}" , "  " + proc . pid . to_s () + " " + proc . name + " " + proc . cpu_percent . to_s () + "%") } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpdI3W5A/main.rs:1:316
  |
1 | ...stem :: os_info () ; println ! ("{}" , "Host: " + hostname) ; println ! ("{}" , "OS: " + os_info . name + " " + os_info . version) ; p...
  |                                     --    ^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                                     |
  |                                     required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpdI3W5A/main.rs:1:381
  |
1 | ... ("{}" , "Host: " + hostname) ; println ! ("{}" , "OS: " + os_info . name + " " + os_info . version) ; println ! ("{}" , "CPUs: " + cp...
  |                                                      ----------------------- ^ --- &str
  |                                                      |
  |                                                      str

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpdI3W5A/main.rs:1:428
  |
1 | ...fo . version) ; println ! ("{}" , "CPUs: " + cpu_count . to_s ()) ; println ! ("{}" , "Memory: " + format_size (total_memory)) ; print...
  |                                --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                                |
  |                                required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpdI3W5A/main.rs:1:493
  |
1 | ...ount . to_s ()) ; println ! ("{}" , "Memory: " + format_size (total_memory)) ; println ! ("") ; loop { { { let cpu_usage = system :: c...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpdI3W5A/main.rs:1:480
  |
1 | ...to_s ()) ; println ! ("{}" , "Memory: " + format_size (total_memory)) ; println ! ("") ; loop { { { let cpu_usage = system :: cpu_usag...
  |                           --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                           |
  |                           required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `clear_screen` in this scope
 --> /tmp/.tmpdI3W5A/main.rs:1:731
  |
1 | ...let network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmpdI3W5A/main.rs:1:825
  |
1 | ...ystem Monitor - Press Ctrl+C to exit") ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , "CPU: " + cpu_usage . to_s () + "% |" + "█...
  |                                                               --- ^ ----- i32
  |                                                               |
  |                                                               &str

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpdI3W5A/main.rs:1:884
  |
1 | ...ln ! ("{}" , "=" * 50i32) ; println ! ("{}" , "CPU: " + cpu_usage . to_s () + "% |" + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 ...
  |                                                  ----------------------------- ^ ----- &str
  |                                                  |
  |                                                  str

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmpdI3W5A/main.rs:1:920
  |
1 | ...usage . to_s () + "% |" + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () + "|") ; let mem_percent = mem...
  |                                                        ^^^^ method not found in `i32`

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpdI3W5A/main.rs:1:892
  |
1 | ..."{}" , "CPU: " + cpu_usage . to_s () + "% |" + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () + "|") ; ...
  |                                                 ^ doesn't have a size known at compile-time
  |
  = help: the trait `Sized` is not implemented for `str`

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmpdI3W5A/main.rs:1:934
  |
1 | ...ge . to_s () + "% |" + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () + "|") ; let mem_percent = memory...
  |                                                               --- ^ ----- i32
  |                                                               |
  |                                                               &str

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmpdI3W5A/main.rs:1:964
  |
1 | ...50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () + "|") ; let mem_percent = memory_info . used / memory_info . total ; prin...
  |                                                        ^^^^ method not found in `i32`

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpdI3W5A/main.rs:1:1092
  |
1 | ...ed / memory_info . total ; println ! ("{}" , "MEM: " + mem_percent . to_s () + "% |" + "█" * mem_percent * 50i32 . to_i () + "░" * 50i...
  |                                                 ------------------------------- ^ ----- &str
  |                                                 |
  |                                                 str

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmpdI3W5A/main.rs:1:1130
  |
1 | ...ent . to_s () + "% |" + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () + "|") ; println ! ("{}" , "...
  |                                                        ^^^^ method not found in `i32`

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpdI3W5A/main.rs:1:1100
  |
1 | ...}" , "MEM: " + mem_percent . to_s () + "% |" + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () + "|"...
  |                                                 ^ doesn't have a size known at compile-time
  |
  = help: the trait `Sized` is not implemented for `str`

error[E0369]: cannot multiply `&str` by `i32`
 --> /tmp/.tmpdI3W5A/main.rs:1:1144
  |
1 | ... . to_s () + "% |" + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () + "|") ; println ! ("{}" , "   ...
  |                                                               --- ^ ----- i32
  |                                                               |
  |                                                               &str

error[E0599]: no method named `to_i` found for type `i32` in the current scope
 --> /tmp/.tmpdI3W5A/main.rs:1:1176
  |
1 | ...i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () + "|") ; println ! ("{}" , "     " + format_size (memory_info . used) + " ...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpdI3W5A/main.rs:1:1221
  |
1 | ...2 . to_i () + "|") ; println ! ("{}" , "     " + format_size (memory_info . used) + " / " + format_size (memory_info . total)) ; print...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpdI3W5A/main.rs:1:1254
  |
1 | ...2 . to_i () + "|") ; println ! ("{}" , "     " + format_size (memory_info . used) + " / " + format_size (memory_info . total)) ; print...
  |                                           ------------------------------------------ ^ ----- &str
  |                                           |
  |                                           str

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpdI3W5A/main.rs:1:1264
  |
1 | ...  " + format_size (memory_info . used) + " / " + format_size (memory_info . total)) ; println ! ("{}" , "Disk Read:  " + format_size (...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpdI3W5A/main.rs:1:1336
  |
1 | ...o . total)) ; println ! ("{}" , "Disk Read:  " + format_size (disk_io . read_bytes) + "/s") ; println ! ("{}" , "Disk Write: " + forma...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpdI3W5A/main.rs:1:1371
  |
1 | ...info . total)) ; println ! ("{}" , "Disk Read:  " + format_size (disk_io . read_bytes) + "/s") ; println ! ("{}" , "Disk Write: " + fo...
  |                                       --------------------------------------------------- ^ ---- &str
  |                                       |
  |                                       str

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpdI3W5A/main.rs:1:1416
  |
1 | ...es) + "/s") ; println ! ("{}" , "Disk Write: " + format_size (disk_io . write_bytes) + "/s") ; println ! ("{}" , "Net Down: " + format...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpdI3W5A/main.rs:1:1452
  |
1 | ...bytes) + "/s") ; println ! ("{}" , "Disk Write: " + format_size (disk_io . write_bytes) + "/s") ; println ! ("{}" , "Net Down: " + for...
  |                                       ---------------------------------------------------- ^ ---- &str
  |                                       |
  |                                       str

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpdI3W5A/main.rs:1:1495
  |
1 | ...ytes) + "/s") ; println ! ("{}" , "Net Down: " + format_size (network_stats . download_speed) + "/s") ; println ! ("{}" , "Net Up:   "...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpdI3W5A/main.rs:1:1540
  |
1 | ...s) + "/s") ; println ! ("{}" , "Net Down: " + format_size (network_stats . download_speed) + "/s") ; println ! ("{}" , "Net Up:   " + ...
  |                                   ----------------------------------------------------------- ^ ---- &str
  |                                   |
  |                                   str

error[E0425]: cannot find function `format_size` in this scope
 --> /tmp/.tmpdI3W5A/main.rs:1:1583
  |
1 | ...peed) + "/s") ; println ! ("{}" , "Net Up:   " + format_size (network_stats . upload_speed) + "/s") ; println ! ("\nTop Processes by C...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpdI3W5A/main.rs:1:1626
  |
1 | ...ed) + "/s") ; println ! ("{}" , "Net Up:   " + format_size (network_stats . upload_speed) + "/s") ; println ! ("\nTop Processes by CPU...
  |                                    --------------------------------------------------------- ^ ---- &str
  |                                    |
  |                                    str

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpdI3W5A/main.rs:1:1835
  |
1 | ...) ; for proc in processes { { println ! ("{}" , "  " + proc . pid . to_s () + " " + proc . name + " " + proc . cpu_percent . to_s () +...
  |                                                    --------------------------- ^ --- &str
  |                                                    |
  |                                                    str

warning: unreachable expression
 --> /tmp/.tmpdI3W5A/main.rs:1:1933
  |
1 | ... ; loop { { { let cpu_usage = system :: cpu_usage () ; { let memory_info = system :: memory_info () ; let disk_io = system :: disk_io_stats () ; let network_stats = system :: network_stats () ; clear_screen () ; println ! ("System Monitor - Press Ctrl+C to exit") ; println ! ("{}" , "=" * 50i32) ; println ! ("{}" , "CPU: " + cpu_usage . to_s () + "% |" + "█" * cpu_usage * 50i32 . to_i () + "░" * 50i32 - cpu_usage * 50i32 . to_i () + "|") ; let mem_percent = memory_info . used / memory_info . total ; println ! ("{}" , "MEM: " + mem_percent . to_s () + "% |" + "█" * mem_percent * 50i32 . to_i () + "░" * 50i32 - mem_percent * 50i32 . to_i () + "|") ; println ! ("{}" , "     " + format_size (memory_info . used) + " / " + format_size (memory_info . total)) ; println ! ("{}" , "Disk Read:  " + format_size (disk_io . read_bytes) + "/s") ; println ! ("{}" , "Disk Write: " + format_size (disk_io . write_bytes) + "/s") ; println ! ("{}" , "Net Down: " + format_size (network_stats . download_speed) + "/s") ; println ! ("{}" , "Net Up:   " + format_size (network_stats . upload_speed) + "/s") ; println ! ("\nTop Processes by CPU:") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! ("{}" , "  " + proc . pid . to_s () + " " + proc . name + " " + proc . cpu_percent . to_s () + "%") } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |       --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression
  |       |
  |       any code following this expression is unreachable
  |
  = note: `#[warn(unreachable_code)]` on by default

error: aborting due to 32 previous errors; 5 warnings emitted

Some errors have detailed explanations: E0277, E0369, E0425, E0432, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch08-00-systems-programming example 2 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmp9ce0np/main.rs:1:291
  |
1 | ... { { println ! ("{}" , "PID: " + proc . pid . to_s () + ", Name: " + proc . name + ", CPU: " + proc . cpu_percent . to_s () + "%") } } ...
  |       ^^                                                                                                                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { let result = { let pid = process :: current_pid () ; let ppid = process :: parent_pid () ; let exe_path = process :: executable_path () ; let args = process :: args () ; let env = process :: environment () ; let all_processes = process :: list () ; for proc in all_processes { { println ! ("{}" , "PID: " + proc . pid . to_s () + ", Name: " + proc . name + ", CPU: " + proc . cpu_percent . to_s () + "%") } } ; let chrome_procs = process :: find_by_name ("chrome") ; let high_cpu_procs = process :: list () . filter (| p | p . cpu_percent > 50i32) ; let proc = process :: from_pid (1234i32) ; proc . suspend () ; proc . resume () ; proc . terminate () ; proc . kill () ; let child = process :: spawn ("ls" , vec ! ["-la"]) ; let output = child . wait_with_output () ; println ! ("{}" , output . stdout) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { let pid = process :: current_pid () ; let ppid = process :: parent_pid () ; let exe_path = process :: executable_path () ; let args = process :: args () ; let env = process :: environment () ; let all_processes = process :: list () ; for proc in all_processes { println ! ("{}" , "PID: " + proc . pid . to_s () + ", Name: " + proc . name + ", CPU: " + proc . cpu_percent . to_s () + "%") } ; let chrome_procs = process :: find_by_name ("chrome") ; let high_cpu_procs = process :: list () . filter (| p | p . cpu_percent > 50i32) ; let proc = process :: from_pid (1234i32) ; proc . suspend () ; proc . resume () ; proc . terminate () ; proc . kill () ; let child = process :: spawn ("ls" , vec ! ["-la"]) ; let output = child . wait_with_output () ; println ! ("{}" , output . stdout) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmp9ce0np/main.rs:1:39
  |
1 | fn main () { let result = { let pid = process :: current_pid () ; let ppid = process :: parent_pid () ; let exe_path = process :: executa...
  |                                       ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmp9ce0np/main.rs:1:78
  |
1 | ...ocess :: current_pid () ; let ppid = process :: parent_pid () ; let exe_path = process :: executable_path () ; let args = process :: a...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmp9ce0np/main.rs:1:120
  |
1 | ...ss :: parent_pid () ; let exe_path = process :: executable_path () ; let args = process :: args () ; let env = process :: environment ...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmp9ce0np/main.rs:1:163
  |
1 | ...s :: executable_path () ; let args = process :: args () ; let env = process :: environment () ; let all_processes = process :: list ()...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmp9ce0np/main.rs:1:194
  |
1 | ...rgs = process :: args () ; let env = process :: environment () ; let all_processes = process :: list () ; for proc in all_processes { ...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmp9ce0np/main.rs:1:242
  |
1 | ...environment () ; let all_processes = process :: list () ; for proc in all_processes { { println ! ("{}" , "PID: " + proc . pid . to_s ...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmp9ce0np/main.rs:1:342
  |
1 | ...roc in all_processes { { println ! ("{}" , "PID: " + proc . pid . to_s () + ", Name: " + proc . name + ", CPU: " + proc . cpu_percent ...
  |                                               ------------------------------ ^ ---------- &str
  |                                               |
  |                                               str

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmp9ce0np/main.rs:1:444
  |
1 | ...s () + "%") } } ; let chrome_procs = process :: find_by_name ("chrome") ; let high_cpu_procs = process :: list () . filter (| p | p . ...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmp9ce0np/main.rs:1:502
  |
1 | ...me ("chrome") ; let high_cpu_procs = process :: list () . filter (| p | p . cpu_percent > 50i32) ; let proc = process :: from_pid (123...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmp9ce0np/main.rs:1:575
  |
1 | ... . cpu_percent > 50i32) ; let proc = process :: from_pid (1234i32) ; proc . suspend () ; proc . resume () ; proc . terminate () ; proc...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`
 --> /tmp/.tmp9ce0np/main.rs:1:697
  |
1 | ...te () ; proc . kill () ; let child = process :: spawn ("ls" , vec ! ["-la"]) ; let output = child . wait_with_output () ; println ! ("...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`
  |
  = help: you might be missing a crate named `process`

error: aborting due to 11 previous errors; 1 warning emitted

Some errors have detailed explanations: E0369, E0433.
For more information about an error, try `rustc --explain E0369`.



=== ch08-00-systems-programming example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-systems-programming example 4 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpCyddNo/main.rs:1:820
  |
1 | ... data = shared . read (0i32 , 1024i32) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0425]: cannot find value `_000_000` in this scope
 --> /tmp/.tmpCyddNo/main.rs:1:418
  |
1 | ...ed . to_s ()) ; if mem_info . available < 100i32 { _000_000 } ; { println ! ("WARNING: Low memory!") ; free_caches () } ; let mmap = m...
  |                                                       ^^^^^^^^ not found in this scope

error[E0425]: cannot find value `READ_ONLY` in this scope
 --> /tmp/.tmpCyddNo/main.rs:1:541
  |
1 | ...t mmap = memory :: map_file ("huge_dataset.bin" , READ_ONLY) ; let data = mmap . read_range (0i32 , 1000000i32) ; mmap . close () ; le...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `system`
 --> /tmp/.tmpCyddNo/main.rs:1:44
  |
1 | fn main () { let result = { let mem_info = system :: memory_info () ; println ! ("{}" , "Total: " + mem_info . total . to_s ()) ; println...
  |                                            ^^^^^^ use of unresolved module or unlinked crate `system`
  |
  = help: you might be missing a crate named `system`

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpCyddNo/main.rs:1:89
  |
1 | ...y_info () ; println ! ("{}" , "Total: " + mem_info . total . to_s ()) ; println ! ("{}" , "Used: " + mem_info . used . to_s ()) ; prin...
  |                            --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                            |
  |                            required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpCyddNo/main.rs:1:149
  |
1 | .... to_s ()) ; println ! ("{}" , "Used: " + mem_info . used . to_s ()) ; println ! ("{}" , "Free: " + mem_info . free . to_s ()) ; print...
  |                             --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                             |
  |                             required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpCyddNo/main.rs:1:207
  |
1 | .... to_s ()) ; println ! ("{}" , "Free: " + mem_info . free . to_s ()) ; println ! ("{}" , "Available: " + mem_info . available . to_s (...
  |                             --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                             |
  |                             required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpCyddNo/main.rs:1:265
  |
1 | ...s ()) ; println ! ("{}" , "Available: " + mem_info . available . to_s ()) ; println ! ("{}" , "Swap Used: " + mem_info . swap_used . t...
  |                        --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                        |
  |                        required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpCyddNo/main.rs:1:333
  |
1 | ...s ()) ; println ! ("{}" , "Swap Used: " + mem_info . swap_used . to_s ()) ; if mem_info . available < 100i32 { _000_000 } ; { println ...
  |                        --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                        |
  |                        required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `free_caches` in this scope
 --> /tmp/.tmpCyddNo/main.rs:1:470
  |
1 | ...0_000 } ; { println ! ("WARNING: Low memory!") ; free_caches () } ; let mmap = memory :: map_file ("huge_dataset.bin" , READ_ONLY) ; l...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `memory`
 --> /tmp/.tmpCyddNo/main.rs:1:500
  |
1 | ...ry!") ; free_caches () } ; let mmap = memory :: map_file ("huge_dataset.bin" , READ_ONLY) ; let data = mmap . read_range (0i32 , 10000...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `memory`
  |
  = help: you might be missing a crate named `memory`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `memory`
 --> /tmp/.tmpCyddNo/main.rs:1:636
  |
1 | ...i32) ; mmap . close () ; let shared = memory :: create_shared ("my_buffer" , 1024i32 * 1024i32) ; shared . write (0i32 , data) ; let s...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `memory`
  |
  = help: you might be missing a crate named `memory`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `memory`
 --> /tmp/.tmpCyddNo/main.rs:1:740
  |
1 | ... . write (0i32 , data) ; let shared = memory :: open_shared ("my_buffer") ; let data = shared . read (0i32 , 1024i32) } ; if let Some ...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `memory`
  |
  = help: you might be missing a crate named `memory`

error: aborting due to 13 previous errors

Some errors have detailed explanations: E0277, E0425, E0433.
For more information about an error, try `rustc --explain E0277`.



=== ch08-00-systems-programming example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-systems-programming example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-systems-programming example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch08-00-systems-programming example 8 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `RECURSIVE` in this scope
 --> /tmp/.tmppbtLCM/main.rs:1:75
  |
1 | fn main () { let result = { let watcher = fs :: watch ("/path/to/watch" , RECURSIVE) ; watcher . on ("created" , | path | { println ! ("{...
  |                                                                           ^^^^^^^^^ not found in this scope

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`
 --> /tmp/.tmppbtLCM/main.rs:1:43
  |
1 | fn main () { let result = { let watcher = fs :: watch ("/path/to/watch" , RECURSIVE) ; watcher . on ("created" , | path | { println ! ("{...
  |                                           ^^ use of unresolved module or unlinked crate `fs`
  |
  = help: you might be missing a crate named `fs`

error[E0369]: cannot add `_` to `&str`
 --> /tmp/.tmppbtLCM/main.rs:1:160
  |
1 | ...atcher . on ("created" , | path | { println ! ("{}" , "File created: " + path) }) ; watcher . on ("modified" , | path | { println ! ("...
  |                                                          ---------------- ^ ---- _
  |                                                          |
  |                                                          &str

error[E0369]: cannot add `_` to `&str`
 --> /tmp/.tmppbtLCM/main.rs:1:247
  |
1 | ...tcher . on ("modified" , | path | { println ! ("{}" , "File modified: " + path) ; process_change (path) }) ; watcher . on ("deleted" ,...
  |                                                          ----------------- ^ ---- _
  |                                                          |
  |                                                          &str

error[E0425]: cannot find function `process_change` in this scope
 --> /tmp/.tmppbtLCM/main.rs:1:257
  |
1 | ...{ println ! ("{}" , "File modified: " + path) ; process_change (path) }) ; watcher . on ("deleted" , | path | { println ! ("{}" , "Fil...
  |                                                    ^^^^^^^^^^^^^^ not found in this scope

error[E0369]: cannot add `_` to `&str`
 --> /tmp/.tmppbtLCM/main.rs:1:356
  |
1 | ...atcher . on ("deleted" , | path | { println ! ("{}" , "File deleted: " + path) }) ; watcher . start () } ; if let Some (s) = (& result...
  |                                                          ---------------- ^ ---- _
  |                                                          |
  |                                                          &str

error: aborting due to 6 previous errors

Some errors have detailed explanations: E0369, E0425, E0433.
For more information about an error, try `rustc --explain E0369`.



=== ch08-00-systems-programming example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch13-00-error-handling example 12 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch03-01-testing-functions example 1 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch03-01-testing-functions example 2 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch03-01-testing-functions example 3 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch03-01-testing-functions example 4 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch03-01-testing-functions example 5 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch03-01-testing-functions example 6 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch03-01-testing-functions example 7 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch03-01-testing-functions example 8 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch03-01-testing-functions example 9 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch03-01-testing-functions example 10 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch03-01-testing-functions example 11 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch03-01-testing-functions example 12 ===
✗ Compilation failed: Failed to transpile to Rust


=== ch16-00-testing-quality example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch16-00-testing-quality example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 2 ===
✗ Compilation failed: Compilation failed:
error: expected one of `async`, `|`, or `||`, found `;`
 --> /tmp/.tmpNfThxF/main.rs:1:209
  |
1 | ...i32 , 2i32 , 3i32] ; let handle = spawn ; move ; { { let sum = data . sum () ; println ! ("{}" , "Sum: " + sum . to_s ()) } } ; let ha...
  |                                                   ^ expected one of `async`, `|`, or `||`

error[E0425]: cannot find value `spawn` in this scope
 --> /tmp/.tmpNfThxF/main.rs:1:42
  |
1 | fn main () { let result = { let handle = spawn ; { println ! ("Running in parallel!") ; compute_result () } ; let result = handle . join ...
  |                                          ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::spawn;
  |

error[E0425]: cannot find value `spawn` in this scope
 --> /tmp/.tmpNfThxF/main.rs:1:196
  |
1 | ...et data = vec ! [1i32 , 2i32 , 3i32] ; let handle = spawn ; move ; { { let sum = data . sum () ; println ! ("{}" , "Sum: " + sum . to_...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::spawn;
  |

error[E0425]: cannot find function `compute_result` in this scope
 --> /tmp/.tmpNfThxF/main.rs:1:89
  |
1 | fn main () { let result = { let handle = spawn ; { println ! ("Running in parallel!") ; compute_result () } ; let result = handle . join ...
  |                                                                                         ^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 4 previous errors

For more information about this error, try `rustc --explain E0425`.



=== ch14-00-concurrency example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 12 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch14-00-concurrency example 13 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch04-00-command-line-tools example 1 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpLs3ffc/main.rs:1:109
  |
1 | ...l") ; print ! ("Enter filename: ") ; let filename = input () ; let content = read_file (filename) ; let words = content . split_whites...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpLs3ffc/main.rs:1:134
  |
1 | ...ame: ") ; let filename = input () ; let content = read_file (filename) ; let words = content . split_whitespace () ; let word_count = ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpLs3ffc/main.rs:1:336
  |
1 | ...s () . len () ; println ! ("{}" , "\nFile Analysis: " + filename) ; println ! ("{}" , "Characters: " + char_count . to_s ()) ; println...
  |                                --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                                |
  |                                required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpLs3ffc/main.rs:1:388
  |
1 | ...filename) ; println ! ("{}" , "Characters: " + char_count . to_s ()) ; println ! ("{}" , "Words: " + word_count . to_s ()) ; println !...
  |                            --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                            |
  |                            required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpLs3ffc/main.rs:1:447
  |
1 | ...t . to_s ()) ; println ! ("{}" , "Words: " + word_count . to_s ()) ; println ! ("{}" , "Lines: " + line_count . to_s ()) } ; if let So...
  |                               --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                               |
  |                               required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpLs3ffc/main.rs:1:501
  |
1 | ...t . to_s ()) ; println ! ("{}" , "Lines: " + line_count . to_s ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downc...
  |                               --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                               |
  |                               required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 6 previous errors

Some errors have detailed explanations: E0277, E0425.
For more information about an error, try `rustc --explain E0277`.



=== ch04-00-command-line-tools example 2 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpqJ1sZn/main.rs:1:181
  |
1 | ...t ("Are you a student? (y/n) ") == "y" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpqJ1sZn/main.rs:1:40
  |
1 | fn main () { let result = { let name = input ("What's your name? ") ; let age = input ("How old are you? ") . to_i () ; let is_student = ...
  |                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpqJ1sZn/main.rs:1:81
  |
1 | fn main () { let result = { let name = input ("What's your name? ") ; let age = input ("How old are you? ") . to_i () ; let is_student = ...
  |                                                                                 ^^^^^ not found in this scope

error: aborting due to 3 previous errors

For more information about this error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 3 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpsmIug5/main.rs:1:285
  |
1 | ...") ; let size = file_size ("data.txt") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpsmIug5/main.rs:1:43
  |
1 | fn main () { let result = { let content = read_file ("data.txt") ; let lines = read_lines ("data.txt") ; write_file ("output.txt" , "Hell...
  |                                           ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_lines` in this scope
 --> /tmp/.tmpsmIug5/main.rs:1:80
  |
1 | fn main () { let result = { let content = read_file ("data.txt") ; let lines = read_lines ("data.txt") ; write_file ("output.txt" , "Hell...
  |                                                                                ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpsmIug5/main.rs:1:106
  |
1 | ...ata.txt") ; let lines = read_lines ("data.txt") ; write_file ("output.txt" , "Hello, World!") ; append_file ("log.txt" , "New entry: "...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `timestamp` in this scope
 --> /tmp/.tmpsmIug5/main.rs:1:193
  |
1 | ...rld!") ; append_file ("log.txt" , "New entry: " + timestamp ()) ; let exists = file_exists ("config.txt") ; let size = file_size ("dat...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `append_file` in this scope
 --> /tmp/.tmpsmIug5/main.rs:1:152
  |
1 | ... ; write_file ("output.txt" , "Hello, World!") ; append_file ("log.txt" , "New entry: " + timestamp ()) ; let exists = file_exists ("c...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpsmIug5/main.rs:1:222
  |
1 | ..." , "New entry: " + timestamp ()) ; let exists = file_exists ("config.txt") ; let size = file_size ("data.txt") } ; if let Some (s) = ...
  |                                                     ^^^^^^^^^^^ not found in this scope

error: aborting due to 7 previous errors

For more information about this error, try `rustc --explain E0425`.



=== ch04-00-command-line-tools example 4 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `command_args` in this scope
 --> /tmp/.tmpTAttcG/main.rs:1:40
  |
1 | fn main () { let result = { let args = command_args () ; let program_name = args [0i32] ; let first_file = args [1i32] ; let second_file ...
  |                                        ^^^^^^^^^^^^ not found in this scope

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpTAttcG/main.rs:1:200
  |
1 | ...second_file = args [2i32] ; println ! ("{}" , "Processing: " + first_file + " and " + second_file) } ; if let Some (s) = (& result as ...
  |                                                  --------------------------- ^ ------- &str
  |                                                  |
  |                                                  str

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0369, E0425.
For more information about an error, try `rustc --explain E0369`.



=== ch04-00-command-line-tools example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `exit` in this scope
 --> /tmp/.tmprPqcit/main.rs:1:209
  |
1 | ...{}" , "Error: File '" + filename + "' not found!") ; exit (1i32) } } ; let content = read_file (filename) ; let lines = content . line...
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::process::exit;
  |

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmprPqcit/main.rs:1:83
  |
1 | fn main () { let result = { println ! ("=== Text Processor ===") ; let filename = input ("Enter filename: ") ; if ! file_exists (filename...
  |                                                                                   ^^^^^ not found in this scope

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmprPqcit/main.rs:1:117
  |
1 | ...let filename = input ("Enter filename: ") ; if ! file_exists (filename) { { println ! ("{}" , "Error: File '" + filename + "' not foun...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmprPqcit/main.rs:1:189
  |
1 | ...le_exists (filename) { { println ! ("{}" , "Error: File '" + filename + "' not found!") ; exit (1i32) } } ; let content = read_file (f...
  |                                               -------------------------- ^ -------------- &str
  |                                               |
  |                                               str

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmprPqcit/main.rs:1:241
  |
1 | ..."' not found!") ; exit (1i32) } } ; let content = read_file (filename) ; let lines = content . lines () ; println ! ("\nChoose operati...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmprPqcit/main.rs:1:491
  |
1 | ... println ! ("4. Remove empty lines") ; let choice = input ("Enter choice (1-4): ") . to_i () ; match choice { 1i32 => { println ! ("{}...
  |                                                        ^^^^^ not found in this scope

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmprPqcit/main.rs:1:577
  |
1 | ...1i32 => { println ! ("{}" , "Total lines: " + lines . len () . to_s ()) } , 2i32 => { { let find = input ("Find: ") ; { let replace = ...
  |                          --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                          |
  |                          required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmprPqcit/main.rs:1:648
  |
1 | ...ines . len () . to_s ()) } , 2i32 => { { let find = input ("Find: ") ; { let replace = input ("Replace with: ") ; let new_content = co...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmprPqcit/main.rs:1:683
  |
1 | ...> { { let find = input ("Find: ") ; { let replace = input ("Replace with: ") ; let new_content = content . replace (find , replace) ; ...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmprPqcit/main.rs:1:831
  |
1 | ...= filename . replace (".txt" , "_modified.txt") ; write_file (output_file , new_content) ; println ! ("{}" , "Saved to: " + output_fil...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmprPqcit/main.rs:1:890
  |
1 | ... , new_content) ; println ! ("{}" , "Saved to: " + output_file) } } } , 3i32 => { { let upper_content = content . to_uppercase () ; { ...
  |                                  --    ^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                                  |
  |                                  required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmprPqcit/main.rs:1:1051
  |
1 | ...le = filename . replace (".txt" , "_upper.txt") ; write_file (output_file , upper_content) ; println ! ("{}" , "Saved to: " + output_f...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmprPqcit/main.rs:1:1112
  |
1 | ... upper_content) ; println ! ("{}" , "Saved to: " + output_file) } } } , 4i32 => { { let clean_lines = lines . filter (| line | ! line ...
  |                                  --    ^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                                  |
  |                                  required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmprPqcit/main.rs:1:1350
  |
1 | ...le = filename . replace (".txt" , "_clean.txt") ; write_file (output_file , clean_content) ; println ! ("{}" , "Saved to: " + output_f...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmprPqcit/main.rs:1:1411
  |
1 | ... clean_content) ; println ! ("{}" , "Saved to: " + output_file) } } } , _ => { println ! ("Invalid choice!") } , } } ; if let Some (s)...
  |                                  --    ^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                                  |
  |                                  required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 15 previous errors

Some errors have detailed explanations: E0277, E0369, E0425.
For more information about an error, try `rustc --explain E0277`.



=== ch04-00-command-line-tools example 6 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpRd4Gwo/main.rs:1:290
  |
1 | ... { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ...
  |       ^^                                                                                                                                                                                                  ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { let result = { println ! ("=== Log Analyzer ===") ; let log_file = input ("Enter log file path: ") ; let lines = read_lines (log_file) ; let total_requests = lines . len () ; let success_count = 0i32 ; let error_count = 0i32 ; let not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; let error_percent = error_count * 100i32 / total_requests ; let not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{}" , "Total Requests: " + total_requests . to_s ()) ; println ! ("{}" , "Success (200): " + success_count . to_s () + " (" + success_percent . to_s () + "%)") ; println ! ("{}" , "Not Found (404): " + not_found_count . to_s () + " (" + not_found_percent . to_s () + "%)") ; println ! ("{}" , "Server Error (500): " + error_count . to_s () + " (" + error_percent . to_s () + "%)") ; let hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , "Busiest Hour: " + busiest_hour . to_s () + ":00") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { println ! ("=== Log Analyzer ===") ; let log_file = input ("Enter log file path: ") ; let lines = read_lines (log_file) ; let total_requests = lines . len () ; let success_count = 0i32 ; let error_count = 0i32 ; let not_found_count = 0i32 ; for line in lines { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } ; let success_percent = success_count * 100i32 / total_requests ; let error_percent = error_count * 100i32 / total_requests ; let not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{}" , "Total Requests: " + total_requests . to_s ()) ; println ! ("{}" , "Success (200): " + success_count . to_s () + " (" + success_percent . to_s () + "%)") ; println ! ("{}" , "Not Found (404): " + not_found_count . to_s () + " (" + not_found_percent . to_s () + "%)") ; println ! ("{}" , "Server Error (500): " + error_count . to_s () + " (" + error_percent . to_s () + "%)") ; let hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , "Busiest Hour: " + busiest_hour . to_s () + ":00") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpRd4Gwo/main.rs:1:323
  |
1 | ... for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_co...
  |                                                          ^^                     ^^
  |
help: remove these braces
  |
1 - fn main () { let result = { println ! ("=== Log Analyzer ===") ; let log_file = input ("Enter log file path: ") ; let lines = read_lines (log_file) ; let total_requests = lines . len () ; let success_count = 0i32 ; let error_count = 0i32 ; let not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; let error_percent = error_count * 100i32 / total_requests ; let not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{}" , "Total Requests: " + total_requests . to_s ()) ; println ! ("{}" , "Success (200): " + success_count . to_s () + " (" + success_percent . to_s () + "%)") ; println ! ("{}" , "Not Found (404): " + not_found_count . to_s () + " (" + not_found_percent . to_s () + "%)") ; println ! ("{}" , "Server Error (500): " + error_count . to_s () + " (" + error_percent . to_s () + "%)") ; let hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , "Busiest Hour: " + busiest_hour . to_s () + ":00") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { println ! ("=== Log Analyzer ===") ; let log_file = input ("Enter log file path: ") ; let lines = read_lines (log_file) ; let total_requests = lines . len () ; let success_count = 0i32 ; let error_count = 0i32 ; let not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { success_count += 1i32 } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; let error_percent = error_count * 100i32 / total_requests ; let not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{}" , "Total Requests: " + total_requests . to_s ()) ; println ! ("{}" , "Success (200): " + success_count . to_s () + " (" + success_percent . to_s () + "%)") ; println ! ("{}" , "Not Found (404): " + not_found_count . to_s () + " (" + not_found_percent . to_s () + "%)") ; println ! ("{}" , "Server Error (500): " + error_count . to_s () + " (" + error_percent . to_s () + "%)") ; let hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , "Busiest Hour: " + busiest_hour . to_s () + ":00") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpRd4Gwo/main.rs:1:389
  |
1 | ...nt += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count...
  |                                                         ^^                       ^^
  |
help: remove these braces
  |
1 - fn main () { let result = { println ! ("=== Log Analyzer ===") ; let log_file = input ("Enter log file path: ") ; let lines = read_lines (log_file) ; let total_requests = lines . len () ; let success_count = 0i32 ; let error_count = 0i32 ; let not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; let error_percent = error_count * 100i32 / total_requests ; let not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{}" , "Total Requests: " + total_requests . to_s ()) ; println ! ("{}" , "Success (200): " + success_count . to_s () + " (" + success_percent . to_s () + "%)") ; println ! ("{}" , "Not Found (404): " + not_found_count . to_s () + " (" + not_found_percent . to_s () + "%)") ; println ! ("{}" , "Server Error (500): " + error_count . to_s () + " (" + error_percent . to_s () + "%)") ; let hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , "Busiest Hour: " + busiest_hour . to_s () + ":00") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { println ! ("=== Log Analyzer ===") ; let log_file = input ("Enter log file path: ") ; let lines = read_lines (log_file) ; let total_requests = lines . len () ; let success_count = 0i32 ; let error_count = 0i32 ; let not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { not_found_count += 1i32 } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; let error_percent = error_count * 100i32 / total_requests ; let not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{}" , "Total Requests: " + total_requests . to_s ()) ; println ! ("{}" , "Success (200): " + success_count . to_s () + " (" + success_percent . to_s () + "%)") ; println ! ("{}" , "Not Found (404): " + not_found_count . to_s () + " (" + not_found_percent . to_s () + "%)") ; println ! ("{}" , "Server Error (500): " + error_count . to_s () + " (" + error_percent . to_s () + "%)") ; let hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , "Busiest Hour: " + busiest_hour . to_s () + ":00") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpRd4Gwo/main.rs:1:457
  |
1 | ...ount += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i3...
  |                                                           ^^                   ^^
  |
help: remove these braces
  |
1 - fn main () { let result = { println ! ("=== Log Analyzer ===") ; let log_file = input ("Enter log file path: ") ; let lines = read_lines (log_file) ; let total_requests = lines . len () ; let success_count = 0i32 ; let error_count = 0i32 ; let not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; let error_percent = error_count * 100i32 / total_requests ; let not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{}" , "Total Requests: " + total_requests . to_s ()) ; println ! ("{}" , "Success (200): " + success_count . to_s () + " (" + success_percent . to_s () + "%)") ; println ! ("{}" , "Not Found (404): " + not_found_count . to_s () + " (" + not_found_percent . to_s () + "%)") ; println ! ("{}" , "Server Error (500): " + error_count . to_s () + " (" + error_percent . to_s () + "%)") ; let hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , "Busiest Hour: " + busiest_hour . to_s () + ":00") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { println ! ("=== Log Analyzer ===") ; let log_file = input ("Enter log file path: ") ; let lines = read_lines (log_file) ; let total_requests = lines . len () ; let success_count = 0i32 ; let error_count = 0i32 ; let not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { error_count += 1i32 } } } } } ; let success_percent = success_count * 100i32 / total_requests ; let error_percent = error_count * 100i32 / total_requests ; let not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{}" , "Total Requests: " + total_requests . to_s ()) ; println ! ("{}" , "Success (200): " + success_count . to_s () + " (" + success_percent . to_s () + "%)") ; println ! ("{}" , "Not Found (404): " + not_found_count . to_s () + " (" + not_found_percent . to_s () + "%)") ; println ! ("{}" , "Server Error (500): " + error_count . to_s () + " (" + error_percent . to_s () + "%)") ; let hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , "Busiest Hour: " + busiest_hour . to_s () + ":00") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpRd4Gwo/main.rs:1:1166
  |
1 | ... lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let b...
  |             ^^                                                                                                               ^^
  |
help: remove these braces
  |
1 - fn main () { let result = { println ! ("=== Log Analyzer ===") ; let log_file = input ("Enter log file path: ") ; let lines = read_lines (log_file) ; let total_requests = lines . len () ; let success_count = 0i32 ; let error_count = 0i32 ; let not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; let error_percent = error_count * 100i32 / total_requests ; let not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{}" , "Total Requests: " + total_requests . to_s ()) ; println ! ("{}" , "Success (200): " + success_count . to_s () + " (" + success_percent . to_s () + "%)") ; println ! ("{}" , "Not Found (404): " + not_found_count . to_s () + " (" + not_found_percent . to_s () + "%)") ; println ! ("{}" , "Server Error (500): " + error_count . to_s () + " (" + error_percent . to_s () + "%)") ; let hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , "Busiest Hour: " + busiest_hour . to_s () + ":00") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { println ! ("=== Log Analyzer ===") ; let log_file = input ("Enter log file path: ") ; let lines = read_lines (log_file) ; let total_requests = lines . len () ; let success_count = 0i32 ; let error_count = 0i32 ; let not_found_count = 0i32 ; for line in lines { { if line . contains (" 200 ") { { success_count += 1i32 } } else { if line . contains (" 404 ") { { not_found_count += 1i32 } } else { if line . contains (" 500 ") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; let error_percent = error_count * 100i32 / total_requests ; let not_found_percent = not_found_count * 100i32 / total_requests ; println ! ("\n=== Analysis Results ===") ; println ! ("{}" , "Total Requests: " + total_requests . to_s ()) ; println ! ("{}" , "Success (200): " + success_count . to_s () + " (" + success_percent . to_s () + "%)") ; println ! ("{}" , "Not Found (404): " + not_found_count . to_s () + " (" + not_found_percent . to_s () + "%)") ; println ! ("{}" , "Server Error (500): " + error_count . to_s () + " (" + error_percent . to_s () + "%)") ; let hour_counts = () ; for line in lines { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } ; let busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , "Busiest Hour: " + busiest_hour . to_s () + ":00") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpRd4Gwo/main.rs:1:81
  |
1 | fn main () { let result = { println ! ("=== Log Analyzer ===") ; let log_file = input ("Enter log file path: ") ; let lines = read_lines ...
  |                                                                                 ^^^^^ not found in this scope

error[E0425]: cannot find function `read_lines` in this scope
 --> /tmp/.tmpRd4Gwo/main.rs:1:127
  |
1 | ...e = input ("Enter log file path: ") ; let lines = read_lines (log_file) ; let total_requests = lines . len () ; let success_count = 0i...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpRd4Gwo/main.rs:1:746
  |
1 | ...===") ; println ! ("{}" , "Total Requests: " + total_requests . to_s ()) ; println ! ("{}" , "Success (200): " + success_count . to_s ...
  |                        --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                        |
  |                        required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpRd4Gwo/main.rs:1:849
  |
1 | ...intln ! ("{}" , "Success (200): " + success_count . to_s () + " (" + success_percent . to_s () + "%)") ; println ! ("{}" , "Not Found ...
  |                                                        ^^^^ method not found in `i32`

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpRd4Gwo/main.rs:1:857
  |
1 | ...equests . to_s ()) ; println ! ("{}" , "Success (200): " + success_count . to_s () + " (" + success_percent . to_s () + "%)") ; printl...
  |                                           ------------------------------------------- ^ ---- &str
  |                                           |
  |                                           str

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpRd4Gwo/main.rs:1:884
  |
1 | ... success_count . to_s () + " (" + success_percent . to_s () + "%)") ; println ! ("{}" , "Not Found (404): " + not_found_count . to_s (...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpRd4Gwo/main.rs:1:960
  |
1 | ...n ! ("{}" , "Not Found (404): " + not_found_count . to_s () + " (" + not_found_percent . to_s () + "%)") ; println ! ("{}" , "Server E...
  |                                                        ^^^^ method not found in `i32`

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpRd4Gwo/main.rs:1:968
  |
1 | ... to_s () + "%)") ; println ! ("{}" , "Not Found (404): " + not_found_count . to_s () + " (" + not_found_percent . to_s () + "%)") ; pr...
  |                                         ----------------------------------------------- ^ ---- &str
  |                                         |
  |                                         str

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpRd4Gwo/main.rs:1:997
  |
1 | ..._found_count . to_s () + " (" + not_found_percent . to_s () + "%)") ; println ! ("{}" , "Server Error (500): " + error_count . to_s ()...
  |                                                        ^^^^ method not found in `i32`

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpRd4Gwo/main.rs:1:1072
  |
1 | ...ln ! ("{}" , "Server Error (500): " + error_count . to_s () + " (" + error_percent . to_s () + "%)") ; let hour_counts = () ; for line...
  |                                                        ^^^^ method not found in `i32`

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpRd4Gwo/main.rs:1:1080
  |
1 | .... to_s () + "%)") ; println ! ("{}" , "Server Error (500): " + error_count . to_s () + " (" + error_percent . to_s () + "%)") ; let ho...
  |                                          ---------------------------------------------- ^ ---- &str
  |                                          |
  |                                          str

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpRd4Gwo/main.rs:1:1105
  |
1 | ... " + error_count . to_s () + " (" + error_percent . to_s () + "%)") ; let hour_counts = () ; for line in lines { { { let timestamp = e...
  |                                                        ^^^^ method not found in `i32`

error[E0425]: cannot find function `extract_hour` in this scope
 --> /tmp/.tmpRd4Gwo/main.rs:1:1186
  |
1 | ...s = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) ...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `get` found for unit type `()` in the current scope
    --> /tmp/.tmpRd4Gwo/main.rs:1:1248
     |
1    | ... = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let busiest_hour = hour_counts ...
     |                                                                     ^^^
     |
help: there is a method `ge` with a similar name, but with different arguments
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1438:5
     |
1438 |     fn ge(&self, other: &Rhs) -> bool {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `max_by_value` found for unit type `()` in the current scope
 --> /tmp/.tmpRd4Gwo/main.rs:1:1319
  |
1 | ...+ 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; println ! ("{}" , "Busiest Hour: " + busiest_hour . to_s () + ...
  |                                                    ^^^^^^^^^^^^ method not found in `()`

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpRd4Gwo/main.rs:1:1403
  |
1 | ...x_by_value () . key ; println ! ("{}" , "Busiest Hour: " + busiest_hour . to_s () + ":00") } ; if let Some (s) = (& result as & dyn st...
  |                                            ----------------------------------------- ^ ----- &str
  |                                            |
  |                                            str

error: aborting due to 16 previous errors; 5 warnings emitted

Some errors have detailed explanations: E0277, E0369, E0425, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch04-00-command-line-tools example 7 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpzO92n2/main.rs:1:307
  |
1 | ... { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; let new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , "Renamed: " + file + " -> " + new_name) ; renamed_count += 1i32 } } else { { println ! ("{}" , "Failed to rename: " + file) } } } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { let result = { println ! ("=== Batch File Renamer ===") ; let directory = input ("Enter directory path: ") ; let pattern = input ("Enter pattern to find: ") ; let replacement = input ("Enter replacement: ") ; let files = list_files (directory) ; let renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; let new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , "Renamed: " + file + " -> " + new_name) ; renamed_count += 1i32 } } else { { println ! ("{}" , "Failed to rename: " + file) } } } } } } } } ; println ! ("{}" , "\nRenamed " + renamed_count . to_s () + " files") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { println ! ("=== Batch File Renamer ===") ; let directory = input ("Enter directory path: ") ; let pattern = input ("Enter pattern to find: ") ; let replacement = input ("Enter replacement: ") ; let files = list_files (directory) ; let renamed_count = 0i32 ; for file in files { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; let new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , "Renamed: " + file + " -> " + new_name) ; renamed_count += 1i32 } } else { { println ! ("{}" , "Failed to rename: " + file) } } } } } } } ; println ! ("{}" , "\nRenamed " + renamed_count . to_s () + " files") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpzO92n2/main.rs:1:340
  |
1 | ... { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; let new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , "Renamed: " + file + " -> " + new_name) ; renamed_count += 1i32 } } else { { println ! ("{}" , "Failed to rename: " + file) } } } } } } ...
  |       ^^                                                                                                                                                                                                                                                                                                                                                          ^^
  |
help: remove these braces
  |
1 - fn main () { let result = { println ! ("=== Batch File Renamer ===") ; let directory = input ("Enter directory path: ") ; let pattern = input ("Enter pattern to find: ") ; let replacement = input ("Enter replacement: ") ; let files = list_files (directory) ; let renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; let new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , "Renamed: " + file + " -> " + new_name) ; renamed_count += 1i32 } } else { { println ! ("{}" , "Failed to rename: " + file) } } } } } } } } ; println ! ("{}" , "\nRenamed " + renamed_count . to_s () + " files") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { println ! ("=== Batch File Renamer ===") ; let directory = input ("Enter directory path: ") ; let pattern = input ("Enter pattern to find: ") ; let replacement = input ("Enter replacement: ") ; let files = list_files (directory) ; let renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; let new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , "Renamed: " + file + " -> " + new_name) ; renamed_count += 1i32 } } else { { println ! ("{}" , "Failed to rename: " + file) } } } } } } } ; println ! ("{}" , "\nRenamed " + renamed_count . to_s () + " files") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpzO92n2/main.rs:1:632
  |
1 | ..._name) ; renamed_count += 1i32 } } else { { println ! ("{}" , "Failed to rename: " + file) } } } } } } } } ; println ! ("{}" , "\nRena...
  |                                              ^^                                              ^^
  |
help: remove these braces
  |
1 - fn main () { let result = { println ! ("=== Batch File Renamer ===") ; let directory = input ("Enter directory path: ") ; let pattern = input ("Enter pattern to find: ") ; let replacement = input ("Enter replacement: ") ; let files = list_files (directory) ; let renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; let new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , "Renamed: " + file + " -> " + new_name) ; renamed_count += 1i32 } } else { { println ! ("{}" , "Failed to rename: " + file) } } } } } } } } ; println ! ("{}" , "\nRenamed " + renamed_count . to_s () + " files") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { println ! ("=== Batch File Renamer ===") ; let directory = input ("Enter directory path: ") ; let pattern = input ("Enter pattern to find: ") ; let replacement = input ("Enter replacement: ") ; let files = list_files (directory) ; let renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; let new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , "Renamed: " + file + " -> " + new_name) ; renamed_count += 1i32 } } else { println ! ("{}" , "Failed to rename: " + file) } } } } } } } ; println ! ("{}" , "\nRenamed " + renamed_count . to_s () + " files") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpzO92n2/main.rs:1:88
  |
1 | fn main () { let result = { println ! ("=== Batch File Renamer ===") ; let directory = input ("Enter directory path: ") ; let pattern = i...
  |                                                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpzO92n2/main.rs:1:137
  |
1 | ... = input ("Enter directory path: ") ; let pattern = input ("Enter pattern to find: ") ; let replacement = input ("Enter replacement: "...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpzO92n2/main.rs:1:191
  |
1 | ...put ("Enter pattern to find: ") ; let replacement = input ("Enter replacement: ") ; let files = list_files (directory) ; let renamed_c...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find function `list_files` in this scope
 --> /tmp/.tmpzO92n2/main.rs:1:235
  |
1 | ...ent = input ("Enter replacement: ") ; let files = list_files (directory) ; let renamed_count = 0i32 ; for file in files { { if file . ...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpzO92n2/main.rs:1:417
  |
1 | ...eplace (pattern , replacement) ; { let old_path = join_path (directory , file) ; let new_path = join_path (directory , new_name) ; if ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `join_path` in this scope
 --> /tmp/.tmpzO92n2/main.rs:1:463
  |
1 | ...ctory , file) ; let new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , "Renamed:...
  |                                   ^^^^^^^^^ help: a local variable with a similar name exists: `old_path`

error[E0425]: cannot find function `rename_file` in this scope
 --> /tmp/.tmpzO92n2/main.rs:1:501
  |
1 | ...new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! ("{}" , "Renamed: " + file + " -> " +...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpzO92n2/main.rs:1:576
  |
1 | ...e_file (old_path , new_path) { { println ! ("{}" , "Renamed: " + file + " -> " + new_name) ; renamed_count += 1i32 } } else { { printl...
  |                                                       ------------------ ^ ------ &str
  |                                                       |
  |                                                       str

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpzO92n2/main.rs:1:652
  |
1 | ...i32 } } else { { println ! ("{}" , "Failed to rename: " + file) } } } } } } } } ; println ! ("{}" , "\nRenamed " + renamed_count . to_...
  |                                 --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                                 |
  |                                 required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpzO92n2/main.rs:1:748
  |
1 | ... ; println ! ("{}" , "\nRenamed " + renamed_count . to_s () + " files") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . ...
  |                                                        ^^^^ method not found in `i32`

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpzO92n2/main.rs:1:756
  |
1 | ...le) } } } } } } } } ; println ! ("{}" , "\nRenamed " + renamed_count . to_s () + " files") } ; if let Some (s) = (& result as & dyn st...
  |                                            -------------------------------------- ^ -------- &str
  |                                            |
  |                                            str

error: aborting due to 11 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0277, E0369, E0425, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch04-00-command-line-tools example 8 ===
✗ Compilation failed: Compilation failed:
error[E0423]: expected value, found macro `try`
 --> /tmp/.tmpZQP0Tl/main.rs:1:451
  |
1 | ...permission denied?)") ; return false } } ; { let content = try ; { { read_file (filename) } ; catch ; error ; { println ! ("{}" , "❌ Er...
  |                                                               ^^^ not a value

error[E0425]: cannot find value `catch` in this scope
 --> /tmp/.tmpZQP0Tl/main.rs:1:486
  |
1 | ... { let content = try ; { { read_file (filename) } ; catch ; error ; { println ! ("{}" , "❌ Error reading file: " + error . to_s ()) ; r...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpZQP0Tl/main.rs:1:494
  |
1 | ...ontent = try ; { { read_file (filename) } ; catch ; error ; { println ! ("{}" , "❌ Error reading file: " + error . to_s ()) ; return fa...
  |                                                        ^^^^^ not found in this scope

error[E0425]: cannot find value `error` in this scope
 --> /tmp/.tmpZQP0Tl/main.rs:1:549
  |
1 | ...or ; { println ! ("{}" , "❌ Error reading file: " + error . to_s ()) ; return false } ; let word_count = content . split_whitespace () ...
  |                                                         ^^^^^ not found in this scope

error[E0425]: cannot find function `exit` in this scope
 --> /tmp/.tmpZQP0Tl/main.rs:1:924
  |
1 | ...y!") } } else { { println ! ("Processing failed!") ; exit (1i32) } } ; }
  |                                                         ^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::process::exit;
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpZQP0Tl/main.rs:1:825
  |
1 | ...ename: ") ; if process_file (filename) { { println ! ("Processing completed successfully!") } } else { { println ! ("Processing failed...
  |                                             ^^                                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn process_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (filename : T) -> T { { if ! file_exists (filename) { { println ! ("{}" , "❌ Error: File '" + filename + "' does not exist") ; return false } } ; if ! file_readable (filename) { { println ! ("{}" , "❌ Error: Cannot read file '" + filename + "' (permission denied?)") ; return false } } ; { let content = try ; { { read_file (filename) } ; catch ; error ; { println ! ("{}" , "❌ Error reading file: " + error . to_s ()) ; return false } ; let word_count = content . split_whitespace () . len () ; println ! ("{}" , "✅ File processed: " + word_count . to_s () + " words") ; return true } } } } fn main () { let filename = input ("Enter filename: ") ; if process_file (filename) { { println ! ("Processing completed successfully!") } } else { { println ! ("Processing failed!") ; exit (1i32) } } ; }
1 + fn process_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (filename : T) -> T { { if ! file_exists (filename) { { println ! ("{}" , "❌ Error: File '" + filename + "' does not exist") ; return false } } ; if ! file_readable (filename) { { println ! ("{}" , "❌ Error: Cannot read file '" + filename + "' (permission denied?)") ; return false } } ; { let content = try ; { { read_file (filename) } ; catch ; error ; { println ! ("{}" , "❌ Error reading file: " + error . to_s ()) ; return false } ; let word_count = content . split_whitespace () . len () ; println ! ("{}" , "✅ File processed: " + word_count . to_s () + " words") ; return true } } } } fn main () { let filename = input ("Enter filename: ") ; if process_file (filename) { println ! ("Processing completed successfully!") } else { { println ! ("Processing failed!") ; exit (1i32) } } ; }
  |

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpZQP0Tl/main.rs:1:176
  |
1 | ... :: Debug + Clone > (filename : T) -> T { { if ! file_exists (filename) { { println ! ("{}" , "❌ Error: File '" + filename + "' does no...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0369]: cannot add `T` to `&str`
 --> /tmp/.tmpZQP0Tl/main.rs:1:239
  |
1 | ...{ if ! file_exists (filename) { { println ! ("{}" , "❌ Error: File '" + filename + "' does not exist") ; return false } } ; if ! file_r...
  |                                                        ------------------ ^ -------- T
  |                                                        |
  |                                                        &str

error[E0308]: mismatched types
 --> /tmp/.tmpZQP0Tl/main.rs:1:252
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (filename : T) -> T { { if ! file_exists (filename) { { println ! ("{}" , "❌ Error: File '" + filename + "' does not exist") ; ...
  |       - expected this type parameter                                                                                                                                                                                                            ^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`

error[E0308]: mismatched types
 --> /tmp/.tmpZQP0Tl/main.rs:1:281
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (filename : T) -> T { { if ! file_exists (filename) { { println ! ("{}" , "❌ Error: File '" + filename + "' does not exist") ; return false } }...
  |       - expected this type parameter                                                                                                                    - expected `T` because of return type                                                                                ^^^^^ expected type parameter `T`, found `bool`
  |
  = note: expected type parameter `T`
                       found type `bool`
  = note: the caller chooses a type for `T` which can be different from `bool`

error[E0425]: cannot find function `file_readable` in this scope
 --> /tmp/.tmpZQP0Tl/main.rs:1:298
  |
1 | ...+ "' does not exist") ; return false } } ; if ! file_readable (filename) { { println ! ("{}" , "❌ Error: Cannot read file '" + filename...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error[E0369]: cannot add `T` to `&str`
 --> /tmp/.tmpZQP0Tl/main.rs:1:375
  |
1 | ...ile_readable (filename) { { println ! ("{}" , "❌ Error: Cannot read file '" + filename + "' (permission denied?)") ; return false } } ;...
  |                                                  ------------------------------ ^ -------- T
  |                                                  |
  |                                                  &str

error[E0308]: mismatched types
 --> /tmp/.tmpZQP0Tl/main.rs:1:388
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (filename : T) -> T { { if ! file_exists (filename) { { println ! ("{}" , "❌ Error: File '" + filename + "' does not exist") ; return false } } ; if ! file_readable (filename) { { println ! ("{}" , "❌ Error: Cannot read file '" + filename + "' (permission denied?)") ; r...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpZQP0Tl/main.rs:1:461
  |
1 | ...") ; return false } } ; { let content = try ; { { read_file (filename) } ; catch ; error ; { println ! ("{}" , "❌ Error reading file: "...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpZQP0Tl/main.rs:1:522
  |
1 | ...error ; { println ! ("{}" , "❌ Error reading file: " + error . to_s ()) ; return false } ; let word_count = content . split_whitespace ...
  |                          --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                          |
  |                          required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

warning: unreachable statement
 --> /tmp/.tmpZQP0Tl/main.rs:1:585
  |
1 | ...error . to_s ()) ; return false } ; let word_count = content . split_whitespace () . len () ; println ! ("{}" , "✅ File processed: " + ...
  |                       ------------     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable statement
  |                       |
  |                       any code following this expression is unreachable
  |
  = note: `#[warn(unreachable_code)]` on by default

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpZQP0Tl/main.rs:1:705
  |
1 | ...pace () . len () ; println ! ("{}" , "✅ File processed: " + word_count . to_s () + " words") ; return true } } } } fn main () { let fil...
  |                                         -------------------------------------------- ^ -------- &str
  |                                         |
  |                                         str

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpZQP0Tl/main.rs:1:767
  |
1 | ...) ; return true } } } } fn main () { let filename = input ("Enter filename: ") ; if process_file (filename) { { println ! ("Processing...
  |                                                        ^^^^^ not found in this scope

error[E0277]: cannot add `bool` to `bool`
 --> /tmp/.tmpZQP0Tl/main.rs:1:813
  |
1 | ...ame = input ("Enter filename: ") ; if process_file (filename) { { println ! ("Processing completed successfully!") } } else { { printl...
  |                                          ------------  ^^^^^^^^ no implementation for `bool + bool`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `bool`
note: required by a bound in `process_file`
 --> /tmp/.tmpZQP0Tl/main.rs:1:23
  |
1 | fn process_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug +...
  |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `process_file`

error[E0277]: cannot multiply `bool` by `bool`
 --> /tmp/.tmpZQP0Tl/main.rs:1:813
  |
1 | ...ame = input ("Enter filename: ") ; if process_file (filename) { { println ! ("Processing completed successfully!") } } else { { printl...
  |                                          ------------  ^^^^^^^^ no implementation for `bool * bool`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `bool`
note: required by a bound in `process_file`
 --> /tmp/.tmpZQP0Tl/main.rs:1:58
  |
1 | fn process_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug +...
  |                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `process_file`

error: aborting due to 18 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0369, E0423, E0425.
For more information about an error, try `rustc --explain E0277`.



=== ch04-00-command-line-tools example 9 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `sleep` in this scope
 --> /tmp/.tmpx5rkhz/main.rs:1:877
  |
1 | ...s . to_s () + "%] " + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } ...
  |                                                        ^^^^^ not found in this scope
  |
help: consider importing this function
  |
1 + use std::thread::sleep;
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpx5rkhz/main.rs:1:636
  |
1 | ... { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let progress = i + 1i32 * 100i32 / total ; print ! ("{}" , "\rProcessing... [" + progress . to_s () + "%] " + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } } f...
  |       ^^                                                                                                                                                                                                                                                                                                                                  ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let progress = i + 1i32 * 100i32 / total ; print ! ("{}" , "\rProcessing... [" + progress . to_s () + "%] " + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } } fn main () { }
1 + fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let progress = i + 1i32 * 100i32 / total ; print ! ("{}" , "\rProcessing... [" + progress . to_s () + "%] " + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } fn main () { }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpx5rkhz/main.rs:1:708
  |
1 | ... { { { let file = files [i] ; { let progress = i + 1i32 * 100i32 / total ; print ! ("{}" , "\rProcessing... [" + progress . to_s () + "%] " + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ...
  |       ^^                                                                                                                                                                                                        ^^
  |
help: remove these braces
  |
1 - fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let progress = i + 1i32 * 100i32 / total ; print ! ("{}" , "\rProcessing... [" + progress . to_s () + "%] " + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } } fn main () { }
1 + fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { let file = files [i] ; { let progress = i + 1i32 * 100i32 / total ; print ! ("{}" , "\rProcessing... [" + progress . to_s () + "%] " + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } ; println ! ("\n✅ All files processed!") } } } } fn main () { }
  |

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpx5rkhz/main.rs:1:660
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len ()...
  |       - method `len` not found for this type parameter                                                                                                                           ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | fn show_help () { { println ! ("File Statistics Tool v1.0") ; println ! ("") ; println ! ("Usage:") ; println ! ("  ruchy run file_stats.ruchy <filename>") ; println ! ("") ; println ! ("Examples:") ; println ! ("  ruchy run file_stats.ruchy document.txt") ; println ! ("  ruchy run file_stats.ruchy data/*.csv") ; println ! ("") ; println ! ("Options:") ; println ! ("  --help     Show this help message") ; println ! ("  --verbose  Show detailed output") } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let progress = i + 1i32 * 100i32 / total ; print ! ("{}" , "\rProcessing... [" + progress . to_s () + "%] " + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } } } } fn main () { }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       +++++++++++++++++++

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpx5rkhz/main.rs:1:729
  |
1 | ...() ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let progress = i + 1i32 * 100i32 / total ; print ! ("{}" , "\...
  |                                                                     ^^^

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpx5rkhz/main.rs:1:829
  |
1 | ... ; print ! ("{}" , "\rProcessing... [" + progress . to_s () + "%] " + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } ...
  |                                                        ^^^^ method not found in `i32`

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpx5rkhz/main.rs:1:837
  |
1 | ...1i32 * 100i32 / total ; print ! ("{}" , "\rProcessing... [" + progress . to_s () + "%] " + file) ; process_file (file) ; sleep (100i32...
  |                                            ---------------------------------------- ^ ----- &str
  |                                            |
  |                                            str

error[E0425]: cannot find function `process_file` in this scope
 --> /tmp/.tmpx5rkhz/main.rs:1:855
  |
1 | ...ing... [" + progress . to_s () + "%] " + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All file...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
 --> /tmp/.tmpx5rkhz/main.rs:1:917
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let progress = i + 1i32 * 100i32 / total ; print ! ("{}" , "\rProcessing... [" + progress . to_s () + "%] " + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! ("\n✅ All files processed!") } }...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 7 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0308, E0369, E0425, E0599, E0608.
For more information about an error, try `rustc --explain E0308`.



=== ch04-00-command-line-tools example 10 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmp2jfDIj/main.rs:1:14
  |
1 | ... { { { let content = "line 1\nline 2\nline 3" ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {} {}" , "File has" , lines , "lines") } } } }
  |       ^^                                                                                                                                                                                                                                                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { { { let content = "line 1\nline 2\nline 3" ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {} {}" , "File has" , lines , "lines") } } } }
1 + fn main () { { let content = "line 1\nline 2\nline 3" ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {} {}" , "File has" , lines , "lines") } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp2jfDIj/main.rs:1:159
  |
1 | ...hile i < content . len () { { if content [i] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {} {}" , "File h...
  |                                                           ^^                    ^^
  |
help: remove these braces
  |
1 - fn main () { { { let content = "line 1\nline 2\nline 3" ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {} {}" , "File has" , lines , "lines") } } } }
1 + fn main () { { { let content = "line 1\nline 2\nline 3" ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i] == '\n' { lines = lines + 1i32 } ; i = i + 1i32 } } ; println ! ("{} {} {}" , "File has" , lines , "lines") } } } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp2jfDIj/main.rs:1:113
  |
1 | ...t lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 ...
  |                                              -   ^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
  |                                              |
  |                                              expected because this is `i32`
  |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
  |
1 | fn main () { { { let content = "line 1\nline 2\nline 3" ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len ().try_into().unwrap() { { if content [i] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {} {}" , "File has" , lines , "lines") } } } }
  |                                                                                                                                 ++++++++++++++++++++

error[E0277]: the type `str` cannot be indexed by `i32`
 --> /tmp/.tmp2jfDIj/main.rs:1:146
  |
1 | ...32 ; while i < content . len () { { if content [i] == '\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! ("{} {} {}" , "...
  |                                                    ^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `i32`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `str` to implement `Index<i32>`

error: aborting due to 2 previous errors; 2 warnings emitted

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.



=== ch04-00-command-line-tools example 11 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `TASK_FILE` in this scope
 --> /tmp/.tmpT16cR0/main.rs:1:245
  |
1 | .... Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `TASK_FILE` in this scope
 --> /tmp/.tmpT16cR0/main.rs:1:279
  |
1 | ...if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output ...
  |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `TASK_FILE` in this scope
 --> /tmp/.tmpT16cR0/main.rs:1:531
  |
1 | ...{ let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + st...
  |                                                      ^^^^^^^^^ not found in this scope

warning: unnecessary braces around block return value
 --> /tmp/.tmpT16cR0/main.rs:1:258
  |
1 | ...fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std ::...
  |                                                      ^^                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () . to_s () + " items):") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌 " + new_task) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: ") ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { return read_lines (TASK_FILE) } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () . to_s () + " items):") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌 " + new_task) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: ") ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpT16cR0/main.rs:1:479
  |
1 | ...+ Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std ::...
  |                                 ^^                                                                        ^^
  |
help: remove these braces
  |
1 - fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () . to_s () + " items):") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌 " + new_task) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: ") ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () . to_s () + " items):") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌 " + new_task) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: ") ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpT16cR0/main.rs:1:923
  |
1 | ... { { { let task = tasks [i] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } }...
  |       ^^                                                                                                                                                                                   ^^
  |
help: remove these braces
  |
1 - fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () . to_s () + " items):") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌 " + new_task) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: ") ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () . to_s () + " items):") ; let mut i = 0i32 ; while i < tasks . len () { { let task = tasks [i] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌 " + new_task) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: ") ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpT16cR0/main.rs:1:995
  |
1 | ...sk = tasks [i] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s (...
  |                                                                   ^^      ^^
  |
help: remove these braces
  |
1 - fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () . to_s () + " items):") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌 " + new_task) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: ") ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () . to_s () + " items):") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with ("✅") { "DONE" } else { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌 " + new_task) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: ") ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpT16cR0/main.rs:1:1015
  |
1 | ... status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i =...
  |                                                                 ^^         ^^
  |
help: remove these braces
  |
1 - fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () . to_s () + " items):") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌 " + new_task) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: ") ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () . to_s () + " items):") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { "PENDING" } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌 " + new_task) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: ") ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpT16cR0/main.rs:1:1273
  |
1 | ... { { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌 " + new_task) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn...
  |       ^^                                                                                                                                                  ^^
  |
help: remove these braces
  |
1 - fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () . to_s () + " items):") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌 " + new_task) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: ") ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () . to_s () + " items):") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌 " + new_task) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: ") ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpT16cR0/main.rs:1:1858
  |
1 | ...) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" ...
  |                                                    ^^                                    ^^
  |
help: remove these braces
  |
1 - fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () . to_s () + " items):") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌 " + new_task) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: ") ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
1 + fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () . to_s () + " items):") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌 " + new_task) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { println ! ("❌ Invalid task number") } } } } fn main () { let TASK_FILE = "tasks.txt" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: ") ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |

error[E0425]: cannot find function `file_exists` in this scope
 --> /tmp/.tmpT16cR0/main.rs:1:232
  |
1 | ...rintln ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } f...
  |                                                     ^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `read_lines` in this scope
 --> /tmp/.tmpT16cR0/main.rs:1:267
  |
1 | ...asks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: A...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0599]: no method named `join` found for type parameter `T` in the current scope
 --> /tmp/.tmpT16cR0/main.rs:1:505
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("...
  |       - method `join` not found for this type parameter                                                                                                                            ^^^^ method not found in `T`

error[E0425]: cannot find function `write_file` in this scope
 --> /tmp/.tmpT16cR0/main.rs:1:519
  |
1 | ...T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Outpu...
  |                                                      ^^^^^^^^^^ not found in this scope

error[E0599]: no method named `is_empty` found for type parameter `T` in the current scope
 --> /tmp/.tmpT16cR0/main.rs:1:734
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty ()...
  |       - method `is_empty` not found for this type parameter                                                                                                           ^^^^^^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following traits define an item `is_empty`, perhaps you need to restrict type parameter `T` with one of them:
  |
1 | fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () . to_s () + " items):") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌 " + new_task) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: ") ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            +++++++++++++++++++
1 | fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + RangeBounds</* T */> > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () . to_s () + " items):") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌 " + new_task) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: ") ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ++++++++++++++++++++++

error[E0069]: `return;` in a function whose return type is not `()`
 --> /tmp/.tmpT16cR0/main.rs:1:784
  |
1 | ... > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" +...
  |                      - expected `T` because of this return type                          ^^^^^^ return type is not `()`
  |
help: give the `return` a value of the expected type
  |
1 | fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return /* value */ } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () . to_s () + " items):") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌 " + new_task) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: ") ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        +++++++++++

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpT16cR0/main.rs:1:844
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () ....
  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () . to_s () + " items):") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌 " + new_task) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: ") ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            +++++++++++++++++++

error[E0369]: cannot add `&str` to `str`
 --> /tmp/.tmpT16cR0/main.rs:1:861
  |
1 | ...) ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () . to_s () + " items):") ; let mut i = 0i32 ; while i < tasks . l...
  |                                       ---------------------------------------------- ^ ---------- &str
  |                                       |
  |                                       str

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpT16cR0/main.rs:1:914
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () . to_s () + " items):") ; let mut i = 0i32 ; while i < tasks . len () {...
  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                                                                                      ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () . to_s () + " items):") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌 " + new_task) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: ") ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            +++++++++++++++++++

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpT16cR0/main.rs:1:944
  |
1 | ...t mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with ("✅") { { "DONE" } } else {...
  |                                                                     ^^^

error[E0599]: no method named `to_s` found for type `i32` in the current scope
 --> /tmp/.tmpT16cR0/main.rs:1:1062
  |
1 | ...se { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: ...
  |                                                        ^^^^ method not found in `i32`

error[E0277]: cannot add `&str` to `i32`
 --> /tmp/.tmpT16cR0/main.rs:1:1070
  |
1 | ...DING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Outpu...
  |                                                     ^ no implementation for `i32 + &str`
  |
  = help: the trait `Add<&str>` is not implemented for `i32`
  = help: the following other types implement trait `Add<Rhs>`:
            `&i32` implements `Add<i32>`
            `&i32` implements `Add`
            `i32` implements `Add<&i32>`
            `i32` implements `Add`

error[E0308]: mismatched types
 --> /tmp/.tmpT16cR0/main.rs:1:896
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () . to_s () + " items):") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } } } f...
  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                                                                                                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: the caller chooses a type for `T` which can be different from `()`
  = note: `while` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () . to_s () + " items):") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } /* `T` value */ } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌 " + new_task) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: ") ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       +++++++++++++++

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpT16cR0/main.rs:1:1292
  |
1 | ...bug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌 " + new_task) ; save_tas...
  |                                                        ^^^^^ not found in this scope

error[E0599]: no method named `push` found for type parameter `T` in the current scope
 --> /tmp/.tmpT16cR0/main.rs:1:1342
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌...
  |       - method `push` not found for this type parameter                                                                                                                                                                       ^^^^ method not found in `T`

error[E0308]: mismatched types
 --> /tmp/.tmpT16cR0/main.rs:1:1388
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌 " + new_task) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } ...
  |       - expected this type parameter                                                                                                                                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpT16cR0/main.rs:1:1627
  |
1 | ...ks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32...
  |                                                        ^^^^^ not found in this scope

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpT16cR0/main.rs:1:1729
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                              ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | fn show_menu () { { println ! ("\n=== Task Manager ===") ; println ! ("1. List tasks") ; println ! ("2. Add task") ; println ! ("3. Complete task") ; println ! ("4. Delete task") ; println ! ("5. Quit") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join ("\n") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! ("\n📝 No tasks yet!") ; return } } ; println ! ("{}" , "\n📋 Your Tasks (" + tasks . len () . to_s () + " items):") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with ("✅") { { "DONE" } } else { { "PENDING" } } ; println ! ("{}" , i + 1i32 . to_s () + ". " + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input ("\nWhat do you want to add? ") ; { tasks . push ("📌 " + new_task) ; save_tasks (tasks) ; println ! ("✅ Task added!") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } } } fn main () { let TASK_FILE = "tasks.txt" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: ") ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; break } , _ => println ! ("❌ Invalid choice") , } } } } ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      +++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpT16cR0/main.rs:1:1815
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } e...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
 --> /tmp/.tmpT16cR0/main.rs:1:1860
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input ("\nWhich task to complete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace ("📌" , "✅") ; save_tasks (tasks) ; println ! ("🎉 Task completed!") } } else { { println ! ("❌ Invalid task number") } } } ...
  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpT16cR0/main.rs:1:2016
  |
1 | ...d_tasks () ; loop { { show_menu () ; { let choice = input ("\nChoose option: ") ; match choice { "1" => list_tasks (tasks) , "2" => ad...
  |                                                        ^^^^^ not found in this scope

error[E0277]: cannot add `()` to `()`
 --> /tmp/.tmpT16cR0/main.rs:1:2080
  |
1 | ...oose option: ") ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_ta...
  |                                            ----------  ^^^^^ no implementation for `() + ()`
  |                                            |
  |                                            required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `()`
note: required by a bound in `list_tasks`
 --> /tmp/.tmpT16cR0/main.rs:1:578
  |
1 | ...ent) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fm...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`

error[E0277]: cannot multiply `()` by `()`
 --> /tmp/.tmpT16cR0/main.rs:1:2080
  |
1 | ...oose option: ") ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_ta...
  |                                            ----------  ^^^^^ no implementation for `() * ()`
  |                                            |
  |                                            required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `()`
note: required by a bound in `list_tasks`
 --> /tmp/.tmpT16cR0/main.rs:1:613
  |
1 | ...:: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) ->...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpT16cR0/main.rs:1:2080
  |
1 | ...: ") ; match choice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks)...
  |                                 ----------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`
  |                                 |
  |                                 required by a bound introduced by this call
  |
note: required by a bound in `list_tasks`
 --> /tmp/.tmpT16cR0/main.rs:1:648
  |
1 | ...+ std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty ()...
  |                                         ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`

error[E0277]: cannot add `()` to `()`
 --> /tmp/.tmpT16cR0/main.rs:1:2106
  |
1 | ...ice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index =...
  |                                             --------  ^^^^^ no implementation for `() + ()`
  |                                             |
  |                                             required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `()`
note: required by a bound in `add_task`
 --> /tmp/.tmpT16cR0/main.rs:1:1130
  |
1 | ...2 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: f...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `add_task`

error[E0277]: cannot multiply `()` by `()`
 --> /tmp/.tmpT16cR0/main.rs:1:2106
  |
1 | ...ice { "1" => list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index =...
  |                                             --------  ^^^^^ no implementation for `() * ()`
  |                                             |
  |                                             required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `()`
note: required by a bound in `add_task`
 --> /tmp/.tmpT16cR0/main.rs:1:1165
  |
1 | ... :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `add_task`

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpT16cR0/main.rs:1:2106
  |
1 | ...> list_tasks (tasks) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Wh...
  |                                  --------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`
  |                                  |
  |                                  required by a bound introduced by this call
  |
note: required by a bound in `add_task`
 --> /tmp/.tmpT16cR0/main.rs:1:1200
  |
1 | ... + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = inpu...
  |                                          ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `add_task`

error[E0277]: cannot add `()` to `()`
 --> /tmp/.tmpT16cR0/main.rs:1:2137
  |
1 | ...s) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete...
  |                                          -------------  ^^^^^ no implementation for `() + ()`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `()`
note: required by a bound in `complete_task`
 --> /tmp/.tmpT16cR0/main.rs:1:1447
  |
1 | ... } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `complete_task`

error[E0277]: cannot multiply `()` by `()`
 --> /tmp/.tmpT16cR0/main.rs:1:2137
  |
1 | ...s) , "2" => add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete...
  |                                          -------------  ^^^^^ no implementation for `() * ()`
  |                                          |
  |                                          required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `()`
note: required by a bound in `complete_task`
 --> /tmp/.tmpT16cR0/main.rs:1:1482
  |
1 | ...: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> ...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `complete_task`

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpT16cR0/main.rs:1:2137
  |
1 | ...> add_task (tasks) , "3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number)...
  |                                -------------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`
  |                                |
  |                                required by a bound introduced by this call
  |
note: required by a bound in `complete_task`
 --> /tmp/.tmpT16cR0/main.rs:1:1517
  |
1 | ...std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { l...
  |                                       ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `complete_task`

error[E0277]: cannot add `()` to `()`
 --> /tmp/.tmpT16cR0/main.rs:1:2167
  |
1 | ..."3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32...
  |                                            ----------  ^^^^^ no implementation for `() + ()`
  |                                            |
  |                                            required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `()`
note: required by a bound in `list_tasks`
 --> /tmp/.tmpT16cR0/main.rs:1:578
  |
1 | ...ent) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fm...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`

error[E0277]: cannot multiply `()` by `()`
 --> /tmp/.tmpT16cR0/main.rs:1:2167
  |
1 | ..."3" => complete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32...
  |                                            ----------  ^^^^^ no implementation for `() * ()`
  |                                            |
  |                                            required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `()`
note: required by a bound in `list_tasks`
 --> /tmp/.tmpT16cR0/main.rs:1:613
  |
1 | ...:: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) ->...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpT16cR0/main.rs:1:2167
  |
1 | ...lete_task (tasks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32 ; if index...
  |                                 ----------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`
  |                                 |
  |                                 required by a bound introduced by this call
  |
note: required by a bound in `list_tasks`
 --> /tmp/.tmpT16cR0/main.rs:1:648
  |
1 | ...+ std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty ()...
  |                                         ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`

error[E0425]: cannot find function `input` in this scope
 --> /tmp/.tmpT16cR0/main.rs:1:2190
  |
1 | ...asks) , "4" => { list_tasks (tasks) ; { let index = input ("Which task to delete? (number): ") . to_i () - 1i32 ; if index >= 0i32 && ...
  |                                                        ^^^^^ not found in this scope

error[E0599]: no method named `len` found for unit type `()` in the current scope
    --> /tmp/.tmpT16cR0/main.rs:1:2288
     |
1    | ...mber): ") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("...
     |                                                                     ^^^
     |
help: there is a method `le` with a similar name, but with different arguments
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1402:5
     |
1402 |     fn le(&self, other: &Rhs) -> bool {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `remove` found for unit type `()` in the current scope
 --> /tmp/.tmpT16cR0/main.rs:1:2307
  |
1 | ...ndex >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } ...
  |                                                       ^^^^^^ method not found in `()`

error[E0277]: cannot add `()` to `()`
 --> /tmp/.tmpT16cR0/main.rs:1:2336
  |
1 | ...s . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Go...
  |                                            ----------  ^^^^^ no implementation for `() + ()`
  |                                            |
  |                                            required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `()`
note: required by a bound in `save_tasks`
 --> /tmp/.tmpT16cR0/main.rs:1:336
  |
1 | ...c ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fm...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `save_tasks`

error[E0277]: cannot multiply `()` by `()`
 --> /tmp/.tmpT16cR0/main.rs:1:2336
  |
1 | ...s . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Go...
  |                                            ----------  ^^^^^ no implementation for `() * ()`
  |                                            |
  |                                            required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `()`
note: required by a bound in `save_tasks`
 --> /tmp/.tmpT16cR0/main.rs:1:371
  |
1 | ...:: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) ->...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `save_tasks`

error[E0277]: `()` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpT16cR0/main.rs:1:2336
  |
1 | ...{ { tasks . remove (index) ; save_tasks (tasks) ; println ! ("🗑\u{fe0f}  Task deleted!") } } } } , "5" => { println ! ("👋 Goodbye!") ; ...
  |                                 ----------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`
  |                                 |
  |                                 required by a bound introduced by this call
  |
note: required by a bound in `save_tasks`
 --> /tmp/.tmpT16cR0/main.rs:1:406
  |
1 | ...+ std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks ...
  |                                         ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `save_tasks`

error: aborting due to 42 previous errors; 7 warnings emitted

Some errors have detailed explanations: E0069, E0277, E0308, E0369, E0425, E0599, E0608.
For more information about an error, try `rustc --explain E0069`.



=== ch04-00-command-line-tools example 13 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpirISel/main.rs:1:79
  |
1 | fn main () { let result = { println ! ("Enter thing:") ; let thing = input () } ; if let Some (s) = (& result as & dyn std :: any :: Any)...
  |                                                                               ^ expected one of `.`, `;`, `?`, `else`, or an operator

error: aborting due to 1 previous error




=== ch04-00-command-line-tools example 14 ===
✗ Compilation failed: Compilation failed:
error: expected expression, found `let` statement
 --> /tmp/.tmpYj2TwG/main.rs:1:27
  |
1 | fn main () { let result = let data = read_file ("/Users/noah/Desktop/data.txt") ; if let Some (s) = (& result as & dyn std :: any :: Any)...
  |                           ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

error[E0425]: cannot find function `read_file` in this scope
 --> /tmp/.tmpYj2TwG/main.rs:1:38
  |
1 | fn main () { let result = let data = read_file ("/Users/noah/Desktop/data.txt") ; if let Some (s) = (& result as & dyn std :: any :: Any)...
  |                                      ^^^^^^^^^ not found in this scope

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0425`.



=== ch12-00-traits-generics example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 9 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch12-00-traits-generics example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 1 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpAc2q3E/main.rs:1:91
  |
1 | ... 24i32 ; let x = 42i32 ; let y = 24i32 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error: aborting due to 1 previous error




=== appendix-c-troubleshooting example 2 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 3 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 4 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmp8YYPD3/main.rs:1:81
  |
1 | ...ng" ; let x = 42i32 ; let x = "string" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

error: aborting due to 1 previous error




=== appendix-c-troubleshooting example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 6 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `takes_ownership` in this scope
 --> /tmp/.tmpxBdVWO/main.rs:1:64
  |
1 | fn main () { let result = { let s = String :: from ("hello") ; takes_ownership (s) ; println ! ("{}" , s) ; let s = String :: from ("hell...
  |                                                                ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `takes_ownership` in this scope
 --> /tmp/.tmpxBdVWO/main.rs:1:144
  |
1 | ..."{}" , s) ; let s = String :: from ("hello") ; takes_ownership (s . clone ()) ; println ! ("{}" , s) ; let s = String :: from ("hello"...
  |                                                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `borrows_value` in this scope
 --> /tmp/.tmpxBdVWO/main.rs:1:235
  |
1 | ...("{}" , s) ; let s = String :: from ("hello") ; borrows_value (& s) ; println ! ("{}" , s) } ; if let Some (s) = (& result as & dyn st...
  |                                                    ^^^^^^^^^^^^^ not found in this scope

error: aborting due to 3 previous errors

For more information about this error, try `rustc --explain E0425`.



=== appendix-c-troubleshooting example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 8 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 9 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpWK34cT/main.rs:1:304
  |
1 | ... if let Some (item) = v . get (5i32) { { println ! ("{} {}" , format ! ("Item: {{}}") , item) } } } ; if let Some (s) = (& result as &...
  |                                           ^^                                                    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { let result = { let v = vec ! [1i32 , 2i32 , 3i32] ; let item = v [5i32] ; let v = vec ! [1i32 , 2i32 , 3i32] ; match v . get (5i32) { Some (item) => println ! ("{} {}" , format ! ("Item: {{}}") , item) , None => println ! ("Index out of bounds") , } ; if let Some (item) = v . get (5i32) { { println ! ("{} {}" , format ! ("Item: {{}}") , item) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { let v = vec ! [1i32 , 2i32 , 3i32] ; let item = v [5i32] ; let v = vec ! [1i32 , 2i32 , 3i32] ; match v . get (5i32) { Some (item) => println ! ("{} {}" , format ! ("Item: {{}}") , item) , None => println ! ("Index out of bounds") , } ; if let Some (item) = v . get (5i32) { println ! ("{} {}" , format ! ("Item: {{}}") , item) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0277]: the type `[i32]` cannot be indexed by `i32`
 --> /tmp/.tmpWK34cT/main.rs:1:80
  |
1 | ...[1i32 , 2i32 , 3i32] ; let item = v [5i32] ; let v = vec ! [1i32 , 2i32 , 3i32] ; match v . get (5i32) { Some (item) => println ! ("{}...
  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`
  |
  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `Vec<i32>` to implement `Index<i32>`

error[E0277]: the type `[i32]` cannot be indexed by `i32`
   --> /tmp/.tmpWK34cT/main.rs:1:140
    |
1   | ...! [1i32 , 2i32 , 3i32] ; match v . get (5i32) { Some (item) => println ! ("{} {}" , format ! ("Item: {{}}") , item) , None => println ...
    |                                       ---  ^^^^ slice indices are of type `usize` or ranges of `usize`
    |                                       |
    |                                       required by a bound introduced by this call
    |
    = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
    = help: the following other types implement trait `SliceIndex<T>`:
              `usize` implements `SliceIndex<ByteStr>`
              `usize` implements `SliceIndex<[T]>`
note: required by a bound in `core::slice::<impl [T]>::get`
   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:573:12
    |
571 |     pub fn get<I>(&self, index: I) -> Option<&I::Output>
    |            --- required by a bound in this associated function
572 |     where
573 |         I: SliceIndex<Self>,
    |            ^^^^^^^^^^^^^^^^ required by this bound in `core::slice::<impl [T]>::get`

error[E0277]: the type `[i32]` cannot be indexed by `i32`
   --> /tmp/.tmpWK34cT/main.rs:1:296
    |
1   | ...s") , } ; if let Some (item) = v . get (5i32) { { println ! ("{} {}" , format ! ("Item: {{}}") , item) } } } ; if let Some (s) = (& re...
    |                                       ---  ^^^^ slice indices are of type `usize` or ranges of `usize`
    |                                       |
    |                                       required by a bound introduced by this call
    |
    = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
    = help: the following other types implement trait `SliceIndex<T>`:
              `usize` implements `SliceIndex<ByteStr>`
              `usize` implements `SliceIndex<[T]>`
note: required by a bound in `core::slice::<impl [T]>::get`
   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:573:12
    |
571 |     pub fn get<I>(&self, index: I) -> Option<&I::Output>
    |            --- required by a bound in this associated function
572 |     where
573 |         I: SliceIndex<Self>,
    |            ^^^^^^^^^^^^^^^^ required by this bound in `core::slice::<impl [T]>::get`

error: aborting due to 3 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0277`.



=== appendix-c-troubleshooting example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 11 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 13 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 14 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 15 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 16 ===
✗ Compilation failed: Compilation failed:
error[E0432]: unresolved import `std::collections::VecDeque`
 --> /tmp/.tmpJ7v0cG/main.rs:1:55
  |
1 | fn main () { let result = { use std :: collections :: VecDeque :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { ...
  |                                                       ^^^^^^^^ `VecDeque` is a struct, not a module

warning: unnecessary trailing semicolon
 --> /tmp/.tmpJ7v0cG/main.rs:1:78
  |
1 | fn main () { let result = { use std :: collections :: VecDeque :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { ...
  |                                                                              ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

warning: unnecessary braces around block return value
 --> /tmp/.tmpJ7v0cG/main.rs:1:138
  |
1 | ...ut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i...
  |                                                         ^^                        ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { let result = { use std :: collections :: VecDeque :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { use std :: collections :: VecDeque :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { list . insert (0i32 , i) } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpJ7v0cG/main.rs:1:235
  |
1 | ...que = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any...
  |                                                          ^^                      ^^
  |
help: remove these braces
  |
1 - fn main () { let result = { use std :: collections :: VecDeque :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1 + fn main () { let result = { use std :: collections :: VecDeque :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { deque . push_front (i) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
  |

error[E0308]: mismatched types
    --> /tmp/.tmpJ7v0cG/main.rs:1:155
     |
1    | ...ew () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { ...
     |                                                ------  ^^^^ expected `usize`, found `i32`
     |                                                |
     |                                                arguments to this method are incorrect
     |
note: method defined here
    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2034:12
     |
2034 |     pub fn insert(&mut self, index: usize, element: T) {
     |            ^^^^^^
help: change the type of the numeric literal from `i32` to `usize`
     |
1    - fn main () { let result = { use std :: collections :: VecDeque :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
1    + fn main () { let result = { use std :: collections :: VecDeque :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0usize , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! ("{}" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! ("{}" , s) ; } else { println ! ("{:?}" , result) ; } }
     |

error: aborting due to 2 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0308, E0432.
For more information about an error, try `rustc --explain E0308`.



=== appendix-c-troubleshooting example 17 ===
✗ Compilation failed: Failed to parse Ruchy source


=== appendix-c-troubleshooting example 18 ===
✗ Compilation failed: Failed to transpile to Rust


=== appendix-c-troubleshooting example 19 ===
✗ Compilation failed: Failed to transpile to Rust


=== appendix-c-troubleshooting example 20 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 1 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 2 ===

thread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:
"alice@email.com" is not a valid Ident
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


=== ch05-00-data-processing example 3 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpJy88NF/main.rs:1:411
  |
1 | ...} ; return groups } } } } fn main () { let total = numbers . sum () ; let average = numbers . sum () / numbers . len () ; let maximum ...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpJy88NF/main.rs:1:444
  |
1 | ... () { let total = numbers . sum () ; let average = numbers . sum () / numbers . len () ; let maximum = numbers . max () ; let minimum ...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpJy88NF/main.rs:1:463
  |
1 | ...umbers . sum () ; let average = numbers . sum () / numbers . len () ; let maximum = numbers . max () ; let minimum = numbers . min () ...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpJy88NF/main.rs:1:496
  |
1 | ...umbers . sum () / numbers . len () ; let maximum = numbers . max () ; let minimum = numbers . min () ; let high_value = transactions ....
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `numbers` in this scope
 --> /tmp/.tmpJy88NF/main.rs:1:529
  |
1 | ...) ; let maximum = numbers . max () ; let minimum = numbers . min () ; let high_value = transactions . filter (| t | t . amount > 100i3...
  |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `transactions` in this scope
 --> /tmp/.tmpJy88NF/main.rs:1:565
  |
1 | ...et minimum = numbers . min () ; let high_value = transactions . filter (| t | t . amount > 100i32) ; let customer_ids = transactions ....
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `transactions` in this scope
 --> /tmp/.tmpJy88NF/main.rs:1:636
  |
1 | ...(| t | t . amount > 100i32) ; let customer_ids = transactions . map (| t | t . customer) ; let amounts_only = transactions . map (| t ...
  |                                                     ^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `transactions` in this scope
 --> /tmp/.tmpJy88NF/main.rs:1:697
  |
1 | ... . map (| t | t . customer) ; let amounts_only = transactions . map (| t | t . amount) ; }
  |                                                     ^^^^^^^^^^^^ not found in this scope

warning: unnecessary braces around block return value
 --> /tmp/.tmpJy88NF/main.rs:1:182
  |
1 | ... { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } } } } ...
  |       ^^                                                                                                                                                                                                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } } } } fn main () { let total = numbers . sum () ; let average = numbers . sum () / numbers . len () ; let maximum = numbers . max () ; let minimum = numbers . min () ; let high_value = transactions . filter (| t | t . amount > 100i32) ; let customer_ids = transactions . map (| t | t . customer) ; let amounts_only = transactions . map (| t | t . amount) ; }
1 + fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } } } fn main () { let total = numbers . sum () ; let average = numbers . sum () / numbers . len () ; let maximum = numbers . max () ; let minimum = numbers . min () ; let high_value = transactions . filter (| t | t . amount > 100i32) ; let customer_ids = transactions . map (| t | t . customer) ; let amounts_only = transactions . map (| t | t . amount) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpJy88NF/main.rs:1:230
  |
1 | ... { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ...
  |       ^^                                                                                                                             ^^
  |
help: remove these braces
  |
1 - fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } } } } fn main () { let total = numbers . sum () ; let average = numbers . sum () / numbers . len () ; let maximum = numbers . max () ; let minimum = numbers . min () ; let high_value = transactions . filter (| t | t . amount > 100i32) ; let customer_ids = transactions . map (| t | t . customer) ; let amounts_only = transactions . map (| t | t . amount) ; }
1 + fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } ; return groups } } } } fn main () { let total = numbers . sum () ; let average = numbers . sum () / numbers . len () ; let maximum = numbers . max () ; let minimum = numbers . min () ; let high_value = transactions . filter (| t | t . amount > 100i32) ; let customer_ids = transactions . map (| t | t . customer) ; let amounts_only = transactions . map (| t | t . amount) ; }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpJy88NF/main.rs:1:293
  |
1 | ...y = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return gro...
  |                                                         ^^                       ^^
  |
help: remove these braces
  |
1 - fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } } } } fn main () { let total = numbers . sum () ; let average = numbers . sum () / numbers . len () ; let maximum = numbers . max () ; let minimum = numbers . min () ; let high_value = transactions . filter (| t | t . amount > 100i32) ; let customer_ids = transactions . map (| t | t . customer) ; let amounts_only = transactions . map (| t | t . amount) ; }
1 + fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { groups [key] = vec ! [] } ; groups [key] . push (record) } } } } ; return groups } } } } fn main () { let total = numbers . sum () ; let average = numbers . sum () / numbers . len () ; let maximum = numbers . max () ; let minimum = numbers . min () ; let high_value = transactions . filter (| t | t . amount > 100i32) ; let customer_ids = transactions . map (| t | t . customer) ; let amounts_only = transactions . map (| t | t . amount) ; }
  |

error[E0277]: `T` is not an iterator
 --> /tmp/.tmpJy88NF/main.rs:1:220
  |
1 | ...d : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups ...
  |                                                        ^^^^^^^ `T` is not an iterator
  |
  = note: required for `T` to implement `IntoIterator`
help: consider further restricting type parameter `T` with trait `Iterator`
  |
1 | fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } } } } fn main () { let total = numbers . sum () ; let average = numbers . sum () / numbers . len () ; let maximum = numbers . max () ; let minimum = numbers . min () ; let high_value = transactions . filter (| t | t . amount > 100i32) ; let customer_ids = transactions . map (| t | t . customer) ; let amounts_only = transactions . map (| t | t . amount) ; }
  |                                                                                                                                                   +++++++++++++++++++++

error[E0599]: no method named `has_key` found for unit type `()` in the current scope
 --> /tmp/.tmpJy88NF/main.rs:1:277
  |
1 | ...s { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } ...
  |                                                       ^^^^^^^ method not found in `()`

error[E0308]: mismatched types
 --> /tmp/.tmpJy88NF/main.rs:1:371
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } ...
  |       - expected this type parameter                                                                                                                               - expected `T` because of return type                                                                                                                                                            ^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: the caller chooses a type for `T` which can be different from `()`

error: aborting due to 11 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0425, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch05-00-data-processing example 4 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 5 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 6 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 7 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch05-00-data-processing example 8 ===
✗ Compilation failed: Compilation failed:
error: struct literal body without path
 --> /tmp/.tmpGQVlpN/main.rs:1:577
  |
1 | ...monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart...
  |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
help: you might have forgotten to add the struct literal inside the block
  |
1 | fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , "\n" + title) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let bar = "█" * bar_width . to_i () ; println ! ("{}" , key + " │" + bar + " " + value . to_s ()) } } } } } } } } fn main () { let monthly_sales = { SomeStruct { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } } ; draw_bar_chart (monthly_sales , "Monthly Sales Report") ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ++++++++++++                                                                                                       +

warning: unnecessary braces around block return value
 --> /tmp/.tmpGQVlpN/main.rs:1:372
  |
1 | ... { { { let bar_width = value * max_bar_width / max_value ; { let bar = "█" * bar_width . to_i () ; println ! ("{}" , key + " │" + bar + " " + value . to_s ()) } } } } ...
  |       ^^                                                                                                                                                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , "\n" + title) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let bar = "█" * bar_width . to_i () ; println ! ("{}" , key + " │" + bar + " " + value . to_s ()) } } } } } } } } fn main () { let monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart (monthly_sales , "Monthly Sales Report") ; }
1 + fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , "\n" + title) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; for (key , value) in data . items () { { let bar_width = value * max_bar_width / max_value ; { let bar = "█" * bar_width . to_i () ; println ! ("{}" , key + " │" + bar + " " + value . to_s ()) } } } } } } } fn main () { let monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart (monthly_sales , "Monthly Sales Report") ; }
  |

error[E0369]: cannot add `T` to `&str`
 --> /tmp/.tmpGQVlpN/main.rs:1:204
  |
1 | ...+ Clone > (data : T , title : T) -> T { { println ! ("{}" , "\n" + title) ; println ! ("{}" , "=" * title . len ()) ; { let max_value ...
  |                                                                ---- ^ ----- T
  |                                                                |
  |                                                                &str

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpGQVlpN/main.rs:1:247
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , "\n" + title) ; println ! ("{}" , "=" * title . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                                                  ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (data : T , title : T) -> T { { println ! ("{}" , "\n" + title) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let bar = "█" * bar_width . to_i () ; println ! ("{}" , key + " │" + bar + " " + value . to_s ()) } } } } } } } } fn main () { let monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart (monthly_sales , "Monthly Sales Report") ; }
  |                                                                                                                                                   +++++++++++++++++++

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpGQVlpN/main.rs:1:233
  |
1 | ...}" , "\n" + title) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i...
  |                                     --    ^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                                     |
  |                                     required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `values` found for type parameter `T` in the current scope
 --> /tmp/.tmpGQVlpN/main.rs:1:282
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , "\n" + title) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values ()...
  |       - method `values` not found for this type parameter                                                                                                                                                                                                                  ^^^^^^ method not found in `T`

error[E0599]: no method named `items` found for type parameter `T` in the current scope
 --> /tmp/.tmpGQVlpN/main.rs:1:361
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , "\n" + title) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; for (key , value) in data . items ()...
  |       - method `items` not found for this type parameter                                                                                                                                                                                                                                                                                                  ^^^^^ method not found in `T`

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpGQVlpN/main.rs:1:434
  |
1 | ...= value * max_bar_width / max_value ; { let bar = "█" * bar_width . to_i () ; println ! ("{}" , key + " │" + bar + " " + value . to_s ...
  |                                                ^^^ doesn't have a size known at compile-time
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: all local variables must have a statically known size

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpGQVlpN/main.rs:1:497
  |
1 | ...dth . to_i () ; println ! ("{}" , key + " │" + bar + " " + value . to_s ()) } } } } } } } } fn main () { let monthly_sales = { January...
  |                                                 ^ doesn't have a size known at compile-time
  |
  = help: the trait `Sized` is not implemented for `str`

error[E0308]: mismatched types
 --> /tmp/.tmpGQVlpN/main.rs:1:333
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , "\n" + title) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let bar = "█" * bar_width . to_i () ; println ! ("{}" , key + " │" + bar + " " + value . to_s ()) } } } } } ...
  |       - expected this type parameter                                                                                                                            - expected `T` because of return type                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
  |
  = note: expected type parameter `T`
                  found unit type `()`
  = note: the caller chooses a type for `T` which can be different from `()`
  = note: `for` loops evaluate to unit type `()`
help: consider returning a value here
  |
1 | fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! ("{}" , "\n" + title) ; println ! ("{}" , "=" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let bar = "█" * bar_width . to_i () ; println ! ("{}" , key + " │" + bar + " " + value . to_s ()) } } } } /* `T` value */ } } } } fn main () { let monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart (monthly_sales , "Monthly Sales Report") ; }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        +++++++++++++++

error: aborting due to 9 previous errors; 1 warning emitted

Some errors have detailed explanations: E0277, E0308, E0369, E0599.
For more information about an error, try `rustc --explain E0277`.



=== ch05-00-data-processing example 9 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find function `load_csv` in this scope
 --> /tmp/.tmpFRmcRT/main.rs:1:46
  |
1 | fn main () { let result = { let sales_data = load_csv ("sales.csv") ; let total = sales_data . map (| row | row . amount . to_f ()) . sum...
  |                                              ^^^^^^^^ not found in this scope

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> /tmp/.tmpFRmcRT/main.rs:1:206
  |
1 | ... . len () ; println ! ("{}" , "Average sale: $" + average . to_s ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . dow...
  |                            --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |                            |
  |                            required by this formatting parameter
  |
  = help: the trait `Sized` is not implemented for `str`
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0277, E0425.
For more information about an error, try `rustc --explain E0277`.



=== ch05-00-data-processing example 10 ===
✗ Compilation failed: Failed to parse Ruchy source


=== ch01-02-hello-world example 3 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpujmd5k/main.rs:1:14
  |
1 | fn main () { { { let name = "Alice" ; { println ! ("{} {}" , "Hello," , name) ; println ! ("{}" , "Hello, " + name + "!") } } } }
  |              ^^                                                                                                              ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { { { let name = "Alice" ; { println ! ("{} {}" , "Hello," , name) ; println ! ("{}" , "Hello, " + name + "!") } } } }
1 + fn main () { { let name = "Alice" ; { println ! ("{} {}" , "Hello," , name) ; println ! ("{}" , "Hello, " + name + "!") } } }
  |

error[E0369]: cannot add `&str` to `&str`
 --> /tmp/.tmpujmd5k/main.rs:1:109
  |
1 | fn main () { { { let name = "Alice" ; { println ! ("{} {}" , "Hello," , name) ; println ! ("{}" , "Hello, " + name + "!") } } } }
  |                                                                                                   --------- ^ ---- &str
  |                                                                                                   |         |
  |                                                                                                   |         `+` cannot be used to concatenate two `&str` strings
  |                                                                                                   &str
  |
  = note: string concatenation requires an owned `String` on the left
help: create an owned `String` from a string reference
  |
1 | fn main () { { { let name = "Alice" ; { println ! ("{} {}" , "Hello," , name) ; println ! ("{}" , "Hello, ".to_owned() + name + "!") } } } }
  |                                                                                                            +++++++++++

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0369`.



=== ch02-00-variables-types example 2 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmp3oKSGk/main.rs:1:14
  |
1 | ... { { { let first_name = "John" ; { let last_name = "Doe" ; let full_name = first_name + " " + last_name ; let score = 95i32 ; let percentage = 95.5f64 ; let temperature = - 10i32 ; let is_student = true ; let has_graduated = false ; let is_enrolled = ! has_graduated ; println ! ("{} {}" , "Student:" , full_name) ; println ! ("{} {} {} {} {}" , "Score:" , score , "(" , percentage , "%)") ; println ! ("{} {} {}" , "Temperature:" , temperature , "°C") ; println ! ("{} {} {} {}" , "Status: student=" , is_student , ", graduated=" , has_graduated) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { { { let first_name = "John" ; { let last_name = "Doe" ; let full_name = first_name + " " + last_name ; let score = 95i32 ; let percentage = 95.5f64 ; let temperature = - 10i32 ; let is_student = true ; let has_graduated = false ; let is_enrolled = ! has_graduated ; println ! ("{} {}" , "Student:" , full_name) ; println ! ("{} {} {} {} {}" , "Score:" , score , "(" , percentage , "%)") ; println ! ("{} {} {}" , "Temperature:" , temperature , "°C") ; println ! ("{} {} {} {}" , "Status: student=" , is_student , ", graduated=" , has_graduated) } } } }
1 + fn main () { { let first_name = "John" ; { let last_name = "Doe" ; let full_name = first_name + " " + last_name ; let score = 95i32 ; let percentage = 95.5f64 ; let temperature = - 10i32 ; let is_student = true ; let has_graduated = false ; let is_enrolled = ! has_graduated ; println ! ("{} {}" , "Student:" , full_name) ; println ! ("{} {} {} {} {}" , "Score:" , score , "(" , percentage , "%)") ; println ! ("{} {} {}" , "Temperature:" , temperature , "°C") ; println ! ("{} {} {} {}" , "Status: student=" , is_student , ", graduated=" , has_graduated) } } }
  |

error[E0369]: cannot add `&str` to `&str`
 --> /tmp/.tmp3oKSGk/main.rs:1:97
  |
1 | ...st_name = "Doe" ; let full_name = first_name + " " + last_name ; let score = 95i32 ; let percentage = 95.5f64 ; let temperature = - 10...
  |                                      ---------- ^ --- &str
  |                                      |          |
  |                                      |          `+` cannot be used to concatenate two `&str` strings
  |                                      &str
  |
  = note: string concatenation requires an owned `String` on the left
help: create an owned `String` from a string reference
  |
1 | fn main () { { { let first_name = "John" ; { let last_name = "Doe" ; let full_name = first_name.to_owned() + " " + last_name ; let score = 95i32 ; let percentage = 95.5f64 ; let temperature = - 10i32 ; let is_student = true ; let has_graduated = false ; let is_enrolled = ! has_graduated ; println ! ("{} {}" , "Student:" , full_name) ; println ! ("{} {} {} {} {}" , "Score:" , score , "(" , percentage , "%)") ; println ! ("{} {} {}" , "Temperature:" , temperature , "°C") ; println ! ("{} {} {} {}" , "Status: student=" , is_student , ", graduated=" , has_graduated) } } } }
  |                                                                                                +++++++++++

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0369`.



=== ch02-00-variables-types example 4 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmp5zdn93/main.rs:1:14
  |
1 | ... { { { let favorite_languages = vec ! ["Python" , "Rust" , "Ruchy"] ; { let daily_temperatures = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let task_completed = vec ! [true , false , true , true] ; println ! ("{} {}" , "First language:" , favorite_languages [0i32]) ; println ! ("{} {} {}" , "Today's temp:" , daily_temperatures [0i32] , "°C") ; println ! ("{} {} {}" , "I know" , favorite_languages . len () , "languages") } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                         ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { { { let favorite_languages = vec ! ["Python" , "Rust" , "Ruchy"] ; { let daily_temperatures = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let task_completed = vec ! [true , false , true , true] ; println ! ("{} {}" , "First language:" , favorite_languages [0i32]) ; println ! ("{} {} {}" , "Today's temp:" , daily_temperatures [0i32] , "°C") ; println ! ("{} {} {}" , "I know" , favorite_languages . len () , "languages") } } } }
1 + fn main () { { let favorite_languages = vec ! ["Python" , "Rust" , "Ruchy"] ; { let daily_temperatures = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let task_completed = vec ! [true , false , true , true] ; println ! ("{} {}" , "First language:" , favorite_languages [0i32]) ; println ! ("{} {} {}" , "Today's temp:" , daily_temperatures [0i32] , "°C") ; println ! ("{} {} {}" , "I know" , favorite_languages . len () , "languages") } } }
  |

error[E0277]: the type `[&str]` cannot be indexed by `i32`
 --> /tmp/.tmp5zdn93/main.rs:1:273
  |
1 | ...rst language:" , favorite_languages [0i32]) ; println ! ("{} {} {}" , "Today's temp:" , daily_temperatures [0i32] , "°C") ; println ! ...
  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`
  |
  = help: the trait `SliceIndex<[&str]>` is not implemented for `i32`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `Vec<&str>` to implement `Index<i32>`

error[E0277]: the type `[f64]` cannot be indexed by `i32`
 --> /tmp/.tmp5zdn93/main.rs:1:344
  |
1 | ...Today's temp:" , daily_temperatures [0i32] , "°C") ; println ! ("{} {} {}" , "I know" , favorite_languages . len () , "languages") } }...
  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`
  |
  = help: the trait `SliceIndex<[f64]>` is not implemented for `i32`
  = help: the following other types implement trait `SliceIndex<T>`:
            `usize` implements `SliceIndex<ByteStr>`
            `usize` implements `SliceIndex<[T]>`
  = note: required for `Vec<f64>` to implement `Index<i32>`

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0277`.



=== ch02-00-variables-types example 5 ===
✗ Compilation failed: Compilation failed:
error[E0425]: cannot find value `user_name` in this scope
 --> /tmp/.tmpHrSuTU/main.rs:1:16
  |
1 | fn main () { { user_name = "Alice" } }
  |                ^^^^^^^^^ not found in this scope

warning: unnecessary braces around block return value
 --> /tmp/.tmpHrSuTU/main.rs:1:14
  |
1 | fn main () { { user_name = "Alice" } }
  |              ^^                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { { user_name = "Alice" } }
1 + fn main () { user_name = "Alice" }
  |

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0425`.



=== ch02-00-variables-types example 6 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpLTN9sl/main.rs:1:62
  |
1 | fn main () { { { let age = "25" ; let next_year = age + 1i32 } } }
  |                                                              ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unnecessary braces around block return value
 --> /tmp/.tmpLTN9sl/main.rs:1:14
  |
1 | fn main () { { { let age = "25" ; let next_year = age + 1i32 } } }
  |              ^^                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { { { let age = "25" ; let next_year = age + 1i32 } } }
1 + fn main () { { let age = "25" ; let next_year = age + 1i32 } }
  |

error: aborting due to 1 previous error; 1 warning emitted




=== ch02-00-variables-types example 9 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmphJGyV3/main.rs:1:14
  |
1 | ... { { { let name = "Alex" ; { let age = 28i32 ; let city = "San Francisco" ; let hobby = "rock climbing" ; let goal = "master Ruchy in 30 days" ; let num1 = 15i32 ; let num2 = 25i32 ; let sum = num1 + num2 ; let difference = num1 - num2 ; let average = num1 + num2 / 2i32 ; let first_name = "Alex" ; let last_name = "Johnson" ; let username = first_name + "_" + last_name ; let email = username + "@example.com" ; let is_adult = age >= 18i32 ; let lives_in_tech_city = city == "San Francisco" ; let ready_for_job = is_adult && lives_in_tech_city ; println ! ("{} {} {} {}" , "Profile:" , name , age , city) ; println ! ("{} {} {} {}" , "Math:" , sum , difference , average) ; println ! ("{} {} {}" , "Contact:" , username , email) ; println ! ("{} {} {} {}" , "Status:" , is_adult , lives_in_tech_city , ready_for_job) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { { { let name = "Alex" ; { let age = 28i32 ; let city = "San Francisco" ; let hobby = "rock climbing" ; let goal = "master Ruchy in 30 days" ; let num1 = 15i32 ; let num2 = 25i32 ; let sum = num1 + num2 ; let difference = num1 - num2 ; let average = num1 + num2 / 2i32 ; let first_name = "Alex" ; let last_name = "Johnson" ; let username = first_name + "_" + last_name ; let email = username + "@example.com" ; let is_adult = age >= 18i32 ; let lives_in_tech_city = city == "San Francisco" ; let ready_for_job = is_adult && lives_in_tech_city ; println ! ("{} {} {} {}" , "Profile:" , name , age , city) ; println ! ("{} {} {} {}" , "Math:" , sum , difference , average) ; println ! ("{} {} {}" , "Contact:" , username , email) ; println ! ("{} {} {} {}" , "Status:" , is_adult , lives_in_tech_city , ready_for_job) } } } }
1 + fn main () { { let name = "Alex" ; { let age = 28i32 ; let city = "San Francisco" ; let hobby = "rock climbing" ; let goal = "master Ruchy in 30 days" ; let num1 = 15i32 ; let num2 = 25i32 ; let sum = num1 + num2 ; let difference = num1 - num2 ; let average = num1 + num2 / 2i32 ; let first_name = "Alex" ; let last_name = "Johnson" ; let username = first_name + "_" + last_name ; let email = username + "@example.com" ; let is_adult = age >= 18i32 ; let lives_in_tech_city = city == "San Francisco" ; let ready_for_job = is_adult && lives_in_tech_city ; println ! ("{} {} {} {}" , "Profile:" , name , age , city) ; println ! ("{} {} {} {}" , "Math:" , sum , difference , average) ; println ! ("{} {} {}" , "Contact:" , username , email) ; println ! ("{} {} {} {}" , "Status:" , is_adult , lives_in_tech_city , ready_for_job) } } }
  |

error[E0369]: cannot add `&str` to `&str`
 --> /tmp/.tmphJGyV3/main.rs:1:364
  |
1 | ...name = "Johnson" ; let username = first_name + "_" + last_name ; let email = username + "@example.com" ; let is_adult = age >= 18i32 ;...
  |                                      ---------- ^ --- &str
  |                                      |          |
  |                                      |          `+` cannot be used to concatenate two `&str` strings
  |                                      &str
  |
  = note: string concatenation requires an owned `String` on the left
help: create an owned `String` from a string reference
  |
1 | fn main () { { { let name = "Alex" ; { let age = 28i32 ; let city = "San Francisco" ; let hobby = "rock climbing" ; let goal = "master Ruchy in 30 days" ; let num1 = 15i32 ; let num2 = 25i32 ; let sum = num1 + num2 ; let difference = num1 - num2 ; let average = num1 + num2 / 2i32 ; let first_name = "Alex" ; let last_name = "Johnson" ; let username = first_name.to_owned() + "_" + last_name ; let email = username + "@example.com" ; let is_adult = age >= 18i32 ; let lives_in_tech_city = city == "San Francisco" ; let ready_for_job = is_adult && lives_in_tech_city ; println ! ("{} {} {} {}" , "Profile:" , name , age , city) ; println ! ("{} {} {} {}" , "Math:" , sum , difference , average) ; println ! ("{} {} {}" , "Contact:" , username , email) ; println ! ("{} {} {} {}" , "Status:" , is_adult , lives_in_tech_city , ready_for_job) } } } }
  |                                                                                                                                                                                                                                                                                                                                                                           +++++++++++

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0369`.



=== ch03-00-functions example 1 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpsI4u9w/main.rs:1:14
  |
1 | ... { { { let name = "Alice" ; { let a = 15i32 ; let b = 27i32 ; let greeting = "Hello, " + name + "! Welcome to Ruchy!" ; let sum = a + b ; let result_message = a + " + " + b + " = " + sum ; println ! ("{}" , greeting) ; println ! ("{}" , result_message) } } } }
  |       ^^                                                                                                                                                                                                                                                           ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { { { let name = "Alice" ; { let a = 15i32 ; let b = 27i32 ; let greeting = "Hello, " + name + "! Welcome to Ruchy!" ; let sum = a + b ; let result_message = a + " + " + b + " = " + sum ; println ! ("{}" , greeting) ; println ! ("{}" , result_message) } } } }
1 + fn main () { { let name = "Alice" ; { let a = 15i32 ; let b = 27i32 ; let greeting = "Hello, " + name + "! Welcome to Ruchy!" ; let sum = a + b ; let result_message = a + " + " + b + " = " + sum ; println ! ("{}" , greeting) ; println ! ("{}" , result_message) } } }
  |

error[E0369]: cannot add `&str` to `&str`
 --> /tmp/.tmpsI4u9w/main.rs:1:98
  |
1 | ...2 ; let b = 27i32 ; let greeting = "Hello, " + name + "! Welcome to Ruchy!" ; let sum = a + b ; let result_message = a + " + " + b + "...
  |                                       --------- ^ ---- &str
  |                                       |         |
  |                                       |         `+` cannot be used to concatenate two `&str` strings
  |                                       &str
  |
  = note: string concatenation requires an owned `String` on the left
help: create an owned `String` from a string reference
  |
1 | fn main () { { { let name = "Alice" ; { let a = 15i32 ; let b = 27i32 ; let greeting = "Hello, ".to_owned() + name + "! Welcome to Ruchy!" ; let sum = a + b ; let result_message = a + " + " + b + " = " + sum ; println ! ("{}" , greeting) ; println ! ("{}" , result_message) } } } }
  |                                                                                                 +++++++++++

error[E0277]: cannot add `&str` to `i32`
 --> /tmp/.tmpsI4u9w/main.rs:1:172
  |
1 | ...chy!" ; let sum = a + b ; let result_message = a + " + " + b + " = " + sum ; println ! ("{}" , greeting) ; println ! ("{}" , result_me...
  |                                                     ^ no implementation for `i32 + &str`
  |
  = help: the trait `Add<&str>` is not implemented for `i32`
  = help: the following other types implement trait `Add<Rhs>`:
            `&i32` implements `Add<i32>`
            `&i32` implements `Add`
            `i32` implements `Add<&i32>`
            `i32` implements `Add`

error: aborting due to 2 previous errors; 1 warning emitted

Some errors have detailed explanations: E0277, E0369.
For more information about an error, try `rustc --explain E0277`.



=== ch03-00-functions example 2 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpTB3jJR/main.rs:1:14
  |
1 | ... { { { let input1 = 10i32 ; { let input2 = 20i32 ; let sum = input1 + input2 ; let product = input1 * input2 ; let average = sum / 2i32 ; let result = "Sum: " + sum + ", Product: " + product + ", Average: " + average ; println ! ("{}" , result) } } } }
  |       ^^                                                                                                                                                                                                                                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { { { let input1 = 10i32 ; { let input2 = 20i32 ; let sum = input1 + input2 ; let product = input1 * input2 ; let average = sum / 2i32 ; let result = "Sum: " + sum + ", Product: " + product + ", Average: " + average ; println ! ("{}" , result) } } } }
1 + fn main () { { let input1 = 10i32 ; { let input2 = 20i32 ; let sum = input1 + input2 ; let product = input1 * input2 ; let average = sum / 2i32 ; let result = "Sum: " + sum + ", Product: " + product + ", Average: " + average ; println ! ("{}" , result) } } }
  |

error[E0369]: cannot add `i32` to `&str`
 --> /tmp/.tmpTB3jJR/main.rs:1:170
  |
1 | ...input1 * input2 ; let average = sum / 2i32 ; let result = "Sum: " + sum + ", Product: " + product + ", Average: " + average ; println ...
  |                                                              ------- ^ --- i32
  |                                                              |
  |                                                              &str

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0369`.



=== ch03-00-functions example 3 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpK86ao4/main.rs:1:14
  |
1 | ... { { { let user_name = "Alice" ; { let greeting_template = "Hello, " + user_name + "! Welcome!" ; let num1 = 15i32 ; let num2 = 27i32 ; let operation = "addition" ; let calc_result = num1 + num2 ; let calc_display = operation + ": " + num1 + " + " + num2 + " = " + calc_result ; println ! ("{}" , greeting_template) ; println ! ("{}" , calc_display) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                            ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { { { let user_name = "Alice" ; { let greeting_template = "Hello, " + user_name + "! Welcome!" ; let num1 = 15i32 ; let num2 = 27i32 ; let operation = "addition" ; let calc_result = num1 + num2 ; let calc_display = operation + ": " + num1 + " + " + num2 + " = " + calc_result ; println ! ("{}" , greeting_template) ; println ! ("{}" , calc_display) } } } }
1 + fn main () { { let user_name = "Alice" ; { let greeting_template = "Hello, " + user_name + "! Welcome!" ; let num1 = 15i32 ; let num2 = 27i32 ; let operation = "addition" ; let calc_result = num1 + num2 ; let calc_display = operation + ": " + num1 + " + " + num2 + " = " + calc_result ; println ! ("{}" , greeting_template) ; println ! ("{}" , calc_display) } } }
  |

error[E0369]: cannot add `&str` to `&str`
 --> /tmp/.tmpK86ao4/main.rs:1:80
  |
1 | fn main () { { { let user_name = "Alice" ; { let greeting_template = "Hello, " + user_name + "! Welcome!" ; let num1 = 15i32 ; let num2 =...
  |                                                                      --------- ^ --------- &str
  |                                                                      |         |
  |                                                                      |         `+` cannot be used to concatenate two `&str` strings
  |                                                                      &str
  |
  = note: string concatenation requires an owned `String` on the left
help: create an owned `String` from a string reference
  |
1 | fn main () { { { let user_name = "Alice" ; { let greeting_template = "Hello, ".to_owned() + user_name + "! Welcome!" ; let num1 = 15i32 ; let num2 = 27i32 ; let operation = "addition" ; let calc_result = num1 + num2 ; let calc_display = operation + ": " + num1 + " + " + num2 + " = " + calc_result ; println ! ("{}" , greeting_template) ; println ! ("{}" , calc_display) } } } }
  |                                                                               +++++++++++

error[E0369]: cannot add `&str` to `&str`
 --> /tmp/.tmpK86ao4/main.rs:1:237
  |
1 | ...= num1 + num2 ; let calc_display = operation + ": " + num1 + " + " + num2 + " = " + calc_result ; println ! ("{}" , greeting_template)...
  |                                       --------- ^ ---- &str
  |                                       |         |
  |                                       |         `+` cannot be used to concatenate two `&str` strings
  |                                       &str
  |
  = note: string concatenation requires an owned `String` on the left
help: create an owned `String` from a string reference
  |
1 | fn main () { { { let user_name = "Alice" ; { let greeting_template = "Hello, " + user_name + "! Welcome!" ; let num1 = 15i32 ; let num2 = 27i32 ; let operation = "addition" ; let calc_result = num1 + num2 ; let calc_display = operation.to_owned() + ": " + num1 + " + " + num2 + " = " + calc_result ; println ! ("{}" , greeting_template) ; println ! ("{}" , calc_display) } } } }
  |                                                                                                                                                                                                                                            +++++++++++

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0369`.



=== ch03-00-functions example 4 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmp5bNpak/main.rs:1:14
  |
1 | ... { { { let temperature_f = 68i32 ; { let user_location = "San Francisco" ; let temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let weather_report = "Weather in " + user_location + ": " + temperature_f + "°F (" + temperature_c + "°C)" ; let comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{}" , weather_report) ; println ! ("{}" , comfort_message) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn main () { { { let temperature_f = 68i32 ; { let user_location = "San Francisco" ; let temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let weather_report = "Weather in " + user_location + ": " + temperature_f + "°F (" + temperature_c + "°C)" ; let comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{}" , weather_report) ; println ! ("{}" , comfort_message) } } } }
1 + fn main () { { let temperature_f = 68i32 ; { let user_location = "San Francisco" ; let temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let weather_report = "Weather in " + user_location + ": " + temperature_f + "°F (" + temperature_c + "°C)" ; let comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{}" , weather_report) ; println ! ("{}" , comfort_message) } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp5bNpak/main.rs:1:365
  |
1 | ...e_c + "°C)" ; let comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{}" , ...
  |                                                            ^^                  ^^
  |
help: remove these braces
  |
1 - fn main () { { { let temperature_f = 68i32 ; { let user_location = "San Francisco" ; let temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let weather_report = "Weather in " + user_location + ": " + temperature_f + "°F (" + temperature_c + "°C)" ; let comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{}" , weather_report) ; println ! ("{}" , comfort_message) } } } }
1 + fn main () { { { let temperature_f = 68i32 ; { let user_location = "San Francisco" ; let temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let weather_report = "Weather in " + user_location + ": " + temperature_f + "°F (" + temperature_c + "°C)" ; let comfort_message = if is_comfortable { "Perfect weather!" } else { { "Dress accordingly" } } ; println ! ("{}" , weather_report) ; println ! ("{}" , comfort_message) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp5bNpak/main.rs:1:397
  |
1 | ... = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{}" , weather_report) ; println ! ("{}"...
  |                                                           ^^                   ^^
  |
help: remove these braces
  |
1 - fn main () { { { let temperature_f = 68i32 ; { let user_location = "San Francisco" ; let temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let weather_report = "Weather in " + user_location + ": " + temperature_f + "°F (" + temperature_c + "°C)" ; let comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{}" , weather_report) ; println ! ("{}" , comfort_message) } } } }
1 + fn main () { { { let temperature_f = 68i32 ; { let user_location = "San Francisco" ; let temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let weather_report = "Weather in " + user_location + ": " + temperature_f + "°F (" + temperature_c + "°C)" ; let comfort_message = if is_comfortable { { "Perfect weather!" } } else { "Dress accordingly" } ; println ! ("{}" , weather_report) ; println ! ("{}" , comfort_message) } } } }
  |

error[E0369]: cannot add `&str` to `&str`
 --> /tmp/.tmp5bNpak/main.rs:1:249
  |
1 | ...c < 25i32 ; let weather_report = "Weather in " + user_location + ": " + temperature_f + "°F (" + temperature_c + "°C)" ; let comfort_m...
  |                                     ------------- ^ ------------- &str
  |                                     |             |
  |                                     |             `+` cannot be used to concatenate two `&str` strings
  |                                     &str
  |
  = note: string concatenation requires an owned `String` on the left
help: create an owned `String` from a string reference
  |
1 | fn main () { { { let temperature_f = 68i32 ; { let user_location = "San Francisco" ; let temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let weather_report = "Weather in ".to_owned() + user_location + ": " + temperature_f + "°F (" + temperature_c + "°C)" ; let comfort_message = if is_comfortable { { "Perfect weather!" } } else { { "Dress accordingly" } } ; println ! ("{}" , weather_report) ; println ! ("{}" , comfort_message) } } } }
  |                                                                                                                                                                                                                                                        +++++++++++

error: aborting due to 1 previous error; 3 warnings emitted

For more information about this error, try `rustc --explain E0369`.



=== ch03-00-functions example 5 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpuj3bIl/main.rs:1:156
  |
1 | ...fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std ...
  |                                                                  ^^     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + "_" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + "!!!" } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" , "Johnson") ; let excited = shout ("I love functions") ; println ! ("{} {}" , "Circle area:" , area) ; println ! ("{} {}" , "Username:" , username) ; println ! ("{}" , excited) } } } }
1 + fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { x * x } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + "_" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + "!!!" } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" , "Johnson") ; let excited = shout ("I love functions") ; println ! ("{} {}" , "Circle area:" , area) ; println ! ("{} {}" , "Username:" , username) ; println ! ("{}" , excited) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpuj3bIl/main.rs:1:333
  |
1 | ...mt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Ad...
  |                                              ^^                                              ^^
  |
help: remove these braces
  |
1 - fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + "_" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + "!!!" } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" , "Johnson") ; let excited = shout ("I love functions") ; println ! ("{} {}" , "Circle area:" , area) ; println ! ("{} {}" , "Username:" , username) ; println ! ("{}" , excited) } } } }
1 + fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { let pi = 3.14159f64 ; pi * square (radius) } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + "_" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + "!!!" } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" , "Johnson") ; let excited = shout ("I love functions") ; println ! ("{} {}" , "Circle area:" , area) ; println ! ("{} {}" , "Username:" , username) ; println ! ("{}" , excited) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpuj3bIl/main.rs:1:573
  |
1 | ... + Clone > (first_name : T , last_name : T) -> T { { first_name + "_" + last_name } } fn shout < T : std :: ops :: Add < Output = T > ...
  |                                                       ^^                            ^^
  |
help: remove these braces
  |
1 - fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + "_" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + "!!!" } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" , "Johnson") ; let excited = shout ("I love functions") ; println ! ("{} {}" , "Circle area:" , area) ; println ! ("{} {}" , "Username:" , username) ; println ! ("{}" , excited) } } } }
1 + fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { first_name + "_" + last_name } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + "!!!" } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" , "Johnson") ; let excited = shout ("I love functions") ; println ! ("{} {}" , "Circle area:" , area) ; println ! ("{} {}" , "Username:" , username) ; println ! ("{}" , excited) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpuj3bIl/main.rs:1:768
  |
1 | ...lay + std :: fmt :: Debug + Clone > (message : T) -> T { { message + "!!!" } } fn main () { { { let area = circle_area (5i32) ; { let ...
  |                                                             ^^               ^^
  |
help: remove these braces
  |
1 - fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + "_" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + "!!!" } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" , "Johnson") ; let excited = shout ("I love functions") ; println ! ("{} {}" , "Circle area:" , area) ; println ! ("{} {}" , "Username:" , username) ; println ! ("{}" , excited) } } } }
1 + fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + "_" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { message + "!!!" } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" , "Johnson") ; let excited = shout ("I love functions") ; println ! ("{} {}" , "Circle area:" , area) ; println ! ("{} {}" , "Username:" , username) ; println ! ("{}" , excited) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpuj3bIl/main.rs:1:803
  |
1 | ... { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" , "Johnson") ; let excited = shout ("I love functions") ; println ! ("{} {}" , "Circle area:" , area) ; println ! ("{} {}" , "Username:" , username) ; println ! ("{}" , excited) } } } }
  |       ^^                                                                                                                                                                                                                                                               ^^
  |
help: remove these braces
  |
1 - fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + "_" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + "!!!" } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" , "Johnson") ; let excited = shout ("I love functions") ; println ! ("{} {}" , "Circle area:" , area) ; println ! ("{} {}" , "Username:" , username) ; println ! ("{}" , excited) } } } }
1 + fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + "_" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + "!!!" } } fn main () { { let area = circle_area (5i32) ; { let username = make_username ("Alice" , "Johnson") ; let excited = shout ("I love functions") ; println ! ("{} {}" , "Circle area:" , area) ; println ! ("{} {}" , "Username:" , username) ; println ! ("{}" , excited) } } }
  |

error[E0277]: cannot multiply `f64` by `T`
 --> /tmp/.tmpuj3bIl/main.rs:1:362
  |
1 | ... (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + st...
  |                                                      ^ no implementation for `f64 * T`
  |
  = help: the trait `Mul<T>` is not implemented for `f64`
help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement
  |
1 | fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T where f64: Mul<T> { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + "_" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + "!!!" } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" , "Johnson") ; let excited = shout ("I love functions") ; println ! ("{} {}" , "Circle area:" , area) ; println ! ("{} {}" , "Username:" , username) ; println ! ("{}" , excited) } } } }
  |                                                                                                                                                                                                                                                                                                                                           +++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpuj3bIl/main.rs:1:588
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + "_" + ...
  |       -                                                                                                                                                                         ----------   ^^^ expected type parameter `T`, found `&str`
  |       |                                                                                                                                                                         |
  |       expected this type parameter                                                                                                                                              expected because this is `T`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`

error[E0308]: mismatched types
 --> /tmp/.tmpuj3bIl/main.rs:1:780
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + "!!!" } ...
  |       -                                                                                                                                                      -------   ^^^^^ expected type parameter `T`, found `&str`
  |       |                                                                                                                                                      |
  |       expected this type parameter                                                                                                                           expected because this is `T`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`

error[E0277]: cannot add `&str` to `&str`
 --> /tmp/.tmpuj3bIl/main.rs:1:856
  |
1 | ...a = circle_area (5i32) ; { let username = make_username ("Alice" , "Johnson") ; let excited = shout ("I love functions") ; println ! (...
  |                                              ^^^^^^^^^^^^^ no implementation for `&str + &str`
  |
  = help: the trait `Add<&str>` is not implemented for `&str`
          but it is implemented for `String`
  = help: for that trait implementation, expected `String`, found `&str`
note: required by a bound in `make_username`
 --> /tmp/.tmpuj3bIl/main.rs:1:409
  |
1 | ... } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `make_username`

error[E0277]: cannot multiply `&str` by `&str`
 --> /tmp/.tmpuj3bIl/main.rs:1:856
  |
1 | ...a = circle_area (5i32) ; { let username = make_username ("Alice" , "Johnson") ; let excited = shout ("I love functions") ; println ! (...
  |                                              ^^^^^^^^^^^^^ no implementation for `&str * &str`
  |
  = help: the trait `Mul` is not implemented for `&str`
note: required by a bound in `make_username`
 --> /tmp/.tmpuj3bIl/main.rs:1:444
  |
1 | ...: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `make_username`

error[E0277]: cannot add `&str` to `&str`
 --> /tmp/.tmpuj3bIl/main.rs:1:915
  |
1 | ...Alice" , "Johnson") ; let excited = shout ("I love functions") ; println ! ("{} {}" , "Circle area:" , area) ; println ! ("{} {}" , "U...
  |                                        -----  ^^^^^^^^^^^^^^^^^^ no implementation for `&str + &str`
  |                                        |
  |                                        required by a bound introduced by this call
  |
  = help: the trait `Add<&str>` is not implemented for `&str`
          but it is implemented for `String`
  = help: for that trait implementation, expected `String`, found `&str`
note: required by a bound in `shout`
 --> /tmp/.tmpuj3bIl/main.rs:1:623
  |
1 | ..._" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std ::...
  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `shout`

error[E0277]: cannot multiply `&str` by `&str`
 --> /tmp/.tmpuj3bIl/main.rs:1:915
  |
1 | ...Alice" , "Johnson") ; let excited = shout ("I love functions") ; println ! ("{} {}" , "Circle area:" , area) ; println ! ("{} {}" , "U...
  |                                        -----  ^^^^^^^^^^^^^^^^^^ no implementation for `&str * &str`
  |                                        |
  |                                        required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `&str`
note: required by a bound in `shout`
 --> /tmp/.tmpuj3bIl/main.rs:1:658
  |
1 | ...td :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : ...
  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `shout`

error[E0382]: use of moved value: `x`
   --> /tmp/.tmpuj3bIl/main.rs:1:162
    |
1   | ...: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output...
    |                              -               ----^
    |                              |               |   |
    |                              |               |   value used here after move
    |                              |               `x` moved due to usage in operator
    |                              move occurs because `x` has type `T`, which does not implement the `Copy` trait
    |
note: calling this operator moves the left-hand side
   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/arith.rs:333:12
    |
333 |     fn mul(self, rhs: Rhs) -> Self::Output;
    |            ^^^^
help: consider cloning the value if the performance cost is acceptable
    |
1   | fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x.clone() * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + "_" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + "!!!" } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" , "Johnson") ; let excited = shout ("I love functions") ; println ! ("{} {}" , "Circle area:" , area) ; println ! ("{} {}" , "Username:" , username) ; println ! ("{}" , excited) } } } }
    |                                                                                                                                                               ++++++++
help: consider further restricting type parameter `T` with trait `Copy`
    |
1   | fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + Copy > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + "_" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + "!!!" } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username ("Alice" , "Johnson") ; let excited = shout ("I love functions") ; println ! ("{} {}" , "Circle area:" , area) ; println ! ("{} {}" , "Username:" , username) ; println ! ("{}" , excited) } } } }
    |                                                                                                                                           ++++++

error: aborting due to 8 previous errors; 5 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0382.
For more information about an error, try `rustc --explain E0277`.



=== ch03-00-functions example 6 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmp02ck2E/main.rs:1:162
  |
1 | ...y + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T...
  |                                                          ^^                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { number % 2i32 == 0i32 } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp02ck2E/main.rs:1:355
  |
1 | ... { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } ...
  |       ^^                                                                                                                                                                   ^^
  |
help: remove these braces
  |
1 - fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp02ck2E/main.rs:1:377
  |
1 | ...mt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { "A" } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp02ck2E/main.rs:1:414
  |
1 | ...T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { "B" } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp02ck2E/main.rs:1:451
  |
1 | ...lse { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } }...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { "C" } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp02ck2E/main.rs:1:488
  |
1 | ...lse { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: op...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { "D" } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp02ck2E/main.rs:1:505
  |
1 | ... 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output...
  |                                                                   ^^   ^^
  |
help: remove these braces
  |
1 - fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { "F" } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp02ck2E/main.rs:1:689
  |
1 | ... { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } ...
  |       ^^                                                                                                                                                                                          ^^
  |
help: remove these braces
  |
1 - fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp02ck2E/main.rs:1:725
  |
1 | ... + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large"...
  |                                                                  ^^      ^^
  |
help: remove these braces
  |
1 - fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { "even" } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp02ck2E/main.rs:1:745
  |
1 | ...> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small...
  |                                                                  ^^     ^^
  |
help: remove these braces
  |
1 - fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { "odd" } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp02ck2E/main.rs:1:788
  |
1 | ..."even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd...
  |                                                                 ^^       ^^
  |
help: remove these braces
  |
1 - fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { "large" } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp02ck2E/main.rs:1:809
  |
1 | ...odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } ...
  |                                                                 ^^       ^^
  |
help: remove these braces
  |
1 - fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
1 + fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { "small" } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |

error[E0369]: cannot calculate the remainder of `T` divided by `i32`
 --> /tmp/.tmp02ck2E/main.rs:1:171
  |
1 | ...lay + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output =...
  |                                                              ------ ^ ---- i32
  |                                                              |
  |                                                              T
  |
help: consider further restricting type parameter `T` with trait `Rem`
  |
1 | fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Rem<i32> > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |                                                                                                                                            ++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmp02ck2E/main.rs:1:164
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } ...
  |       -                                                                                                                                               -     ^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `bool`
  |       |                                                                                                                                               |
  |       expected this type parameter                                                                                                                    expected `T` because of return type
  |
  = note: expected type parameter `T`
                       found type `bool`
  = note: the caller chooses a type for `T` which can be different from `bool`

error[E0369]: binary operation `>=` cannot be applied to type `T`
 --> /tmp/.tmp02ck2E/main.rs:1:366
  |
1 | ...y + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if sc...
  |                                                              ----- ^^ ----- i32
  |                                                              |
  |                                                              T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |                                                                                                                                                                                                                                                                                                                                              +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmp02ck2E/main.rs:1:379
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } ...
  |       -                                                                                                                                              -                           ^^^ expected type parameter `T`, found `&str`
  |       |                                                                                                                                              |
  |       expected this type parameter                                                                                                                   expected `T` because of return type
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0369]: binary operation `>=` cannot be applied to type `T`
 --> /tmp/.tmp02ck2E/main.rs:1:403
  |
1 | ...ore : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if sc...
  |                                                              ----- ^^ ----- i32
  |                                                              |
  |                                                              T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |                                                                                                                                                                                                                                                                                                                                              +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmp02ck2E/main.rs:1:416
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } ...
  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                            ^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0369]: binary operation `>=` cannot be applied to type `T`
 --> /tmp/.tmp02ck2E/main.rs:1:440
  |
1 | ... { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F"...
  |                                                              ----- ^^ ----- i32
  |                                                              |
  |                                                              T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |                                                                                                                                                                                                                                                                                                                                              +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmp02ck2E/main.rs:1:453
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } ...
  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                                                                 ^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0369]: binary operation `>=` cannot be applied to type `T`
 --> /tmp/.tmp02ck2E/main.rs:1:477
  |
1 | ... { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T...
  |                                                              ----- ^^ ----- i32
  |                                                              |
  |                                                              T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |                                                                                                                                                                                                                                                                                                                                              +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmp02ck2E/main.rs:1:490
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } ...
  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                                                                                                      ^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0308]: mismatched types
 --> /tmp/.tmp02ck2E/main.rs:1:507
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } ...
  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                                                                                                                       ^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0308]: mismatched types
 --> /tmp/.tmp02ck2E/main.rs:1:720
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) {...
  |       -                                                                                                                                                                    -------  ^ expected `bool`, found type parameter `T`
  |       |                                                                                                                                                                    |
  |       found this type parameter                                                                                                                                            arguments to this function are incorrect
  |
  = note:        expected type `bool`
          found type parameter `T`
help: the return type of this call is `T` due to the type of the argument passed
 --> /tmp/.tmp02ck2E/main.rs:1:711
  |
1 | ... : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { {...
  |                                       ^^^^^^^^^-^
  |                                                |
  |                                                this argument influences the return type of `is_even`
note: function defined here
 --> /tmp/.tmp02ck2E/main.rs:1:4
  |
1 | fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -...
  |    ^^^^^^^                                                                                                                                    ----------

error[E0277]: cannot add `bool` to `bool`
 --> /tmp/.tmp02ck2E/main.rs:1:720
  |
1 | ...e > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } el...
  |                                             -------  ^ no implementation for `bool + bool`
  |                                             |
  |                                             required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `bool`
note: required by a bound in `is_even`
 --> /tmp/.tmp02ck2E/main.rs:1:18
  |
1 | fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clon...
  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_even`

error[E0277]: cannot multiply `bool` by `bool`
 --> /tmp/.tmp02ck2E/main.rs:1:720
  |
1 | ...e > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } el...
  |                                             -------  ^ no implementation for `bool * bool`
  |                                             |
  |                                             required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `bool`
note: required by a bound in `is_even`
 --> /tmp/.tmp02ck2E/main.rs:1:53
  |
1 | fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clon...
  |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_even`

error[E0369]: binary operation `>` cannot be applied to type `T`
 --> /tmp/.tmp02ck2E/main.rs:1:777
  |
1 | ...ven (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " ...
  |                                                                - ^ ------ i32
  |                                                                |
  |                                                                T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { "A" } } else { if score >= 80i32 { { "B" } } else { if score >= 70i32 { { "C" } } else { if score >= 60i32 { { "D" } } else { { "F" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } } } } fn main () { { println ! ("{}" , describe_number (42i32)) ; println ! ("{}" , describe_number (150i32)) ; println ! ("{}" , grade_letter (85i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmp02ck2E/main.rs:1:829
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + ...
  |       -                                                                                                                                                                                                                                                                                      -   ^^^^^^^^ expected type parameter `T`, found `&str`
  |       |                                                                                                                                                                                                                                                                                      |
  |       expected this type parameter                                                                                                                                                                                                                                                           expected because this is `T`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`

error[E0308]: mismatched types
 --> /tmp/.tmp02ck2E/main.rs:1:847
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + ...
  |       -                                                                                                                                                                                                                                                                                      -------------------   ^^^ expected type parameter `T`, found `&str`
  |       |                                                                                                                                                                                                                                                                                      |
  |       expected this type parameter                                                                                                                                                                                                                                                           expected because this is `T`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`

error[E0308]: mismatched types
 --> /tmp/.tmp02ck2E/main.rs:1:853
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + ...
  |       -                                                                                                                                                                                                                                                                                      -------------------------   ^^^^^^^^ expected type parameter `T`, found `&str`
  |       |                                                                                                                                                                                                                                                                                      |
  |       expected this type parameter                                                                                                                                                                                                                                                           expected because this is `T`
  |
  = note: expected type parameter `T`
                  found reference `&str`

error[E0308]: mismatched types
 --> /tmp/.tmp02ck2E/main.rs:1:864
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { "even" } } else { { "odd" } } ; { let size = if n > 100i32 { { "large" } } else { { "small" } } ; n + " is a " + size + " " + even_odd + " number" } ...
  |       -                                                                                                                                                                                                                                                                                      ------------------------------------   ^^^^^^^^^ expected type parameter `T`, found `&str`
  |       |                                                                                                                                                                                                                                                                                      |
  |       expected this type parameter                                                                                                                                                                                                                                                           expected because this is `T`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`

error: aborting due to 19 previous errors; 12 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0369.
For more information about an error, try `rustc --explain E0277`.



=== ch03-00-functions example 7 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpCjemrl/main.rs:1:579
  |
1 | ...e i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T ...
  |                                                          ^^                     ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let essay = "Functions make code reusable and testable" ; println ! ("{} {}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" , count_words (essay)) } } } }
1 + fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { max_val = numbers [i] } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let essay = "Functions make code reusable and testable" ; println ! ("{} {}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" , count_words (essay)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpCjemrl/main.rs:1:803
  |
1 | ...t :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = ...
  |                                           ^^                                                   ^^
  |
help: remove these braces
  |
1 - fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let essay = "Functions make code reusable and testable" ; println ! ("{} {}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" , count_words (essay)) } } } }
1 + fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { let words = text . split (" ") ; words . len () } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let essay = "Functions make code reusable and testable" ; println ! ("{} {}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" , count_words (essay)) } } } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpCjemrl/main.rs:1:874
  |
1 | ... { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let essay = "Functions make code reusable and testable" ; println ! ("{} {}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" , count_words (essay)) } } } }
  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                           ^^
  |
help: remove these braces
  |
1 - fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let essay = "Functions make code reusable and testable" ; println ! ("{} {}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" , count_words (essay)) } } } }
1 + fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let essay = "Functions make code reusable and testable" ; println ! ("{} {}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" , count_words (essay)) } } }
  |

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpCjemrl/main.rs:1:233
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                                   ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let essay = "Functions make code reusable and testable" ; println ! ("{} {}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" , count_words (essay)) } } } }
  |                                                                                                                                                    +++++++++++++++++++

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpCjemrl/main.rs:1:267
  |
1 | ... i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Ad...
  |                                                                     ^^^

error[E0308]: mismatched types
 --> /tmp/.tmpCjemrl/main.rs:1:292
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } ...
  |       - expected this type parameter                                                                                                                  - expected `T` because of return type                                                                                         ^^^^^ expected type parameter `T`, found `f64`
  |
  = note: expected type parameter `T`
                       found type `f64`
  = note: the caller chooses a type for `T` which can be different from `f64`

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpCjemrl/main.rs:1:493
  |
1 | ...ebug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers ...
  |                                                                    ^^^^^^

error[E0599]: no method named `len` found for type parameter `T` in the current scope
 --> /tmp/.tmpCjemrl/main.rs:1:541
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len ()...
  |       - method `len` not found for this type parameter                                                                                                                                                                                 ^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:
  |
1 | fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let essay = "Functions make code reusable and testable" ; println ! ("{} {}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" , count_words (essay)) } } } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++++++

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpCjemrl/main.rs:1:563
  |
1 | ...] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_...
  |                                                                     ^^^

error[E0608]: cannot index into a value of type `T`
 --> /tmp/.tmpCjemrl/main.rs:1:599
  |
1 | ...bers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ...
  |                                                                     ^^^

error[E0599]: no method named `split` found for type parameter `T` in the current scope
 --> /tmp/.tmpCjemrl/main.rs:1:826
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split ("...
  |       - method `split` not found for this type parameter                                                                                                                       ^^^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `split`, perhaps you need to restrict type parameter `T` with it:
  |
1 | fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + BufRead > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let essay = "Functions make code reusable and testable" ; println ! ("{} {}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" , count_words (essay)) } } } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               +++++++++

error[E0277]: cannot add `Vec<f64>` to `Vec<f64>`
 --> /tmp/.tmpCjemrl/main.rs:1:1126
  |
1 | ... ("{} {}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" , find_max (test_scores)) ; pri...
  |                                  ---------------  ^^^^^^^^^^^^^ no implementation for `Vec<f64> + Vec<f64>`
  |                                  |
  |                                  required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `Vec<f64>`
note: required by a bound in `calculate_total`
 --> /tmp/.tmpCjemrl/main.rs:1:26
  |
1 | fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debu...
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `calculate_total`

error[E0277]: cannot multiply `Vec<f64>` by `Vec<f64>`
 --> /tmp/.tmpCjemrl/main.rs:1:1126
  |
1 | ... ("{} {}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" , find_max (test_scores)) ; pri...
  |                                  ---------------  ^^^^^^^^^^^^^ no implementation for `Vec<f64> * Vec<f64>`
  |                                  |
  |                                  required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `Vec<f64>`
note: required by a bound in `calculate_total`
 --> /tmp/.tmpCjemrl/main.rs:1:61
  |
1 | ... ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> ...
  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `calculate_total`

error[E0277]: `Vec<f64>` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpCjemrl/main.rs:1:1126
  |
1 | ..., "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" , find_max (test_scores)) ; println ! ("{...
  |                        ---------------  ^^^^^^^^^^^^^ the trait `std::fmt::Display` is not implemented for `Vec<f64>`
  |                        |
  |                        required by a bound introduced by this call
  |
note: required by a bound in `calculate_total`
 --> /tmp/.tmpCjemrl/main.rs:1:96
  |
1 | ...td :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; l...
  |                                      ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `calculate_total`

error[E0277]: `Vec<f64>` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpCjemrl/main.rs:1:1109
  |
1 | ...ln ! ("{} {}" , "Total cost: $" , calculate_total (shopping_cart)) ; println ! ("{} {}" , "Highest score:" , find_max (test_scores)) ;...
  |              --                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `Vec<f64>` cannot be formatted with the default formatter
  |              |
  |              required by this formatting parameter
  |
  = help: the trait `std::fmt::Display` is not implemented for `Vec<f64>`
  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: cannot add `Vec<i32>` to `Vec<i32>`
 --> /tmp/.tmpCjemrl/main.rs:1:1194
  |
1 | ...n ! ("{} {}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" , count_words (essay)) } } } }
  |                                      --------  ^^^^^^^^^^^ no implementation for `Vec<i32> + Vec<i32>`
  |                                      |
  |                                      required by a bound introduced by this call
  |
  = help: the trait `Add` is not implemented for `Vec<i32>`
note: required by a bound in `find_max`
 --> /tmp/.tmpCjemrl/main.rs:1:320
  |
1 | ...} ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: f...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`

error[E0277]: cannot multiply `Vec<i32>` by `Vec<i32>`
 --> /tmp/.tmpCjemrl/main.rs:1:1194
  |
1 | ...n ! ("{} {}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" , count_words (essay)) } } } }
  |                                      --------  ^^^^^^^^^^^ no implementation for `Vec<i32> * Vec<i32>`
  |                                      |
  |                                      required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `Vec<i32>`
note: required by a bound in `find_max`
 --> /tmp/.tmpCjemrl/main.rs:1:355
  |
1 | ... :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T)...
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`

error[E0277]: `Vec<i32>` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpCjemrl/main.rs:1:1194
  |
1 | ...}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" , count_words (essay)) } } } }
  |                            --------  ^^^^^^^^^^^ the trait `std::fmt::Display` is not implemented for `Vec<i32>`
  |                            |
  |                            required by a bound introduced by this call
  |
note: required by a bound in `find_max`
 --> /tmp/.tmpCjemrl/main.rs:1:390
  |
1 | ... + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = n...
  |                                          ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`

error[E0277]: `Vec<i32>` doesn't implement `std::fmt::Display`
 --> /tmp/.tmpCjemrl/main.rs:1:1184
  |
1 | ...rintln ! ("{} {}" , "Highest score:" , find_max (test_scores)) ; println ! ("{} {}" , "Word count:" , count_words (essay)) } } } }
  |                  --                       ^^^^^^^^^^^^^^^^^^^^^^ `Vec<i32>` cannot be formatted with the default formatter
  |                  |
  |                  required by this formatting parameter
  |
  = help: the trait `std::fmt::Display` is not implemented for `Vec<i32>`
  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: cannot add `&str` to `&str`
 --> /tmp/.tmpCjemrl/main.rs:1:1260
  |
1 | ...; println ! ("{} {}" , "Word count:" , count_words (essay)) } } } }
  |                                           -----------  ^^^^^ no implementation for `&str + &str`
  |                                           |
  |                                           required by a bound introduced by this call
  |
  = help: the trait `Add<&str>` is not implemented for `&str`
          but it is implemented for `String`
  = help: for that trait implementation, expected `String`, found `&str`
note: required by a bound in `count_words`
 --> /tmp/.tmpCjemrl/main.rs:1:661
  |
1 | ...x_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fm...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `count_words`

error[E0277]: cannot multiply `&str` by `&str`
 --> /tmp/.tmpCjemrl/main.rs:1:1260
  |
1 | ...; println ! ("{} {}" , "Word count:" , count_words (essay)) } } } }
  |                                           -----------  ^^^^^ no implementation for `&str * &str`
  |                                           |
  |                                           required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `&str`
note: required by a bound in `count_words`
 --> /tmp/.tmpCjemrl/main.rs:1:696
  |
1 | ...:: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> ...
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `count_words`

error: aborting due to 18 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0599, E0608.
For more information about an error, try `rustc --explain E0277`.



=== ch03-00-functions example 9 ===
✗ Compilation failed: Compilation failed:
error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`
 --> /tmp/.tmpq3eLUF/main.rs:1:263
  |
1 | ... main () { { let msg = greet ("Alice") } }
  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator

warning: unnecessary braces around block return value
 --> /tmp/.tmpq3eLUF/main.rs:1:168
  |
1 | ...ug + Clone > (name : T , age : T) -> T { { "Hi " + name + ", you're " + age + " years old" } } fn main () { { let msg = greet ("Alice"...
  |                                             ^^                                               ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn greet < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , age : T) -> T { { "Hi " + name + ", you're " + age + " years old" } } fn main () { { let msg = greet ("Alice") } }
1 + fn greet < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , age : T) -> T { "Hi " + name + ", you're " + age + " years old" } fn main () { { let msg = greet ("Alice") } }
  |

error[E0369]: cannot add `T` to `&str`
 --> /tmp/.tmpq3eLUF/main.rs:1:176
  |
1 | ...std :: fmt :: Debug + Clone > (name : T , age : T) -> T { { "Hi " + name + ", you're " + age + " years old" } } fn main () { { let msg...
  |                                                                ----- ^ ---- T
  |                                                                |
  |                                                                &str

error[E0308]: mismatched types
 --> /tmp/.tmpq3eLUF/main.rs:1:185
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , age : T) -> T { { "Hi " + name + ", you're " + ...
  |       - expected this type parameter                                                                                                                                               ^^^^^^^^^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`

error[E0308]: mismatched types
 --> /tmp/.tmpq3eLUF/main.rs:1:205
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , age : T) -> T { { "Hi " + name + ", you're " + age + " years old" } ...
  |       - expected this type parameter                                                                                                                                                                   ^^^^^^^^^^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`

error: aborting due to 4 previous errors; 1 warning emitted

Some errors have detailed explanations: E0308, E0369.
For more information about an error, try `rustc --explain E0308`.



=== ch03-00-functions example 10 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmp5BULcc/main.rs:1:347
  |
1 | ... + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; result } } } fn main () { { println ! ("{}" , good_functio...
  |                                                    ^^                                  ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn bad_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; x } } fn good_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; result } } } fn main () { { println ! ("{}" , good_function (5i32)) } }
1 + fn bad_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; x } } fn good_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { let result = x + 1i32 ; result } } fn main () { { println ! ("{}" , good_function (5i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmp5BULcc/main.rs:1:401
  |
1 | ...esult = x + 1i32 ; result } } } fn main () { { println ! ("{}" , good_function (5i32)) } }
  |                                                 ^^                                       ^^
  |
help: remove these braces
  |
1 - fn bad_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; x } } fn good_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; result } } } fn main () { { println ! ("{}" , good_function (5i32)) } }
1 + fn bad_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; x } } fn good_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; result } } } fn main () { println ! ("{}" , good_function (5i32)) }
  |

error[E0308]: mismatched types
 --> /tmp/.tmp5BULcc/main.rs:1:172
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; ...
  |       -                                                                                                                                                    -   ^^^^ expected type parameter `T`, found `i32`
  |       |                                                                                                                                                    |
  |       expected this type parameter                                                                                                                         expected because this is `T`
  |
  = note: expected type parameter `T`
                       found type `i32`

error[E0308]: mismatched types
 --> /tmp/.tmp5BULcc/main.rs:1:368
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; ...
  |       -                                                                                                                                                               -   ^^^^ expected type parameter `T`, found `i32`
  |       |                                                                                                                                                               |
  |       expected this type parameter                                                                                                                                    expected because this is `T`
  |
  = note: expected type parameter `T`
                       found type `i32`

error: aborting due to 2 previous errors; 2 warnings emitted

For more information about this error, try `rustc --explain E0308`.



=== ch03-00-functions example 12 ===
✗ Compilation failed: Compilation failed:
warning: unnecessary braces around block return value
 --> /tmp/.tmpHsLLoy/main.rs:1:177
  |
1 | ...td :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Outpu...
  |                                                      ^^                             ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
1 - fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { celsius * 9i32 / 5i32 + 32i32 } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpHsLLoy/main.rs:1:398
  |
1 | ... + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Out...
  |                                                     ^^                               ^^
  |
help: remove these braces
  |
1 - fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { weight_kg / height_m * height_m } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpHsLLoy/main.rs:1:626
  |
1 | ...discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ...
  |                                 ^^                                                                       ^^
  |
help: remove these braces
  |
1 - fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { let discount = price * discount_percent / 100i32 ; price - discount } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpHsLLoy/main.rs:1:866
  |
1 | ...t :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: A...
  |                                           ^^                                                   ^^
  |
help: remove these braces
  |
1 - fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { let words = text . split (" ") ; words . len () } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpHsLLoy/main.rs:1:1093
  |
1 | ... { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } ...
  |       ^^                                                                                                                                                                                                                    ^^
  |
help: remove these braces
  |
1 - fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpHsLLoy/main.rs:1:1207
  |
1 | ...ile i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn r...
  |                             ^^                                                                               ^^
  |
help: remove these braces
  |
1 - fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpHsLLoy/main.rs:1:1511
  |
1 | ... { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } ...
  |       ^^                                                                                                                                                                                                                            ^^
  |
help: remove these braces
  |
1 - fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpHsLLoy/main.rs:1:1564
  |
1 | ...f energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time...
  |                                                      ^^                              ^^
  |
help: remove these braces
  |
1 - fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { "Go for a run or hit the gym!" } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpHsLLoy/main.rs:1:1659
  |
1 | ... if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn ...
  |                                                        ^^                         ^^
  |
help: remove these braces
  |
1 - fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { "Perfect time for a walk" } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

warning: unnecessary braces around block return value
 --> /tmp/.tmpHsLLoy/main.rs:1:1698
  |
1 | ...e > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to...
  |                                                       ^^                           ^^
  |
help: remove these braces
  |
1 - fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { "Maybe just relax and read" } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

error[E0308]: mismatched types
 --> /tmp/.tmpHsLLoy/main.rs:1:189
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / ...
  |       -                                                                                                                                                      -------   ^^^^ expected type parameter `T`, found `i32`
  |       |                                                                                                                                                      |
  |       expected this type parameter                                                                                                                           expected because this is `T`
  |
  = note: expected type parameter `T`
                       found type `i32`

error[E0369]: cannot divide `T` by `i32`
 --> /tmp/.tmpHsLLoy/main.rs:1:194
  |
1 | ... std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Out...
  |                                                          -------------- ^ ---- i32
  |                                                          |
  |                                                          T
  |
help: consider further restricting type parameter `T` with trait `Div`
  |
1 | fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Div<i32> > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                          ++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpHsLLoy/main.rs:1:203
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } ...
  |       - expected this type parameter                                                                                                                                                 ^^^^^ expected type parameter `T`, found `i32`
  |
  = note: expected type parameter `T`
                       found type `i32`

error[E0369]: cannot divide `T` by `T`
 --> /tmp/.tmpHsLLoy/main.rs:1:410
  |
1 | ...Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add ...
  |                                                            --------- ^ -------- T
  |                                                            |
  |                                                            T
  |
help: consider further restricting type parameter `T` with trait `Div`
  |
1 | fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Div > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                      +++++++++++++++

error[E0369]: cannot divide `T` by `i32`
 --> /tmp/.tmpHsLLoy/main.rs:1:670
  |
1 | ...discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ...
  |                                                    ------------------------ ^ ------ i32
  |                                                    |
  |                                                    T
  |
help: consider further restricting type parameter `T` with trait `Div`
  |
1 | fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Div<i32> > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ++++++++++++++++++++

error[E0599]: no method named `split` found for type parameter `T` in the current scope
 --> /tmp/.tmpHsLLoy/main.rs:1:889
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split ("...
  |       - method `split` not found for this type parameter                                                                                                                       ^^^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `split`, perhaps you need to restrict type parameter `T` with it:
  |
1 | fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + BufRead > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              +++++++++

error[E0599]: no method named `split` found for type parameter `T` in the current scope
 --> /tmp/.tmpHsLLoy/main.rs:1:1121
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split ("...
  |       - method `split` not found for this type parameter                                                                                                                                 ^^^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `split`, perhaps you need to restrict type parameter `T` with it:
  |
1 | fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + BufRead > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            +++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpHsLLoy/main.rs:1:1247
  |
1 | ...itials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1...
  |             -- expected due to this value                                                              ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `str`
  |
help: consider borrowing here
  |
1 | fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = &(initials + word [0i32]) ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ++                      +

error[E0308]: mismatched types
 --> /tmp/.tmpHsLLoy/main.rs:1:1295
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } ...
  |       - expected this type parameter                                                                                                                     - expected `T` because of return type                                                                                                                                                                         ^^^^^^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&str`
  = note: the caller chooses a type for `T` which can be different from `&str`

error[E0369]: binary operation `>` cannot be applied to type `T`
 --> /tmp/.tmpHsLLoy/main.rs:1:1529
  |
1 | ... > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!...
  |                                                           ------------ ^ ---- i32
  |                                                           |
  |                                                           T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      +++++++++++++++++++++++++++

error[E0369]: binary operation `>` cannot be applied to type `T`
 --> /tmp/.tmpHsLLoy/main.rs:1:1554
  |
1 | ...vailable_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_l...
  |                                                          -------------- ^ ----- i32
  |                                                          |
  |                                                          T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpHsLLoy/main.rs:1:1566
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } ...
  |       - expected this type parameter                                                                                                                                             - expected `T` because of return type                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0369]: binary operation `>` cannot be applied to type `T`
 --> /tmp/.tmpHsLLoy/main.rs:1:1624
  |
1 | ...60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } }...
  |                                                           ------------ ^ ---- i32
  |                                                           |
  |                                                           T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      +++++++++++++++++++++++++++

error[E0369]: binary operation `>` cannot be applied to type `T`
 --> /tmp/.tmpHsLLoy/main.rs:1:1649
  |
1 | ...or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just re...
  |                                                          -------------- ^ ----- i32
  |                                                          |
  |                                                          T
  |
help: consider further restricting type parameter `T` with trait `PartialOrd`
  |
1 | fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      +++++++++++++++++++++++++++

error[E0308]: mismatched types
 --> /tmp/.tmpHsLLoy/main.rs:1:1661
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } ...
  |       - expected this type parameter                                                                                                                                             - expected `T` because of return type                                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0308]: mismatched types
 --> /tmp/.tmpHsLLoy/main.rs:1:1700
  |
1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } ...
  |       - expected this type parameter                                                                                                                                             - expected `T` because of return type                                                                                                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `&str`
  |
  = note: expected type parameter `T`
                  found reference `&'static str`
  = note: the caller chooses a type for `T` which can be different from `&'static str`

error[E0308]: mismatched types
 --> /tmp/.tmpHsLLoy/main.rs:1:1845
  |
1 | ..."{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i...
  |           -------------  -----   ^^^^^^^ expected `i32`, found `f64`
  |           |              |
  |           |              expected all arguments to be this `i32` type because they need to match the type of this parameter
  |           arguments to this function are incorrect
  |
help: the return type of this call is `f64` due to the type of the argument passed
 --> /tmp/.tmpHsLLoy/main.rs:1:1822
  |
1 | ...) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recomme...
  |                          ^^^^^^^^^^^^^^^^^^^^^^^-------^
  |                                                 |
  |                                                 this argument influences the return type of `calculate_bmi`
note: function defined here
 --> /tmp/.tmpHsLLoy/main.rs:1:216
  |
1 | ...fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -...
  |       ^^^^^^^^^^^^^   -                                                                                                                                -------------   ------------ this parameter needs to match the `i32` type of `weight_kg`
  |                       |                                                                                                                                |
  |                       `weight_kg` and `height_m` both reference this parameter `T`                                                                     `height_m` needs to match the `i32` type of this parameter
help: change the type of the numeric literal from `f64` to `i32`
  |
1 - fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
1 + fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (" ") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (" ") ; { let mut initials = "" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { "Go for a run or hit the gym!" } } else { if energy_level > 5i32 && available_time > 30i32 { { "Perfect time for a walk" } } else { { "Maybe just relax and read" } } } } } fn main () { { println ! ("{}" , celsius_to_fahrenheit (20i32)) ; println ! ("{}" , calculate_bmi (70i32 , 1i32)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |

error[E0277]: cannot add `&str` to `&str`
 --> /tmp/.tmpHsLLoy/main.rs:1:1889
  |
1 | ...2 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                      ------------  ^^^^^^^^^^^^^^^ no implementation for `&str + &str`
  |                                      |
  |                                      required by a bound introduced by this call
  |
  = help: the trait `Add<&str>` is not implemented for `&str`
          but it is implemented for `String`
  = help: for that trait implementation, expected `String`, found `&str`
note: required by a bound in `get_initials`
 --> /tmp/.tmpHsLLoy/main.rs:1:946
  |
1 | ...) } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `get_initials`

error[E0277]: cannot multiply `&str` by `&str`
 --> /tmp/.tmpHsLLoy/main.rs:1:1889
  |
1 | ...2 , 1.75f64)) ; println ! ("{}" , get_initials ("Alice Johnson")) ; println ! ("{}" , recommend_activity (8i32 , 45i32)) } }
  |                                      ------------  ^^^^^^^^^^^^^^^ no implementation for `&str * &str`
  |                                      |
  |                                      required by a bound introduced by this call
  |
  = help: the trait `Mul` is not implemented for `&str`
note: required by a bound in `get_initials`
 --> /tmp/.tmpHsLLoy/main.rs:1:981
  |
1 | ...: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T)...
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `get_initials`

error: aborting due to 19 previous errors; 10 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0369, E0599.
For more information about an error, try `rustc --explain E0277`.


