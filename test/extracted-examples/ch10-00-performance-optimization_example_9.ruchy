// File: web_server_optimization.ruchy
// High-performance web server

use std::net::http;
use std::cache;

let app = http::Server::new("0.0.0.0:8080")

// Response caching
let response_cache = cache::LRU::new(1000)

app.use(|req, res, next| {
    let cache_key = f"{req.method}:{req.path}:{req.query_string}"
    
    if req.method == "GET" && response_cache.has(cache_key) {
        let cached = response_cache.get(cache_key)
        return res
            .status(200)
            .header("X-Cache", "HIT")
            .send(cached)
    }
    
    // Capture response for caching
    let original_send = res.send
    res.send = |body| {
        if req.method == "GET" && res.status == 200 {
            response_cache.set(cache_key, body, ttl: 60)
        }
        original_send(body)
    }
    
    next()
})

// Static file serving with ETags
app.static("/static", "./public", {
    maxAge: 86400,  // 1 day
    etag: true,
    gzip: true
})

// Database connection pooling
let db_pool = ConnectionPool::new(
    url: "postgres://localhost/myapp",
    min: 5,
    max: 20
)

// Async request handling
app.get("/api/data", async |req, res| {
    let conn = db_pool.acquire().await()
    let data = conn.query("SELECT * FROM data").await()
    db_pool.release(conn)
    
    res.json(data)
})

// Enable HTTP/2
app.enable_http2()

// Compression middleware
app.use(compression({
    level: 6,
    threshold: 1024,  // Only compress > 1KB
    types: ["text/*", "application/json", "application/javascript"]
}))

println("ðŸš€ Optimized server running with:")
println("  â€¢ Response caching")
println("  â€¢ Connection pooling")  
println("  â€¢ HTTP/2 support")
println("  â€¢ Gzip compression")

app.listen()