// File: process_tree.ruchy
// Visualize process hierarchy

fn build_process_tree() {
    let processes = process::list()
    let tree = {}
    
    // Build parent-child relationships
    for proc in processes {
        let ppid = proc.parent_pid
        if !tree.has_key(ppid) {
            tree[ppid] = []
        }
        tree[ppid].push(proc)
    }
    
    return tree
}

fn print_tree(pid, tree, indent = "") {
    if !tree.has_key(pid) {
        return
    }
    
    let children = tree[pid].sort_by(|p| p.pid)
    for i, proc in children.enumerate() {
        let is_last = (i == children.len() - 1)
        let prefix = is_last ? "└─" : "├─"
        let extension = is_last ? "  " : "│ "
        
        let memory = format_size(proc.memory_info.rss)
        println(f"{indent}{prefix} [{proc.pid}] {proc.name} ({memory}, {proc.cpu_percent:.1}%)")
        
        // Recursively print children
        print_tree(proc.pid, tree, indent + extension)
    }
}

println("=== Process Tree ===")
let tree = build_process_tree()

// Start from init (PID 1) or system idle (PID 0)
let root_pid = tree.has_key(0) ? 0 : 1
println(f"[{root_pid}] System Root")
print_tree(root_pid, tree)

// Show process statistics
let all_procs = process::list()
let total_memory = all_procs.map(|p| p.memory_info.rss).sum()
let total_cpu = all_procs.map(|p| p.cpu_percent).sum()

println(f"\nTotal Processes: {all_procs.len()}")
println(f"Total Memory: {format_size(total_memory)}")
println(f"Total CPU: {total_cpu:.1}%")