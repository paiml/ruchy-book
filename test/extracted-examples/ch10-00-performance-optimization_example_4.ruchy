// Parallel map
let data = range(1, 1000000)
let results = parallel::map(data, |n| {
    expensive_computation(n)
})

// Parallel reduce
let sum = parallel::reduce(data, 0, |acc, n| {
    acc + n
})

// Thread pool
let pool = parallel::ThreadPool::new(num_cpus())

for task in tasks {
    pool.execute(|| {
        process_task(task)
    })
}

pool.wait()

// Parallel pipeline
parallel::pipeline()
    .stage(|item| fetch_data(item))      // I/O bound
    .stage(|data| parse_data(data))      // CPU bound
    .stage(|parsed| transform(parsed))   // CPU bound
    .stage(|result| save_result(result)) // I/O bound
    .process(items)

// Async concurrency
let futures = []
for url in urls {
    futures.push(async {
        http::get(url).await()
    })
}

let responses = async::wait_all(futures)