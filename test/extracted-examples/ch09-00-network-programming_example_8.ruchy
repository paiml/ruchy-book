// File: load_balancer.ruchy
// HTTP load balancer with health checking

use std::net::http;

let backends = [
    {url: "http://server1:8080", weight: 1, healthy: true},
    {url: "http://server2:8080", weight: 2, healthy: true},
    {url: "http://server3:8080", weight: 1, healthy: true}
]

let current_backend = 0

fn select_backend() {
    // Weighted round-robin selection
    let healthy_backends = backends.filter(|b| b.healthy)
    
    if healthy_backends.is_empty() {
        throw "No healthy backends available"
    }
    
    // Simple round-robin for now
    current_backend = (current_backend + 1) % healthy_backends.len()
    return healthy_backends[current_backend]
}

fn health_check() {
    for backend in backends {
        try {
            let response = http::get(f"{backend.url}/health")
                .timeout(2000)
                .send()
            
            backend.healthy = response.status == 200
        } catch {
            backend.healthy = false
        }
        
        let status = backend.healthy ? "âœ“" : "âœ—"
        println(f"Health check {backend.url}: {status}")
    }
}

// Start health check timer
spawn {
    loop {
        health_check()
        sleep(10000)  // Check every 10 seconds
    }
}

// Create load balancer server
let balancer = http::Server::new("0.0.0.0:80")

balancer.all("*", |req, res| {
    let backend = select_backend()
    
    println(f"Routing {req.method} {req.path} -> {backend.url}")
    
    // Forward request
    let backend_response = http::request(backend.url + req.path)
        .method(req.method)
        .headers(req.headers)
        .body(req.body)
        .send()
    
    // Return response
    res.status(backend_response.status)
        .headers(backend_response.headers)
        .send(backend_response.body)
})

println("ğŸ”„ Load balancer running on port 80")
println(f"Backends: {backends.len()}")
balancer.listen()