// 1. Project structure
my-project/
├── src/
│   ├── main.rs
│   ├── lib.rs
│   ├── models/
│   ├── handlers/
│   └── utils/
├── tests/
├── benches/
├── docs/
├── Cargo.toml
├── README.md
└── .github/
    └── workflows/

// 2. Error handling
type Result<T> = std::result::Result<T, Error>;

#[derive(Debug, thiserror::Error)]
enum Error {
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),
    
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("Invalid input: {0}")]
    InvalidInput(String),
}

// 3. Configuration
#[derive(Debug, Deserialize)]
struct Config {
    server: ServerConfig,
    database: DatabaseConfig,
    #[serde(default)]
    features: Features,
}

impl Config {
    fn load() -> Result<Self> {
        // Try multiple sources
        let config = config::Config::builder()
            .add_source(config::File::with_name("config"))
            .add_source(config::Environment::with_prefix("APP"))
            .build()?;
        
        Ok(config.try_deserialize()?)
    }
}

// 4. Logging
fn init_logging() {
    tracing_subscriber::fmt()
        .with_env_filter(EnvFilter::from_default_env())
        .with_target(false)
        .with_thread_ids(true)
        .with_file(true)
        .with_line_number(true)
        .init();
}

// 5. Testing
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_functionality() {
        // Arrange
        let input = prepare_test_data();
        
        // Act
        let result = function_under_test(input);
        
        // Assert
        assert_eq!(result, expected);
    }
}