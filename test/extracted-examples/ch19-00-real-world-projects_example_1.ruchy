// taskmaster.ruchy - Complete task management system
use std::cli::{App, Arg, SubCommand};
use std::fs;
use std::chrono::{DateTime, Local};

#[derive(Serialize, Deserialize, Clone)]
struct Task {
    id: String,
    title: String,
    description: Option<String>,
    status: TaskStatus,
    priority: Priority,
    due_date: Option<DateTime<Local>>,
    tags: Vec<String>,
    created_at: DateTime<Local>,
    completed_at: Option<DateTime<Local>>,
}

#[derive(Serialize, Deserialize, Clone)]
enum TaskStatus {
    Todo,
    InProgress,
    Done,
    Archived
}

#[derive(Serialize, Deserialize, Clone)]
enum Priority {
    Low,
    Medium,
    High,
    Critical
}

struct TaskStore {
    path: PathBuf,
    tasks: Vec<Task>,
}

impl TaskStore {
    fn load(path: PathBuf) -> Result<Self> {
        let tasks = if path.exists() {
            let content = fs::read_to_string(&path)?;
            serde_json::from_str(&content)?
        } else {
            Vec::new()
        };
        
        Ok(TaskStore { path, tasks })
    }
    
    fn save(&self) -> Result<()> {
        let json = serde_json::to_string_pretty(&self.tasks)?;
        fs::write(&self.path, json)?;
        Ok(())
    }
    
    fn add(&mut self, task: Task) -> Result<()> {
        self.tasks.push(task);
        self.save()
    }
    
    fn find(&self, id: &str) -> Option<&Task> {
        self.tasks.iter().find(|t| t.id == id)
    }
    
    fn update<F>(&mut self, id: &str, updater: F) -> Result<()>
    where F: FnOnce(&mut Task)
    {
        if let Some(task) = self.tasks.iter_mut().find(|t| t.id == id) {
            updater(task);
            self.save()?;
        }
        Ok(())
    }
    
    fn list(&self, filter: Option<TaskFilter>) -> Vec<&Task> {
        self.tasks.iter()
            .filter(|t| {
                if let Some(ref f) = filter {
                    f.matches(t)
                } else {
                    true
                }
            })
            .collect()
    }
}

struct TaskFilter {
    status: Option<TaskStatus>,
    priority: Option<Priority>,
    tags: Vec<String>,
    search: Option<String>,
}

impl TaskFilter {
    fn matches(&self, task: &Task) -> bool {
        if let Some(ref status) = self.status {
            if task.status != *status {
                return false;
            }
        }
        
        if let Some(ref priority) = self.priority {
            if task.priority != *priority {
                return false;
            }
        }
        
        if !self.tags.is_empty() {
            if !self.tags.iter().any(|tag| task.tags.contains(tag)) {
                return false;
            }
        }
        
        if let Some(ref search) = self.search {
            let search_lower = search.to_lowercase();
            if !task.title.to_lowercase().contains(&search_lower) &&
               !task.description.as_ref()
                   .map(|d| d.to_lowercase().contains(&search_lower))
                   .unwrap_or(false) {
                return false;
            }
        }
        
        true
    }
}

fn main() -> Result<()> {
    let app = App::new("taskmaster")
        .version("1.0.0")
        .author("Your Name")
        .about("Powerful task management from the command line")
        .subcommand(
            SubCommand::with_name("add")
                .about("Add a new task")
                .arg(Arg::with_name("title").required(true))
                .arg(Arg::with_name("description").short("d").takes_value(true))
                .arg(Arg::with_name("priority").short("p").takes_value(true))
                .arg(Arg::with_name("due").long("due").takes_value(true))
                .arg(Arg::with_name("tags").short("t").multiple(true))
        )
        .subcommand(
            SubCommand::with_name("list")
                .about("List tasks")
                .arg(Arg::with_name("status").short("s").takes_value(true))
                .arg(Arg::with_name("priority").short("p").takes_value(true))
                .arg(Arg::with_name("tags").short("t").multiple(true))
        )
        .subcommand(
            SubCommand::with_name("done")
                .about("Mark task as done")
                .arg(Arg::with_name("id").required(true))
        )
        .get_matches();
    
    let store_path = dirs::home_dir()
        .unwrap()
        .join(".taskmaster")
        .join("tasks.json");
    
    let mut store = TaskStore::load(store_path)?;
    
    match app.subcommand() {
        ("add", Some(matches)) => {
            let task = Task {
                id: generate_id(),
                title: matches.value_of("title").unwrap().to_string(),
                description: matches.value_of("description").map(String::from),
                status: TaskStatus::Todo,
                priority: matches.value_of("priority")
                    .and_then(|p| p.parse().ok())
                    .unwrap_or(Priority::Medium),
                due_date: matches.value_of("due")
                    .and_then(|d| parse_date(d).ok()),
                tags: matches.values_of("tags")
                    .map(|tags| tags.map(String::from).collect())
                    .unwrap_or_default(),
                created_at: Local::now(),
                completed_at: None,
            };
            
            store.add(task)?;
            println!("âœ… Task added successfully!");
        }
        
        ("list", Some(matches)) => {
            let filter = TaskFilter {
                status: matches.value_of("status").and_then(|s| s.parse().ok()),
                priority: matches.value_of("priority").and_then(|p| p.parse().ok()),
                tags: matches.values_of("tags")
                    .map(|tags| tags.map(String::from).collect())
                    .unwrap_or_default(),
                search: None,
            };
            
            let tasks = store.list(Some(filter));
            
            for task in tasks {
                let status_emoji = match task.status {
                    TaskStatus::Todo => "â¬œ",
                    TaskStatus::InProgress => "ðŸ”„",
                    TaskStatus::Done => "âœ…",
                    TaskStatus::Archived => "ðŸ“¦",
                };
                
                let priority_marker = match task.priority {
                    Priority::Critical => "ðŸ”´",
                    Priority::High => "ðŸŸ ",
                    Priority::Medium => "ðŸŸ¡",
                    Priority::Low => "ðŸŸ¢",
                };
                
                println!("{} {} {} {}", 
                    status_emoji, 
                    priority_marker,
                    task.id[..8].to_string(),
                    task.title
                );
                
                if let Some(ref desc) = task.description {
                    println!("    {}", desc);
                }
                
                if !task.tags.is_empty() {
                    println!("    Tags: {}", task.tags.join(", "));
                }
            }
        }
        
        ("done", Some(matches)) => {
            let id = matches.value_of("id").unwrap();
            store.update(id, |task| {
                task.status = TaskStatus::Done;
                task.completed_at = Some(Local::now());
            })?;
            println!("âœ… Task marked as done!");
        }
        
        _ => {
            println!("Use --help for usage information");
        }
    }
    
    Ok(())
}