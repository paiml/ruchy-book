// File: algorithm_optimization.ruchy
// Common optimization patterns

// 1. Cache computed values
let fibonacci_cache = {}
fn fibonacci_memo(n) {
    if fibonacci_cache.has_key(n) {
        return fibonacci_cache[n]
    }
    
    let result = if n <= 1 {
        n
    } else {
        fibonacci_memo(n - 1) + fibonacci_memo(n - 2)
    }
    
    fibonacci_cache[n] = result
    return result
}

// 2. Use better data structures
fn find_duplicates_naive(items) {
    let duplicates = []
    for i in range(items.len()) {
        for j in range(i + 1, items.len()) {
            if items[i] == items[j] {
                duplicates.push(items[i])
            }
        }
    }
    return duplicates  // O(nÂ²)
}

fn find_duplicates_optimized(items) {
    let seen = Set::new()
    let duplicates = Set::new()
    
    for item in items {
        if seen.contains(item) {
            duplicates.add(item)
        }
        seen.add(item)
    }
    return duplicates.to_array()  // O(n)
}

// 3. Batch operations
fn save_records_naive(records) {
    for record in records {
        database.insert(record)  // N database calls
    }
}

fn save_records_optimized(records) {
    database.insert_batch(records)  // 1 database call
}

// 4. Early termination
fn find_first_match(items, predicate) {
    for item in items {
        if predicate(item) {
            return item  // Stop as soon as found
        }
    }
    return null
}