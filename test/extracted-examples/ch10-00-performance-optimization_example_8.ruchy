// File: query_optimizer.ruchy
// Optimize database queries

use std::db;
use std::perf;

let database = db::connect("postgres://localhost/myapp")

// Enable query logging
database.log_queries(true)

// Analyze slow queries
fn analyze_query(sql) {
    let plan = database.explain(sql)
    println(f"Query: {sql}")
    println(f"Execution plan: {plan}")
    
    // Find missing indexes
    if plan.contains("Seq Scan") {
        println("⚠️  Sequential scan detected - consider adding index")
        
        // Suggest index
        let table = extract_table(sql)
        let where_clause = extract_where(sql)
        println(f"Suggested: CREATE INDEX ON {table} ({where_clause.column})")
    }
    
    // Check for N+1 queries
    let query_log = database.get_recent_queries(100)
    let patterns = find_patterns(query_log)
    
    for pattern in patterns {
        if pattern.count > 10 && pattern.similar {
            println(f"⚠️  N+1 query pattern detected: {pattern.example}")
            println("Consider using JOIN or batch loading")
        }
    }
}

// Optimize ORM queries
fn get_users_with_posts_naive() {
    let users = database.query("SELECT * FROM users")
    for user in users {
        user.posts = database.query(
            "SELECT * FROM posts WHERE user_id = ?", 
            [user.id]
        )  // N+1 problem
    }
    return users
}

fn get_users_with_posts_optimized() {
    // Single query with JOIN
    return database.query("
        SELECT u.*, p.*
        FROM users u
        LEFT JOIN posts p ON p.user_id = u.id
        ORDER BY u.id, p.created_at
    ").group_by(|row| row.user_id)
}

// Benchmark improvements
let naive_time = perf::measure {
    get_users_with_posts_naive()
}

let optimized_time = perf::measure {
    get_users_with_posts_optimized()
}

println(f"Improvement: {naive_time / optimized_time:.1}x faster")