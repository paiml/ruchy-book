// Composable validators
type Validator<T> = Fn(T) -> Result<T, ValidationError>

fn validate_pipeline<T>(
    value: T,
    validators: Vec<Validator<T>>
) -> Result<T, Vec<ValidationError>> {
    let mut errors = Vec::new()
    let mut current = value
    
    for validator in validators {
        match validator(current) {
            Ok(validated) => current = validated
            Err(e) => errors.push(e)
        }
    }
    
    if errors.is_empty() {
        Ok(current)
    } else {
        Err(errors)
    }
}

// Use validation pipeline
let user_validators = vec![
    validate_required_fields,
    validate_email_format,
    validate_age_range,
    validate_unique_username
]

match validate_pipeline(user, user_validators) {
    Ok(valid_user) => save_user(valid_user)
    Err(errors) => {
        for error in errors {
            println(f"Validation error: {error}")
        }
    }
}