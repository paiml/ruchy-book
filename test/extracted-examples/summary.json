{
  "timestamp": "2025-08-22T21:52:34.035Z",
  "ruchy_version": "ruchy 0.11.0",
  "chapters_processed": 24,
  "examples_found": 280,
  "examples_working": 119,
  "examples_failing": 161,
  "success_rate": 43,
  "chapters": {
    "ch10-00-performance-optimization": {
      "chapter": "ch10-00-performance-optimization",
      "total_examples": 11,
      "working_examples": 4,
      "failing_examples": 7,
      "examples": [
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ‚ùå BROKEN\n\n// File: optimize_data_processing.ruchy\n// Before and after optimization\n\nuse std::perf;\nuse std::parallel;\n\n// Naive version - slow\nfn process_data_naive(data) {\n    let results = []\n    for item in data {\n        // Expensive computation\n        let processed = expensive_transform(item)\n        for existing in results {\n            if similar(processed, existing) {\n                processed.merge(existing)\n            }\n        }\n        results.push(processed)\n    }\n    return results\n}\n\n// Optimized version - fast\nfn process_data_optimized(data) {\n    // 1. Parallel processing\n    let results = parallel::map(data, |item| {\n        expensive_transform(item)\n    })\n    \n    // 2. Use hash map for lookups\n    let lookup = {}\n    for item in results {\n        let key = item.hash_key()\n        if lookup.has_key(key) {\n            lookup[key].merge(item)\n        } else {\n            lookup[key] = item\n        }\n    }\n    \n    return lookup.values()\n}\n\n// Benchmark both versions\nlet data = generate_test_data(10000)\n\nlet naive_time = perf::measure {\n    process_data_naive(data)\n}\n\nlet optimized_time = perf::measure {\n    process_data_optimized(data)\n}\n\nprintln(f\"Naive: {naive_time}ms\")\nprintln(f\"Optimized: {optimized_time}ms\")\nprintln(f\"Speedup: {naive_time / optimized_time:.1}x\")\n// Output: Speedup: 42.3x\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 2,
          "line_number": 105,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// CPU profiling\nlet profiler = perf::CpuProfiler::new()\nprofiler.start()\n\n// Your code here\ncomplex_operation()\n\nprofiler.stop()\nlet report = profiler.report()\n\nprintln(\"=== CPU Profile ===\")\nfor func in report.top_functions(10) {\n    println(f\"{func.name}: {func.self_time}ms ({func.percent}%)\")\n}\n\n// Memory profiling\nlet mem_profiler = perf::MemoryProfiler::new()\nmem_profiler.start()\n\n// Your code here\nmemory_intensive_operation()\n\nmem_profiler.stop()\nlet mem_report = mem_profiler.report()\n\nprintln(\"\\n=== Memory Profile ===\")\nprintln(\"Peak memory: \" + format_size(mem_report.peak_usage))\nprintln(\"Allocations: \" + mem_report.allocation_count.to_s())\nprintln(\"Largest allocation: \" + format_size(mem_report.largest_allocation))\n\n// Flame graph generation\nprofiler.generate_flamegraph(\"profile.svg\")\nprintln(\"Flame graph saved to profile.svg\")",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: ColonColon\n"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 3,
          "line_number": 150,
          "code": "// Status: ‚ùå BROKEN\n\n// Micro-benchmarks\nuse std::bench;\n\nbench::suite(\"String Operations\", {\n    \"concatenation\" => || {\n        let s = \"\"\n        for i in range(1000) {\n            s += i.to_s()\n        }\n    },\n    \n    \"string builder\" => || {\n        let builder = StringBuilder::new()\n        for i in range(1000) {\n            builder.append(i.to_s())\n        }\n        builder.to_string()\n    },\n    \n    \"join\" => || {\n        range(1000).map(|i| i.to_s()).join(\"\")\n    }\n})\n\n// Results:\n// String Operations\n//   concatenation:  2.3ms ¬± 0.1ms\n//   string builder: 0.4ms ¬± 0.02ms  [FASTEST]\n//   join:          0.6ms ¬± 0.03ms\n\n// Custom benchmarks\nfn benchmark_algorithm(name, func, data) {\n    let times = []\n    \n    // Warmup\n    for i in range(5) {\n        func(data)\n    }\n    \n    // Measure\n    for i in range(100) {\n        let time = perf::measure {\n            func(data)\n        }\n        times.push(time)\n    }\n    \n    let avg = times.mean()\n    let std = times.std_dev()\n    println(f\"{name}: {avg:.2}ms ¬± {std:.2}ms\")\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 4,
          "line_number": 214,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Parallel map\nlet data = range(1, 1000000)\nlet results = parallel::map(data, |n| {\n    expensive_computation(n)\n})\n\n// Parallel reduce\nlet sum = parallel::reduce(data, 0, |acc, n| {\n    acc + n\n})\n\n// Thread pool\nlet pool = parallel::ThreadPool::new(num_cpus())\n\nfor task in tasks {\n    pool.execute(|| {\n        process_task(task)\n    })\n}\n\npool.wait()\n\n// Parallel pipeline\nparallel::pipeline()\n    .stage(|item| fetch_data(item))      // I/O bound\n    .stage(|data| parse_data(data))      // CPU bound\n    .stage(|parsed| transform(parsed))   // CPU bound\n    .stage(|result| save_result(result)) // I/O bound\n    .process(items)\n\n// Async concurrency\nlet futures = []\nfor url in urls {\n    futures.push(async {\n        http::get(url).await()\n    })\n}\n\nlet responses = async::wait_all(futures)",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: ColonColon\n"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 5,
          "line_number": 265,
          "code": "// Status: ‚ùå BROKEN\n\n// File: algorithm_optimization.ruchy\n// Common optimization patterns\n\n// 1. Cache computed values\nlet fibonacci_cache = {}\nfn fibonacci_memo(n) {\n    if fibonacci_cache.has_key(n) {\n        return fibonacci_cache[n]\n    }\n    \n    let result = if n <= 1 {\n        n\n    } else {\n        fibonacci_memo(n - 1) + fibonacci_memo(n - 2)\n    }\n    \n    fibonacci_cache[n] = result\n    return result\n}\n\n// 2. Use better data structures\nfn find_duplicates_naive(items) {\n    let duplicates = []\n    for i in range(items.len()) {\n        for j in range(i + 1, items.len()) {\n            if items[i] == items[j] {\n                duplicates.push(items[i])\n            }\n        }\n    }\n    return duplicates  // O(n¬≤)\n}\n\nfn find_duplicates_optimized(items) {\n    let seen = Set::new()\n    let duplicates = Set::new()\n    \n    for item in items {\n        if seen.contains(item) {\n            duplicates.add(item)\n        }\n        seen.add(item)\n    }\n    return duplicates.to_array()  // O(n)\n}\n\n// 3. Batch operations\nfn save_records_naive(records) {\n    for record in records {\n        database.insert(record)  // N database calls\n    }\n}\n\nfn save_records_optimized(records) {\n    database.insert_batch(records)  // 1 database call\n}\n\n// 4. Early termination\nfn find_first_match(items, predicate) {\n    for item in items {\n        if predicate(item) {\n            return item  // Stop as soon as found\n        }\n    }\n    return null\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 6,
          "line_number": 342,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// File: memory_optimization.ruchy\n// Reduce memory usage\n\n// 1. Use generators for large datasets\nfn read_large_file_naive(path) {\n    return read_file(path).lines()  // Loads entire file\n}\n\nfn read_large_file_optimized(path) {\n    // Generator - yields lines one at a time\n    return generate {\n        let file = open(path)\n        while !file.eof() {\n            yield file.read_line()\n        }\n        file.close()\n    }\n}\n\n// 2. Object pooling\nlet connection_pool = Pool::new(\n    create: || Database::connect(),\n    reset: |conn| conn.clear()\n)\n\nfn handle_request(request) {\n    let conn = connection_pool.acquire()\n    let result = conn.query(request.sql)\n    connection_pool.release(conn)\n    return result\n}\n\n// 3. Weak references for caches\nlet cache = WeakMap::new()\n\nfn get_cached_data(key) {\n    if cache.has(key) {\n        return cache.get(key)\n    }\n    \n    let data = expensive_load(key)\n    cache.set(key, data)\n    return data\n}\n\n// 4. Compact data structures\nstruct CompactUser {\n    id: u32,        // 4 bytes instead of 8\n    flags: u8,      // Bit flags instead of booleans\n    name: String    // Single allocation\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected RightParen, found Colon\n"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 7,
          "line_number": 403,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// File: io_optimization.ruchy\n// Speed up I/O operations\n\n// 1. Buffered I/O\nfn process_file_naive(path) {\n    let file = open(path)\n    while !file.eof() {\n        let byte = file.read_byte()  // Syscall for each byte\n        process(byte)\n    }\n}\n\nfn process_file_optimized(path) {\n    let file = BufferedReader::new(open(path), 8192)\n    while !file.eof() {\n        let byte = file.read_byte()  // Reads from buffer\n        process(byte)\n    }\n}\n\n// 2. Async I/O\nasync fn fetch_all_naive(urls) {\n    let results = []\n    for url in urls {\n        let data = http::get(url).await()  // Sequential\n        results.push(data)\n    }\n    return results\n}\n\nasync fn fetch_all_optimized(urls) {\n    let futures = urls.map(|url| {\n        http::get(url)  // Concurrent\n    })\n    return async::wait_all(futures)\n}\n\n// 3. Memory-mapped files\nfn process_huge_file(path) {\n    let mmap = MemoryMap::open(path)\n    \n    // Process in parallel chunks\n    parallel::for_chunks(mmap, 1_000_000, |chunk| {\n        process_chunk(chunk)\n    })\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: ColonColon\n"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 8,
          "line_number": 461,
          "code": "// Status: ‚ùå BROKEN\n\n// File: query_optimizer.ruchy\n// Optimize database queries\n\nuse std::db;\nuse std::perf;\n\nlet database = db::connect(\"postgres://localhost/myapp\")\n\n// Enable query logging\ndatabase.log_queries(true)\n\n// Analyze slow queries\nfn analyze_query(sql) {\n    let plan = database.explain(sql)\n    println(\"Query: \" + sql)\n    println(\"Execution plan: \" + plan)\n    \n    // Find missing indexes\n    if plan.contains(\"Seq Scan\") {\n        println(\"‚ö†Ô∏è  Sequential scan detected - consider adding index\")\n        \n        // Suggest index\n        let table = extract_table(sql)\n        let where_clause = extract_where(sql)\n        println(f\"Suggested: CREATE INDEX ON {table} ({where_clause.column})\")\n    }\n    \n    // Check for N+1 queries\n    let query_log = database.get_recent_queries(100)\n    let patterns = find_patterns(query_log)\n    \n    for pattern in patterns {\n        if pattern.count > 10 && pattern.similar {\n            println(\"‚ö†Ô∏è  N+1 query pattern detected: \" + pattern.example)\n            println(\"Consider using JOIN or batch loading\")\n        }\n    }\n}\n\n// Optimize ORM queries\nfn get_users_with_posts_naive() {\n    let users = database.query(\"SELECT * FROM users\")\n    for user in users {\n        user.posts = database.query(\n            \"SELECT * FROM posts WHERE user_id = ?\", \n            [user.id]\n        )  // N+1 problem\n    }\n    return users\n}\n\nfn get_users_with_posts_optimized() {\n    // Single query with JOIN\n    return database.query(\"\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    \").group_by(|row| row.user_id)\n}\n\n// Benchmark improvements\nlet naive_time = perf::measure {\n    get_users_with_posts_naive()\n}\n\nlet optimized_time = perf::measure {\n    get_users_with_posts_optimized()\n}\n\nprintln(f\"Improvement: {naive_time / optimized_time:.1}x faster\")\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 9,
          "line_number": 543,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// File: web_server_optimization.ruchy\n// High-performance web server\n\nuse std::net::http;\nuse std::cache;\n\nlet app = http::Server::new(\"0.0.0.0:8080\")\n\n// Response caching\nlet response_cache = cache::LRU::new(1000)\n\napp.use(|req, res, next| {\n    let cache_key = req.method + \":\" + req.path + \":\" + req.query_string\n    \n    if req.method == \"GET\" && response_cache.has(cache_key) {\n        let cached = response_cache.get(cache_key)\n        return res\n            .status(200)\n            .header(\"X-Cache\", \"HIT\")\n            .send(cached)\n    }\n    \n    // Capture response for caching\n    let original_send = res.send\n    res.send = |body| {\n        if req.method == \"GET\" && res.status == 200 {\n            response_cache.set(cache_key, body, ttl: 60)\n        }\n        original_send(body)\n    }\n    \n    next()\n})\n\n// Static file serving with ETags\napp.static(\"/static\", \"./public\", {\n    maxAge: 86400,  // 1 day\n    etag: true,\n    gzip: true\n})\n\n// Database connection pooling\nlet db_pool = ConnectionPool::new(\n    url: \"postgres://localhost/myapp\",\n    min: 5,\n    max: 20\n)\n\n// Async request handling\napp.get(\"/api/data\", async |req, res| {\n    let conn = db_pool.acquire().await()\n    let data = conn.query(\"SELECT * FROM data\").await()\n    db_pool.release(conn)\n    \n    res.json(data)\n})\n\n// Enable HTTP/2\napp.enable_http2()\n\n// Compression middleware\napp.use(compression({\n    level: 6,\n    threshold: 1024,  // Only compress > 1KB\n    types: [\"text/*\", \"application/json\", \"application/javascript\"]\n}))\n\nprintln(\"üöÄ Optimized server running with:\")\nprintln(\"  ‚Ä¢ Response caching\")\nprintln(\"  ‚Ä¢ Connection pooling\")  \nprintln(\"  ‚Ä¢ HTTP/2 support\")\nprintln(\"  ‚Ä¢ Gzip compression\")\n\napp.listen()",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: ColonColon\n"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 10,
          "line_number": 627,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// File: data_pipeline_optimization.ruchy\n// Optimize large-scale data processing\n\nuse std::parallel;\nuse std::stream;\n\nfn process_dataset(input_file, output_file) {\n    let start = perf::Timer::start()\n    \n    // Stream processing to avoid loading all data\n    let input = stream::FileStream::new(input_file)\n    let output = stream::FileWriter::new(output_file)\n    \n    input\n        // Parse in parallel\n        .parallel_map(|line| {\n            parse_record(line)\n        }, workers: num_cpus())\n        \n        // Filter early to reduce data\n        .filter(|record| {\n            record.is_valid() && record.value > threshold\n        })\n        \n        // Batch for efficient processing\n        .batch(1000)\n        \n        // Process batches in parallel\n        .parallel_map(|batch| {\n            let enriched = enrich_batch(batch)\n            let transformed = transform_batch(enriched)\n            return transformed\n        })\n        \n        // Flatten batches\n        .flatten()\n        \n        // Write with buffering\n        .for_each(|record| {\n            output.write_line(to_json(record))\n        })\n    \n    let duration = start.elapsed()\n    let records = input.count()\n    let throughput = records / duration.seconds()\n    \n    println(\"Processed \" + records.to_s() + \" records in \" + duration.to_s())\n    println(f\"Throughput: {throughput:.0} records/second\")\n}\n\n// Monitor performance\nlet monitor = perf::Monitor::new()\n\nmonitor.track(\"cpu_usage\", || system::cpu_usage())\nmonitor.track(\"memory_usage\", || system::memory_usage())\nmonitor.track(\"disk_io\", || system::disk_io_rate())\n\nprocess_dataset(\"input.jsonl\", \"output.jsonl\")\n\nmonitor.report()",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: ColonColon\n"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 11,
          "line_number": 699,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// 1. Measure first\nperf::profile {\n    suspicious_function()\n}\n\n// 2. Optimize the right thing\n// Focus on the bottleneck, not random code\n\n// 3. Use the right algorithm\n// O(n) beats O(n¬≤) even with overhead\n\n// 4. Batch operations\n// 1 operation on 1000 items > 1000 operations on 1 item\n\n// 5. Cache expensive computations\nlet cache = memoize(expensive_function)\n\n// 6. Parallelize independent work\nparallel::map(items, process)\n\n// 7. Use async for I/O\nasync::wait_all(io_operations)\n\n// 8. Profile in production\n// Dev performance ‚â† Production performance",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: ColonColon\n"
        }
      ]
    },
    "ch19-00-real-world-projects": {
      "chapter": "ch19-00-real-world-projects",
      "total_examples": 4,
      "working_examples": 0,
      "failing_examples": 4,
      "examples": [
        {
          "file": "src/ch19-00-real-world-projects.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// taskmaster.ruchy - Complete task management system\nuse std::cli::{App, Arg, SubCommand};\nuse std::fs;\nuse std::chrono::{DateTime, Local};\n\n#[derive(Serialize, Deserialize, Clone)]\nstruct Task {\n    id: String,\n    title: String,\n    description: Option<String>,\n    status: TaskStatus,\n    priority: Priority,\n    due_date: Option<DateTime<Local>>,\n    tags: Vec<String>,\n    created_at: DateTime<Local>,\n    completed_at: Option<DateTime<Local>>,\n}\n\n#[derive(Serialize, Deserialize, Clone)]\nenum TaskStatus {\n    Todo,\n    InProgress,\n    Done,\n    Archived\n}\n\n#[derive(Serialize, Deserialize, Clone)]\nenum Priority {\n    Low,\n    Medium,\n    High,\n    Critical\n}\n\nstruct TaskStore {\n    path: PathBuf,\n    tasks: Vec<Task>,\n}\n\nimpl TaskStore {\n    fn load(path: PathBuf) -> Result<Self> {\n        let tasks = if path.exists() {\n            let content = fs::read_to_string(&path)?;\n            serde_json::from_str(&content)?\n        } else {\n            Vec::new()\n        };\n        \n        Ok(TaskStore { path, tasks })\n    }\n    \n    fn save(&self) -> Result<()> {\n        let json = serde_json::to_string_pretty(&self.tasks)?;\n        fs::write(&self.path, json)?;\n        Ok(())\n    }\n    \n    fn add(&mut self, task: Task) -> Result<()> {\n        self.tasks.push(task);\n        self.save()\n    }\n    \n    fn find(&self, id: &str) -> Option<&Task> {\n        self.tasks.iter().find(|t| t.id == id)\n    }\n    \n    fn update<F>(&mut self, id: &str, updater: F) -> Result<()>\n    where F: FnOnce(&mut Task)\n    {\n        if let Some(task) = self.tasks.iter_mut().find(|t| t.id == id) {\n            updater(task);\n            self.save()?;\n        }\n        Ok(())\n    }\n    \n    fn list(&self, filter: Option<TaskFilter>) -> Vec<&Task> {\n        self.tasks.iter()\n            .filter(|t| {\n                if let Some(ref f) = filter {\n                    f.matches(t)\n                } else {\n                    true\n                }\n            })\n            .collect()\n    }\n}\n\nstruct TaskFilter {\n    status: Option<TaskStatus>,\n    priority: Option<Priority>,\n    tags: Vec<String>,\n    search: Option<String>,\n}\n\nimpl TaskFilter {\n    fn matches(&self, task: &Task) -> bool {\n        if let Some(ref status) = self.status {\n            if task.status != *status {\n                return false;\n            }\n        }\n        \n        if let Some(ref priority) = self.priority {\n            if task.priority != *priority {\n                return false;\n            }\n        }\n        \n        if !self.tags.is_empty() {\n            if !self.tags.iter().any(|tag| task.tags.contains(tag)) {\n                return false;\n            }\n        }\n        \n        if let Some(ref search) = self.search {\n            let search_lower = search.to_lowercase();\n            if !task.title.to_lowercase().contains(&search_lower) &&\n               !task.description.as_ref()\n                   .map(|d| d.to_lowercase().contains(&search_lower))\n                   .unwrap_or(false) {\n                return false;\n            }\n        }\n        \n        true\n    }\n}\n\nfn main() -> Result<()> {\n    let app = App::new(\"taskmaster\")\n        .version(\"1.0.0\")\n        .author(\"Your Name\")\n        .about(\"Powerful task management from the command line\")\n        .subcommand(\n            SubCommand::with_name(\"add\")\n                .about(\"Add a new task\")\n                .arg(Arg::with_name(\"title\").required(true))\n                .arg(Arg::with_name(\"description\").short(\"d\").takes_value(true))\n                .arg(Arg::with_name(\"priority\").short(\"p\").takes_value(true))\n                .arg(Arg::with_name(\"due\").long(\"due\").takes_value(true))\n                .arg(Arg::with_name(\"tags\").short(\"t\").multiple(true))\n        )\n        .subcommand(\n            SubCommand::with_name(\"list\")\n                .about(\"List tasks\")\n                .arg(Arg::with_name(\"status\").short(\"s\").takes_value(true))\n                .arg(Arg::with_name(\"priority\").short(\"p\").takes_value(true))\n                .arg(Arg::with_name(\"tags\").short(\"t\").multiple(true))\n        )\n        .subcommand(\n            SubCommand::with_name(\"done\")\n                .about(\"Mark task as done\")\n                .arg(Arg::with_name(\"id\").required(true))\n        )\n        .get_matches();\n    \n    let store_path = dirs::home_dir()\n        .unwrap()\n        .join(\".taskmaster\")\n        .join(\"tasks.json\");\n    \n    let mut store = TaskStore::load(store_path)?;\n    \n    match app.subcommand() {\n        (\"add\", Some(matches)) => {\n            let task = Task {\n                id: generate_id(),\n                title: matches.value_of(\"title\").unwrap().to_string(),\n                description: matches.value_of(\"description\").map(String::from),\n                status: TaskStatus::Todo,\n                priority: matches.value_of(\"priority\")\n                    .and_then(|p| p.parse().ok())\n                    .unwrap_or(Priority::Medium),\n                due_date: matches.value_of(\"due\")\n                    .and_then(|d| parse_date(d).ok()),\n                tags: matches.values_of(\"tags\")\n                    .map(|tags| tags.map(String::from).collect())\n                    .unwrap_or_default(),\n                created_at: Local::now(),\n                completed_at: None,\n            };\n            \n            store.add(task)?;\n            println!(\"‚úÖ Task added successfully!\");\n        }\n        \n        (\"list\", Some(matches)) => {\n            let filter = TaskFilter {\n                status: matches.value_of(\"status\").and_then(|s| s.parse().ok()),\n                priority: matches.value_of(\"priority\").and_then(|p| p.parse().ok()),\n                tags: matches.values_of(\"tags\")\n                    .map(|tags| tags.map(String::from).collect())\n                    .unwrap_or_default(),\n                search: None,\n            };\n            \n            let tasks = store.list(Some(filter));\n            \n            for task in tasks {\n                let status_emoji = match task.status {\n                    TaskStatus::Todo => \"‚¨ú\",\n                    TaskStatus::InProgress => \"üîÑ\",\n                    TaskStatus::Done => \"‚úÖ\",\n                    TaskStatus::Archived => \"üì¶\",\n                };\n                \n                let priority_marker = match task.priority {\n                    Priority::Critical => \"üî¥\",\n                    Priority::High => \"üü†\",\n                    Priority::Medium => \"üü°\",\n                    Priority::Low => \"üü¢\",\n                };\n                \n                println!(\"{} {} {} {}\", \n                    status_emoji, \n                    priority_marker,\n                    task.id[..8].to_string(),\n                    task.title\n                );\n                \n                if let Some(ref desc) = task.description {\n                    println!(\"    {}\", desc);\n                }\n                \n                if !task.tags.is_empty() {\n                    println!(\"    Tags: {}\", task.tags.join(\", \"));\n                }\n            }\n        }\n        \n        (\"done\", Some(matches)) => {\n            let id = matches.value_of(\"id\").unwrap();\n            store.update(id, |task| {\n                task.status = TaskStatus::Done;\n                task.completed_at = Some(Local::now());\n            })?;\n            println!(\"‚úÖ Task marked as done!\");\n        }\n        \n        _ => {\n            println!(\"Use --help for usage information\");\n        }\n    }\n    \n    Ok(())\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected type\n"
        },
        {
          "file": "src/ch19-00-real-world-projects.md",
          "example_number": 2,
          "line_number": 290,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// api_server.ruchy - Complete web service\nuse warp::{Filter, Reply, Rejection};\nuse sqlx::{PgPool, FromRow};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Deserialize, Serialize, FromRow)]\nstruct User {\n    id: i32,\n    username: String,\n    email: String,\n    created_at: chrono::DateTime<chrono::Utc>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct CreateUser {\n    username: String,\n    email: String,\n    password: String,\n}\n\n#[derive(Clone)]\nstruct AppState {\n    db: PgPool,\n    jwt_secret: String,\n}\n\nasync fn create_user(\n    user: CreateUser,\n    state: AppState,\n) -> Result<impl Reply, Rejection> {\n    let hashed_password = hash_password(&user.password)?;\n    \n    let result = sqlx::query_as!(\n        User,\n        r#\"\n        INSERT INTO users (username, email, password_hash)\n        VALUES ($1, $2, $3)\n        RETURNING id, username, email, created_at\n        \"#,\n        user.username,\n        user.email,\n        hashed_password\n    )\n    .fetch_one(&state.db)\n    .await\n    .map_err(|e| reject::custom(DatabaseError(e)))?;\n    \n    Ok(warp::reply::json(&result))\n}\n\nasync fn get_user(\n    id: i32,\n    state: AppState,\n) -> Result<impl Reply, Rejection> {\n    let user = sqlx::query_as!(\n        User,\n        \"SELECT id, username, email, created_at FROM users WHERE id = $1\",\n        id\n    )\n    .fetch_one(&state.db)\n    .await\n    .map_err(|e| reject::custom(DatabaseError(e)))?;\n    \n    Ok(warp::reply::json(&user))\n}\n\nasync fn list_users(\n    state: AppState,\n) -> Result<impl Reply, Rejection> {\n    let users = sqlx::query_as!(\n        User,\n        \"SELECT id, username, email, created_at FROM users ORDER BY created_at DESC\"\n    )\n    .fetch_all(&state.db)\n    .await\n    .map_err(|e| reject::custom(DatabaseError(e)))?;\n    \n    Ok(warp::reply::json(&users))\n}\n\nfn with_state(\n    state: AppState,\n) -> impl Filter<Extract = (AppState,), Error = Infallible> + Clone {\n    warp::any().map(move || state.clone())\n}\n\nfn routes(state: AppState) -> impl Filter<Extract = impl Reply> + Clone {\n    let users_create = warp::path(\"users\")\n        .and(warp::post())\n        .and(warp::body::json())\n        .and(with_state(state.clone()))\n        .and_then(create_user);\n    \n    let users_get = warp::path!(\"users\" / i32)\n        .and(warp::get())\n        .and(with_state(state.clone()))\n        .and_then(get_user);\n    \n    let users_list = warp::path(\"users\")\n        .and(warp::get())\n        .and(with_state(state.clone()))\n        .and_then(list_users);\n    \n    let health = warp::path(\"health\")\n        .and(warp::get())\n        .map(|| \"OK\");\n    \n    users_create\n        .or(users_get)\n        .or(users_list)\n        .or(health)\n        .with(warp::cors().allow_any_origin())\n        .with(warp::log(\"api\"))\n        .recover(handle_rejection)\n}\n\nasync fn handle_rejection(err: Rejection) -> Result<impl Reply, Infallible> {\n    let code;\n    let message;\n    \n    if err.is_not_found() {\n        code = StatusCode::NOT_FOUND;\n        message = \"Not Found\";\n    } else if let Some(DatabaseError(_)) = err.find() {\n        code = StatusCode::INTERNAL_SERVER_ERROR;\n        message = \"Database Error\";\n    } else {\n        code = StatusCode::INTERNAL_SERVER_ERROR;\n        message = \"Internal Server Error\";\n    }\n    \n    let json = warp::reply::json(&ErrorResponse {\n        message: message.to_string(),\n    });\n    \n    Ok(warp::reply::with_status(json, code))\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    env_logger::init();\n    \n    let database_url = env::var(\"DATABASE_URL\")\n        .expect(\"DATABASE_URL must be set\");\n    \n    let pool = PgPool::connect(&database_url).await?;\n    \n    // Run migrations\n    sqlx::migrate!(\"./migrations\").run(&pool).await?;\n    \n    let state = AppState {\n        db: pool,\n        jwt_secret: env::var(\"JWT_SECRET\")\n            .expect(\"JWT_SECRET must be set\"),\n    };\n    \n    let routes = routes(state);\n    \n    println!(\"üöÄ Server running on http://localhost:3030\");\n    \n    warp::serve(routes)\n        .run(([0, 0, 0, 0], 3030))\n        .await;\n    \n    Ok(())\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected RightBrace, found ColonColon\n"
        },
        {
          "file": "src/ch19-00-real-world-projects.md",
          "example_number": 3,
          "line_number": 468,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// sysmon.ruchy - System monitoring dashboard\nuse sysinfo::{System, SystemExt, ProcessExt, CpuExt};\nuse tui::{Terminal, Frame, backend::CrosstermBackend};\nuse crossterm::event::{self, Event, KeyCode};\n\nstruct App {\n    system: System,\n    cpu_history: Vec<f32>,\n    memory_history: Vec<f32>,\n    selected_process: Option<usize>,\n    processes: Vec<ProcessInfo>,\n}\n\n#[derive(Clone)]\nstruct ProcessInfo {\n    pid: u32,\n    name: String,\n    cpu_usage: f32,\n    memory: u64,\n    status: String,\n}\n\nimpl App {\n    fn new() -> Self {\n        let mut system = System::new_all();\n        system.refresh_all();\n        \n        App {\n            system,\n            cpu_history: Vec::with_capacity(60),\n            memory_history: Vec::with_capacity(60),\n            selected_process: None,\n            processes: Vec::new(),\n        }\n    }\n    \n    fn update(&mut self) {\n        self.system.refresh_all();\n        \n        // Update CPU history\n        let cpu_usage = self.system.global_cpu_info().cpu_usage();\n        self.cpu_history.push(cpu_usage);\n        if self.cpu_history.len() > 60 {\n            self.cpu_history.remove(0);\n        }\n        \n        // Update memory history\n        let used_memory = self.system.used_memory();\n        let total_memory = self.system.total_memory();\n        let memory_usage = (used_memory as f32 / total_memory as f32) * 100.0;\n        self.memory_history.push(memory_usage);\n        if self.memory_history.len() > 60 {\n            self.memory_history.remove(0);\n        }\n        \n        // Update process list\n        self.processes = self.system.processes()\n            .iter()\n            .map(|(pid, process)| ProcessInfo {\n                pid: pid.as_u32(),\n                name: process.name().to_string(),\n                cpu_usage: process.cpu_usage(),\n                memory: process.memory(),\n                status: format!(\"{:?}\", process.status()),\n            })\n            .collect();\n        \n        // Sort by CPU usage\n        self.processes.sort_by(|a, b| \n            b.cpu_usage.partial_cmp(&a.cpu_usage).unwrap()\n        );\n    }\n    \n    fn draw(&self, frame: &mut Frame<impl Backend>) {\n        let chunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Length(3),\n                Constraint::Percentage(30),\n                Constraint::Percentage(30),\n                Constraint::Percentage(40),\n            ])\n            .split(frame.size());\n        \n        // Header\n        let header = Paragraph::new(\"System Monitor - Press 'q' to quit\")\n            .style(Style::default().fg(Color::Cyan))\n            .block(Block::default().borders(Borders::ALL));\n        frame.render_widget(header, chunks[0]);\n        \n        // CPU Chart\n        let cpu_data: Vec<(f64, f64)> = self.cpu_history\n            .iter()\n            .enumerate()\n            .map(|(i, &val)| (i as f64, val as f64))\n            .collect();\n        \n        let cpu_chart = Chart::new(vec![\n            Dataset::default()\n                .name(\"CPU\")\n                .marker(symbols::Marker::Dot)\n                .style(Style::default().fg(Color::Yellow))\n                .data(&cpu_data),\n        ])\n        .block(Block::default().title(\"CPU Usage\").borders(Borders::ALL))\n        .x_axis(Axis::default()\n            .bounds([0.0, 60.0])\n            .labels(vec![\"60s\", \"30s\", \"Now\"]))\n        .y_axis(Axis::default()\n            .bounds([0.0, 100.0])\n            .labels(vec![\"0%\", \"50%\", \"100%\"]));\n        \n        frame.render_widget(cpu_chart, chunks[1]);\n        \n        // Memory Chart\n        let memory_data: Vec<(f64, f64)> = self.memory_history\n            .iter()\n            .enumerate()\n            .map(|(i, &val)| (i as f64, val as f64))\n            .collect();\n        \n        let memory_chart = Chart::new(vec![\n            Dataset::default()\n                .name(\"Memory\")\n                .marker(symbols::Marker::Dot)\n                .style(Style::default().fg(Color::Blue))\n                .data(&memory_data),\n        ])\n        .block(Block::default().title(\"Memory Usage\").borders(Borders::ALL))\n        .x_axis(Axis::default()\n            .bounds([0.0, 60.0])\n            .labels(vec![\"60s\", \"30s\", \"Now\"]))\n        .y_axis(Axis::default()\n            .bounds([0.0, 100.0])\n            .labels(vec![\"0%\", \"50%\", \"100%\"]));\n        \n        frame.render_widget(memory_chart, chunks[2]);\n        \n        // Process List\n        let processes: Vec<ListItem> = self.processes\n            .iter()\n            .take(10)\n            .map(|p| {\n                let content = format!(\"{:5} {:20} {:6.1}% {:8}\",\n                    p.pid,\n                    p.name,\n                    p.cpu_usage,\n                    format_bytes(p.memory)\n                );\n                ListItem::new(content)\n            })\n            .collect();\n        \n        let process_list = List::new(processes)\n            .block(Block::default()\n                .title(\"Top Processes (PID | Name | CPU | Memory)\")\n                .borders(Borders::ALL))\n            .highlight_style(Style::default().bg(Color::DarkGray));\n        \n        frame.render_widget(process_list, chunks[3]);\n    }\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    // Setup terminal\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backend = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backend)?;\n    \n    let mut app = App::new();\n    let mut last_update = Instant::now();\n    \n    loop {\n        // Update data every second\n        if last_update.elapsed() >= Duration::from_secs(1) {\n            app.update();\n            last_update = Instant::now();\n        }\n        \n        // Draw UI\n        terminal.draw(|f| app.draw(f))?;\n        \n        // Handle events\n        if event::poll(Duration::from_millis(100))? {\n            if let Event::Key(key) = event::read()? {\n                match key.code {\n                    KeyCode::Char('q') => break,\n                    KeyCode::Up => {\n                        if let Some(selected) = &mut app.selected_process {\n                            if *selected > 0 {\n                                *selected -= 1;\n                            }\n                        }\n                    }\n                    KeyCode::Down => {\n                        if let Some(selected) = &mut app.selected_process {\n                            if *selected < app.processes.len() - 1 {\n                                *selected += 1;\n                            }\n                        } else {\n                            app.selected_process = Some(0);\n                        }\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n    \n    // Restore terminal\n    disable_raw_mode()?;\n    execute!(terminal.backend_mut(), LeaveAlternateScreen)?;\n    terminal.show_cursor()?;\n    \n    Ok(())\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected ',' or '}' in import list\n"
        },
        {
          "file": "src/ch19-00-real-world-projects.md",
          "example_number": 4,
          "line_number": 733,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// 1. Project structure\nmy-project/\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ main.rs\n‚îÇ   ‚îú‚îÄ‚îÄ lib.rs\n‚îÇ   ‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îú‚îÄ‚îÄ handlers/\n‚îÇ   ‚îî‚îÄ‚îÄ utils/\n‚îú‚îÄ‚îÄ tests/\n‚îú‚îÄ‚îÄ benches/\n‚îú‚îÄ‚îÄ docs/\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ README.md\n‚îî‚îÄ‚îÄ .github/\n    ‚îî‚îÄ‚îÄ workflows/\n\n// 2. Error handling\ntype Result<T> = std::result::Result<T, Error>;\n\n#[derive(Debug, thiserror::Error)]\nenum Error {\n    #[error(\"Database error: {0}\")]\n    Database(#[from] sqlx::Error),\n    \n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n    \n    #[error(\"Invalid input: {0}\")]\n    InvalidInput(String),\n}\n\n// 3. Configuration\n#[derive(Debug, Deserialize)]\nstruct Config {\n    server: ServerConfig,\n    database: DatabaseConfig,\n    #[serde(default)]\n    features: Features,\n}\n\nimpl Config {\n    fn load() -> Result<Self> {\n        // Try multiple sources\n        let config = config::Config::builder()\n            .add_source(config::File::with_name(\"config\"))\n            .add_source(config::Environment::with_prefix(\"APP\"))\n            .build()?;\n        \n        Ok(config.try_deserialize()?)\n    }\n}\n\n// 4. Logging\nfn init_logging() {\n    tracing_subscriber::fmt()\n        .with_env_filter(EnvFilter::from_default_env())\n        .with_target(false)\n        .with_thread_ids(true)\n        .with_file(true)\n        .with_line_number(true)\n        .init();\n}\n\n// 5. Testing\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_functionality() {\n        // Arrange\n        let input = prepare_test_data();\n        \n        // Act\n        let result = function_under_test(input);\n        \n        // Assert\n        assert_eq!(result, expected);\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: Dot\n"
        }
      ]
    },
    "ch11-00-advanced-patterns": {
      "chapter": "ch11-00-advanced-patterns",
      "total_examples": 12,
      "working_examples": 0,
      "failing_examples": 12,
      "examples": [
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// File: event_system.ruchy\n// Event-driven architecture with multiple patterns\n\nuse std::patterns;\n\n// Observer pattern for events\nclass EventBus {\n    let subscribers = {}\n    \n    fn on(event, handler) {\n        if !subscribers.has_key(event) {\n            subscribers[event] = []\n        }\n        subscribers[event].push(handler)\n        \n        // Return unsubscribe function (closure pattern)\n        return || {\n            subscribers[event] = subscribers[event].filter(|h| h != handler)\n        }\n    }\n    \n    fn emit(event, data) {\n        if subscribers.has_key(event) {\n            for handler in subscribers[event] {\n                spawn { handler(data) }  // Async pattern\n            }\n        }\n    }\n}\n\n// Singleton pattern for global event bus\nlet events = EventBus::singleton()\n\n// Decorator pattern for logging\nfn with_logging(handler) {\n    return |data| {\n        println(\"[\" + current_datetime() + \"] Event triggered: \" + data)\n        let result = handler(data)\n        println(\"[\" + current_datetime() + \"] Event completed\")\n        return result\n    }\n}\n\n// Usage combining patterns\nlet unsubscribe = events.on(\"user.login\", with_logging(|user| {\n    println(\"User \" + user.name + \" logged in\")\n    update_last_login(user)\n}))\n\nevents.emit(\"user.login\", {name: \"Alice\", id: 123})",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected field name\n"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 2,
          "line_number": 96,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Fluent interface for configuration\nclass ServerBuilder {\n    let config = {\n        port: 8080,\n        host: \"localhost\",\n        threads: 4,\n        timeout: 30000,\n        middleware: [],\n        routes: {}\n    }\n    \n    fn port(p) {\n        config.port = p\n        return self  // Enable chaining\n    }\n    \n    fn host(h) {\n        config.host = h\n        return self\n    }\n    \n    fn threads(t) {\n        config.threads = t\n        return self\n    }\n    \n    fn use(middleware) {\n        config.middleware.push(middleware)\n        return self\n    }\n    \n    fn route(path, handler) {\n        config.routes[path] = handler\n        return self\n    }\n    \n    fn build() {\n        validate_config()\n        return Server::new(config)\n    }\n}\n\n// Clean, readable configuration\nlet server = ServerBuilder::new()\n    .port(3000)\n    .host(\"0.0.0.0\")\n    .threads(8)\n    .use(cors())\n    .use(auth())\n    .use(logging())\n    .route(\"/\", home_handler)\n    .route(\"/api\", api_handler)\n    .build()",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected field name\n"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 3,
          "line_number": 161,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Different compression strategies\nclass CompressionContext {\n    let strategy\n    \n    fn set_strategy(s) {\n        strategy = s\n    }\n    \n    fn compress(data) {\n        return strategy.compress(data)\n    }\n}\n\nclass GzipStrategy {\n    fn compress(data) {\n        return gzip::compress(data, level: 6)\n    }\n}\n\nclass BrotliStrategy {\n    fn compress(data) {\n        return brotli::compress(data, quality: 4)\n    }\n}\n\nclass NoCompressionStrategy {\n    fn compress(data) {\n        return data\n    }\n}\n\n// Choose strategy based on context\nlet compressor = CompressionContext::new()\n\nif file_size > mb(10) {\n    compressor.set_strategy(BrotliStrategy::new())  // Better for large files\n} else if client_supports_gzip {\n    compressor.set_strategy(GzipStrategy::new())\n} else {\n    compressor.set_strategy(NoCompressionStrategy::new())\n}\n\nlet compressed = compressor.compress(file_data)",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected field name\n"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 4,
          "line_number": 216,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Middleware chain for request processing\nclass MiddlewareChain {\n    let middlewares = []\n    \n    fn use(middleware) {\n        middlewares.push(middleware)\n    }\n    \n    fn execute(request, response) {\n        let index = 0\n        \n        fn next() {\n            if index < middlewares.len() {\n                let middleware = middlewares[index]\n                index += 1\n                middleware(request, response, next)\n            }\n        }\n        \n        next()\n    }\n}\n\n// Define middleware\nfn auth_middleware(req, res, next) {\n    let token = req.header(\"Authorization\")\n    if !token {\n        return res.status(401).json({error: \"Unauthorized\"})\n    }\n    \n    req.user = validate_token(token)\n    next()\n}\n\nfn rate_limit_middleware(req, res, next) {\n    let key = req.ip\n    if rate_limiter.exceeded(key) {\n        return res.status(429).json({error: \"Too many requests\"})\n    }\n    \n    rate_limiter.increment(key)\n    next()\n}\n\nfn cache_middleware(req, res, next) {\n    let cache_key = req.url\n    if cache.has(cache_key) {\n        return res.send(cache.get(cache_key))\n    }\n    \n    // Intercept response to cache it\n    let original_send = res.send\n    res.send = |data| {\n        cache.set(cache_key, data)\n        original_send(data)\n    }\n    \n    next()\n}\n\n// Build the chain\nlet chain = MiddlewareChain::new()\nchain.use(rate_limit_middleware)\nchain.use(auth_middleware)\nchain.use(cache_middleware)\nchain.use(route_handler)\n\nchain.execute(request, response)",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected field name\n"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 5,
          "line_number": 298,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Function composition\nfn compose(...functions) {\n    return |x| {\n        let result = x\n        for f in functions.reverse() {\n            result = f(result)\n        }\n        return result\n    }\n}\n\n// Pipeline operator\nfn pipeline(value, ...functions) {\n    let result = value\n    for f in functions {\n        result = f(result)\n    }\n    return result\n}\n\n// Example: Data transformation pipeline\nlet process_data = compose(\n    validate,\n    normalize,\n    enrich,\n    transform,\n    format\n)\n\nlet result = process_data(raw_data)\n\n// Or using pipeline\nlet result = pipeline(\n    raw_data,\n    validate,\n    normalize,\n    enrich,\n    transform,\n    format\n)",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Function parameters must be simple identifiers (destructuring patterns not supported)\n"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 6,
          "line_number": 350,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Result monad for error handling\nclass Result {\n    let value\n    let error\n    \n    static fn ok(val) {\n        return Result{value: val, error: null}\n    }\n    \n    static fn err(e) {\n        return Result{value: null, error: e}\n    }\n    \n    fn is_ok() {\n        return error == null\n    }\n    \n    fn map(f) {\n        if is_ok() {\n            return Result::ok(f(value))\n        }\n        return self\n    }\n    \n    fn flat_map(f) {\n        if is_ok() {\n            return f(value)\n        }\n        return self\n    }\n    \n    fn unwrap_or(default) {\n        if is_ok() {\n            return value\n        }\n        return default\n    }\n}\n\n// Chain operations safely\nfn process_user(id) {\n    return fetch_user(id)\n        .map(|user| validate_user(user))\n        .flat_map(|user| enrich_user_data(user))\n        .map(|user| format_user(user))\n        .unwrap_or({error: \"Processing failed\"})\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected field name\n"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 7,
          "line_number": 409,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Lazy sequences\nclass LazySeq {\n    let generator\n    let cache = []\n    let index = 0\n    \n    fn next() {\n        if index >= cache.len() {\n            let value = generator()\n            if value != null {\n                cache.push(value)\n            }\n        }\n        \n        if index < cache.len() {\n            let value = cache[index]\n            index += 1\n            return value\n        }\n        \n        return null\n    }\n    \n    fn take(n) {\n        let result = []\n        for i in range(n) {\n            let value = next()\n            if value == null {\n                break\n            }\n            result.push(value)\n        }\n        return result\n    }\n    \n    fn map(f) {\n        return LazySeq::new(|| {\n            let value = next()\n            if value != null {\n                return f(value)\n            }\n            return null\n        })\n    }\n    \n    fn filter(predicate) {\n        return LazySeq::new(|| {\n            loop {\n                let value = next()\n                if value == null {\n                    return null\n                }\n                if predicate(value) {\n                    return value\n                }\n            }\n        })\n    }\n}\n\n// Infinite sequence\nlet fibonacci = LazySeq::new(|| {\n    static let a = 0\n    static let b = 1\n    let next = a\n    a = b\n    b = next + b\n    return next\n})\n\n// Only computes what's needed\nlet first_10_even = fibonacci\n    .filter(|n| n % 2 == 0)\n    .take(10)",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected field name\n"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 8,
          "line_number": 497,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Generic repository interface\nclass Repository {\n    fn find(id)\n    fn find_all()\n    fn find_where(conditions)\n    fn save(entity)\n    fn delete(id)\n}\n\n// Concrete implementation\nclass UserRepository < Repository {\n    let db\n    \n    fn find(id) {\n        let row = db.query_one(\"SELECT * FROM users WHERE id = ?\", [id])\n        return row ? User::from_row(row) : null\n    }\n    \n    fn find_where(conditions) {\n        let query = QueryBuilder::new(\"users\")\n            .where(conditions)\n            .build()\n        \n        return db.query(query).map(|row| User::from_row(row))\n    }\n    \n    fn save(user) {\n        if user.id {\n            db.execute(\"UPDATE users SET ... WHERE id = ?\", user.to_row())\n        } else {\n            user.id = db.execute(\"INSERT INTO users ... VALUES ...\", user.to_row())\n        }\n        return user\n    }\n}\n\n// Use repository in service layer\nclass UserService {\n    let repository\n    \n    fn get_active_users() {\n        return repository.find_where({active: true})\n    }\n    \n    fn create_user(data) {\n        let user = User::new(data)\n        user.validate()\n        return repository.save(user)\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected field name\n"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 9,
          "line_number": 559,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Event sourcing system\nclass EventStore {\n    let events = []\n    let snapshots = {}\n    let projections = {}\n    \n    fn append(event) {\n        event.id = generate_id()\n        event.timestamp = current_time()\n        event.version = events.len() + 1\n        \n        events.push(event)\n        update_projections(event)\n        \n        // Create snapshot every 100 events\n        if events.len() % 100 == 0 {\n            create_snapshot()\n        }\n    }\n    \n    fn replay(from_version = 0) {\n        let state = snapshots.get_latest_before(from_version) || {}\n        \n        for event in events.filter(|e| e.version > from_version) {\n            state = apply_event(state, event)\n        }\n        \n        return state\n    }\n    \n    fn get_projection(name) {\n        return projections[name]\n    }\n}\n\n// Domain events\nclass OrderPlaced {\n    let order_id\n    let customer_id\n    let items\n    let total\n}\n\nclass PaymentReceived {\n    let order_id\n    let amount\n    let method\n}\n\n// Event handlers update projections\nfn handle_order_placed(event) {\n    projections.orders[event.order_id] = {\n        status: \"pending\",\n        customer: event.customer_id,\n        total: event.total\n    }\n    \n    projections.customer_orders[event.customer_id].push(event.order_id)\n}\n\n// Rebuild state from events\nlet current_state = event_store.replay()",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected field name\n"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 10,
          "line_number": 633,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Command side - writes\nclass CommandBus {\n    let handlers = {}\n    \n    fn register(command_type, handler) {\n        handlers[command_type] = handler\n    }\n    \n    fn dispatch(command) {\n        let handler = handlers[command.type]\n        if !handler {\n            throw \"No handler for command: \" + command.type\n        }\n        \n        return handler(command)\n    }\n}\n\n// Query side - reads\nclass QueryBus {\n    let handlers = {}\n    \n    fn register(query_type, handler) {\n        handlers[query_type] = handler\n    }\n    \n    fn query(query) {\n        let handler = handlers[query.type]\n        if !handler {\n            throw \"No handler for query: \" + query.type\n        }\n        \n        return handler(query)\n    }\n}\n\n// Commands modify state\ncommand_bus.register(\"CreateOrder\", |cmd| {\n    let order = Order::new(cmd.data)\n    order.validate()\n    event_store.append(OrderPlaced::new(order))\n    return order.id\n})\n\n// Queries read projections\nquery_bus.register(\"GetOrdersByCustomer\", |query| {\n    return read_model.get_customer_orders(query.customer_id)\n})\n\n// Usage\nlet order_id = command_bus.dispatch({\n    type: \"CreateOrder\",\n    data: {customer: 123, items: [...]}\n})\n\nlet orders = query_bus.query({\n    type: \"GetOrdersByCustomer\",\n    customer_id: 123\n})",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected field name\n"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 11,
          "line_number": 706,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Actor system\nclass Actor {\n    let mailbox = Queue::new()\n    let running = true\n    \n    fn receive(message) {\n        mailbox.push(message)\n    }\n    \n    fn start() {\n        spawn {\n            while running {\n                let message = mailbox.pop()\n                if message {\n                    handle_message(message)\n                }\n                sleep(1)\n            }\n        }\n    }\n    \n    fn handle_message(message) {\n        // Override in subclass\n    }\n}\n\n// Concrete actor\nclass WorkerActor < Actor {\n    let state = {}\n    \n    fn handle_message(message) {\n        match message.type {\n            \"process\" => {\n                let result = process_work(message.data)\n                message.reply_to.receive({\n                    type: \"result\",\n                    data: result\n                })\n            }\n            \"get_state\" => {\n                message.reply_to.receive({\n                    type: \"state\",\n                    data: state\n                })\n            }\n            \"shutdown\" => {\n                running = false\n            }\n        }\n    }\n}\n\n// Actor system\nlet system = ActorSystem::new()\nlet worker = system.spawn(WorkerActor)\n\nworker.send({\n    type: \"process\",\n    data: work_item,\n    reply_to: self\n})",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected field name\n"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 12,
          "line_number": 779,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\nclass CircuitBreaker {\n    let failure_threshold = 5\n    let timeout = 30000\n    let failure_count = 0\n    let last_failure_time = 0\n    let state = \"closed\"  // closed, open, half_open\n    \n    fn call(operation) {\n        if state == \"open\" {\n            if current_time() - last_failure_time > timeout {\n                state = \"half_open\"\n            } else {\n                throw \"Circuit breaker is open\"\n            }\n        }\n        \n        try {\n            let result = operation()\n            \n            if state == \"half_open\" {\n                state = \"closed\"\n                failure_count = 0\n            }\n            \n            return result\n        } catch error {\n            failure_count += 1\n            last_failure_time = current_time()\n            \n            if failure_count >= failure_threshold {\n                state = \"open\"\n                println(\"Circuit breaker opened after \" + failure_count.to_s() + \" failures\")\n            }\n            \n            throw error\n        }\n    }\n}\n\n// Use circuit breaker for external service\nlet api_breaker = CircuitBreaker::new()\n\nfn call_external_api(data) {\n    return api_breaker.call(|| {\n        http::post(\"https://api.external.com/endpoint\")\n            .json(data)\n            .timeout(5000)\n            .send()\n    })\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected field name\n"
        }
      ]
    },
    "appendix-b-syntax-reference": {
      "chapter": "appendix-b-syntax-reference",
      "total_examples": 35,
      "working_examples": 5,
      "failing_examples": 30,
      "examples": [
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 1,
          "line_number": 23,
          "code": "// Status: ‚ùå BROKEN\n\n// Single line comment\n\n/* \n   Multi-line comment\n   Can span multiple lines\n*/\n\n/// Documentation comment for the following item\nfn documented_function() {}\n\n//! Inner documentation comment for containing item\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 2,
          "line_number": 44,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Valid identifiers\nvariable_name\ncamelCase\nPascalCase\n_private\n_internal\nsnake_case_123\nœÑ  // Unicode allowed\n\n// Keywords (reserved)\nlet mut fn if else match while for loop break continue\nreturn true false null struct enum trait impl use mod\nasync await type where const static pub super self",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected '(' or '[' after macro name\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 3,
          "line_number": 68,
          "code": "// Status: ‚ùå BROKEN\n\n// Integers\n42          // Decimal\n0xFF        // Hexadecimal  \n0o77        // Octal\n0b1010      // Binary\n1_000_000   // With separators\n\n// Floating point\n3.14\n2.0\n1e6         // Scientific notation\n1.5e-10\n\n// Type suffixes\n42i32       // 32-bit integer\n3.14f64     // 64-bit float\n100u8       // Unsigned 8-bit\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 4,
          "line_number": 95,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// String literals\n\"hello world\"\n\"unicode: Œ±Œ≤Œ≥\"\n\"escapes: \\n \\t \\r \\\\ \\\" \\'\"\n\n// Raw strings (no escapes)\nr\"raw string with \\n literal backslashes\"\nr#\"can contain \"quotes\" with # delimiters\"#\nr##\"even more \"# nested # delimiters\"##\n\n// Multi-line strings\n\"line one\\\nline two\"\n\n// Format strings\n\"Hello, \" + name + \"!\"\n\"Result: \" + value.to_s()",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected '[' after '#'\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 5,
          "line_number": 121,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n'a'         // ASCII character\n'\\n'        // Escape sequence\n'\\x41'      // Hex escape\n'\\u{1F600}' // Unicode escape",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected Arrow, found Bang\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 6,
          "line_number": 136,
          "code": "// Status: ‚ùå BROKEN\n\n// Boolean\nlet flag: bool = true\n\n// Integers\nlet small: i8 = -128           // 8-bit signed\nlet byte: u8 = 255             // 8-bit unsigned  \nlet short: i16 = -32768        // 16-bit signed\nlet word: u16 = 65535          // 16-bit unsigned\nlet int: i32 = -2147483648     // 32-bit signed\nlet uint: u32 = 4294967295     // 32-bit unsigned\nlet long: i64 = -9223372036854775808  // 64-bit signed\nlet ulong: u64 = 18446744073709551615 // 64-bit unsigned\nlet size: isize = -1           // Pointer-sized signed\nlet usize: usize = 1           // Pointer-sized unsigned\n\n// Floating point\nlet single: f32 = 3.14         // 32-bit float\nlet double: f64 = 2.718281828  // 64-bit float\n\n// Character\nlet ch: char = 'A'             // Unicode scalar value\n\n// String\nlet text: str = \"hello\"        // String slice\nlet owned: String = \"world\"    // Owned string\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 7,
          "line_number": 171,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Arrays (fixed size)\nlet arr: [i32; 5] = [1, 2, 3, 4, 5]\nlet zeros: [i32; 100] = [0; 100]\n\n// Slices (dynamic size)\nlet slice: &[i32] = &arr[1..3]\n\n// Tuples\nlet tuple: (i32, str, bool) = (42, \"hello\", true)\nlet unit: () = ()  // Unit type\n\n// Vectors (dynamic arrays)\nlet vec: Vec<i32> = vec![1, 2, 3, 4, 5]\n\n// Hash maps\nlet map: HashMap<String, i32> = HashMap::new()\n\n// Options\nlet maybe: Option<i32> = Some(42)\nlet nothing: Option<i32> = None\n\n// Results  \nlet ok: Result<i32, String> = Ok(42)\nlet err: Result<i32, String> = Err(\"error message\")",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected RightBracket, found Semicolon\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 8,
          "line_number": 206,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Immutable by default\nlet x = 42\nlet name = \"Alice\"\n\n// Explicit type annotation\nlet count: i32 = 100\nlet score: f64 = 95.5\n\n// Mutable variables\nlet mut counter = 0\ncounter += 1\n\n// Pattern destructuring\nlet (x, y) = (10, 20)\nlet [first, second, ..] = [1, 2, 3, 4, 5]\n\n// Shadowing\nlet x = 42\nlet x = \"now a string\"  // Shadows previous x",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected identifier after 'let' or 'let mut'\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 9,
          "line_number": 234,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Compile-time constants\nconst MAX_SIZE: usize = 1024\nconst PI: f64 = 3.14159265359\n\n// Static variables\nstatic GLOBAL_COUNTER: AtomicUsize = AtomicUsize::new(0)\nstatic mut GLOBAL_STATE: i32 = 0  // Unsafe to mutate",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: Const\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 10,
          "line_number": 252,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// If expressions\nlet result = if condition {\n    \"true branch\"\n} else {\n    \"false branch\"\n}\n\n// Multiple conditions\nif x > 0 {\n    \"positive\"\n} else if x < 0 {\n    \"negative\"  \n} else {\n    \"zero\"\n}\n\n// Let-else pattern\nlet Some(value) = optional else {\n    return Err(\"No value\")\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected identifier after 'let' or 'let mut'\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 11,
          "line_number": 281,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Match expressions\nmatch value {\n    0 => \"zero\",\n    1 | 2 => \"one or two\",\n    3..=10 => \"three through ten\",\n    n if n > 100 => \"big number\",\n    _ => \"something else\"\n}\n\n// Destructuring patterns\nmatch point {\n    Point { x: 0, y: 0 } => \"origin\",\n    Point { x, y: 0 } => \"on x-axis at \" + x.to_s() + \",\",\n    Point { x: 0, y } => \"on y-axis at \" + y.to_s() + \",\",\n    Point { x, y } => \"point at (\" + x.to_s() + \", \" + y.to_s() + \")\"\n}\n\n// Guards\nmatch number {\n    n if n < 0 => \"negative\",\n    n if n > 0 => \"positive\", \n    _ => \"zero\"\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected FatArrow, found If\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 12,
          "line_number": 313,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Infinite loop\nloop {\n    // Code here\n    if condition {\n        break\n    }\n}\n\n// While loop\nwhile condition {\n    // Code here\n}\n\n// For loop with iterators\nfor item in collection {\n    // Process item\n}\n\n// For loop with range\nfor i in 0..10 {\n    println(\"Count: \" + i.to_s())\n}\n\n// For loop with enumerate\nfor (index, item) in collection.enumerate() {\n    println(index.to_s() + \": \" + item)\n}\n\n// Loop labels and break/continue\n'outer: loop {\n    loop {\n        if condition {\n            break 'outer  // Break outer loop\n        }\n        if other_condition {\n            continue 'outer  // Continue outer loop\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected identifier after 'for'\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 13,
          "line_number": 363,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Basic function\nfn greet(name: String) -> String {\n    return \"Hello, \" + name + \"!\"\n}\n\n// Implicit return (no semicolon)\nfn add(a: i32, b: i32) -> i32 {\n    a + b  // Last expression is returned\n}\n\n// Unit return type (no return value)\nfn print_message(msg: String) {\n    println(msg)\n}\n\n// Multiple parameters\nfn calculate(x: f64, y: f64, operation: char) -> f64 {\n    match operation {\n        '+' => x + y,\n        '-' => x - y,\n        '*' => x * y,\n        '/' => x / y,\n        _ => panic(\"Invalid operation\")\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected FatArrow, found Char('+')\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 14,
          "line_number": 397,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// By value (move)\nfn take_ownership(s: String) {\n    // s is moved here\n}\n\n// By reference (borrow)\nfn borrow_value(s: &String) -> usize {\n    s.len()  // s is borrowed\n}\n\n// Mutable reference\nfn modify_value(s: &mut String) {\n    s.push_str(\" modified\")\n}\n\n// Default parameters\nfn connect(host: String, port: u16 = 8080, timeout: u64 = 5000) {\n    // Implementation\n}\n\n// Variable arguments\nfn sum(numbers: &[i32]) -> i32 {\n    numbers.iter().sum()\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected type\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 15,
          "line_number": 430,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Closure syntax\nlet add = |a, b| a + b\nlet result = add(5, 3)\n\n// Explicit types\nlet multiply: fn(i32, i32) -> i32 = |a, b| a * b\n\n// Capturing environment\nlet x = 10\nlet add_x = |y| x + y  // Captures x\nlet result = add_x(5)  // 15\n\n// Move capture\nlet name = String::from(\"Alice\")\nlet greeter = move |greeting| {\n    greeting + \", \" + name + \"!\"  // name is moved into closure\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected type\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 16,
          "line_number": 456,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Function as parameter\nfn apply_operation(x: i32, y: i32, op: fn(i32, i32) -> i32) -> i32 {\n    op(x, y)\n}\n\n// Function returning function\nfn make_adder(n: i32) -> impl Fn(i32) -> i32 {\n    move |x| x + n\n}\n\n// Generic function\nfn map_over<T, U, F>(items: Vec<T>, f: F) -> Vec<U>\nwhere F: Fn(T) -> U\n{\n    items.into_iter().map(f).collect()\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected type\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 17,
          "line_number": 483,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Basic struct\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\n// Tuple struct\nstruct Color(u8, u8, u8)\n\n// Unit struct\nstruct Marker\n\n// Generic struct\nstruct Container<T> {\n    value: T,\n}\n\n// Struct with lifetime\nstruct Excerpt<'a> {\n    text: &'a str,\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected LeftBrace, found LeftParen\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 18,
          "line_number": 513,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Creating instances\nlet origin = Point { x: 0.0, y: 0.0 }\nlet red = Color(255, 0, 0)\n\n// Field access\nlet x_coord = origin.x\n\n// Struct update syntax\nlet point2 = Point { x: 1.0, ..origin }\n\n// Destructuring\nlet Point { x, y } = origin\nlet Color(r, g, b) = red",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected field name\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 19,
          "line_number": 535,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Basic enum\nenum Direction {\n    North,\n    South,\n    East,\n    West,\n}\n\n// Enum with data\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\n// Generic enum\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected RightBrace, found LeftBrace\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 20,
          "line_number": 565,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\nimpl Point {\n    // Associated function (constructor)\n    fn new(x: f64, y: f64) -> Point {\n        Point { x, y }\n    }\n    \n    // Method (takes &self)\n    fn distance_from_origin(&self) -> f64 {\n        (self.x.powi(2) + self.y.powi(2)).sqrt()\n    }\n    \n    // Mutable method (takes &mut self)\n    fn translate(&mut self, dx: f64, dy: f64) {\n        self.x += dx\n        self.y += dy\n    }\n    \n    // Consuming method (takes self)\n    fn into_tuple(self) -> (f64, f64) {\n        (self.x, self.y)\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected Colon, found Comma\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 21,
          "line_number": 598,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Basic trait\ntrait Draw {\n    fn draw(&self)\n}\n\n// Trait with default implementation\ntrait Summary {\n    fn summarize_author(&self) -> String\n    \n    fn summarize(&self) -> String {\n        \"(Read more from \" + self.summarize_author() + \"...)\"\n    }\n}\n\n// Trait with associated types\ntrait Iterator {\n    type Item\n    \n    fn next(&mut self) -> Option<Self::Item>\n}\n\n// Trait with generic parameters\ntrait From<T> {\n    fn from(value: T) -> Self\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected 'fun' or 'fn' keyword\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 22,
          "line_number": 632,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\nimpl Draw for Point {\n    fn draw(&self) {\n        println(\"Drawing point at (\" + self.x.to_s() + \", \" + self.y.to_s() + \")\")\n    }\n}\n\n// Conditional implementation\nimpl<T: Display> ToString for T {\n    fn to_string(&self) -> String {\n        // Implementation\n    }\n}\n\n// Blanket implementation\nimpl<T: Clone> Clone for Box<T> {\n    fn clone(&self) -> Box<T> {\n        // Implementation  \n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected Greater, found Colon\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 23,
          "line_number": 662,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\nfn largest<T: PartialOrd>(list: &[T]) -> &T {\n    let mut largest = &list[0]\n    for item in list {\n        if item > largest {\n            largest = item\n        }\n    }\n    largest\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected Greater, found Colon\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 24,
          "line_number": 680,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Point<T> {\n    fn new(x: T, y: T) -> Point<T> {\n        Point { x, y }\n    }\n}\n\nimpl Point<f64> {\n    fn distance_from_origin(&self) -> f64 {\n        (self.x.powi(2) + self.y.powi(2)).sqrt()\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected LeftBrace, found Less\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 25,
          "line_number": 705,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Single bound\nfn print_it<T: Display>(item: T) {\n    println(\"{}\", item)\n}\n\n// Multiple bounds\nfn compare_and_print<T: Display + PartialOrd>(a: T, b: T) {\n    if a > b {\n        println(\"a is greater\")\n    } else {\n        println(\"b is greater or equal\")\n    }\n}\n\n// Where clause\nfn some_function<T, U>(t: T, u: U) -> i32\nwhere\n    T: Display + Clone,\n    U: Clone + Debug,\n{\n    // Implementation\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected Greater, found Colon\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 26,
          "line_number": 738,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Inline module\nmod network {\n    fn connect() {\n        // Implementation\n    }\n    \n    pub fn public_function() {\n        // Can be called from outside module\n    }\n}\n\n// File-based modules\nmod utils;  // Looks for utils.rs or utils/mod.rs\n\n// Nested modules\nmod graphics {\n    pub mod shapes {\n        pub fn draw_circle() {}\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected LeftBrace, found Semicolon\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 27,
          "line_number": 767,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\npub fn public_function() {}           // Public\nfn private_function() {}              // Private to module\n\npub struct PublicStruct {\n    pub public_field: i32,            // Public field\n    private_field: i32,               // Private field\n}\n\npub(crate) fn crate_visible() {}      // Visible within crate\npub(super) fn parent_visible() {}     // Visible to parent module\npub(in crate::utils) fn limited() {} // Visible within specific path",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected 'fn', 'struct', 'enum', 'trait', 'impl', or 'mod' after 'pub'\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 28,
          "line_number": 787,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\nuse std::collections::HashMap         // Single import\nuse std::fs::{File, OpenOptions}      // Multiple imports\nuse std::io::*                        // Glob import\nuse std::collections::HashMap as Map  // Alias\n\n// Re-exports\npub use internal::public_api\n\n// Conditional compilation\n#[cfg(unix)]\nuse unix_specific::module\n\n#[cfg(windows)]  \nuse windows_specific::module",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected 'fn', 'struct', 'enum', 'trait', 'impl', or 'mod' after 'pub'\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 29,
          "line_number": 812,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Result type\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n\n// Option type\nenum Option<T> {\n    Some(T),\n    None,\n}\n\n// Using ? operator\nfn read_file(path: &str) -> Result<String, std::io::Error> {\n    let content = std::fs::read_to_string(path)?\n    Ok(content.to_uppercase())\n}\n\n// Combining with match\nmatch result {\n    Ok(value) => println(\"Success: {}\", value),\n    Err(error) => eprintln(\"Error: {}\", error),\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected enum name\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 30,
          "line_number": 844,
          "code": "// Status: ‚ùå BROKEN\n\n// Unconditional panic\npanic!(\"Something went wrong!\")\n\n// Conditional panic\nassert!(condition, \"Condition must be true\")\nassert_eq!(left, right, \"Values must be equal\")\n\n// Debug assertions (only in debug builds)\ndebug_assert!(expensive_check())\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 31,
          "line_number": 865,
          "code": "// Status: ‚ùå BROKEN\n\n// Function-like macros\nprintln!(\"Hello, {}!\", name)\nvec![1, 2, 3, 4, 5]\nformat!(\"Value: {}\", x)\n\n// Attribute-like macros\n#[derive(Debug, Clone)]\nstruct MyStruct {}\n\n#[cfg(test)]\nmod tests {}\n\n// Derive macros\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\nstruct Point { x: i32, y: i32 }\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 32,
          "line_number": 890,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Declarative macro\nmacro_rules! say_hello {\n    () => {\n        println!(\"Hello!\")\n    };\n    ($name:expr) => {\n        println!(\"Hello, {}!\", $name)\n    };\n}\n\n// Usage\nsay_hello!()\nsay_hello!(\"World\")",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected '(' or '[' after macro name\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 33,
          "line_number": 914,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Conditional compilation\n#[cfg(target_os = \"linux\")]\nfn linux_only() {}\n\n#[cfg(feature = \"network\")]\nmod networking {}\n\n// Testing\n#[test]\nfn test_function() {}\n\n#[ignore]\n#[test]\nfn expensive_test() {}\n\n// Documentation\n#[doc = \"This is a documented function\"]\nfn documented() {}\n\n// Deprecation\n#[deprecated(note = \"Use new_function instead\")]\nfn old_function() {}\n\n// Allow/deny lints\n#[allow(dead_code)]\nfn unused_function() {}\n\n#[deny(missing_docs)]\nmod well_documented {}\n\n// Inline hints\n#[inline]\nfn small_function() {}\n\n#[inline(always)]\nfn always_inline() {}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: RightParen\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 34,
          "line_number": 961,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Async function\nasync fn fetch_data(url: &str) -> Result<String, reqwest::Error> {\n    let response = reqwest::get(url).await?\n    let text = response.text().await?\n    Ok(text)\n}\n\n// Async blocks\nlet future = async {\n    let result = some_async_operation().await\n    process_result(result)\n}\n\n// Async closures\nlet async_closure = async |x| {\n    expensive_async_operation(x).await\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected type\n"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 35,
          "line_number": 987,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\nuse futures::{Future, Stream}\n\n// Implementing Future\nimpl Future for MyFuture {\n    type Output = i32\n    \n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n        // Implementation\n    }\n}\n\n// Working with streams\nlet stream = async_stream::stream! {\n    for i in 0..10 {\n        yield i\n        tokio::time::sleep(Duration::from_millis(100)).await\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected 'fun' or 'fn' keyword\n"
        }
      ]
    },
    "ch18-00-deployment-devops": {
      "chapter": "ch18-00-deployment-devops",
      "total_examples": 8,
      "working_examples": 4,
      "failing_examples": 4,
      "examples": [
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ‚ùå BROKEN\n\n// deploy.ruchy - One-command deployment\nuse std::deploy;\n\nlet config = DeployConfig {\n    app: \"my-app\",\n    environment: env::var(\"DEPLOY_ENV\"),  // staging/production\n    strategy: BlueGreen,\n    health_check: \"/health\",\n    rollback_on_failure: true\n}\n\n// Build and test\ndeploy::build()\n    .test()\n    .security_scan()\n    .create_artifact()\n\n// Deploy with zero downtime\nlet deployment = deploy::start(config)\n    .provision_infrastructure()\n    .deploy_new_version()\n    .run_smoke_tests()\n    .switch_traffic()\n    .verify_metrics()\n\nif deployment.is_healthy() {\n    deployment.commit()\n    println(\"‚úÖ Deployment successful!\")\n} else {\n    deployment.rollback()\n    println(\"‚ö†Ô∏è  Rolled back to previous version\")\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 2,
          "line_number": 277,
          "code": "// Status: ‚ùå BROKEN\n\n// blue_green.ruchy\nfn deploy_blue_green(new_version: String) {\n    // Current production is \"blue\"\n    let blue = Environment::current()\n    \n    // Provision identical \"green\" environment\n    let green = Environment::provision(new_version)\n    \n    // Deploy to green\n    green.deploy()\n    green.run_health_checks()\n    green.run_smoke_tests()\n    \n    // Verify green is healthy\n    if !green.is_healthy() {\n        green.destroy()\n        panic!(\"Green environment unhealthy\")\n    }\n    \n    // Switch traffic to green\n    LoadBalancer::switch_to(green)\n    \n    // Monitor for issues\n    sleep(Duration::from_mins(5))\n    \n    if green.error_rate() > 0.01 {\n        // Rollback\n        LoadBalancer::switch_to(blue)\n        green.destroy()\n        panic!(\"High error rate, rolled back\")\n    }\n    \n    // Success - green is now production\n    blue.destroy()\n    println!(\"‚úÖ Deployed version {}\", new_version)\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 3,
          "line_number": 326,
          "code": "// Status: ‚ùå BROKEN\n\n// canary.ruchy\nfn deploy_canary(new_version: String) {\n    let deployment = CanaryDeployment::new(new_version)\n    \n    // Start with 5% traffic\n    deployment.set_traffic_percentage(5)\n    deployment.deploy()\n    \n    // Monitor metrics\n    let baseline = Metrics::baseline()\n    \n    // Gradually increase traffic\n    for percentage in [5, 10, 25, 50, 100] {\n        deployment.set_traffic_percentage(percentage)\n        \n        sleep(Duration::from_mins(10))\n        \n        let current = Metrics::current()\n        if current.error_rate > baseline.error_rate * 1.1 {\n            deployment.rollback()\n            panic!(\"Error rate increased by >10%\")\n        }\n        \n        if current.p99_latency > baseline.p99_latency * 1.2 {\n            deployment.rollback()\n            panic!(\"Latency increased by >20%\")\n        }\n        \n        println!(\"‚úÖ Canary at {}% - metrics healthy\", percentage)\n    }\n    \n    deployment.finalize()\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 4,
          "line_number": 372,
          "code": "// Status: ‚ùå BROKEN\n\n// feature_flags.ruchy\nuse feature_flags::{Client, Flag};\n\nlet flags = Client::new(\"api_key\")\n\n// Define feature flag\nlet new_algorithm = Flag::new(\"new-algorithm\")\n    .default(false)\n    .rollout_percentage(10)  // 10% of users\n    .targeting_rules([\n        Rule::new(\"beta_users\", true),\n        Rule::new(\"internal_users\", true)\n    ])\n\n// Use in code\nif flags.is_enabled(new_algorithm, user) {\n    use_new_algorithm()\n} else {\n    use_old_algorithm()\n}\n\n// Gradual rollout\nfor percentage in [10, 25, 50, 75, 100] {\n    flags.set_rollout(new_algorithm, percentage)\n    monitor_metrics()\n    \n    if metrics_degraded() {\n        flags.disable(new_algorithm)\n        break\n    }\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 5,
          "line_number": 475,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// metrics.ruchy\nuse metrics::{counter, gauge, histogram};\n\n// Application metrics\ncounter!(\"requests_total\", 1, \"endpoint\" => \"/api/users\")\nhistogram!(\"request_duration_seconds\", duration.as_secs_f64())\ngauge!(\"active_connections\", connections.len() as f64)\n\n// Prometheus endpoint\n#[get(\"/metrics\")]\nasync fn metrics_endpoint() -> String {\n    prometheus::gather()\n}\n\n// Grafana dashboard configuration\nlet dashboard = json!({\n    \"title\": \"Application Metrics\",\n    \"panels\": [\n        {\n            \"title\": \"Request Rate\",\n            \"targets\": [{\n                \"expr\": \"rate(requests_total[5m])\"\n            }]\n        },\n        {\n            \"title\": \"Error Rate\",\n            \"targets\": [{\n                \"expr\": \"rate(requests_total{status=~'5..'}[5m])\"\n            }]\n        },\n        {\n            \"title\": \"P99 Latency\",\n            \"targets\": [{\n                \"expr\": \"histogram_quantile(0.99, request_duration_seconds)\"\n            }]\n        }\n    ]\n})",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected ',' or closing delimiter in macro arguments\n"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 6,
          "line_number": 523,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// logging.ruchy\nuse tracing::{info, warn, error, debug, span, Level};\n\n// Structured logging\n#[instrument]\nasync fn process_request(req: Request) -> Result<Response, Error> {\n    let span = span!(Level::INFO, \"request\", \n        method = %req.method(),\n        path = %req.path(),\n        request_id = %generate_id()\n    );\n    \n    let _enter = span.enter();\n    \n    info!(\"Processing request\");\n    \n    let result = match handle_request(req).await {\n        Ok(response) => {\n            info!(status = response.status(), \"Request successful\");\n            Ok(response)\n        }\n        Err(e) => {\n            error!(error = ?e, \"Request failed\");\n            Err(e)\n        }\n    };\n    \n    result\n}\n\n// Log aggregation config\nlet config = json!({\n    \"sinks\": {\n        \"elasticsearch\": {\n            \"type\": \"elasticsearch\",\n            \"endpoints\": [\"http://elasticsearch:9200\"],\n            \"index\": \"logs-%Y.%m.%d\"\n        },\n        \"s3\": {\n            \"type\": \"aws_s3\",\n            \"bucket\": \"my-app-logs\",\n            \"compression\": \"gzip\"\n        }\n    }\n})",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected type\n"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 7,
          "line_number": 578,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// tracing.ruchy\nuse opentelemetry::{global, sdk, trace::Tracer};\n\n// Initialize tracing\nlet tracer = global::tracer(\"my-app\")\n\n// Trace requests\n#[instrument(skip(db))]\nasync fn handle_request(req: Request, db: &Database) -> Result<Response> {\n    let span = tracer.start(\"handle_request\")\n    \n    // Trace database query\n    let user = db.with_span(\"fetch_user\", |db| {\n        db.query_one(\"SELECT * FROM users WHERE id = $1\", &[req.user_id()])\n    }).await?\n    \n    // Trace external API call\n    let data = http_client.with_span(\"fetch_external_data\", |client| {\n        client.get(\"https://api.example.com/data\").send()\n    }).await?\n    \n    span.end()\n    \n    Ok(Response::new(data))\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected ',' or '}' in import list\n"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 8,
          "line_number": 669,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// secrets.ruchy\nuse vault::Client;\n\n// Vault integration\nlet vault = Client::new(\"https://vault.example.com\")\n    .auth_kubernetes()  // Use K8s service account\n\n// Fetch secrets\nlet db_password = vault.read(\"secret/database/password\").await?\nlet api_key = vault.read(\"secret/external/api_key\").await?\n\n// Rotate secrets\nvault.rotate(\"secret/database/password\").await?\n\n// Environment injection\nenv::set_var(\"DATABASE_URL\", \n    format!(\"postgres://user:{}@host/db\", db_password))",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: Question\n"
        }
      ]
    },
    "ch01-03-interpreter-scripting": {
      "chapter": "ch01-03-interpreter-scripting",
      "total_examples": 15,
      "working_examples": 15,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 1,
          "line_number": 28,
          "code": "// Status: ‚ùå BROKEN\nruchy -e \"2 + 2\"\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 2,
          "line_number": 38,
          "code": "// Status: ‚ùå BROKEN\nruchy -e \"let name = \\\"World\\\"; \\\"Hello \\\" + name + \\\"!\\\"\"\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 3,
          "line_number": 48,
          "code": "// Status: ‚ùå BROKEN\nruchy -e \"let nums = [1, 2, 3]; nums[1]\"\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 4,
          "line_number": 76,
          "code": "// Status: ‚ùå BROKEN\nfun main() {\n    // Integer values\n    let small_int = 42\n    let result = small_int * 2\n\n    // Floating point numbers  \n    let pi = 3.14159\n    let area = pi * 5.0 * 5.0\n\n    // String operations\n    let greeting = \"Hello\"\n    let name = \"Ruchy\"\n\n    // Arrays with indexing\n    let data = [1, 2, 3, 4, 5]\n    println(data[2])\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 5,
          "line_number": 121,
          "code": "// Status: ‚ùå BROKEN\n// calculator.ruchy - Basic calculator functionality\n\nfun add(a, b) {\n    a + b\n}\n\nfun subtract(a, b) {\n    a - b\n}\n\nfun multiply(a, b) {\n    a * b\n}\n\nfun divide(a, b) {\n    if b == 0 {\n        println(\"Error: Division by zero\")\n        0\n    } else {\n        a / b\n    }\n}\n\nfun main() {\n    // Test our calculator\n    let x = 10\n    let y = 3\n\n    println(\"Addition:\")\n    println(add(x, y))\n    println(\"Subtraction:\")\n    println(subtract(x, y))\n    println(\"Multiplication:\")\n    println(multiply(x, y))\n    println(\"Division:\")\n    println(divide(x, y))\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 6,
          "line_number": 172,
          "code": "// Status: ‚ùå BROKEN\n// data_processing.ruchy - Array manipulation examples\n\nfun main() {\n    let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    // Access elements\n    println(\"First:\")\n    println(numbers[0])\n    println(\"Last:\")\n    println(numbers[9])\n\n    // Simple iteration (manual)\n    let mut sum = 0\n    let mut i = 0\n    while i < 10 {\n        sum = sum + numbers[i]\n        i = i + 1\n    }\n    println(\"Sum:\")\n    println(sum)\n\n    // Calculate average\n    let average = sum / 10\n    println(\"Average:\")\n    println(average)\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 7,
          "line_number": 209,
          "code": "// Status: ‚ùå BROKEN\n// scoping.ruchy - Variable scope examples\n\nlet global_var = \"I'm global\"\n\nfun demonstrate_scope() {\n    let local_var = \"I'm local\"\n    println(global_var)  // Can access global\n    println(local_var)   // Can access local\n    \n    // Nested function\n    fun nested() {\n        println(global_var)  // Can access global\n        println(local_var)   // Can access parent local\n        let nested_var = \"I'm nested\"\n        println(nested_var)\n    }\n    \n    nested()\n}\n\nfun main() {\n    demonstrate_scope()\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 8,
          "line_number": 245,
          "code": "// Status: ‚ùå BROKEN\nfun main() {\n    let arr = [1, 2, 3]\n\n    // Unsafe - may cause error if index is out of bounds\n    // println(arr[5])\n\n    // Better approach\n    if 5 < arr.len() {\n        println(arr[5])\n    } else {\n        println(\"Index out of bounds\")\n    }\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 9,
          "line_number": 269,
          "code": "// Status: ‚ùå BROKEN\nfun main() {\n    let x = 5\n    // x = 10  // Error! x is immutable\n\n    // Use mut for mutable variables\n    let mut y = 5\n    y = 10  // OK\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 10,
          "line_number": 288,
          "code": "// Status: ‚ùå BROKEN\nfun get_double(x) {\n    x * 2  // This is returned (no semicolon)\n}\n\nfun process_and_print(x) {\n    let doubled = x * 2\n    println(\"Doubled:\")\n    println(doubled)\n    // No explicit return - returns unit type ()\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 11,
          "line_number": 351,
          "code": "// Status: ‚ùå BROKEN\n// Good: Clear, functional style\nfun calculate_tax(income, rate) {\n    income * rate\n}\n\n// Avoid: Complex nested logic (for now)\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 12,
          "line_number": 365,
          "code": "// Status: ‚ùå BROKEN\n// Good\nlet user_count = 42\nlet total_price = calculate_price(items)\n\n// Avoid\nlet x = 42\nlet y = calc(z)\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 13,
          "line_number": 382,
          "code": "// Status: ‚ùå BROKEN\nfun main() {\n    let grades = [95, 87, 92, 78, 89]\n    let first_grade = grades[0]\n    let last_grade = grades[4]\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 14,
          "line_number": 397,
          "code": "// Status: ‚ùå BROKEN\n// Add functions\nfun double(n) { n * 2 }\n\nfun main() {\n    // Start simple\n    let x = 5\n\n    // Combine\n    let result = double(x)\n    println(result)\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 15,
          "line_number": 419,
          "code": "// Status: ‚ùå BROKEN\n// test_calculator.ruchy\nfun add(a, b) { a + b }\n\nfun main() {\n    // Test cases\n    let test1 = add(2, 3) == 5\n    let test2 = add(0, 0) == 0\n    let test3 = add(-1, 1) == 0\n\n    if test1 && test2 && test3 {\n        println(\"All tests passed!\")\n    } else {\n        println(\"Some tests failed\")\n    }\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch17-00-documentation": {
      "chapter": "ch17-00-documentation",
      "total_examples": 10,
      "working_examples": 2,
      "failing_examples": 8,
      "examples": [
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n/// A high-performance cache with automatic eviction.\n/// \n/// # Examples\n/// \n/// ```\n/// let cache = Cache::new(100)  // Max 100 items\n/// cache.insert(\"key\", \"value\")\n/// assert_eq!(cache.get(\"key\"), Some(\"value\"))\n/// ```\n/// \n/// # Performance\n/// \n/// - Insert: O(1) amortized\n/// - Get: O(1)\n/// - Memory: O(n) where n is cache size\n/// \n/// # Thread Safety\n/// \n/// This cache is thread-safe using internal locking.\n/// For better performance with multiple threads, consider\n/// using `ShardedCache` instead.\npub struct Cache<K, V> {\n    /// Maximum number of items before eviction starts\n    capacity: usize\n    \n    /// Current items in cache\n    items: HashMap<K, V>\n    \n    /// Access order for LRU eviction\n    order: LinkedList<K>\n}\n\nimpl<K, V> Cache<K, V> {\n    /// Creates a new cache with the specified capacity.\n    /// \n    /// # Arguments\n    /// \n    /// * `capacity` - Maximum items to store before eviction\n    /// \n    /// # Panics\n    /// \n    /// Panics if capacity is 0.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// let cache = Cache::new(1000)\n    /// ```\n    pub fn new(capacity: usize) -> Self {\n        assert!(capacity > 0, \"Capacity must be positive\")\n        // Implementation\n    }\n    \n    /// Inserts a key-value pair, evicting LRU item if at capacity.\n    /// \n    /// Returns the evicted value if any.\n    /// \n    /// # Complexity\n    /// \n    /// O(1) amortized time complexity.\n    pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n        // Implementation with inline comments for complex parts\n        \n        // Update access order for LRU\n        self.update_access_order(&key)\n        \n        // Check capacity and evict if necessary\n        if self.items.len() >= self.capacity {\n            // Evict least recently used\n            let lru = self.order.pop_front()\n            // ...\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected RightBrace, found Identifier(\"items\")\n"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 2,
          "line_number": 120,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n/// Single line summary of what this does.\n/// \n/// More detailed explanation that provides context,\n/// use cases, and important information.\n/// \n/// # Arguments\n/// \n/// * `param1` - Description of first parameter\n/// * `param2` - Description of second parameter\n/// \n/// # Returns\n/// \n/// Description of return value and what it represents.\n/// \n/// # Errors\n/// \n/// * `ErrorType1` - When this error occurs\n/// * `ErrorType2` - When that error occurs\n/// \n/// # Examples\n/// \n/// ```\n/// let result = function(arg1, arg2)?\n/// assert_eq!(result, expected)\n/// ```\n/// \n/// # Safety\n/// \n/// This function is safe to call from multiple threads.\n/// \n/// # Performance\n/// \n/// Time: O(n log n)\n/// Space: O(n)\npub fn documented_function(param1: Type1, param2: Type2) -> Result<Return, Error> {\n    // Implementation\n}\n\n// Module-level documentation\n//! # Module Name\n//! \n//! This module provides functionality for...\n//! \n//! ## Overview\n//! \n//! Explain the module's purpose and main components.\n//! \n//! ## Usage\n//! \n//! ```\n//! use mylib::module\n//! \n//! let thing = module::Thing::new()\n//! thing.do_stuff()\n//! ```\n\n// Inner documentation\nimpl Struct {\n    fn method(&self) {\n        //! This method does...\n        \n        // Regular comment for implementation details\n        let temp = calculate_something()\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected type\n"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 3,
          "line_number": 197,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n/// Calculates the factorial of a number.\n/// \n/// # Examples\n/// \n/// ```\n/// assert_eq!(factorial(0), 1)\n/// assert_eq!(factorial(5), 120)\n/// assert_eq!(factorial(10), 3628800)\n/// ```\n/// \n/// ```should_panic\n/// factorial(-1)  // Panics on negative input\n/// ```\n/// \n/// ```no_run\n/// // Example that shouldn't be executed during tests\n/// let huge = factorial(1000000)\n/// ```\n/// \n/// ```ignore\n/// // Example that's temporarily broken\n/// let result = factorial(non_existent_var)\n/// ```\npub fn factorial(n: i32) -> i32 {\n    assert!(n >= 0, \"Factorial undefined for negative numbers\")\n    if n <= 1 { 1 } else { n * factorial(n - 1) }\n}\n\n// Run doc tests\n$ ruchy test --doc\n   Doc-tests mylib\nrunning 4 doc tests\ntest src/lib.rs - factorial (line 5) ... ok\ntest src/lib.rs - factorial (line 9) ... ok\ntest src/lib.rs - factorial (line 13) ... ok\ntest src/lib.rs - factorial (line 17) ... ignored\n\ntest result: ok. 3 passed; 0 failed; 1 ignored",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected RightParen, found Integer(5)\n"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 4,
          "line_number": 247,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n/// Configuration for the application.\n/// \n/// This struct holds all configuration values needed to run\n/// the application. It can be loaded from files, environment\n/// variables, or command-line arguments.\n/// \n/// # Example Configuration File\n/// \n/// ```toml\n/// [server]\n/// host = \"localhost\"\n/// port = 8080\n/// \n/// [database]\n/// url = \"postgres://localhost/myapp\"\n/// pool_size = 20\n/// ```\n#[derive(Deserialize, Serialize, Debug)]\npub struct Config {\n    /// Server configuration\n    pub server: ServerConfig,\n    \n    /// Database configuration  \n    pub database: DatabaseConfig,\n    \n    /// Optional cache configuration\n    pub cache: Option<CacheConfig>,\n}\n\n/// Server configuration options.\n#[derive(Deserialize, Serialize, Debug)]\npub struct ServerConfig {\n    /// Host to bind to (default: \"127.0.0.1\")\n    #[serde(default = \"default_host\")]\n    pub host: String,\n    \n    /// Port to listen on (default: 8080)\n    #[serde(default = \"default_port\")]\n    pub port: u16,\n    \n    /// Number of worker threads (default: CPU cores)\n    #[serde(default = \"num_cpus\")]\n    pub workers: usize,\n}\n\n// Generate HTML documentation\n$ ruchy doc --open\nDocumenting mylib v0.1.0\n    Finished documentation\n    Opening docs/mylib/index.html",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected type\n"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 5,
          "line_number": 309,
          "code": "// Status: ‚ùå BROKEN\n\n//! # System Architecture\n//! \n//! ## Overview\n//! \n//! This application follows a layered architecture:\n//! \n//! ```text\n//! ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n//! ‚îÇ          HTTP Layer             ‚îÇ\n//! ‚îÇ  (Handlers, Middleware, Routes) ‚îÇ\n//! ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n//!               ‚îÇ\n//! ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n//! ‚îÇ        Service Layer            ‚îÇ\n//! ‚îÇ   (Business Logic, Validation)  ‚îÇ\n//! ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n//!               ‚îÇ\n//! ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n//! ‚îÇ      Repository Layer           ‚îÇ\n//! ‚îÇ    (Database Access, Caching)   ‚îÇ\n//! ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n//!               ‚îÇ\n//! ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n//! ‚îÇ         Data Layer              ‚îÇ\n//! ‚îÇ    (PostgreSQL, Redis, S3)      ‚îÇ\n//! ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n//! ```\n//! \n//! ## Data Flow\n//! \n//! 1. Request enters through HTTP handler\n//! 2. Handler validates input and calls service\n//! 3. Service applies business logic\n//! 4. Repository handles data persistence\n//! 5. Response flows back through layers\n//! \n//! ## Key Design Decisions\n//! \n//! ### Why Layered Architecture?\n//! \n//! - **Separation of Concerns**: Each layer has a single responsibility\n//! - **Testability**: Layers can be tested independently with mocks\n//! - **Flexibility**: Easy to swap implementations (e.g., database)\n//! \n//! ### Why Event Sourcing?\n//! \n//! - **Audit Trail**: Complete history of all changes\n//! - **Time Travel**: Can reconstruct state at any point\n//! - **Event Replay**: Easy to fix bugs in event processing\n\n/// Module containing HTTP handlers\npub mod handlers {\n    //! HTTP request handlers.\n    //! \n    //! Each handler is responsible for:\n    //! - Request validation\n    //! - Calling appropriate service\n    //! - Response formatting\n}\n\n/// Module containing business logic\npub mod services {\n    //! Business logic layer.\n    //! \n    //! Services contain all business rules and orchestrate\n    //! operations across multiple repositories.\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 6,
          "line_number": 505,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n/// # Examples Section\n/// \n/// ## Basic Usage\n/// \n/// The simplest way to use this library:\n/// \n/// ```\n/// use mylib::Thing;\n/// \n/// let thing = Thing::default();\n/// thing.process()?;\n/// ```\n/// \n/// ## Advanced Usage\n/// \n/// For more control, configure manually:\n/// \n/// ```\n/// use mylib::{Thing, Config};\n/// \n/// let config = Config::builder()\n///     .timeout(5000)\n///     .retries(3)\n///     .build()?;\n/// \n/// let thing = Thing::with_config(config);\n/// ```\n/// \n/// ## Error Handling\n/// \n/// All operations return `Result`:\n/// \n/// ```\n/// match thing.risky_operation() {\n///     Ok(value) => println!(\"Success: {}\", value),\n///     Err(e) => eprintln!(\"Error: {}\", e),\n/// }\n/// ```\n/// \n/// ## Complete Example\n/// \n/// Here's a full working program:\n/// \n/// ```no_run\n/// use mylib::{Thing, Config, Error};\n/// \n/// fn main() -> Result<(), Error> {\n///     let config = Config::from_env()?;\n///     let thing = Thing::with_config(config);\n///     \n///     for item in thing.process_all()? {\n///         println!(\"Processed: {:?}\", item);\n///     }\n///     \n///     Ok(())\n/// }\n/// ```",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Empty program\n"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 7,
          "line_number": 574,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Generate interactive documentation site\n$ ruchy doc --format html --output docs/\n\n// With search, examples, and playground\n$ ruchy doc --features search,playground,examples\n\n// Serve documentation locally\n$ ruchy doc --serve --port 8080\nServing documentation at http://localhost:8080",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: Comma\n"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 8,
          "line_number": 593,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n/// Interactive API endpoint documentation\n/// \n/// <playground>\n/// {\n///   \"endpoint\": \"/api/users\",\n///   \"method\": \"POST\",\n///   \"body\": {\n///     \"name\": \"Alice\",\n///     \"email\": \"alice@example.com\"\n///   }\n/// }\n/// </playground>\n#[post(\"/api/users\")]\npub async fn create_user(user: Json<User>) -> Result<Json<User>, Error> {\n    // Implementation\n}\n\n// Generates interactive API tester in docs",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: RightBracket\n"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 9,
          "line_number": 623,
          "code": "// Status: ‚ùå BROKEN\n\n// Generate documentation from code\n#[doc_gen]\nimpl ConfigBuilder {\n    // Automatically documents builder pattern\n}\n\n// Generate diagrams from code\n#[diagram(sequence)]\nasync fn request_flow() {\n    client.send_request()\n    server.validate()\n    server.process()\n    server.respond()\n}\n\n// Generates:\n// Client -> Server: send_request()\n// Server -> Server: validate()\n// Server -> Server: process()\n// Server -> Client: respond()\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 10,
          "line_number": 654,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Check documentation quality\n$ ruchy doc-lint\nChecking documentation...\n\n‚ö†Ô∏è  Missing documentation: src/internal.rs:15 `fn process()`\n‚ö†Ô∏è  Broken link: src/lib.rs:42 `[Config](../config.html)`\n‚ö†Ô∏è  Outdated example: src/api.rs:88 (code changed)\n‚ùå  Missing examples: src/client.rs `struct Client`\n\nDocumentation score: 87/100\n\n// Enforce in CI\n$ ruchy doc-lint --min-score 90",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: DotDotDot\n"
        }
      ]
    },
    "ch06-00-file-operations": {
      "chapter": "ch06-00-file-operations",
      "total_examples": 10,
      "working_examples": 7,
      "failing_examples": 3,
      "examples": [
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// File: desktop_organizer.ruchy\n// Organizes files by type into folders\n\nprintln(\"=== Desktop Organizer ===\")\n\n// Define organization rules\nlet file_categories = {\n    \"Documents\": [\".pdf\", \".doc\", \".docx\", \".txt\"],\n    \"Images\": [\".jpg\", \".jpeg\", \".png\", \".gif\", \".svg\"],\n    \"Videos\": [\".mp4\", \".avi\", \".mov\", \".mkv\"],\n    \"Code\": [\".py\", \".js\", \".rs\", \".ruchy\", \".cpp\"],\n    \"Data\": [\".csv\", \".json\", \".xml\", \".xlsx\"]\n}\n\nlet source_dir = \"~/Desktop\"\nlet files = list_files(source_dir)\n\nprintln(\"Found \" + files.len().to_s() + \" files to organize\")\n\n// Organize files\nfor file in files {\n    let extension = get_extension(file).lower()\n    \n    for category, extensions in file_categories.items() {\n        if extensions.contains(extension) {\n            let target_dir = join_path(source_dir, category)\n            \n            // Create category folder if needed\n            if !dir_exists(target_dir) {\n                create_dir(target_dir)\n                println(\"Created folder: \" + category)\n            }\n            \n            // Move file to appropriate folder\n            let source = join_path(source_dir, file)\n            let destination = join_path(target_dir, file)\n            \n            move_file(source, destination)\n            println(\"  Moved \" + file + \" -> \" + category + \"/\")\n            break\n        }\n    }\n}\n\nprintln(\"‚úÖ Desktop organized!\")",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected In, found Comma\n"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 2,
          "line_number": 90,
          "code": "// Status: ‚ùå BROKEN\n\n// Current directory operations\nlet current_dir = get_current_dir()\nset_current_dir(\"/home/user/projects\")\n\n// Path operations\nlet full_path = absolute_path(\"data.txt\")\nlet parent = parent_dir(full_path)\nlet filename = file_name(full_path)\nlet extension = file_extension(full_path)\n\n// Path joining and normalization\nlet project_path = join_path(home_dir(), \"projects\", \"my_app\")\nlet clean_path = normalize_path(\".././data//file.txt\")\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 3,
          "line_number": 115,
          "code": "// Status: ‚ùå BROKEN\n\n// Check file properties\nlet exists = file_exists(\"config.json\")\nlet size = file_size(\"data.csv\")  // In bytes\nlet modified = file_modified_time(\"log.txt\")\nlet is_read_only = is_readonly(\"system.conf\")\n\n// File type checking\nlet is_file = is_file(path)\nlet is_dir = is_directory(path)\nlet is_symlink = is_symbolic_link(path)\n\n// Permissions (Unix-like systems)\nlet can_read = is_readable(path)\nlet can_write = is_writable(path)\nlet can_execute = is_executable(path)\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 4,
          "line_number": 142,
          "code": "// Status: ‚ùå BROKEN\n\n// Create and remove directories\ncreate_dir(\"new_folder\")\ncreate_dir_all(\"path/to/nested/folder\")  // Creates parent dirs\nremove_dir(\"empty_folder\")\nremove_dir_all(\"folder_with_contents\")  // Recursive delete\n\n// List directory contents\nlet all_items = list_dir(\".\")\nlet files_only = list_files(\".\")\nlet dirs_only = list_directories(\".\")\n\n// Recursive directory walking\nfn walk_directory(dir) {\n    let items = list_dir(dir)\n    for item in items {\n        let path = join_path(dir, item)\n        if is_directory(path) {\n            walk_directory(path)  // Recurse into subdirectory\n        } else {\n            process_file(path)\n        }\n    }\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 5,
          "line_number": 178,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// File: smart_backup.ruchy\n// Creates timestamped backups of important files\n\nprintln(\"=== Smart Backup System ===\")\n\nlet backup_config = {\n    \"documents\": [\"~/Documents\", \"*.doc\", \"*.pdf\", \"*.txt\"],\n    \"code\": [\"~/Projects\", \"*.py\", \"*.js\", \"*.rs\"],\n    \"config\": [\"~/.config\", \"*.conf\", \"*.json\", \"*.yaml\"]\n}\n\nlet backup_root = \"~/Backups\"\nlet timestamp = current_datetime().format(\"%Y%m%d_%H%M%S\")\nlet backup_dir = join_path(backup_root, \"backup_\" + timestamp)\n\ncreate_dir_all(backup_dir)\nprintln(\"Creating backup at: \" + backup_dir)\n\nlet total_files = 0\nlet total_size = 0\n\nfor category, config in backup_config.items() {\n    let source_dir = expand_home(config[0])\n    let patterns = config[1..]\n    \n    let category_dir = join_path(backup_dir, category)\n    create_dir(category_dir)\n    \n    println(\"\\nüìÅ Backing up \" + category + \"...\")\n    \n    for pattern in patterns {\n        let files = glob(join_path(source_dir, pattern))\n        \n        for file in files {\n            let size = file_size(file)\n            let relative_path = relative_to(file, source_dir)\n            let backup_path = join_path(category_dir, relative_path)\n            \n            // Create parent directories\n            let parent = parent_dir(backup_path)\n            if !dir_exists(parent) {\n                create_dir_all(parent)\n            }\n            \n            // Copy file to backup\n            copy_file(file, backup_path)\n            total_files += 1\n            total_size += size\n            \n            println(\"  ‚úì \" + relative_path + \" (\" + format_size(size) + \")\")\n        }\n    }\n}\n\nprintln(\"\\n‚úÖ Backup complete!\")\nprintln(\"Files backed up: \" + total_files.to_s())\nprintln(\"Total size: \" + format_size(total_size))\nprintln(\"Location: \" + backup_dir)\n\n// Create backup summary\nlet summary = \"Backup Summary\\n==============\\nDate: \" + timestamp + \"\\nFiles: \" + total_files.to_s() + \"\\nSize: \" + format_size(total_size) + \"\\nCategories: \" + backup_config.keys().join(\", \") + \"\\n\"\n\nwrite_file(join_path(backup_dir, \"summary.txt\"), summary)",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected In, found Comma\n"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 6,
          "line_number": 251,
          "code": "// Status: ‚ùå BROKEN\n\n// File: find_duplicates.ruchy\n// Finds duplicate files based on content hash\n\nprintln(\"=== Duplicate File Finder ===\")\n\nlet search_dir = input(\"Enter directory to search: \")\nlet min_size = input(\"Minimum file size (bytes, 0 for all): \").to_i()\n\nprintln(\"\\nScanning \" + search_dir + \"...\")\n\n// Build file hash map\nlet file_hashes = {}\nlet duplicates = []\n\nfn hash_file(path) {\n    let content = read_bytes(path)\n    return sha256(content)\n}\n\nfn scan_directory(dir) {\n    let items = list_dir(dir)\n    \n    for item in items {\n        let path = join_path(dir, item)\n        \n        if is_directory(path) {\n            scan_directory(path)  // Recurse\n        } else if is_file(path) {\n            let size = file_size(path)\n            \n            if size >= min_size {\n                let hash = hash_file(path)\n                \n                if file_hashes.has_key(hash) {\n                    // Found duplicate\n                    duplicates.push({\n                        \"original\": file_hashes[hash],\n                        \"duplicate\": path,\n                        \"size\": size,\n                        \"hash\": hash\n                    })\n                } else {\n                    file_hashes[hash] = path\n                }\n            }\n        }\n    }\n}\n\nscan_directory(search_dir)\n\nif duplicates.is_empty() {\n    println(\"\\n‚úÖ No duplicate files found!\")\n} else {\n    println(\"\\n‚ö†Ô∏è  Found \" + duplicates.len().to_s() + \" duplicate files:\")\n    \n    let total_wasted = 0\n    \n    for dup in duplicates {\n        println(\"\\nOriginal: \" + dup.original)\n        println(\"Duplicate: \" + dup.duplicate)\n        println(\"Size: \" + format_size(dup.size))\n        total_wasted += dup.size\n    }\n    \n    println(\"\\nTotal space wasted: \" + format_size(total_wasted))\n    \n    let action = input(\"\\nDelete duplicates? (y/n): \")\n    if action.lower() == \"y\" {\n        for dup in duplicates {\n            remove_file(dup.duplicate)\n            println(\"Deleted: \" + dup.duplicate)\n        }\n        println(\"\\n‚úÖ Freed \" + format_size(total_wasted) + \" of space!\")\n    }\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 7,
          "line_number": 338,
          "code": "// Status: ‚ùå BROKEN\n\n// File: log_rotator.ruchy\n// Manages log files with size-based rotation\n\nprintln(\"=== Log Rotation System ===\")\n\nlet log_config = {\n    \"max_size\": 10 * 1024 * 1024,  // 10MB\n    \"max_backups\": 5,\n    \"compress\": true\n}\n\nlet log_dir = \"/var/log/myapp\"\nlet log_files = glob(join_path(log_dir, \"*.log\"))\n\nfor log_file in log_files {\n    let size = file_size(log_file)\n    \n    if size > log_config.max_size {\n        println(\"Rotating \" + log_file + \" (\" + format_size(size) + \")...\")\n        \n        // Shift existing backups\n        for i in range(log_config.max_backups - 1, 0, -1) {\n            let old_backup = log_file + \".\" + i.to_s()\n            let new_backup = log_file + \".\" + (i + 1).to_s()\n            \n            if file_exists(old_backup) {\n                if i == log_config.max_backups - 1 {\n                    // Delete oldest backup\n                    remove_file(old_backup)\n                } else {\n                    // Rename to next number\n                    rename_file(old_backup, new_backup)\n                }\n            }\n        }\n        \n        // Move current log to .1\n        let backup_path = log_file + \".1\"\n        rename_file(log_file, backup_path)\n        \n        // Compress if configured\n        if log_config.compress {\n            compress_file(backup_path, backup_path + \".gz\")\n            remove_file(backup_path)\n            println(\"  Compressed to \" + backup_path + \".gz\")\n        }\n        \n        // Create new empty log file\n        write_file(log_file, \"\")\n        println(\"  Created new \" + log_file)\n    }\n}\n\nprintln(\"\\n‚úÖ Log rotation complete!\")\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 8,
          "line_number": 403,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// File: config_manager.ruchy\n// Manages application configuration files\n\nprintln(\"=== Configuration Manager ===\")\n\nlet config_dir = \"~/.config/myapp\"\nlet config_file = join_path(config_dir, \"config.json\")\n\n// Ensure config directory exists\nif !dir_exists(config_dir) {\n    create_dir_all(config_dir)\n    println(\"Created config directory: \" + config_dir)\n}\n\n// Load or create default configuration\nlet config = if file_exists(config_file) {\n    parse_json(read_file(config_file))\n} else {\n    // Default configuration\n    {\n        \"version\": \"1.0\",\n        \"theme\": \"dark\",\n        \"auto_save\": true,\n        \"backup_interval\": 3600,\n        \"recent_files\": [],\n        \"window\": {\n            \"width\": 1200,\n            \"height\": 800,\n            \"maximized\": false\n        }\n    }\n}\n\nfn save_config() {\n    let json = to_json_pretty(config)\n    write_file(config_file, json)\n    println(\"‚úÖ Configuration saved\")\n}\n\nfn update_setting(key, value) {\n    config[key] = value\n    save_config()\n}\n\nfn add_recent_file(path) {\n    if !config.recent_files.contains(path) {\n        config.recent_files.insert(0, path)\n        // Keep only last 10 files\n        if config.recent_files.len() > 10 {\n            config.recent_files = config.recent_files[..10]\n        }\n        save_config()\n    }\n}\n\n// Interactive configuration editor\nloop {\n    println(\"\\n=== Current Configuration ===\")\n    for key, value in config.items() {\n        println(key + \": \" + value.to_s())\n    }\n    \n    println(\"\\nOptions:\")\n    println(\"1. Change theme\")\n    println(\"2. Toggle auto-save\")\n    println(\"3. Set backup interval\")\n    println(\"4. Clear recent files\")\n    println(\"5. Reset to defaults\")\n    println(\"6. Exit\")\n    \n    let choice = input(\"\\nChoice: \")\n    \n    match choice {\n        \"1\" => {\n            let theme = input(\"Theme (light/dark): \")\n            update_setting(\"theme\", theme)\n        }\n        \"2\" => {\n            config.auto_save = !config.auto_save\n            save_config()\n        }\n        \"3\" => {\n            let interval = input(\"Backup interval (seconds): \").to_i()\n            update_setting(\"backup_interval\", interval)\n        }\n        \"4\" => {\n            config.recent_files = []\n            save_config()\n        }\n        \"5\" => {\n            // Reset to defaults\n            remove_file(config_file)\n            println(\"Configuration reset!\")\n            break\n        }\n        \"6\" => break\n        _ => println(\"Invalid choice\")\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: DotDot\n"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 9,
          "line_number": 514,
          "code": "// Status: ‚ùå BROKEN\n\nfn safe_file_operation(path) {\n    // Check permissions first\n    if !file_exists(path) {\n        println(\"Error: File not found: \" + path)\n        return false\n    }\n    \n    if !is_readable(path) {\n        println(\"Error: No read permission for: \" + path)\n        return false\n    }\n    \n    // Try operation with error handling\n    try {\n        let content = read_file(path)\n        process_content(content)\n        return true\n    } catch error {\n        println(\"Error processing file: \" + error.to_s())\n        \n        // Log error for debugging\n        let error_log = \"errors.log\"\n        let timestamp = current_datetime()\n        append_file(error_log, timestamp.to_s() + \": \" + path + \" - \" + error.to_s() + \"\\n\")\n        \n        return false\n    }\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 10,
          "line_number": 559,
          "code": "// Status: ‚ùå BROKEN\n\nlet files = list_files(\"data\")\nfor file in files {\n    let size = file_size(file)\n    if size > 1000000 {\n        move_file(file, \"large_files/\" + file)\n    }\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch20-00-tooling": {
      "chapter": "ch20-00-tooling",
      "total_examples": 6,
      "working_examples": 6,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch20-00-tooling.md",
          "example_number": 1,
          "line_number": 79,
          "code": "// Status: ‚ùå BROKEN\n// bad_code.ruchy - Multiple issues for demonstration\nfun calculate_something(x: int) {\n    let unused_var = 42;\n    let y = x + 1;\n    return y;\n}\n\nfun main() {\n    let result=calculate_something(10);\n    println(result);\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch20-00-tooling.md",
          "example_number": 2,
          "line_number": 156,
          "code": "// Status: ‚ùå BROKEN\n// Before formatting (messy)\nfun fibonacci(n:int)->int{if n<=1{n}else{fibonacci(n-1)+fibonacci(n-2)}}\n\n// After running: ruchy fmt fibonacci.ruchy\nfun fibonacci(n: int) -> int {\n    if n <= 1 {\n        n\n    } else {\n        fibonacci(n - 1) + fibonacci(n - 2)\n    }\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch20-00-tooling.md",
          "example_number": 3,
          "line_number": 197,
          "code": "// Status: ‚ùå BROKEN\n// math_utils.ruchy\nfun add(a: int, b: int) -> int {\n    a + b\n}\n\nfun multiply(a: int, b: int) -> int {\n    a * b\n}\n\n// Tests can be in the same file or separate test files\nfun test_add() {\n    assert_eq(add(2, 3), 5);\n    assert_eq(add(-1, 1), 0);\n    assert_eq(add(0, 0), 0);\n}\n\nfun test_multiply() {\n    assert_eq(multiply(2, 3), 6);\n    assert_eq(multiply(-1, 5), -5);\n    assert_eq(multiply(0, 100), 0);\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch20-00-tooling.md",
          "example_number": 4,
          "line_number": 268,
          "code": "// Status: ‚ùå BROKEN\n// property_test.ruchy\nfun reverse_string(s: string) -> string {\n    // Implementation details...\n    s  // Placeholder\n}\n\nfun property_test_reverse_twice_is_identity() {\n    // Property: reverse(reverse(s)) == s\n    property_test(|s: string| {\n        assert_eq(reverse_string(reverse_string(s)), s);\n    });\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch20-00-tooling.md",
          "example_number": 5,
          "line_number": 353,
          "code": "// Status: ‚ùå BROKEN\n// documented_code.ruchy\n\n/// Calculates the factorial of a positive integer\n/// \n/// # Examples\n/// ```ruchy\n/// let result = factorial(5);\n/// assert_eq(result, 120);\n/// ```\n///\n/// # Panics\n/// Panics if n is negative\nfun factorial(n: int) -> int {\n    if n < 0 {\n        panic(\"Factorial not defined for negative numbers\");\n    }\n    \n    if n == 0 || n == 1 {\n        1\n    } else {\n        n * factorial(n - 1)\n    }\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch20-00-tooling.md",
          "example_number": 6,
          "line_number": 403,
          "code": "// Status: ‚ùå BROKEN\n// bench_test.ruchy\nfun fibonacci_recursive(n: int) -> int {\n    if n <= 1 { n } else { fibonacci_recursive(n-1) + fibonacci_recursive(n-2) }\n}\n\nfun fibonacci_iterative(n: int) -> int {\n    let mut a = 0;\n    let mut b = 1;\n    for i in range(n) {\n        let temp = a + b;\n        a = b;\n        b = temp;\n    }\n    a\n}\n\n// Benchmark functions\nfun bench_recursive_fib() {\n    bench(\"fibonacci_recursive_20\", || fibonacci_recursive(20));\n}\n\nfun bench_iterative_fib() {\n    bench(\"fibonacci_iterative_20\", || fibonacci_iterative(20));\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch07-00-building-applications": {
      "chapter": "ch07-00-building-applications",
      "total_examples": 9,
      "working_examples": 5,
      "failing_examples": 4,
      "examples": [
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// File: note_keeper.ruchy\n// A complete note-taking application\n\nlet APP_NAME = \"NoteKeeper\"\nlet VERSION = \"1.0.0\"\nlet NOTES_DIR = expand_home(\"~/.notes\")\nlet NOTES_INDEX = join_path(NOTES_DIR, \"index.json\")\n\n// Initialize application\nfn init_app() {\n    if !dir_exists(NOTES_DIR) {\n        create_dir_all(NOTES_DIR)\n        println(\"Created notes directory: \" + NOTES_DIR)\n    }\n    \n    if !file_exists(NOTES_INDEX) {\n        let initial_index = {\n            \"version\": VERSION,\n            \"notes\": [],\n            \"tags\": [],\n            \"last_modified\": current_datetime()\n        }\n        save_index(initial_index)\n    }\n}\n\nfn load_index() {\n    let content = read_file(NOTES_INDEX)\n    return parse_json(content)\n}\n\nfn save_index(index) {\n    index.last_modified = current_datetime()\n    let json = to_json_pretty(index)\n    write_file(NOTES_INDEX, json)\n}\n\nfn create_note() {\n    println(\"\\nüìù Create New Note\")\n    let title = input(\"Title: \")\n    let content = input_multiline(\"Content (end with empty line):\\n\")\n    let tags = input(\"Tags (comma-separated): \").split(\",\").map(|t| t.trim())\n    \n    let note_id = generate_id()\n    let note_file = join_path(NOTES_DIR, note_id + \".md\")\n    \n    let note = {\n        \"id\": note_id,\n        \"title\": title,\n        \"created\": current_datetime(),\n        \"modified\": current_datetime(),\n        \"tags\": tags,\n        \"file\": note_file\n    }\n    \n    // Save note content\n    let markdown = \"# \" + title + \"\\n\\nCreated: \" + note.created + \"\\nTags: \" + tags.join(\", \") + \"\\n\\n---\\n\\n\" + content\n    \n    write_file(note_file, markdown)\n    \n    // Update index\n    let index = load_index()\n    index.notes.push(note)\n    index.tags = index.tags.union(tags)\n    save_index(index)\n    \n    println(\"‚úÖ Note created: \" + title)\n}\n\nfn list_notes(filter_tag = null) {\n    let index = load_index()\n    let notes = index.notes\n    \n    if filter_tag {\n        notes = notes.filter(|n| n.tags.contains(filter_tag))\n        println(f\"\\nüìã Notes tagged '{filter_tag}':\")\n    } else {\n        println(f\"\\nüìã All Notes ({notes.len()} total):\")\n    }\n    \n    if notes.is_empty() {\n        println(\"  No notes found\")\n        return\n    }\n    \n    for i, note in notes.enumerate() {\n        let age = time_ago(note.created)\n        println((i+1).to_s() + \". \" + note.title)\n        println(\"     Tags: \" + note.tags.join(\", \") + \" | Created: \" + age)\n    }\n}\n\nfn search_notes(query) {\n    let index = load_index()\n    let results = []\n    \n    for note in index.notes {\n        // Search in title\n        if note.title.lower().contains(query.lower()) {\n            results.push(note)\n            continue\n        }\n        \n        // Search in content\n        let content = read_file(note.file)\n        if content.lower().contains(query.lower()) {\n            results.push(note)\n        }\n    }\n    \n    println(f\"\\nüîç Search results for '{query}': {results.len()} matches\")\n    \n    for note in results {\n        println(\"  ‚Ä¢ \" + note.title)\n        \n        // Show context\n        let content = read_file(note.file)\n        let lines = content.lines()\n        for line in lines {\n            if line.lower().contains(query.lower()) {\n                println(f\"    ...{line.trim()}...\")\n                break\n            }\n        }\n    }\n}\n\nfn view_note(index_num) {\n    let index = load_index()\n    \n    if index_num < 1 || index_num > index.notes.len() {\n        println(\"‚ùå Invalid note number\")\n        return\n    }\n    \n    let note = index.notes[index_num - 1]\n    let content = read_file(note.file)\n    \n    println(\"\\n\" + \"=\"*50)\n    println(content)\n    println(\"=\"*50)\n}\n\nfn export_notes(format) {\n    let index = load_index()\n    let export_file = \"notes_export_\" + current_date() + \".\" + format\n    \n    match format {\n        \"json\" => {\n            let data = {\n                \"exported\": current_datetime(),\n                \"notes\": []\n            }\n            \n            for note in index.notes {\n                let content = read_file(note.file)\n                data.notes.push({\n                    \"title\": note.title,\n                    \"content\": content,\n                    \"tags\": note.tags,\n                    \"created\": note.created\n                })\n            }\n            \n            write_file(export_file, to_json_pretty(data))\n        }\n        \"markdown\" => {\n            let markdown = f\"# My Notes\nExported: {current_datetime()}\n\n\"\n            for note in index.notes {\n                let content = read_file(note.file)\n                markdown += f\"\n\n---\n\n{content}\n\"\n            }\n            \n            write_file(export_file, markdown)\n        }\n        _ => {\n            println(\"‚ùå Unsupported format: \" + format)\n            return\n        }\n    }\n    \n    println(\"‚úÖ Exported \" + index.notes.len().to_s() + \" notes to \" + export_file)\n}\n\nfn show_menu() {\n    println(f\"\\n=== {APP_NAME} v{VERSION} ===\")\n    println(\"1. Create note\")\n    println(\"2. List all notes\")\n    println(\"3. Search notes\")\n    println(\"4. View note\")\n    println(\"5. List by tag\")\n    println(\"6. Export notes\")\n    println(\"7. Statistics\")\n    println(\"8. Quit\")\n}\n\nfn show_statistics() {\n    let index = load_index()\n    let total_notes = index.notes.len()\n    let total_tags = index.tags.len()\n    \n    // Calculate word count\n    let total_words = 0\n    for note in index.notes {\n        let content = read_file(note.file)\n        total_words += content.split_whitespace().len()\n    }\n    \n    // Find most used tags\n    let tag_counts = {}\n    for note in index.notes {\n        for tag in note.tags {\n            tag_counts[tag] = tag_counts.get(tag, 0) + 1\n        }\n    }\n    \n    println(f\"\\nüìä NoteKeeper Statistics\")\n    println(\"Total notes: \" + total_notes.to_s())\n    println(\"Total words: \" + total_words.to_s())\n    println(\"Average words per note: \" + (total_words / max(total_notes, 1)).to_s())\n    println(\"Unique tags: \" + total_tags.to_s())\n    \n    if !tag_counts.is_empty() {\n        println(\"\\nTop tags:\")\n        let sorted_tags = tag_counts.items().sort_by(|item| -item.value)\n        for tag, count in sorted_tags[..min(5, sorted_tags.len())] {\n            println(f\"  ‚Ä¢ {tag}: {count} notes\")\n        }\n    }\n}\n\n// Main application loop\nfn main() {\n    init_app()\n    \n    println(f\"Welcome to {APP_NAME}!\")\n    println(\"Your personal note-taking assistant\")\n    \n    loop {\n        show_menu()\n        let choice = input(\"\\nChoice: \")\n        \n        match choice {\n            \"1\" => create_note()\n            \"2\" => list_notes()\n            \"3\" => {\n                let query = input(\"Search for: \")\n                search_notes(query)\n            }\n            \"4\" => {\n                list_notes()\n                let num = input(\"\\nNote number to view: \").to_i()\n                view_note(num)\n            }\n            \"5\" => {\n                let index = load_index()\n                println(\"\\nAvailable tags:\")\n                for tag in index.tags {\n                    println(\"  ‚Ä¢ \" + tag)\n                }\n                let tag = input(\"\\nFilter by tag: \")\n                list_notes(tag)\n            }\n            \"6\" => {\n                let format = input(\"Export format (json/markdown): \")\n                export_notes(format)\n            }\n            \"7\" => show_statistics()\n            \"8\" => {\n                println(\"üëã Thanks for using NoteKeeper!\")\n                break\n            }\n            _ => println(\"‚ùå Invalid choice\")\n        }\n    }\n}\n\n// Run the application\nmain()",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected In, found Comma\n"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 2,
          "line_number": 333,
          "code": "// Status: ‚ùå BROKEN\n\n// Application structure\nlet APP = {\n    \"name\": \"MyApp\",\n    \"version\": \"1.0.0\",\n    \"config_dir\": \"~/.config/myapp\",\n    \"data_dir\": \"~/.local/share/myapp\",\n    \"cache_dir\": \"~/.cache/myapp\"\n}\n\n// Separate concerns into modules\n// models.ruchy - Data structures\nlet User = {\n    \"id\": null,\n    \"name\": \"\",\n    \"email\": \"\",\n    \"created\": null\n}\n\n// services.ruchy - Business logic\nfn create_user(name, email) {\n    let user = User.copy()\n    user.id = generate_uuid()\n    user.name = name\n    user.email = email\n    user.created = current_datetime()\n    return user\n}\n\n// ui.ruchy - User interface\nfn display_user(user) {\n    println(f\"User: {user.name} ({user.email})\")\n    println(\"Member since: \" + user.created)\n}\n\n// main.ruchy - Application entry point\nfn main() {\n    init_app()\n    load_config()\n    run_event_loop()\n    cleanup()\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 3,
          "line_number": 387,
          "code": "// Status: ‚ùå BROKEN\n\n// Global application state\nlet STATE = {\n    \"users\": [],\n    \"current_user\": null,\n    \"settings\": {},\n    \"cache\": {},\n    \"dirty\": false\n}\n\nfn update_state(key, value) {\n    STATE[key] = value\n    STATE.dirty = true\n    trigger_save()\n}\n\nfn save_state() {\n    if STATE.dirty {\n        let state_file = join_path(APP.data_dir, \"state.json\")\n        write_file(state_file, to_json(STATE))\n        STATE.dirty = false\n    }\n}\n\nfn load_state() {\n    let state_file = join_path(APP.data_dir, \"state.json\")\n    if file_exists(state_file) {\n        STATE = parse_json(read_file(state_file))\n    }\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 4,
          "line_number": 429,
          "code": "// Status: ‚ùå BROKEN\n\nfn safe_operation(operation_fn, fallback_value) {\n    try {\n        return operation_fn()\n    } catch error {\n        log_error(error)\n        return fallback_value\n    }\n}\n\nfn with_retry(operation_fn, max_attempts = 3) {\n    for attempt in range(max_attempts) {\n        try {\n            return operation_fn()\n        } catch error {\n            if attempt == max_attempts - 1 {\n                println(\"‚ùå Failed after \" + max_attempts.to_s() + \" attempts: \" + error.to_s())\n                throw error\n            }\n            \n            let wait_time = 2 ** attempt  // Exponential backoff\n            println(f\"‚ö†Ô∏è  Attempt {attempt + 1} failed, retrying in {wait_time}s...\")\n            sleep(wait_time * 1000)\n        }\n    }\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 5,
          "line_number": 467,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Simple password manager with encryption\nlet MASTER_KEY = null\nlet PASSWORDS_FILE = \"~/.passwords.enc\"\n\nfn encrypt(text, key) {\n    // Simple XOR encryption (use real encryption in production!)\n    let encrypted = []\n    for i, char in text.chars().enumerate() {\n        let key_char = key[i % key.len()]\n        encrypted.push(char.code() ^ key_char.code())\n    }\n    return base64_encode(encrypted)\n}\n\nfn decrypt(encrypted, key) {\n    let bytes = base64_decode(encrypted)\n    let decrypted = []\n    for i, byte in bytes.enumerate() {\n        let key_char = key[i % key.len()]\n        decrypted.push(char_from_code(byte ^ key_char.code()))\n    }\n    return decrypted.join(\"\")\n}\n\nfn add_password(site, username, password) {\n    let passwords = load_passwords()\n    passwords[site] = {\n        \"username\": username,\n        \"password\": encrypt(password, MASTER_KEY),\n        \"created\": current_datetime()\n    }\n    save_passwords(passwords)\n}\n\nfn get_password(site) {\n    let passwords = load_passwords()\n    if passwords.has_key(site) {\n        let entry = passwords[site]\n        let password = decrypt(entry.password, MASTER_KEY)\n        copy_to_clipboard(password)\n        println(\"‚úÖ Password copied to clipboard!\")\n        \n        // Clear clipboard after 30 seconds\n        spawn_after(30000, || clear_clipboard())\n    } else {\n        println(\"‚ùå No password found for \" + site)\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected In, found Comma\n"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 6,
          "line_number": 525,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Personal finance tracker\nlet TRANSACTIONS_FILE = \"~/.budget/transactions.csv\"\nlet CATEGORIES = [\"Food\", \"Transport\", \"Bills\", \"Entertainment\", \"Other\"]\n\nfn add_transaction(amount, category, description) {\n    let transaction = {\n        \"date\": current_date(),\n        \"amount\": amount,\n        \"category\": category,\n        \"description\": description\n    }\n    \n    append_csv(TRANSACTIONS_FILE, transaction)\n    \n    // Check budget alerts\n    let monthly_spent = get_monthly_total(category)\n    let budget_limit = get_budget_limit(category)\n    \n    if monthly_spent > budget_limit {\n        send_notification(f\"‚ö†Ô∏è Over budget for {category}!\")\n        println(\"Warning: \" + category + \" spending at $\" + monthly_spent.to_s() + \"/$\" + budget_limit.to_s())\n    }\n}\n\nfn generate_report(month) {\n    let transactions = load_transactions(month)\n    let by_category = group_by(transactions, \"category\")\n    \n    println(\"\\nüìä Budget Report for \" + month)\n    println(\"=\"*40)\n    \n    let total = 0\n    for category, items in by_category.items() {\n        let category_total = items.map(|t| t.amount).sum()\n        total += category_total\n        \n        let bar = \"‚ñà\" * (category_total / 50).to_i()\n        println(category + \" $\" + category_total.to_s() + \" \" + bar)\n    }\n    \n    println(\"=\"*40)\n    println(\"Total:          $\" + total.to_s())\n    \n    // Save report\n    let report_file = f\"budget_report_{month}.pdf\"\n    generate_pdf(report_file, report_data)\n    println(\"\\nüìÑ Report saved to \" + report_file)\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected In, found Comma\n"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 7,
          "line_number": 583,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Development project scaffolding tool\nlet TEMPLATES = {\n    \"python\": {\n        \"files\": [\"main.py\", \"requirements.txt\", \"README.md\", \".gitignore\"],\n        \"folders\": [\"src\", \"tests\", \"docs\"]\n    },\n    \"javascript\": {\n        \"files\": [\"index.js\", \"package.json\", \"README.md\", \".gitignore\"],\n        \"folders\": [\"src\", \"test\", \"public\"]\n    },\n    \"ruchy\": {\n        \"files\": [\"main.ruchy\", \"Cargo.toml\", \"README.md\", \".gitignore\"],\n        \"folders\": [\"src\", \"tests\", \"docs\"]\n    }\n}\n\nfn create_project(name, language) {\n    let project_dir = name\n    \n    if dir_exists(project_dir) {\n        println(f\"‚ùå Directory {project_dir} already exists\")\n        return\n    }\n    \n    create_dir(project_dir)\n    println(\"üìÅ Created project: \" + name)\n    \n    let template = TEMPLATES[language]\n    \n    // Create folder structure\n    for folder in template.folders {\n        create_dir(join_path(project_dir, folder))\n        println(f\"  üìÇ {folder}/\")\n    }\n    \n    // Create files from templates\n    for file in template.files {\n        let template_content = get_template_content(language, file)\n        let content = template_content\n            .replace(\"{{PROJECT_NAME}}\", name)\n            .replace(\"{{DATE}}\", current_date())\n            .replace(\"{{AUTHOR}}\", get_git_user())\n        \n        write_file(join_path(project_dir, file), content)\n        println(\"  üìÑ \" + file)\n    }\n    \n    // Initialize git\n    run_command(\"git init\", project_dir)\n    run_command(\"git add .\", project_dir)\n    run_command('git commit -m \"Initial commit\"', project_dir)\n    \n    println(f\"\\n‚úÖ Project {name} created successfully!\")\n    println(f\"Next steps:\")\n    println(\"  cd \" + project_dir)\n    println(\"  \" + get_run_command(language))\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected RightParen, found Identifier(\"commit\")\n"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 8,
          "line_number": 652,
          "code": "// Status: ‚ùå BROKEN\n\n// test_app.ruchy - Application test suite\n\nfn test_user_creation() {\n    let user = create_user(\"Alice\", \"alice@example.com\")\n    \n    assert(user.name == \"Alice\", \"Name should be set\")\n    assert(user.email == \"alice@example.com\", \"Email should be set\")\n    assert(user.id != null, \"ID should be generated\")\n    \n    println(\"‚úÖ test_user_creation passed\")\n}\n\nfn test_data_persistence() {\n    let test_data = {\"test\": \"value\"}\n    let test_file = \"test_data.json\"\n    \n    // Save data\n    save_json(test_file, test_data)\n    assert(file_exists(test_file), \"File should be created\")\n    \n    // Load data\n    let loaded = load_json(test_file)\n    assert(loaded.test == \"value\", \"Data should persist\")\n    \n    // Cleanup\n    remove_file(test_file)\n    \n    println(\"‚úÖ test_data_persistence passed\")\n}\n\nfn run_all_tests() {\n    println(\"üß™ Running application tests...\")\n    \n    test_user_creation()\n    test_data_persistence()\n    test_error_handling()\n    test_performance()\n    \n    println(\"\\n‚úÖ All tests passed!\")\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 9,
          "line_number": 705,
          "code": "// Status: ‚ùå BROKEN\n\n// build.ruchy - Build and package script\n\nfn build_release() {\n    println(\"üî® Building release version...\")\n    \n    // Run tests first\n    run_tests()\n    \n    // Create release directory\n    let release_dir = \"release_\" + VERSION\n    create_dir_all(release_dir)\n    \n    // Copy application files\n    copy_file(\"main.ruchy\", join_path(release_dir, APP_NAME))\n    copy_dir(\"resources\", join_path(release_dir, \"resources\"))\n    \n    // Generate documentation\n    generate_docs(join_path(release_dir, \"docs\"))\n    \n    // Create installer script\n    let installer = f\"#!/bin/bash\necho 'Installing {APP_NAME} v{VERSION}'\nmkdir -p ~/.local/bin\ncp {APP_NAME} ~/.local/bin/\nchmod +x ~/.local/bin/{APP_NAME}\necho 'Installation complete! Run {APP_NAME} to start.'\n\"\n    write_file(join_path(release_dir, \"install.sh\"), installer)\n    \n    // Package as archive\n    create_archive(f\"{APP_NAME}-{VERSION}.tar.gz\", release_dir)\n    \n    println(f\"‚úÖ Release built: {APP_NAME}-{VERSION}.tar.gz\")\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch15-00-macros-metaprogramming": {
      "chapter": "ch15-00-macros-metaprogramming",
      "total_examples": 9,
      "working_examples": 0,
      "failing_examples": 9,
      "examples": [
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Define a macro for JSON-like syntax\nmacro! json {\n    // Match JSON-like input\n    ({ $($key:ident : $value:expr),* }) => {\n        {\n            let mut map = HashMap::new()\n            $(\n                map.insert(stringify!($key), json!($value))\n            )*\n            Value::Object(map)\n        }\n    }\n    ([ $($element:expr),* ]) => {\n        Value::Array(vec![$(json!($element)),*])\n    }\n    ($other:expr) => {\n        Value::from($other)\n    }\n}\n\n// Use it like native syntax!\nlet user = json!({\n    name: \"Alice\",\n    age: 30,\n    emails: [\"alice@example.com\", \"alice@work.com\"],\n    active: true,\n    metadata: {\n        created: \"2024-01-01\",\n        tags: [\"premium\", \"verified\"]\n    }\n})\n\n// Macro for automatic implementation\n#[derive(Debug, Clone, Serialize)]\nstruct User {\n    name: String\n    email: String\n    age: i32\n}\n\n// The derive macro generates all the boilerplate!",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected '(' or '[' after macro name\n"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 2,
          "line_number": 87,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Simple macro\nmacro! say_hello {\n    () => {\n        println(\"Hello, World!\")\n    }\n    ($name:expr) => {\n        println(f\"Hello, {$name}!\")\n    }\n}\n\nsay_hello!()           // Prints: Hello, World!\nsay_hello!(\"Alice\")    // Prints: Hello, Alice!\n\n// Macro with repetition\nmacro! vec_of_strings {\n    ($($x:expr),*) => {\n        vec![$(String::from($x)),*]\n    }\n}\n\nlet strings = vec_of_strings![\"one\", \"two\", \"three\"]\n\n// Recursive macro\nmacro! count {\n    () => { 0 }\n    ($head:expr) => { 1 }\n    ($head:expr, $($tail:expr),*) => {\n        1 + count!($($tail),*)\n    }\n}\n\nlet n = count!(a, b, c, d)  // 4\n\n// Macro generating match arms\nmacro! handle_codes {\n    ($($code:expr => $message:expr),*) => {\n        match status_code {\n            $($code => println($message)),*\n            _ => println(\"Unknown status\")\n        }\n    }\n}\n\nhandle_codes! {\n    200 => \"OK\",\n    404 => \"Not Found\",\n    500 => \"Internal Error\"\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected '(' or '[' after macro name\n"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 3,
          "line_number": 147,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Derive macro for automatic implementation\n#[proc_macro_derive(Builder)]\nfn derive_builder(input: TokenStream) -> TokenStream {\n    let ast = parse(input)\n    let name = ast.name\n    let builder_name = f\"{name}Builder\"\n    \n    let fields = ast.fields.map(|f| {\n        let name = f.name\n        let ty = f.ty\n        quote! {\n            fn $name(mut self, value: $ty) -> Self {\n                self.$name = Some(value)\n                self\n            }\n        }\n    })\n    \n    quote! {\n        struct $builder_name {\n            $($fields.name: Option<$fields.ty>),*\n        }\n        \n        impl $builder_name {\n            fn new() -> Self {\n                Self {\n                    $($fields.name: None),*\n                }\n            }\n            \n            $fields\n            \n            fn build(self) -> Result<$name, String> {\n                Ok($name {\n                    $($fields.name: self.$fields.name\n                        .ok_or(\"Missing field: \" + stringify!($fields.name))?,)*\n                })\n            }\n        }\n        \n        impl $name {\n            fn builder() -> $builder_name {\n                $builder_name::new()\n            }\n        }\n    }\n}\n\n// Use the derive macro\n#[derive(Builder)]\nstruct Config {\n    host: String\n    port: u16\n    workers: usize\n}\n\n// Generated builder pattern!\nlet config = Config::builder()\n    .host(\"localhost\")\n    .port(8080)\n    .workers(4)\n    .build()?",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected '(' or '[' after macro name\n"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 4,
          "line_number": 221,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Attribute macro for benchmarking\n#[proc_macro_attribute]\nfn bench(args: TokenStream, input: TokenStream) -> TokenStream {\n    let func = parse(input)\n    let name = func.name\n    \n    quote! {\n        fn $name() {\n            let start = Instant::now()\n            let result = { $func.body }\n            let duration = start.elapsed()\n            println(stringify!($name) + \" took \" + duration.to_s())\n            result\n        }\n    }\n}\n\n#[bench]\nfn expensive_operation() {\n    // Function body\n    heavy_computation()\n}\n// Automatically prints timing!\n\n// Route attribute for web framework\n#[route(GET, \"/users/:id\")]\nasync fn get_user(id: i32) -> Response {\n    let user = fetch_user(id).await?\n    Response::json(user)\n}\n\n// Test attribute with custom behavior\n#[test_case(1, 2, 3)]\n#[test_case(10, 20, 30)]\n#[test_case(-1, -2, -3)]\nfn test_addition(a: i32, b: i32, expected: i32) {\n    assert_eq!(a + b, expected)\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected '(' or '[' after macro name\n"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 5,
          "line_number": 271,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// SQL-like macro\nmacro! sql {\n    (SELECT $($field:ident),* FROM $table:ident WHERE $($cond:tt)*) => {\n        Query::select(vec![$(stringify!($field)),*])\n            .from(stringify!($table))\n            .where(parse_condition!($($cond)*))\n    }\n}\n\nlet query = sql! {\n    SELECT name, email, age \n    FROM users \n    WHERE age > 18 AND active = true\n}\n\n// HTML templating\nmacro! html {\n    (<$tag:ident $($attr:ident = $value:expr)*> $($content:tt)* </$close:ident>) => {\n        Element::new(stringify!($tag))\n            $(.attr(stringify!($attr), $value))*\n            .children(vec![$(html!($content)),*])\n    }\n    ($text:expr) => {\n        Text::new($text)\n    }\n}\n\nlet page = html! {\n    <div class=\"container\">\n        <h1>\"Welcome\"</h1>\n        <p>\"This is \"<strong>\"Ruchy\"</strong>\" macros!\"</p>\n    </div>\n}\n\n// Regular expression literals\nmacro! regex {\n    ($pattern:expr) => {\n        {\n            static REGEX: OnceCell<Regex> = OnceCell::new()\n            REGEX.get_or_init(|| {\n                Regex::new($pattern).expect(\"Invalid regex\")\n            })\n        }\n    }\n}\n\nlet email_regex = regex!(r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\")",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected '(' or '[' after macro name\n"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 6,
          "line_number": 330,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Debug print with variable names\nmacro! dbg {\n    ($($x:expr),*) => {\n        $(\n            eprintln!(\"{} = {:?}\", stringify!($x), $x)\n        )*\n    }\n}\n\nlet x = 42\nlet y = \"hello\"\ndbg!(x, y, x + 10)\n// Prints:\n// x = 42\n// y = \"hello\"\n// x + 10 = 52\n\n// Trace macro for function calls\nmacro! trace {\n    ($func:expr) => {\n        {\n            println(\"Entering \" + stringify!($func))\n            let result = $func\n            println(\"Leaving \" + stringify!($func) + \": \" + result.to_s())\n            result\n        }\n    }\n}\n\nlet result = trace!(expensive_calculation())\n\n// Assert with custom messages\nmacro! assert_eq_msg {\n    ($left:expr, $right:expr, $msg:expr) => {\n        if $left != $right {\n            panic($msg + \"\\nLeft: \" + $left.to_s() + \"\\nRight: \" + $right.to_s())\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected '(' or '[' after macro name\n"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 7,
          "line_number": 379,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Generate getters and setters\nmacro! accessors {\n    ($struct_name:ident { $($field:ident : $type:ty),* }) => {\n        impl $struct_name {\n            $(\n                fn $field(&self) -> &$type {\n                    &self.$field\n                }\n                \n                fn set_$field(&mut self, value: $type) {\n                    self.$field = value\n                }\n            )*\n        }\n    }\n}\n\nstruct Person {\n    name: String\n    age: i32\n}\n\naccessors!(Person { name: String, age: i32 })\n\n// Now person.name() and person.set_name() exist!\n\n// Generate enum variants and matchers\nmacro! define_opcodes {\n    ($($name:ident = $value:expr),*) => {\n        enum Opcode {\n            $($name = $value),*\n        }\n        \n        impl Opcode {\n            fn from_byte(byte: u8) -> Option<Opcode> {\n                match byte {\n                    $($value => Some(Opcode::$name)),*\n                    _ => None\n                }\n            }\n            \n            fn to_string(&self) -> &str {\n                match self {\n                    $(Opcode::$name => stringify!($name)),*\n                }\n            }\n        }\n    }\n}\n\ndefine_opcodes! {\n    ADD = 0x01,\n    SUB = 0x02,\n    MUL = 0x03,\n    DIV = 0x04,\n    JMP = 0x10,\n    JEQ = 0x11\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected '(' or '[' after macro name\n"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 8,
          "line_number": 447,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// State machine DSL\nmacro! state_machine {\n    (\n        states: [$($state:ident),*]\n        transitions: [\n            $($from:ident -> $to:ident on $event:ident),*\n        ]\n        initial: $initial:ident\n    ) => {\n        enum State {\n            $($state),*\n        }\n        \n        enum Event {\n            $($event),*\n        }\n        \n        struct StateMachine {\n            state: State\n        }\n        \n        impl StateMachine {\n            fn new() -> Self {\n                Self { state: State::$initial }\n            }\n            \n            fn transition(&mut self, event: Event) {\n                self.state = match (&self.state, event) {\n                    $(\n                        (State::$from, Event::$event) => State::$to,\n                    )*\n                    _ => panic(\"Invalid transition\")\n                }\n            }\n        }\n    }\n}\n\nstate_machine! {\n    states: [Idle, Running, Paused, Stopped]\n    transitions: [\n        Idle -> Running on Start,\n        Running -> Paused on Pause,\n        Paused -> Running on Resume,\n        Running -> Stopped on Stop,\n        Paused -> Stopped on Stop\n    ]\n    initial: Idle\n}\n\n// Configuration DSL\nmacro! config {\n    {\n        $($section:ident {\n            $($key:ident : $value:expr),*\n        })*\n    } => {\n        {\n            let mut config = Config::new()\n            $(\n                let mut section = ConfigSection::new(stringify!($section))\n                $(\n                    section.set(stringify!($key), $value)\n                )*\n                config.add_section(section)\n            )*\n            config\n        }\n    }\n}\n\nlet config = config! {\n    server {\n        host: \"localhost\",\n        port: 8080,\n        workers: 4\n    }\n    database {\n        url: \"postgres://localhost/myapp\",\n        pool_size: 20\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected '(' or '[' after macro name\n"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 9,
          "line_number": 539,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Hygienic macros prevent name collisions\nmacro! safe_swap {\n    ($a:expr, $b:expr) => {\n        {\n            // Generated names won't conflict\n            let __temp = $a\n            $a = $b\n            $b = __temp\n        }\n    }\n}\n\n// Best practices:\n// 1. Keep macros simple\n// 2. Provide good error messages\nmacro! validate {\n    ($expr:expr) => {\n        if !$expr {\n            compile_error!(concat!(\n                \"Validation failed: \",\n                stringify!($expr)\n            ))\n        }\n    }\n}\n\n// 3. Document macro syntax\n/// Creates a new vector with the given elements\n/// \n/// # Example\n/// ```\n/// let v = vec![1, 2, 3]\n/// ```\nmacro! vec {\n    // Implementation\n}\n\n// 4. Use macro namespaces\nmod macros {\n    macro! internal_helper {\n        // Not exported\n    }\n    \n    #[macro_export]\n    macro! public_macro {\n        // Exported\n    }\n}\n\n// 5. Test macros thoroughly\n#[test]\nfn test_macro() {\n    let result = my_macro!(input)\n    assert_eq!(result, expected)\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected '(' or '[' after macro name\n"
        }
      ]
    },
    "ch09-00-network-programming": {
      "chapter": "ch09-00-network-programming",
      "total_examples": 10,
      "working_examples": 0,
      "failing_examples": 10,
      "examples": [
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// File: web_server.ruchy\n// HTTP server with routing and middleware\n\nuse std::net::http;\n\nlet server = http::Server::new(\"0.0.0.0:8080\")\n\n// Middleware for logging\nserver.use(|req, res, next| {\n    let start = current_time_ms()\n    next()\n    let duration = current_time_ms() - start\n    println(req.method + \" \" + req.path + \" - \" + res.status.to_s() + \" (\" + duration.to_s() + \"ms)\")\n})\n\n// Routes\nserver.get(\"/\", |req, res| {\n    res.html(\"<h1>Welcome to Ruchy Server!</h1>\")\n})\n\nserver.get(\"/api/users\", |req, res| {\n    let users = [\n        {id: 1, name: \"Alice\", email: \"alice@example.com\"},\n        {id: 2, name: \"Bob\", email: \"bob@example.com\"}\n    ]\n    res.json(users)\n})\n\nserver.post(\"/api/users\", |req, res| {\n    let user = req.json()\n    println(\"Creating user: \" + user.name)\n    user.id = generate_id()\n    user.created = current_datetime()\n    res.status(201).json(user)\n})\n\n// Static files\nserver.static(\"/public\", \"./static\")\n\n// Start server\nprintln(f\"üöÄ Server running on http://localhost:8080\")\nserver.listen()",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: ColonColon\n"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 2,
          "line_number": 88,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// TCP Server\nlet server = net::TcpListener::bind(\"127.0.0.1:9000\")\nprintln(\"Server listening on port 9000\")\n\nloop {\n    let client = server.accept()\n    \n    // Handle each client in a separate thread\n    spawn {\n        println(\"Client connected: \" + client.remote_addr())\n        \n        loop {\n            let message = client.read_line()\n            if message.is_empty() {\n                break\n            }\n            \n            println(\"Received: \" + message)\n            client.write(\"Echo: \" + message + \"\\n\")\n        }\n        \n        println(\"Client disconnected\")\n    }\n}\n\n// TCP Client\nlet client = net::TcpStream::connect(\"127.0.0.1:9000\")\nclient.write(\"Hello, server!\\n\")\nlet response = client.read_line()\nprintln(\"Server replied: \" + response)",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: ColonColon\n"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 3,
          "line_number": 130,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Simple GET request\nlet response = http::get(\"https://api.example.com/data\")\nlet data = response.json()\nprintln(\"Got \" + data.items.len().to_s() + \" items\")\n\n// POST with JSON\nlet user = {\n    name: \"Alice\",\n    email: \"alice@example.com\"\n}\nlet response = http::post(\"https://api.example.com/users\")\n    .json(user)\n    .send()\n\n// Advanced requests\nlet response = http::request(\"https://api.example.com/data\")\n    .method(\"GET\")\n    .header(\"Authorization\", \"Bearer \" + token)\n    .header(\"User-Agent\", \"Ruchy/1.0\")\n    .query(\"page\", 1)\n    .query(\"limit\", 100)\n    .timeout(5000)\n    .send()\n\nif response.is_success() {\n    let data = response.json()\n    process_data(data)\n} else {\n    println(\"Error: \" + response.status.to_s() + \" - \" + response.text())\n}\n\n// Download file with progress\nhttp::download(\"https://example.com/big-file.zip\", \"downloads/file.zip\")\n    .on_progress(|downloaded, total| {\n        let percent = (downloaded / total) * 100\n        print(\"\\rDownloading: \" + percent.to_s() + \"%\")\n    })\n    .await()",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected method name or 'await' after '.'\n"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 4,
          "line_number": 180,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// WebSocket Server\nlet ws_server = ws::Server::new(\"0.0.0.0:8081\")\n\nws_server.on_connection(|socket| {\n    println(\"WebSocket connected: \" + socket.id)\n    \n    socket.on(\"message\", |data| {\n        println(\"Received: \" + data)\n        \n        // Broadcast to all clients\n        ws_server.broadcast({\n            type: \"chat\",\n            user: socket.id,\n            message: data\n        })\n    })\n    \n    socket.on(\"close\", || {\n        println(\"WebSocket disconnected: \" + socket.id)\n    })\n})\n\nws_server.listen()\n\n// WebSocket Client\nlet ws = ws::connect(\"ws://localhost:8081\")\n\nws.on(\"open\", || {\n    println(\"Connected to server\")\n    ws.send(\"Hello, server!\")\n})\n\nws.on(\"message\", |data| {\n    println(\"Server says: \" + data)\n})\n\nws.on(\"error\", |err| {\n    println(\"WebSocket error: \" + err.to_s())\n})",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: ColonColon\n"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 5,
          "line_number": 231,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// File: api_server.ruchy\n// RESTful API with database\n\nuse std::net::http;\nuse std::db;\n\nlet app = http::Server::new(\"0.0.0.0:3000\")\nlet database = db::connect(\"sqlite:data.db\")\n\n// CORS middleware\napp.use(|req, res, next| {\n    res.header(\"Access-Control-Allow-Origin\", \"*\")\n    res.header(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE\")\n    next()\n})\n\n// Authentication middleware\nfn require_auth(req, res, next) {\n    let token = req.header(\"Authorization\")\n    if !token || !validate_token(token) {\n        return res.status(401).json({error: \"Unauthorized\"})\n    }\n    req.user = decode_token(token)\n    next()\n}\n\n// Routes\napp.get(\"/api/posts\", |req, res| {\n    let page = req.query(\"page\", 1)\n    let limit = req.query(\"limit\", 10)\n    \n    let posts = database.query(\"\n        SELECT * FROM posts \n        ORDER BY created_at DESC \n        LIMIT ? OFFSET ?\n    \", [limit, (page - 1) * limit])\n    \n    res.json({\n        posts: posts,\n        page: page,\n        total: database.count(\"posts\")\n    })\n})\n\napp.get(\"/api/posts/:id\", |req, res| {\n    let id = req.params.id\n    let post = database.find(\"posts\", id)\n    \n    if post {\n        res.json(post)\n    } else {\n        res.status(404).json({error: \"Post not found\"})\n    }\n})\n\napp.post(\"/api/posts\", require_auth, |req, res| {\n    let post = req.json()\n    post.author_id = req.user.id\n    post.created_at = current_datetime()\n    \n    let id = database.insert(\"posts\", post)\n    let created = database.find(\"posts\", id)\n    \n    res.status(201).json(created)\n})\n\napp.put(\"/api/posts/:id\", require_auth, |req, res| {\n    let id = req.params.id\n    let updates = req.json()\n    \n    // Check ownership\n    let post = database.find(\"posts\", id)\n    if post.author_id != req.user.id {\n        return res.status(403).json({error: \"Forbidden\"})\n    }\n    \n    updates.updated_at = current_datetime()\n    database.update(\"posts\", id, updates)\n    \n    res.json(database.find(\"posts\", id))\n})\n\napp.delete(\"/api/posts/:id\", require_auth, |req, res| {\n    let id = req.params.id\n    \n    // Check ownership\n    let post = database.find(\"posts\", id)\n    if post.author_id != req.user.id {\n        return res.status(403).json({error: \"Forbidden\"})\n    }\n    \n    database.delete(\"posts\", id)\n    res.status(204).send()\n})\n\n// Error handling\napp.use(|err, req, res, next| {\n    console.error(\"Error: \" + err.to_s())\n    res.status(500).json({\n        error: \"Internal server error\",\n        message: err.message\n    })\n})\n\nprintln(\"üöÄ API server running on http://localhost:3000\")\napp.listen()",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: ColonColon\n"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 6,
          "line_number": 347,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// File: chat_server.ruchy\n// Multi-room chat server with history\n\nuse std::net::ws;\n\nlet server = ws::Server::new(\"0.0.0.0:8080\")\nlet rooms = {}\nlet users = {}\n\nfn broadcast_to_room(room_id, message, exclude_user = null) {\n    if rooms.has_key(room_id) {\n        for user_id in rooms[room_id] {\n            if user_id != exclude_user {\n                users[user_id].socket.send(message)\n            }\n        }\n    }\n}\n\nserver.on_connection(|socket| {\n    let user = {\n        id: generate_id(),\n        socket: socket,\n        name: null,\n        room: null,\n        joined_at: current_datetime()\n    }\n    \n    users[user.id] = user\n    \n    socket.send(json({\n        type: \"welcome\",\n        user_id: user.id,\n        message: \"Welcome to chat! Send /help for commands\"\n    }))\n    \n    socket.on(\"message\", |data| {\n        let msg = parse_json(data)\n        \n        match msg.type {\n            \"join\" => {\n                user.name = msg.name\n                user.room = msg.room\n                \n                // Add user to room\n                if !rooms.has_key(msg.room) {\n                    rooms[msg.room] = []\n                }\n                rooms[msg.room].push(user.id)\n                \n                // Notify room\n                broadcast_to_room(msg.room, json({\n                    type: \"user_joined\",\n                    user: user.name,\n                    time: current_datetime()\n                }))\n                \n                // Send room history\n                let history = get_room_history(msg.room)\n                socket.send(json({\n                    type: \"history\",\n                    messages: history\n                }))\n            }\n            \n            \"message\" => {\n                let chat_msg = {\n                    type: \"message\",\n                    user: user.name,\n                    text: msg.text,\n                    time: current_datetime()\n                }\n                \n                // Save to history\n                save_message(user.room, chat_msg)\n                \n                // Broadcast to room\n                broadcast_to_room(user.room, json(chat_msg))\n            }\n            \n            \"private\" => {\n                let target = find_user_by_name(msg.to)\n                if target {\n                    target.socket.send(json({\n                        type: \"private\",\n                        from: user.name,\n                        text: msg.text,\n                        time: current_datetime()\n                    }))\n                }\n            }\n            \n            \"typing\" => {\n                broadcast_to_room(user.room, json({\n                    type: \"typing\",\n                    user: user.name\n                }), user.id)\n            }\n        }\n    })\n    \n    socket.on(\"close\", || {\n        // Remove from room\n        if user.room && rooms.has_key(user.room) {\n            rooms[user.room] = rooms[user.room].filter(|id| id != user.id)\n            \n            broadcast_to_room(user.room, json({\n                type: \"user_left\",\n                user: user.name,\n                time: current_datetime()\n            }))\n        }\n        \n        users.remove(user.id)\n    })\n})\n\nprintln(\"üí¨ Chat server running on ws://localhost:8080\")\nserver.listen()",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: ColonColon\n"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 7,
          "line_number": 476,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// File: network_scanner.ruchy\n// Scan network for open ports and services\n\nuse std::net;\nuse std::async;\n\nprintln(\"=== Network Scanner ===\")\n\nfn scan_port(host, port, timeout = 1000) {\n    try {\n        let socket = net::TcpStream::connect_timeout(\n            host + \":\" + port.to_s(), \n            timeout\n        )\n        socket.close()\n        return true\n    } catch {\n        return false\n    }\n}\n\nfn identify_service(port) {\n    let services = {\n        21: \"FTP\",\n        22: \"SSH\",\n        23: \"Telnet\",\n        25: \"SMTP\",\n        53: \"DNS\",\n        80: \"HTTP\",\n        110: \"POP3\",\n        143: \"IMAP\",\n        443: \"HTTPS\",\n        445: \"SMB\",\n        3306: \"MySQL\",\n        5432: \"PostgreSQL\",\n        6379: \"Redis\",\n        8080: \"HTTP-Alt\",\n        8443: \"HTTPS-Alt\",\n        27017: \"MongoDB\"\n    }\n    \n    return services.get(port, \"Unknown\")\n}\n\nfn scan_host(host, ports) {\n    println(\"\\nScanning \" + host + \"...\")\n    let open_ports = []\n    \n    // Parallel port scanning\n    let tasks = []\n    for port in ports {\n        tasks.push(async {\n            if scan_port(host, port) {\n                return port\n            }\n            return null\n        })\n    }\n    \n    let results = async::wait_all(tasks)\n    \n    for port in results {\n        if port {\n            let service = identify_service(port)\n            open_ports.push({port: port, service: service})\n            println(\"  ‚úì Port \" + port.to_s() + \" open - \" + service)\n        }\n    }\n    \n    return open_ports\n}\n\n// Get scan parameters\nlet target = input(\"Target host (IP or domain): \")\nlet scan_type = input(\"Scan type (quick/full/custom): \")\n\nlet ports = match scan_type {\n    \"quick\" => [21, 22, 23, 25, 80, 443, 3306, 5432, 8080]\n    \"full\" => range(1, 65535)\n    \"custom\" => {\n        let range_str = input(\"Port range (e.g., 1-1000): \")\n        let parts = range_str.split(\"-\")\n        range(parts[0].to_i(), parts[1].to_i())\n    }\n    _ => [80, 443]\n}\n\nprintln(\"\\nScanning \" + ports.len().to_s() + \" ports on \" + target + \"...\")\nlet start_time = current_time_ms()\n\nlet results = scan_host(target, ports)\n\nlet duration = (current_time_ms() - start_time) / 1000\nprintln(\"\\nScan complete in \" + duration.to_s() + \"s\")\nprintln(\"Found \" + results.len().to_s() + \" open ports\")\n\n// Generate report\nif results.len() > 0 {\n    println(\"\\n=== Open Services ===\")\n    for item in results.sort_by(|r| r.port) {\n        println(item.port.to_s() + \" - \" + item.service)\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected identifier, '*', or '{' after '::'\n"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 8,
          "line_number": 589,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// File: load_balancer.ruchy\n// HTTP load balancer with health checking\n\nuse std::net::http;\n\nlet backends = [\n    {url: \"http://server1:8080\", weight: 1, healthy: true},\n    {url: \"http://server2:8080\", weight: 2, healthy: true},\n    {url: \"http://server3:8080\", weight: 1, healthy: true}\n]\n\nlet current_backend = 0\n\nfn select_backend() {\n    // Weighted round-robin selection\n    let healthy_backends = backends.filter(|b| b.healthy)\n    \n    if healthy_backends.is_empty() {\n        throw \"No healthy backends available\"\n    }\n    \n    // Simple round-robin for now\n    current_backend = (current_backend + 1) % healthy_backends.len()\n    return healthy_backends[current_backend]\n}\n\nfn health_check() {\n    for backend in backends {\n        try {\n            let response = http::get(backend.url + \"/health\")\n                .timeout(2000)\n                .send()\n            \n            backend.healthy = response.status == 200\n        } catch {\n            backend.healthy = false\n        }\n        \n        let status = backend.healthy ? \"‚úì\" : \"‚úó\"\n        println(\"Health check \" + backend.url + \": \" + status)\n    }\n}\n\n// Start health check timer\nspawn {\n    loop {\n        health_check()\n        sleep(10000)  // Check every 10 seconds\n    }\n}\n\n// Create load balancer server\nlet balancer = http::Server::new(\"0.0.0.0:80\")\n\nbalancer.all(\"*\", |req, res| {\n    let backend = select_backend()\n    \n    println(\"Routing \" + req.method + \" \" + req.path + \" -> \" + backend.url)\n    \n    // Forward request\n    let backend_response = http::request(backend.url + req.path)\n        .method(req.method)\n        .headers(req.headers)\n        .body(req.body)\n        .send()\n    \n    // Return response\n    res.status(backend_response.status)\n        .headers(backend_response.headers)\n        .send(backend_response.body)\n})\n\nprintln(\"üîÑ Load balancer running on port 80\")\nprintln(\"Backends: \" + backends.len().to_s())\nbalancer.listen()",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected method name or 'await' after '.'\n"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 9,
          "line_number": 678,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Custom protocol over TCP\nfn send_packet(socket, type, data) {\n    let packet = {\n        version: 1,\n        type: type,\n        timestamp: current_time_ms(),\n        data: data\n    }\n    \n    let json = to_json(packet)\n    let length = json.len()\n    \n    // Send length-prefixed message\n    socket.write_u32(length)\n    socket.write(json)\n}\n\nfn receive_packet(socket) {\n    let length = socket.read_u32()\n    let json = socket.read(length)\n    return parse_json(json)\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Function parameters must be simple identifiers (destructuring patterns not supported)\n"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 10,
          "line_number": 710,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Monitor network traffic\nlet monitor = net::PacketCapture::new(\"eth0\")\n\nmonitor.on_packet(|packet| {\n    if packet.protocol == \"TCP\" {\n        println(\"TCP: \" + packet.src + \":\" + packet.src_port.to_s() + \" -> \" + packet.dst + \":\" + packet.dst_port.to_s())\n    } else if packet.protocol == \"UDP\" {\n        println(\"UDP: \" + packet.src + \" -> \" + packet.dst + \" (\" + packet.size.to_s() + \" bytes)\")\n    }\n})\n\nmonitor.start()",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: ColonColon\n"
        }
      ]
    },
    "ch08-00-systems-programming": {
      "chapter": "ch08-00-systems-programming",
      "total_examples": 9,
      "working_examples": 4,
      "failing_examples": 5,
      "examples": [
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ‚ùå BROKEN\n\n// File: system_monitor.ruchy\n// Real-time system resource monitoring\n\nuse std::system;\nuse std::process;\n\nprintln(\"=== System Monitor ===\")\n\n// Get system information\nlet cpu_count = system::cpu_count()\nlet total_memory = system::total_memory()\nlet hostname = system::hostname()\nlet os_info = system::os_info()\n\nprintln(\"Host: \" + hostname)\nprintln(\"OS: \" + os_info.name + \" \" + os_info.version)\nprintln(\"CPUs: \" + cpu_count.to_s())\nprintln(\"Memory: \" + format_size(total_memory))\nprintln(\"\")\n\n// Monitor resources in real-time\nloop {\n    let cpu_usage = system::cpu_usage()\n    let memory_info = system::memory_info()\n    let disk_io = system::disk_io_stats()\n    let network_stats = system::network_stats()\n    \n    // Clear screen and show header\n    clear_screen()\n    println(\"System Monitor - Press Ctrl+C to exit\")\n    println(\"=\" * 50)\n    \n    // CPU Usage\n    println(\"CPU: \" + cpu_usage.to_s() + \"% |\" + (\"‚ñà\" * (cpu_usage * 50).to_i()) + (\"‚ñë\" * (50 - cpu_usage * 50).to_i()) + \"|\")\n    \n    // Memory Usage\n    let mem_percent = memory_info.used / memory_info.total\n    println(\"MEM: \" + mem_percent.to_s() + \"% |\" + (\"‚ñà\" * (mem_percent * 50).to_i()) + (\"‚ñë\" * (50 - mem_percent * 50).to_i()) + \"|\")\n    println(\"     \" + format_size(memory_info.used) + \" / \" + format_size(memory_info.total))\n    \n    // Disk I/O\n    println(\"Disk Read:  \" + format_size(disk_io.read_bytes) + \"/s\")\n    println(\"Disk Write: \" + format_size(disk_io.write_bytes) + \"/s\")\n    \n    // Network\n    println(\"Net Down: \" + format_size(network_stats.download_speed) + \"/s\")\n    println(\"Net Up:   \" + format_size(network_stats.upload_speed) + \"/s\")\n    \n    // Top processes\n    println(\"\\nTop Processes by CPU:\")\n    let processes = process::list()\n        .sort_by(|p| -p.cpu_percent)\n        .take(5)\n    \n    for proc in processes {\n        println(\"  \" + proc.pid.to_s() + \" \" + proc.name + \" \" + proc.cpu_percent.to_s() + \"%\")\n    }\n    \n    sleep(1000)  // Update every second\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 2,
          "line_number": 107,
          "code": "// Status: ‚ùå BROKEN\n\n// Current process information\nlet pid = process::current_pid()\nlet ppid = process::parent_pid()\nlet exe_path = process::executable_path()\nlet args = process::args()\nlet env = process::environment()\n\n// List all processes\nlet all_processes = process::list()\nfor proc in all_processes {\n    println(\"PID: \" + proc.pid.to_s() + \", Name: \" + proc.name + \", CPU: \" + proc.cpu_percent.to_s() + \"%\")\n}\n\n// Find specific process\nlet chrome_procs = process::find_by_name(\"chrome\")\nlet high_cpu_procs = process::list()\n    .filter(|p| p.cpu_percent > 50)\n\n// Process control\nlet proc = process::from_pid(1234)\nproc.suspend()  // Pause process\nproc.resume()   // Resume process\nproc.terminate() // Request termination\nproc.kill()     // Force kill\n\n// Launch new process\nlet child = process::spawn(\"ls\", [\"-la\"])\nlet output = child.wait_with_output()\nprintln(output.stdout)\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 3,
          "line_number": 149,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Register signal handlers\nsignal::on(SIGINT, || {\n    println(\"\\nGracefully shutting down...\")\n    cleanup()\n    exit(0)\n})\n\nsignal::on(SIGTERM, || {\n    save_state()\n    exit(0)\n})\n\nsignal::on(SIGUSR1, || {\n    reload_config()\n})\n\n// Send signals to other processes\nlet target_pid = 1234\nsignal::send(target_pid, SIGUSR1)\n\n// Block/unblock signals\nsignal::block([SIGPIPE])\ncritical_operation()\nsignal::unblock([SIGPIPE])",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected identifier after '::'\n"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 4,
          "line_number": 185,
          "code": "// Status: ‚ùå BROKEN\n\n// Get memory information\nlet mem_info = system::memory_info()\nprintln(\"Total: \" + mem_info.total.to_s())\nprintln(\"Used: \" + mem_info.used.to_s())\nprintln(\"Free: \" + mem_info.free.to_s())\nprintln(\"Available: \" + mem_info.available.to_s())\nprintln(\"Swap Used: \" + mem_info.swap_used.to_s())\n\n// Monitor memory pressure\nif mem_info.available < 100_000_000 {  // Less than 100MB\n    println(\"WARNING: Low memory!\")\n    free_caches()\n}\n\n// Memory-mapped files for large data\nlet mmap = memory::map_file(\"huge_dataset.bin\", READ_ONLY)\nlet data = mmap.read_range(0, 1000000)  // Read 1MB\nmmap.close()\n\n// Shared memory between processes\nlet shared = memory::create_shared(\"my_buffer\", 1024 * 1024)\nshared.write(0, data)\n\n// In another process\nlet shared = memory::open_shared(\"my_buffer\")\nlet data = shared.read(0, 1024)\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 5,
          "line_number": 224,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// File: service_manager.ruchy\n// Manage system services\n\nprintln(\"=== Service Manager ===\")\n\nlet services = [\n    {name: \"web_server\", command: \"./server\", port: 8080},\n    {name: \"worker\", command: \"./worker\", count: 4},\n    {name: \"scheduler\", command: \"./scheduler\", interval: 60}\n]\n\nlet running_services = {}\n\nfn start_service(service) {\n    println(\"Starting \" + service.name + \"...\")\n    \n    match service.name {\n        \"web_server\" => {\n            let proc = process::spawn(service.command, [\n                \"--port\", service.port.to_s()\n            ])\n            running_services[service.name] = proc\n            \n            // Wait for port to be available\n            while !network::port_is_open(\"localhost\", service.port) {\n                sleep(100)\n            }\n            println(\"‚úÖ \" + service.name + \" listening on port \" + service.port.to_s())\n        }\n        \"worker\" => {\n            let workers = []\n            for i in range(service.count) {\n                let proc = process::spawn(service.command, [\n                    \"--id\", i.to_s()\n                ])\n                workers.push(proc)\n            }\n            running_services[service.name] = workers\n            println(\"‚úÖ Started \" + service.count.to_s() + \" workers\")\n        }\n        \"scheduler\" => {\n            let proc = process::spawn(service.command, [\n                \"--interval\", service.interval.to_s()\n            ])\n            running_services[service.name] = proc\n            println(\"‚úÖ Scheduler running every \" + service.interval.to_s() + \"s\")\n        }\n    }\n}\n\nfn stop_service(name) {\n    if running_services.has_key(name) {\n        println(\"Stopping \" + name + \"...\")\n        let proc = running_services[name]\n        \n        if proc.is_array() {\n            // Multiple processes (workers)\n            for p in proc {\n                p.terminate()\n                p.wait()\n            }\n        } else {\n            // Single process\n            proc.terminate()\n            proc.wait()\n        }\n        \n        running_services.remove(name)\n        println(\"‚úÖ \" + name + \" stopped\")\n    }\n}\n\nfn service_status() {\n    println(\"\\n=== Service Status ===\")\n    for service in services {\n        let status = if running_services.has_key(service.name) {\n            \"üü¢ Running\"\n        } else {\n            \"üî¥ Stopped\"\n        }\n        println(service.name + \" \" + status)\n    }\n}\n\n// Handle shutdown gracefully\nsignal::on(SIGTERM, || {\n    println(\"\\nShutting down all services...\")\n    for name in running_services.keys() {\n        stop_service(name)\n    }\n    exit(0)\n})\n\n// Interactive management\nloop {\n    service_status()\n    println(\"\\nCommands: start <name>, stop <name>, restart <name>, quit\")\n    let command = input(\"> \").split(\" \")\n    \n    match command[0] {\n        \"start\" => start_service(services.find(|s| s.name == command[1]))\n        \"stop\" => stop_service(command[1])\n        \"restart\" => {\n            stop_service(command[1])\n            start_service(services.find(|s| s.name == command[1]))\n        }\n        \"quit\" => break\n        _ => println(\"Unknown command\")\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected identifier or string key in object literal\n"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 6,
          "line_number": 344,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// File: health_check.ruchy\n// Monitor system health and alert on issues\n\nprintln(\"=== System Health Checker ===\")\n\nlet checks = {\n    cpu_threshold: 80,      // Alert if CPU > 80%\n    memory_threshold: 90,   // Alert if memory > 90%\n    disk_threshold: 95,     // Alert if disk > 95%\n    load_threshold: 4.0,    // Alert if load average > 4\n    temp_threshold: 80      // Alert if CPU temp > 80¬∞C\n}\n\nlet alerts = []\n\nfn check_cpu() {\n    let usage = system::cpu_usage() * 100\n    if usage > checks.cpu_threshold {\n        alerts.push({\n            level: \"WARNING\",\n            message: \"CPU usage high: \" + usage.to_s() + \"%\",\n            time: current_datetime()\n        })\n        return false\n    }\n    return true\n}\n\nfn check_memory() {\n    let mem = system::memory_info()\n    let usage = (mem.used / mem.total) * 100\n    if usage > checks.memory_threshold {\n        alerts.push({\n            level: \"CRITICAL\",\n            message: \"Memory usage critical: \" + usage.to_s() + \"%\",\n            time: current_datetime()\n        })\n        return false\n    }\n    return true\n}\n\nfn check_disk() {\n    let disks = system::disk_usage()\n    for disk in disks {\n        let usage = (disk.used / disk.total) * 100\n        if usage > checks.disk_threshold {\n            alerts.push({\n                level: \"WARNING\",\n                message: \"Disk \" + disk.mount + \" almost full: \" + usage.to_s() + \"%\",\n                time: current_datetime()\n            })\n            return false\n        }\n    }\n    return true\n}\n\nfn check_load() {\n    let load = system::load_average()\n    let cpu_count = system::cpu_count()\n    let normalized_load = load.one_minute / cpu_count\n    \n    if normalized_load > checks.load_threshold {\n        alerts.push({\n            level: \"WARNING\",\n            message: \"System load high: \" + load.one_minute.to_s() + \",\",\n            time: current_datetime()\n        })\n        return false\n    }\n    return true\n}\n\nfn check_temperature() {\n    let temps = system::temperatures()\n    for sensor in temps {\n        if sensor.current > checks.temp_threshold {\n            alerts.push({\n                level: \"CRITICAL\",\n                message: \"Temperature critical: \" + sensor.name + \" at \" + sensor.current.to_s() + \"¬∞C\",\n                time: current_datetime()\n            })\n            return false\n        }\n    }\n    return true\n}\n\nfn run_health_checks() {\n    let all_healthy = true\n    \n    all_healthy = check_cpu() && all_healthy\n    all_healthy = check_memory() && all_healthy\n    all_healthy = check_disk() && all_healthy\n    all_healthy = check_load() && all_healthy\n    all_healthy = check_temperature() && all_healthy\n    \n    return all_healthy\n}\n\n// Main monitoring loop\nloop {\n    clear_screen()\n    println(\"System Health Check - \" + current_datetime())\n    println(\"=\" * 50)\n    \n    let healthy = run_health_checks()\n    \n    if healthy {\n        println(\"‚úÖ All systems healthy\")\n    } else {\n        println(\"‚ö†Ô∏è  Issues detected:\")\n        for alert in alerts.last(5) {\n            let icon = alert.level == \"CRITICAL\" ? \"üî¥\" : \"üü°\"\n            println(icon + \" [\" + alert.level + \"] \" + alert.message)\n        }\n    }\n    \n    // Show current stats\n    println(\"\\nCurrent Status:\")\n    let cpu = system::cpu_usage() * 100\n    let mem = system::memory_info()\n    let mem_percent = (mem.used / mem.total) * 100\n    let load = system::load_average()\n    \n    println(\"CPU:    \" + cpu.to_s() + \"% / \" + checks.cpu_threshold.to_s() + \"%\")\n    println(\"Memory: \" + mem_percent.to_s() + \"% / \" + checks.memory_threshold.to_s() + \"%\")\n    println(\"Load:   \" + load.one_minute.to_s() + \" / \" + checks.load_threshold.to_s())\n    \n    // Send notifications for critical alerts\n    for alert in alerts {\n        if alert.level == \"CRITICAL\" {\n            system::notify(alert.message, \"System Health Alert\")\n        }\n    }\n    \n    sleep(5000)  // Check every 5 seconds\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: Question\n"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 7,
          "line_number": 493,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// File: process_tree.ruchy\n// Visualize process hierarchy\n\nfn build_process_tree() {\n    let processes = process::list()\n    let tree = {}\n    \n    // Build parent-child relationships\n    for proc in processes {\n        let ppid = proc.parent_pid\n        if !tree.has_key(ppid) {\n            tree[ppid] = []\n        }\n        tree[ppid].push(proc)\n    }\n    \n    return tree\n}\n\nfn print_tree(pid, tree, indent = \"\") {\n    if !tree.has_key(pid) {\n        return\n    }\n    \n    let children = tree[pid].sort_by(|p| p.pid)\n    for i, proc in children.enumerate() {\n        let is_last = (i == children.len() - 1)\n        let prefix = is_last ? \"‚îî‚îÄ\" : \"‚îú‚îÄ\"\n        let extension = is_last ? \"  \" : \"‚îÇ \"\n        \n        let memory = format_size(proc.memory_info.rss)\n        println(indent + prefix + \" [\" + proc.pid.to_s() + \"] \" + proc.name + \" (\" + memory + \", \" + proc.cpu_percent.to_s() + \"%)\")\n        \n        // Recursively print children\n        print_tree(proc.pid, tree, indent + extension)\n    }\n}\n\nprintln(\"=== Process Tree ===\")\nlet tree = build_process_tree()\n\n// Start from init (PID 1) or system idle (PID 0)\nlet root_pid = tree.has_key(0) ? 0 : 1\nprintln(\"[\" + root_pid.to_s() + \"] System Root\")\nprint_tree(root_pid, tree)\n\n// Show process statistics\nlet all_procs = process::list()\nlet total_memory = all_procs.map(|p| p.memory_info.rss).sum()\nlet total_cpu = all_procs.map(|p| p.cpu_percent).sum()\n\nprintln(\"\\nTotal Processes: \" + all_procs.len().to_s())\nprintln(\"Total Memory: \" + format_size(total_memory))\nprintln(\"Total CPU: \" + total_cpu.to_s() + \"%\")",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected In, found Comma\n"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 8,
          "line_number": 561,
          "code": "// Status: ‚ùå BROKEN\n\n// Watch for file system events\nlet watcher = fs::watch(\"/path/to/watch\", RECURSIVE)\n\nwatcher.on(\"created\", |path| {\n    println(\"File created: \" + path)\n})\n\nwatcher.on(\"modified\", |path| {\n    println(\"File modified: \" + path)\n    process_change(path)\n})\n\nwatcher.on(\"deleted\", |path| {\n    println(\"File deleted: \" + path)\n})\n\nwatcher.start()\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 9,
          "line_number": 589,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Automated system maintenance\nfn auto_cleanup() {\n    // Clean temp files older than 7 days\n    let temp_dir = \"/tmp\"\n    let cutoff_time = current_time() - days(7)\n    \n    for file in fs::walk(temp_dir) {\n        if fs::modified_time(file) < cutoff_time {\n            fs::remove(file)\n            println(\"Cleaned: \" + file)\n        }\n    }\n    \n    // Clear package manager cache\n    if fs::dir_size(\"/var/cache/apt\") > gb(1) {\n        run_command(\"apt-get clean\")\n    }\n    \n    // Rotate logs\n    for log in fs::glob(\"/var/log/*.log\") {\n        if fs::size(log) > mb(100) {\n            fs::rotate_log(log, keep_count: 5)\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected RightParen, found Colon\n"
        }
      ]
    },
    "ch13-00-error-handling": {
      "chapter": "ch13-00-error-handling",
      "total_examples": 12,
      "working_examples": 0,
      "failing_examples": 12,
      "examples": [
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Define error types\nenum AppError {\n    NetworkError(String)\n    ParseError(String)\n    NotFound(String)\n    Unauthorized\n}\n\n// Functions return Result\nfn fetch_user(id: i32) -> Result<User, AppError> {\n    // Note: In v0.11.0, the ? operator is removed. Use match for error handling:\n    let response = match http::get(\"/api/users/\" + id.to_s()) {\n        Ok(r) => r,\n        Err(e) => return Err(AppError::NetworkError(e))\n    }\n    \n    if response.status == 404 {\n        return Err(AppError::NotFound(\"User \" + id.to_s() + \" not found\"))\n    }\n    \n    if response.status == 401 {\n        return Err(AppError::Unauthorized)\n    }\n    \n    let user = match parse_json(response.body) {\n        Ok(u) => u,\n        Err(e) => return Err(AppError::ParseError(e.to_string()))\n    }\n    \n    return Ok(user)\n}\n\n// Handle errors explicitly\nmatch fetch_user(123) {\n    Ok(user) => {\n        println(\"Found user: \" + user.name)\n    }\n    Err(AppError::NotFound(msg)) => {\n        println(\"User not found: \" + msg)\n    }\n    Err(AppError::NetworkError(e)) => {\n        println(\"Network problem: \" + e.to_s())\n        retry_with_backoff()\n    }\n    Err(e) => {\n        log_error(e)\n        return_default_user()\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected RightBrace, found Identifier(\"ParseError\")\n"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 2,
          "line_number": 95,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Result is an enum with two variants\nenum Result<T, E> {\n    Ok(T)    // Success with value\n    Err(E)   // Error with error value\n}\n\n// Functions that can fail return Result\nfn divide(a: f64, b: f64) -> Result<f64, String> {\n    if b == 0.0 {\n        return Err(\"Division by zero\")\n    }\n    return Ok(a / b)\n}\n\n// Check and handle results\nlet result = divide(10.0, 2.0)\nif result.is_ok() {\n    println(\"Result: \" + result.unwrap().to_s())\n} else {\n    println(\"Error: \" + result.unwrap_err().to_s())\n}\n\n// Pattern matching\nmatch divide(10.0, 0.0) {\n    Ok(value) => println(\"Success: \" + value.to_s())\n    Err(error) => println(\"Failed: \" + error.to_s())\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected enum name\n"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 3,
          "line_number": 134,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Option represents nullable values\nenum Option<T> {\n    Some(T)  // Value present\n    None     // Value absent\n}\n\n// Functions that might not return a value\nfn find_user(name: String) -> Option<User> {\n    let users = load_users()\n    for user in users {\n        if user.name == name {\n            return Some(user)\n        }\n    }\n    return None\n}\n\n// Safe handling of missing values\nlet user = find_user(\"Alice\")\nif let Some(u) = user {\n    println(\"Found: \" + u.email)\n} else {\n    println(\"User not found\")\n}\n\n// Chain operations safely\nlet email = find_user(\"Bob\")\n    .map(|u| u.email)\n    .unwrap_or(\"no-email@example.com\")",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected enum name\n"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 4,
          "line_number": 175,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Without ? operator - verbose\nfn process_file_verbose(path: String) -> Result<String, Error> {\n    let file = match open_file(path) {\n        Ok(f) => f\n        Err(e) => return Err(e)\n    }\n    \n    let contents = match read_all(file) {\n        Ok(c) => c\n        Err(e) => return Err(e)\n    }\n    \n    let processed = match process(contents) {\n        Ok(p) => p\n        Err(e) => return Err(e)\n    }\n    \n    return Ok(processed)\n}\n\n// In v0.11.0 - use explicit error handling\nfn process_file(path: String) -> Result<String, Error> {\n    let file = match open_file(path) {\n        Ok(f) => f,\n        Err(e) => return Err(e)\n    }\n    let contents = match read_all(file) {\n        Ok(c) => c,\n        Err(e) => return Err(e)\n    }\n    let processed = match process(contents) {\n        Ok(p) => p,\n        Err(e) => return Err(e)\n    }\n    return Ok(processed)\n}\n\n// Chain multiple operations with explicit handling\nfn complex_operation() -> Result<Data, Error> {\n    let data = match fetch_data() {\n        Ok(d) => d,\n        Err(e) => return Err(e)\n    }\n    let validated = match data.validate() {\n        Ok(v) => v,\n        Err(e) => return Err(e)\n    }\n    let transformed = match validated.transform() {\n        Ok(t) => t,\n        Err(e) => return Err(e)\n    }\n    let optimized = match transformed.optimize() {\n        Ok(o) => o,\n        Err(e) => return Err(e)\n    }\n    \n    return Ok(optimized)\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected type\n"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 5,
          "line_number": 245,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Detailed error enum\nenum DatabaseError {\n    ConnectionFailed { host: String, port: i32 }\n    QueryFailed { query: String, error: String }\n    Timeout { duration: i32 }\n    InvalidCredentials\n}\n\nimpl Display for DatabaseError {\n    fn fmt(self, f: Formatter) -> Result {\n        match self {\n            ConnectionFailed{host, port} => \n                write(f, \"Failed to connect to \" + host + \":\" + port.to_s())\n            QueryFailed{query, error} => \n                write(f, \"Query failed: \" + query + \"\\nError: \" + error)\n            Timeout{duration} => \n                write(f, \"Operation timed out after \" + duration.to_s() + \"ms\")\n            InvalidCredentials => \n                write(f, \"Invalid database credentials\")\n        }\n    }\n}\n\n// Error with context\nstruct Error {\n    kind: ErrorKind\n    message: String\n    source: Option<Box<Error>>\n    backtrace: Backtrace\n}\n\nimpl Error {\n    fn new(kind: ErrorKind, message: String) -> Error {\n        return Error{\n            kind,\n            message,\n            source: None,\n            backtrace: Backtrace::capture()\n        }\n    }\n    \n    fn with_source(mut self, source: Error) -> Error {\n        self.source = Some(Box::new(source))\n        return self\n    }\n    \n    fn chain(self) -> Vec<String> {\n        let mut messages = vec![self.message]\n        let mut current = self.source\n        \n        while let Some(error) = current {\n            messages.push(error.message)\n            current = error.source\n        }\n        \n        return messages\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected RightBrace, found LeftBrace\n"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 6,
          "line_number": 317,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\nfn validate_user(user: User) -> Result<User, ValidationError> {\n    // Early return on validation failures\n    if user.name.is_empty() {\n        return Err(ValidationError::EmptyName)\n    }\n    \n    if !is_valid_email(user.email) {\n        return Err(ValidationError::InvalidEmail(user.email))\n    }\n    \n    if user.age < 0 || user.age > 150 {\n        return Err(ValidationError::InvalidAge(user.age))\n    }\n    \n    // All validations passed\n    return Ok(user)\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected type\n"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 7,
          "line_number": 346,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Retry with exponential backoff\nfn fetch_with_retry<T>(\n    operation: Fn() -> Result<T, Error>,\n    max_attempts: i32\n) -> Result<T, Error> {\n    let mut attempt = 0\n    let mut delay = 1000  // Start with 1 second\n    \n    loop {\n        match operation() {\n            Ok(result) => return Ok(result)\n            Err(e) if attempt >= max_attempts => {\n                return Err(e)\n            }\n            Err(e) => {\n                println(\"Attempt \" + (attempt + 1).to_s() + \" failed: \" + e.to_s())\n                sleep(delay)\n                delay *= 2  // Exponential backoff\n                attempt += 1\n            }\n        }\n    }\n}\n\n// Fallback strategies\nfn get_config() -> Config {\n    load_config_file()\n        .or_else(|| load_env_config())\n        .or_else(|| fetch_remote_config())\n        .unwrap_or_else(|| Config::default())\n}\n\n// Circuit breaker pattern\nstruct CircuitBreaker {\n    failure_count: i32\n    last_failure: Option<Instant>\n    state: State\n}\n\nimpl CircuitBreaker {\n    fn call<T>(mut self, f: Fn() -> Result<T, Error>) -> Result<T, Error> {\n        match self.state {\n            State::Open => {\n                if self.should_attempt() {\n                    self.state = State::HalfOpen\n                } else {\n                    return Err(Error::CircuitOpen)\n                }\n            }\n            _ => {}\n        }\n        \n        match f() {\n            Ok(result) => {\n                self.reset()\n                Ok(result)\n            }\n            Err(e) => {\n                self.record_failure()\n                Err(e)\n            }\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected RightParen, found LeftParen\n"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 8,
          "line_number": 422,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Trait for adding context\ntrait Context<T> {\n    fn context(self, msg: String) -> Result<T, Error>\n    fn with_context<F>(self, f: F) -> Result<T, Error>\n        where F: FnOnce() -> String\n}\n\nimpl<T, E: Into<Error>> Context<T> for Result<T, E> {\n    fn context(self, msg: String) -> Result<T, Error> {\n        self.map_err(|e| {\n            Error::new(e.into())\n                .with_message(msg)\n        })\n    }\n    \n    fn with_context<F>(self, f: F) -> Result<T, Error>\n        where F: FnOnce() -> String\n    {\n        self.map_err(|e| {\n            Error::new(e.into())\n                .with_message(f())\n        })\n    }\n}\n\n// Use context for better errors\nfn process_order(order_id: i32) -> Result<Order, Error> {\n    let order = fetch_order(order_id)\n        .context(\"Failed to fetch order \" + order_id)??\n    \n    let validated = validate_order(order)\n        .context(\"Order validation failed\")?\n    \n    let processed = process_payment(validated)\n        .with_context(|| \"Payment processing failed for $\" + validated.total.to_s())??\n    \n    return Ok(processed)\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected type\n"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 9,
          "line_number": 472,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Structured API errors\nstruct ApiError {\n    status: i32\n    code: String\n    message: String\n    details: Option<Map<String, Any>>\n}\n\nimpl ApiError {\n    fn bad_request(message: String) -> ApiError {\n        ApiError{\n            status: 400,\n            code: \"BAD_REQUEST\",\n            message,\n            details: None\n        }\n    }\n    \n    fn unauthorized() -> ApiError {\n        ApiError{\n            status: 401,\n            code: \"UNAUTHORIZED\",\n            message: \"Authentication required\",\n            details: None\n        }\n    }\n    \n    fn internal_error(error: Error) -> ApiError {\n        // Log full error internally\n        log::error(\"Internal error: \" + error.chain().join(\" -> \"))\n        \n        // Return sanitized error to client\n        ApiError{\n            status: 500,\n            code: \"INTERNAL_ERROR\",\n            message: \"An internal error occurred\",\n            details: None\n        }\n    }\n}\n\n// Convert to HTTP response\nimpl IntoResponse for ApiError {\n    fn into_response(self) -> Response {\n        Response::builder()\n            .status(self.status)\n            .json(self)\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected RightBrace, found Identifier(\"code\")\n"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 10,
          "line_number": 531,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Composable validators\ntype Validator<T> = Fn(T) -> Result<T, ValidationError>\n\nfn validate_pipeline<T>(\n    value: T,\n    validators: Vec<Validator<T>>\n) -> Result<T, Vec<ValidationError>> {\n    let mut errors = Vec::new()\n    let mut current = value\n    \n    for validator in validators {\n        match validator(current) {\n            Ok(validated) => current = validated\n            Err(e) => errors.push(e)\n        }\n    }\n    \n    if errors.is_empty() {\n        Ok(current)\n    } else {\n        Err(errors)\n    }\n}\n\n// Use validation pipeline\nlet user_validators = vec![\n    validate_required_fields,\n    validate_email_format,\n    validate_age_range,\n    validate_unique_username\n]\n\nmatch validate_pipeline(user, user_validators) {\n    Ok(valid_user) => save_user(valid_user)\n    Err(errors) => {\n        for error in errors {\n            println(\"Validation error: \" + error.to_s())\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: Type\n"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 11,
          "line_number": 581,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Async Result type\nasync fn fetch_data(url: String) -> Result<Data, Error> {\n    let response = http::get(url).await?\n    let parsed = parse_response(response).await?\n    return Ok(parsed)\n}\n\n// Try multiple sources\nasync fn get_data_with_fallback() -> Result<Data, Error> {\n    // Try primary source\n    if let Ok(data) = fetch_data(PRIMARY_URL).await {\n        return Ok(data)\n    }\n    \n    // Try backup source\n    if let Ok(data) = fetch_data(BACKUP_URL).await {\n        return Ok(data)\n    }\n    \n    // Try cache\n    if let Some(cached) = get_cached_data().await {\n        log::warn(\"Using stale cached data\")\n        return Ok(cached)\n    }\n    \n    return Err(Error::NoDataAvailable)\n}\n\n// Parallel error handling\nasync fn fetch_all(urls: Vec<String>) -> Vec<Result<Data, Error>> {\n    let futures = urls.map(|url| fetch_data(url))\n    return join_all(futures).await\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected type\n"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 12,
          "line_number": 624,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n#[test]\nfn test_error_handling() {\n    // Test expected errors\n    let result = divide(10.0, 0.0)\n    assert!(result.is_err())\n    assert_eq!(result.unwrap_err(), \"Division by zero\")\n    \n    // Test error propagation\n    let result = process_invalid_file()\n    assert!(matches!(result, Err(FileError::NotFound(_))))\n    \n    // Test recovery\n    let config = get_config_with_fallback()\n    assert!(config.is_valid())  // Should always succeed\n}\n\n#[test]\n#[should_panic(expected = \"assertion failed\")]\nfn test_panic_condition() {\n    unsafe_operation()\n}\n\n// Property-based testing for error conditions\n#[property_test]\nfn never_panics(input: RandomInput) {\n    let _ = safe_process(input)  // Should never panic\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: Underscore\n"
        }
      ]
    },
    "ch03-01-testing-functions": {
      "chapter": "ch03-01-testing-functions",
      "total_examples": 12,
      "working_examples": 12,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ‚ùå BROKEN\n// Your function\nfun add(a, b) {\n    a + b\n}\n\n// Your test\n#[test]\nfun test_add() {\n    assert_eq!(add(2, 3), 5)\n    assert_eq!(add(0, 0), 0)\n    assert_eq!(add(-1, 1), 0)\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 2,
          "line_number": 64,
          "code": "// Status: ‚ùå BROKEN\n#[test]\nfun test_function_name() {\n    // Test code here\n    assert_eq!(actual, expected)\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 3,
          "line_number": 90,
          "code": "// Status: ‚ùå BROKEN\n// tests/calculator_test.ruchy\n\nuse super::*;  // Import functions from main module\n\n#[test]\nfun test_addition() {\n    assert_eq!(add(2, 3), 5)\n}\n\n#[test]  \nfun test_subtraction() {\n    assert_eq!(subtract(10, 4), 6)\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 4,
          "line_number": 116,
          "code": "// Status: ‚ùå BROKEN\n// calculator.ruchy\nfun multiply(a, b) {\n    a * b\n}\n\nfun divide(a, b) {\n    if b == 0 {\n        0  // Simple handling for now\n    } else {\n        a / b\n    }\n}\n\nfun is_even(n) {\n    n % 2 == 0\n}\n\n// tests/calculator_test.ruchy  \n#[test]\nfun test_multiply() {\n    assert_eq!(multiply(3, 4), 12)\n    assert_eq!(multiply(0, 5), 0)\n    assert_eq!(multiply(-2, 3), -6)\n}\n\n#[test]\nfun test_divide() {\n    assert_eq!(divide(10, 2), 5)\n    assert_eq!(divide(7, 3), 2)  // Integer division\n    assert_eq!(divide(5, 0), 0)  // Division by zero handled\n}\n\n#[test]\nfun test_is_even() {\n    assert!(is_even(4))        // 4 is even\n    assert!(!is_even(3))       // 3 is not even  \n    assert!(is_even(0))        // 0 is even\n    assert!(!is_even(-1))      // -1 is not even\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 5,
          "line_number": 166,
          "code": "// Status: ‚ùå BROKEN\nfun find_max(numbers) {\n    if numbers.len() == 0 {\n        -999999  // Sentinel value for empty\n    } else {\n        let mut max_val = numbers[0]\n        let mut i = 1\n        while i < numbers.len() {\n            if numbers[i] > max_val {\n                max_val = numbers[i]\n            }\n            i = i + 1\n        }\n        max_val\n    }\n}\n\n#[test]\nfun test_find_max() {\n    // Normal cases\n    assert_eq!(find_max([1, 5, 3, 9, 2]), 9)\n    assert_eq!(find_max([10]), 10)\n    \n    // Edge cases\n    assert_eq!(find_max([]), -999999)        // Empty list\n    assert_eq!(find_max([-5, -1, -10]), -1)  // All negative\n    assert_eq!(find_max([5, 5, 5]), 5)       // All same\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 6,
          "line_number": 202,
          "code": "// Status: ‚ùå BROKEN\nfun clean_username(raw_username) {\n    // Simple cleaning - replace spaces with underscores\n    raw_username.replace(\" \", \"_\")\n}\n\nfun count_vowels(text) {\n    let vowels = \"aeiouAEIOU\"\n    let mut count = 0\n    let mut i = 0\n    while i < text.len() {\n        if vowels.contains(text[i]) {\n            count = count + 1\n        }\n        i = i + 1\n    }\n    count\n}\n\n#[test]\nfun test_clean_username() {\n    assert_eq!(clean_username(\"Alice Johnson\"), \"Alice_Johnson\")\n    assert_eq!(clean_username(\"JOHN\"), \"JOHN\")\n    assert_eq!(clean_username(\"\"), \"\")\n}\n\n#[test]\nfun test_count_vowels() {\n    assert_eq!(count_vowels(\"hello\"), 2)      // e, o\n    assert_eq!(count_vowels(\"HELLO\"), 2)      // Case insensitive\n    assert_eq!(count_vowels(\"xyz\"), 0)        // No vowels\n    assert_eq!(count_vowels(\"aeiou\"), 5)      // All vowels\n    assert_eq!(count_vowels(\"\"), 0)           // Empty string\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 7,
          "line_number": 244,
          "code": "// Status: ‚ùå BROKEN\nfun calculate_grade(score) {\n    if score >= 90 { \"A\" }\n    else if score >= 80 { \"B\" } \n    else if score >= 70 { \"C\" }\n    else if score >= 60 { \"D\" }\n    else { \"F\" }\n}\n\nfun can_vote(age, is_citizen) {\n    age >= 18 && is_citizen\n}\n\n#[test]\nfun test_calculate_grade() {\n    // Boundary testing\n    assert_eq!(calculate_grade(95), \"A\")\n    assert_eq!(calculate_grade(90), \"A\")  // Exactly 90\n    assert_eq!(calculate_grade(89), \"B\")  // Just below A\n    assert_eq!(calculate_grade(80), \"B\")  // Exactly 80\n    assert_eq!(calculate_grade(79), \"C\")  // Just below B\n    assert_eq!(calculate_grade(59), \"F\")  // Failing grade\n    assert_eq!(calculate_grade(0), \"F\")   // Very low\n}\n\n#[test]\nfun test_can_vote() {\n    // All combinations\n    assert!(can_vote(18, true))      // Minimum age, citizen\n    assert!(can_vote(25, true))      // Adult citizen\n    assert!(!can_vote(17, true))     // Too young\n    assert!(!can_vote(25, false))    // Not citizen\n    assert!(!can_vote(17, false))    // Too young AND not citizen\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 8,
          "line_number": 292,
          "code": "// Status: ‚ùå BROKEN\n\n// Step 1: Write the test first\n#[test]\nfn test_fahrenheit_to_celsius() {\n    assert_eq!(fahrenheit_to_celsius(32), 0)    // Freezing point\n    assert_eq!(fahrenheit_to_celsius(212), 100) // Boiling point\n    assert_eq!(fahrenheit_to_celsius(98.6), 37) // Body temperature\n}\n\n// Step 2: Write minimal code to pass\nfn fahrenheit_to_celsius(fahrenheit) {\n    return (fahrenheit - 32) * 5 / 9\n}\n\n// Step 3: Run tests, refactor if needed\n// All tests pass! Code is ready to use.\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 9,
          "line_number": 319,
          "code": "// Status: ‚ùå BROKEN\n\n// ‚ùå Only testing happy path\n#[test]\nfn test_divide_bad() {\n    assert_eq!(divide(10, 2), 5)  // What about divide by zero?\n}\n\n// ‚úÖ Testing edge cases\n#[test]\nfn test_divide_good() {\n    assert_eq!(divide(10, 2), 5)      // Normal case\n    assert_eq!(divide(0, 5), 0)       // Zero dividend\n    // Should handle divide by zero gracefully\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 10,
          "line_number": 342,
          "code": "// Status: ‚ùå BROKEN\n\n// ‚ùå This test will always pass\n#[test]\nfn test_useless() {\n    let result = add(2, 3)\n    assert!(result > 0)  // Too vague!\n}\n\n// ‚úÖ This test verifies exact behavior\n#[test]  \nfn test_useful() {\n    assert_eq!(add(2, 3), 5)  // Exact expectation\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 11,
          "line_number": 364,
          "code": "// Status: ‚ùå BROKEN\n\n// ‚ùå Unclear what this tests\n#[test]\nfn test1() {\n    assert_eq!(is_valid(\"abc\"), false)\n}\n\n// ‚úÖ Clear, descriptive name\n#[test]\nfn test_password_too_short() {\n    assert_eq!(is_valid_password(\"abc\"), false)\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 12,
          "line_number": 423,
          "code": "// Status: ‚ùå BROKEN\n\n// 1. Write failing tests first\n#[test]\nfn test_is_strong_password() {\n    assert!(is_strong_password(\"MyPass123!\"))      // Valid\n    assert!(!is_strong_password(\"weak\"))           // Too short\n    assert!(!is_strong_password(\"NoNumbers!\"))     // No digits\n    assert!(!is_strong_password(\"nonumbers123\"))   // No special chars\n}\n\n// 2. Write minimal code to pass\nfn is_strong_password(password) {\n    if password.len() < 8 { return false }\n    \n    let has_digit = password.chars().any(|c| c.is_digit())\n    let has_special = password.chars().any(|c| \"!@#$%^&*\".contains(c))\n    \n    return has_digit && has_special\n}\n\n// 3. Run tests - they should all pass now!\n\n// 4. Add more edge case tests\n#[test]\nfn test_password_edge_cases() {\n    assert!(!is_strong_password(\"\"))              // Empty\n    assert!(!is_strong_password(\"12345678\"))      // Only digits\n    assert!(!is_strong_password(\"!!!!!!!!\"))      // Only special\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch16-00-testing-quality": {
      "chapter": "ch16-00-testing-quality",
      "total_examples": 11,
      "working_examples": 0,
      "failing_examples": 11,
      "examples": [
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Unit test with multiple assertions\n#[test]\nfn test_user_validation() {\n    // Arrange\n    let valid_user = User {\n        name: \"Alice\",\n        email: \"alice@example.com\",\n        age: 25\n    }\n    \n    // Act\n    let result = validate_user(valid_user)\n    \n    // Assert\n    assert!(result.is_ok())\n    assert_eq!(result.unwrap().name, \"Alice\")\n}\n\n// Property-based testing\n#[proptest]\nfn test_serialization_roundtrip(user: User) {\n    let serialized = user.serialize()\n    let deserialized = User::deserialize(serialized)\n    assert_eq!(user, deserialized)\n}\n\n// Integration test\n#[integration_test]\nasync fn test_api_workflow() {\n    // Start test server\n    let server = TestServer::new()\n    \n    // Create user\n    let response = server.post(\"/users\")\n        .json(new_user)\n        .send()\n        .await\n    \n    assert_eq!(response.status(), 201)\n    let user: User = response.json().await\n    \n    // Verify user exists\n    let get_response = server.get(\"/users/\" + user.id.to_s())\n        .send()\n        .await\n    \n    assert_eq!(get_response.status(), 200)\n}\n\n// Benchmark\n#[bench]\nfn bench_data_processing(b: &mut Bencher) {\n    let data = generate_test_data(10000)\n    b.iter(|| {\n        process_data(data.clone())\n    })\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected method name or 'await' after '.'\n"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 2,
          "line_number": 103,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Basic test\n#[test]\nfn test_addition() {\n    assert_eq!(2 + 2, 4)\n}\n\n// Test with setup\n#[test]\nfn test_calculator() {\n    // Arrange\n    let calc = Calculator::new()\n    \n    // Act\n    let result = calc.add(5, 3)\n    \n    // Assert\n    assert_eq!(result, 8)\n}\n\n// Test expected failures\n#[test]\n#[should_panic(expected = \"Division by zero\")]\nfn test_divide_by_zero() {\n    divide(10, 0)\n}\n\n// Async tests\n#[async_test]\nasync fn test_async_operation() {\n    let result = fetch_data().await\n    assert!(result.is_ok())\n}\n\n// Parameterized tests\n#[test_case(0, 0, 0)]\n#[test_case(1, 1, 2)]\n#[test_case(-1, 1, 0)]\n#[test_case(100, 200, 300)]\nfn test_add_parameterized(a: i32, b: i32, expected: i32) {\n    assert_eq!(add(a, b), expected)\n}\n\n// Test groups\nmod calculator_tests {\n    use super::*\n    \n    #[test]\n    fn test_add() { /* ... */ }\n    \n    #[test]\n    fn test_subtract() { /* ... */ }\n    \n    #[test]\n    fn test_multiply() { /* ... */ }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: RightParen\n"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 3,
          "line_number": 170,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Fixture trait\ntrait TestFixture {\n    fn setup() -> Self\n    fn teardown(self)\n}\n\n// Database fixture\nstruct DatabaseFixture {\n    db: Database\n    test_data: Vec<User>\n}\n\nimpl TestFixture for DatabaseFixture {\n    fn setup() -> Self {\n        let db = Database::connect(\":memory:\")\n        db.migrate()\n        \n        let test_data = vec![\n            User::new(\"Alice\", \"alice@example.com\"),\n            User::new(\"Bob\", \"bob@example.com\")\n        ]\n        \n        for user in &test_data {\n            db.insert(user)\n        }\n        \n        DatabaseFixture { db, test_data }\n    }\n    \n    fn teardown(self) {\n        self.db.drop_all_tables()\n        self.db.disconnect()\n    }\n}\n\n// Use fixture in tests\n#[test]\nfn test_user_query() {\n    let fixture = DatabaseFixture::setup()\n    \n    let users = fixture.db.query(\"SELECT * FROM users\")\n    assert_eq!(users.len(), 2)\n    \n    fixture.teardown()\n}\n\n// Fixture macro for automatic cleanup\n#[with_fixture(DatabaseFixture)]\nfn test_with_auto_cleanup(fixture: DatabaseFixture) {\n    // Fixture automatically cleaned up after test\n    let user = fixture.db.find_user(\"Alice\")\n    assert!(user.is_some())\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected RightBrace, found Identifier(\"test_data\")\n"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 4,
          "line_number": 235,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Mock trait\ntrait EmailService {\n    fn send_email(to: String, subject: String, body: String) -> Result<(), Error>\n}\n\n// Mock implementation\n#[mockable]\nstruct MockEmailService {\n    sent_emails: RefCell<Vec<Email>>\n}\n\nimpl EmailService for MockEmailService {\n    fn send_email(to: String, subject: String, body: String) -> Result<(), Error> {\n        self.sent_emails.borrow_mut().push(Email { to, subject, body })\n        Ok(())\n    }\n}\n\n// Test with mock\n#[test]\nfn test_user_registration() {\n    let email_service = MockEmailService::new()\n    let user_service = UserService::new(email_service)\n    \n    user_service.register_user(\"alice@example.com\")\n    \n    // Verify email was sent\n    assert_eq!(email_service.sent_emails.borrow().len(), 1)\n    assert_eq!(email_service.sent_emails.borrow()[0].subject, \"Welcome!\")\n}\n\n// Spy to verify behavior\n#[test]\nfn test_with_spy() {\n    let spy = Spy::new(RealService::new())\n    \n    spy.method_call()\n    \n    assert!(spy.was_called(\"method_call\"))\n    assert_eq!(spy.call_count(\"method_call\"), 1)\n    assert_eq!(spy.last_args(\"method_call\"), expected_args)\n}\n\n// Stub for predetermined responses\n#[test]\nfn test_with_stub() {\n    let stub = Stub::new()\n        .with_response(\"get_user\", User::test_user())\n        .with_error(\"network_call\", NetworkError)\n    \n    let result = service_using_stub.process()\n    assert_eq!(result, expected)\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected type\n"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 5,
          "line_number": 300,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\nuse proptest::prelude::*\n\n// Generate arbitrary test data\n#[derive(Arbitrary)]\nstruct TestUser {\n    #[proptest(regex = \"[a-z]{3,10}\")]\n    name: String\n    \n    #[proptest(range = 0..150)]\n    age: u8\n    \n    #[proptest(strategy = \"email_strategy()\")]\n    email: String\n}\n\n// Property test\n#[proptest]\nfn test_user_serialization(user: TestUser) {\n    // Property: serialization round-trip preserves data\n    let json = to_json(user)\n    let restored: TestUser = from_json(json)\n    prop_assert_eq!(user, restored)\n}\n\n// Custom strategies\nfn email_strategy() -> impl Strategy<Value = String> {\n    \"[a-z]{3,10}@[a-z]{3,10}\\\\.(com|org|net)\"\n        .prop_map(|s| s.to_string())\n}\n\n// Shrinking for minimal failing case\n#[proptest]\nfn test_no_panic(input: Vec<u8>) {\n    // Proptest will find minimal input that causes panic\n    process_bytes(input)  // Should never panic\n}\n\n// Stateful property testing\n#[proptest]\nfn test_database_consistency(operations: Vec<DbOperation>) {\n    let db = Database::new()\n    \n    for op in operations {\n        op.apply(&db)\n    }\n    \n    // Properties that should always hold\n    prop_assert!(db.is_consistent())\n    prop_assert_eq!(db.total_balance(), INITIAL_BALANCE)\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected field name\n"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 6,
          "line_number": 362,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Integration test in tests/ directory\n#[integration_test]\nasync fn test_full_api_flow() {\n    // Start services\n    let db = TestDatabase::new()\n    let cache = TestCache::new()\n    let server = TestServer::with_services(db, cache)\n    \n    // Register user\n    let register_response = server\n        .post(\"/api/register\")\n        .json(json!({\n            \"email\": \"test@example.com\",\n            \"password\": \"secure123\"\n        }))\n        .send()\n        .await\n    \n    assert_eq!(register_response.status(), 201)\n    let user: User = register_response.json().await\n    \n    // Login\n    let login_response = server\n        .post(\"/api/login\")\n        .json(json!({\n            \"email\": \"test@example.com\",\n            \"password\": \"secure123\"\n        }))\n        .send()\n        .await\n    \n    assert_eq!(login_response.status(), 200)\n    let token = login_response.header(\"Authorization\")\n    \n    // Use authenticated endpoint\n    let profile_response = server\n        .get(\"/api/profile\")\n        .header(\"Authorization\", token)\n        .send()\n        .await\n    \n    assert_eq!(profile_response.status(), 200)\n    let profile: Profile = profile_response.json().await\n    assert_eq!(profile.email, \"test@example.com\")\n}\n\n// Database integration test\n#[test]\nfn test_database_transactions() {\n    let db = Database::connect(TEST_DATABASE_URL)\n    \n    db.transaction(|tx| {\n        tx.insert_user(user1)?\n        tx.insert_user(user2)?\n        \n        // Verify within transaction\n        let count = tx.count_users()?\n        assert_eq!(count, 2)\n        \n        // Rollback for test isolation\n        Err(TestRollback)\n    })\n    \n    // Verify rollback worked\n    assert_eq!(db.count_users(), 0)\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected method name or 'await' after '.'\n"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 7,
          "line_number": 440,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Benchmarks\n#[bench]\nfn bench_sorting_algorithms(b: &mut Bencher) {\n    let data = generate_random_vec(10000)\n    \n    b.iter(|| {\n        let mut copy = data.clone()\n        copy.sort()\n    })\n}\n\n// Comparative benchmarks\n#[bench_group]\nmod sorting_benchmarks {\n    #[bench]\n    fn quick_sort(b: &mut Bencher) {\n        let data = generate_data()\n        b.iter(|| quick_sort(data.clone()))\n    }\n    \n    #[bench]\n    fn merge_sort(b: &mut Bencher) {\n        let data = generate_data()\n        b.iter(|| merge_sort(data.clone()))\n    }\n    \n    #[bench]\n    fn heap_sort(b: &mut Bencher) {\n        let data = generate_data()\n        b.iter(|| heap_sort(data.clone()))\n    }\n}\n\n// Load testing\n#[load_test]\nasync fn test_api_under_load() {\n    let config = LoadTestConfig {\n        concurrent_users: 1000,\n        requests_per_user: 100,\n        ramp_up_time: Duration::from_secs(10)\n    }\n    \n    let results = load_test(config, |client| async {\n        client.get(\"/api/endpoint\").send().await\n    }).await\n    \n    assert!(results.median_response_time < Duration::from_millis(100))\n    assert!(results.p99_response_time < Duration::from_millis(500))\n    assert!(results.error_rate < 0.01)\n}\n\n// Profiling in tests\n#[test]\n#[profile]\nfn test_with_profiling() {\n    let profiler = CpuProfiler::start()\n    \n    expensive_operation()\n    \n    let report = profiler.report()\n    assert!(report.total_time < Duration::from_secs(1))\n    \n    // Generate flame graph\n    report.save_flamegraph(\"profile.svg\")\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected type\n"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 8,
          "line_number": 517,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Run tests with coverage\n$ ruchy test --coverage\n\n// Coverage report\n================================\nFile            Lines  Covered  %\nsrc/lib.rs      245    238     97.1%\nsrc/parser.rs   512    487     95.1%\nsrc/executor.rs 380    360     94.7%\n================================\nTotal           1137   1085    95.4%\n\n// Coverage annotations\n#[test]\nfn test_all_branches() {\n    // Tool shows which branches are not covered\n    if condition {      // ‚úì true branch covered\n        do_something()\n    } else {           // ‚úó false branch not covered\n        do_other()\n    }\n}\n\n// Exclude from coverage\n#[cfg(not(tarpaulin_include))]\nfn debug_function() {\n    // Not included in coverage metrics\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: EqualEqual\n"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 9,
          "line_number": 555,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Mutation testing finds gaps in tests\n$ ruchy mutate\n\n// Mutations that survived (tests didn't catch)\nsrc/calculator.rs:15\n- Original: x + y\n+ Mutation: x - y\nStatus: SURVIVED ‚ùå\n\n// Add test to catch mutation\n#[test]\nfn test_addition_not_subtraction() {\n    assert_ne!(add(5, 3), subtract(5, 3))\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: Colon\n"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 10,
          "line_number": 579,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Fuzz testing for security\n#[fuzz_test]\nfn fuzz_parser(data: &[u8]) {\n    // Fuzzer generates random inputs\n    if let Ok(s) = std::str::from_utf8(data) {\n        // Should never panic or crash\n        let _ = parse_input(s)\n    }\n}\n\n// Run fuzzer\n$ ruchy fuzz parser_fuzz\n=== Fuzzing parser_fuzz ===\nIterations: 1000000\nCrashes found: 0\nHangs found: 0\nCoverage: 95%\n\n// Targeted fuzzing\n#[fuzz_target]\nfn fuzz_api_endpoint(input: FuzzInput) {\n    let request = Request::from_fuzz(input)\n    let response = handle_request(request)\n    \n    // Properties that should hold\n    assert!(response.status() < 600)\n    assert!(response.body().len() < 10_000_000)\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected type\n"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 11,
          "line_number": 651,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// quality.ruchy - Quality gate script\nfn main() {\n    let mut passed = true\n    \n    // Test coverage gate\n    let coverage = run_coverage_analysis()\n    if coverage.percentage < 80.0 {\n        println(\"‚ùå Coverage too low: \" + coverage.percentage.to_s() + \"%\")\n        passed = false\n    }\n    \n    // Performance gate\n    let benchmarks = run_benchmarks()\n    for (name, result) in benchmarks {\n        if result.regression > 0.1 {  // 10% regression\n            println(\"‚ùå Performance regression in \" + name + \": \" + (result.regression * 100).to_s() + \"%\")\n            passed = false\n        }\n    }\n    \n    // Complexity gate\n    let complexity = analyze_complexity()\n    if complexity.max_cyclomatic > 10 {\n        println(\"‚ùå Complexity too high: \" + complexity.max_cyclomatic.to_s())\n        passed = false\n    }\n    \n    // Security gate\n    let vulnerabilities = security_scan()\n    if !vulnerabilities.is_empty() {\n        println(\"‚ùå Security vulnerabilities found: \" + vulnerabilities.len().to_s())\n        passed = false\n    }\n    \n    if !passed {\n        exit(1)\n    }\n    \n    println(\"‚úÖ All quality gates passed!\")\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected identifier after 'for'\n"
        }
      ]
    },
    "ch14-00-concurrency": {
      "chapter": "ch14-00-concurrency",
      "total_examples": 13,
      "working_examples": 1,
      "failing_examples": 12,
      "examples": [
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\nuse std::sync;\nuse std::async;\n\n// Parallel processing with channels\nfn process_files(files: Vec<String>) -> Vec<Result> {\n    let (sender, receiver) = channel()\n    \n    // Spawn worker for each file\n    for file in files {\n        let tx = sender.clone()\n        spawn {\n            let result = process_file(file)\n            tx.send((file, result))\n        }\n    }\n    \n    // Collect results\n    let results = Vec::new()\n    for _ in files.len() {\n        let (file, result) = receiver.recv()\n        results.push(result)\n    }\n    \n    return results\n}\n\n// Async/await for I/O\nasync fn fetch_all_data(urls: Vec<String>) -> Vec<Data> {\n    let futures = urls.map(|url| async {\n        let response = http::get(url).await?\n        parse_response(response)\n    })\n    \n    return join_all(futures).await\n}\n\n// Thread pool for CPU-bound work\nlet pool = ThreadPool::new(num_cpus())\nlet results = pool.parallel_map(items, |item| {\n    expensive_computation(item)\n})",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected identifier, '*', or '{' after '::'\n"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 2,
          "line_number": 87,
          "code": "// Status: ‚ùå BROKEN\n\n// Spawn a thread\nlet handle = spawn {\n    println(\"Running in parallel!\")\n    compute_result()\n}\n\n// Wait for thread to complete\nlet result = handle.join()\n\n// Spawn with move semantics\nlet data = vec![1, 2, 3]\nlet handle = spawn move {\n    let sum = data.sum()  // data moved into thread\n    println(\"Sum: \" + sum.to_s())\n}\n\n// Thread builder for configuration\nlet handle = Thread::builder()\n    .name(\"worker\")\n    .stack_size(4 * 1024 * 1024)\n    .spawn(|| {\n        heavy_computation()\n    })\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 3,
          "line_number": 123,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Create a channel\nlet (sender, receiver) = channel()\n\n// Multiple producers\nfor i in range(10) {\n    let tx = sender.clone()\n    spawn move {\n        let result = process(i)\n        tx.send(result)\n    }\n}\n\n// Single consumer\nspawn move {\n    while let Ok(result) = receiver.recv() {\n        println(\"Got: \" + result.to_s())\n    }\n}\n\n// Bounded channels for backpressure\nlet (tx, rx) = sync_channel(100)  // Buffer size 100\n\n// Select from multiple channels\nloop {\n    select! {\n        msg = rx1.recv() => {\n            process_message(msg)\n        }\n        data = rx2.recv() => {\n            process_data(data)\n        }\n        _ = timeout(1000) => {\n            println(\"Timeout!\")\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected identifier after 'let' or 'let mut'\n"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 4,
          "line_number": 171,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Mutex for mutual exclusion\nlet counter = Arc::new(Mutex::new(0))\n\nlet handles = Vec::new()\nfor _ in range(10) {\n    let counter = counter.clone()\n    handles.push(spawn move {\n        let mut num = counter.lock()\n        *num += 1\n    })\n}\n\nfor handle in handles {\n    handle.join()\n}\n\nprintln(\"Result: \" + (*counter.lock()).to_s())\n\n// RwLock for multiple readers\nlet data = Arc::new(RwLock::new(HashMap::new()))\n\n// Multiple readers\nlet data_clone = data.clone()\nspawn move {\n    let map = data_clone.read()  // Shared read access\n    println(\"Value: \" + map.get(\"key\").to_s())\n}\n\n// Single writer\nlet data_clone = data.clone()\nspawn move {\n    let mut map = data_clone.write()  // Exclusive write access\n    map.insert(\"key\", \"value\")\n}\n\n// Atomic operations for lock-free programming\nlet counter = Arc::new(AtomicI32::new(0))\ncounter.fetch_add(1, Ordering::SeqCst)",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected identifier after 'for'\n"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 5,
          "line_number": 221,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Async function\nasync fn fetch_user(id: i32) -> Result<User, Error> {\n    let response = http::get(\"/api/users/\" + id.to_s()).await?\n    let user = parse_json(response.body).await?\n    return Ok(user)\n}\n\n// Await multiple futures\nasync fn fetch_all_users(ids: Vec<i32>) -> Vec<User> {\n    let futures = ids.map(|id| fetch_user(id))\n    let results = join_all(futures).await\n    \n    return results\n        .filter_map(|r| r.ok())\n        .collect()\n}\n\n// Select first to complete\nasync fn fetch_with_timeout(url: String) -> Result<Data, Error> {\n    select! {\n        result = fetch_data(url) => result,\n        _ = sleep(5000) => Err(Error::Timeout)\n    }\n}\n\n// Async streams\nasync fn process_stream(stream: AsyncStream<Item>) {\n    while let Some(item) = stream.next().await {\n        process_item(item).await\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected type\n"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 6,
          "line_number": 266,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\nstruct ThreadPool {\n    workers: Vec<Worker>\n    sender: Sender<Job>\n}\n\nimpl ThreadPool {\n    fn new(size: usize) -> ThreadPool {\n        let (sender, receiver) = channel()\n        let receiver = Arc::new(Mutex::new(receiver))\n        \n        let workers = Vec::with_capacity(size)\n        for id in range(size) {\n            workers.push(Worker::new(id, receiver.clone()))\n        }\n        \n        ThreadPool { workers, sender }\n    }\n    \n    fn execute<F>(&self, f: F)\n    where F: FnOnce() + Send + 'static\n    {\n        self.sender.send(Box::new(f))\n    }\n    \n    fn parallel_map<T, R, F>(&self, items: Vec<T>, f: F) -> Vec<R>\n    where\n        F: Fn(T) -> R + Send + Clone + 'static,\n        T: Send + 'static,\n        R: Send + 'static\n    {\n        let (tx, rx) = channel()\n        \n        for item in items {\n            let tx = tx.clone()\n            let f = f.clone()\n            self.execute(move || {\n                let result = f(item)\n                tx.send(result)\n            })\n        }\n        \n        let results = Vec::new()\n        for _ in items.len() {\n            results.push(rx.recv())\n        }\n        \n        return results\n    }\n}\n\n// Use thread pool\nlet pool = ThreadPool::new(4)\n\nfor i in range(100) {\n    pool.execute(move || {\n        println(\"Task \" + i.to_s() + \" on thread \" + current_thread_id().to_s())\n        heavy_work()\n    })\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected RightBrace, found Identifier(\"sender\")\n"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 7,
          "line_number": 337,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\nfn producer_consumer_pipeline<T>() {\n    let (tx, rx) = channel()\n    \n    // Multiple producers\n    for i in range(4) {\n        let tx = tx.clone()\n        spawn move {\n            loop {\n                let work = generate_work(i)\n                if tx.send(work).is_err() {\n                    break  // Channel closed\n                }\n            }\n        }\n    }\n    \n    // Multiple consumers  \n    for i in range(2) {\n        let rx = rx.clone()\n        spawn move {\n            while let Ok(work) = rx.recv() {\n                process_work(work)\n            }\n        }\n    }\n}\n\n// With bounded queue for backpressure\nfn bounded_pipeline() {\n    let (tx, rx) = sync_channel(100)  // Max 100 items\n    \n    spawn move {\n        for item in generate_items() {\n            tx.send(item)  // Blocks if queue full\n        }\n    }\n    \n    spawn move {\n        while let Ok(item) = rx.recv() {\n            slow_process(item)\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected identifier after 'let' or 'let mut'\n"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 8,
          "line_number": 392,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\nfn parallel_merge_sort<T: Ord + Send>(mut items: Vec<T>) -> Vec<T> {\n    if items.len() <= 1 {\n        return items\n    }\n    \n    let mid = items.len() / 2\n    let right = items.split_off(mid)\n    \n    // Fork: sort halves in parallel\n    let (left_sorted, right_sorted) = join(\n        || parallel_merge_sort(items),\n        || parallel_merge_sort(right)\n    )\n    \n    // Join: merge sorted halves\n    return merge(left_sorted, right_sorted)\n}\n\n// Parallel reduce\nfn parallel_sum(numbers: Vec<i32>) -> i32 {\n    if numbers.len() <= 1000 {\n        return numbers.sum()  // Sequential for small inputs\n    }\n    \n    let chunk_size = numbers.len() / num_cpus()\n    let chunks = numbers.chunks(chunk_size)\n    \n    let sums = chunks\n        .parallel_map(|chunk| chunk.sum())\n        .collect()\n    \n    return sums.sum()\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected Greater, found Colon\n"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 9,
          "line_number": 437,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Actor trait\ntrait Actor {\n    type Message\n    \n    fn handle(&mut self, msg: Self::Message)\n}\n\n// Example actor\nstruct CounterActor {\n    count: i32\n}\n\nenum CounterMessage {\n    Increment\n    Decrement\n    Get(Sender<i32>)\n}\n\nimpl Actor for CounterActor {\n    type Message = CounterMessage\n    \n    fn handle(&mut self, msg: CounterMessage) {\n        match msg {\n            Increment => self.count += 1\n            Decrement => self.count -= 1\n            Get(reply) => reply.send(self.count)\n        }\n    }\n}\n\n// Actor system\nstruct ActorSystem {\n    actors: HashMap<String, Box<dyn Actor>>\n}\n\nimpl ActorSystem {\n    fn spawn<A: Actor>(&mut self, name: String, actor: A) -> ActorRef<A> {\n        let (tx, rx) = channel()\n        \n        spawn move {\n            let mut actor = actor\n            while let Ok(msg) = rx.recv() {\n                actor.handle(msg)\n            }\n        }\n        \n        ActorRef { name, sender: tx }\n    }\n}\n\n// Use actors\nlet system = ActorSystem::new()\nlet counter = system.spawn(\"counter\", CounterActor { count: 0 })\n\ncounter.send(Increment)\ncounter.send(Increment)\n\nlet (tx, rx) = channel()\ncounter.send(Get(tx))\nlet count = rx.recv()\nprintln(\"Count: \" + count.to_s())  // 2",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected 'fun' or 'fn' keyword\n"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 10,
          "line_number": 512,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\nasync fn web_server() {\n    let listener = TcpListener::bind(\"0.0.0.0:8080\").await\n    \n    loop {\n        let (socket, addr) = listener.accept().await\n        \n        // Handle each connection concurrently\n        spawn async {\n            handle_connection(socket, addr).await\n        }\n    }\n}\n\nasync fn handle_connection(socket: TcpStream, addr: SocketAddr) {\n    let (reader, writer) = socket.split()\n    \n    let request = read_http_request(reader).await\n    let response = route_request(request).await\n    \n    write_http_response(writer, response).await\n}\n\n// Connection pool for database\nlet db_pool = ConnectionPool::new(20)\n\nasync fn handle_request(req: Request) -> Response {\n    let conn = db_pool.get().await\n    \n    let data = conn.query(\"SELECT * FROM users\").await\n    \n    db_pool.return(conn)\n    \n    Response::json(data)\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected identifier after 'let' or 'let mut'\n"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 11,
          "line_number": 558,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\nfn process_dataset(data: Vec<Record>) -> Vec<Result> {\n    // Partition data for parallel processing\n    let chunk_size = data.len() / num_cpus()\n    let chunks = data.chunks(chunk_size)\n    \n    // Process chunks in parallel\n    let handles = chunks.map(|chunk| {\n        spawn move {\n            chunk.iter()\n                .map(|record| process_record(record))\n                .collect()\n        }\n    })\n    \n    // Collect results\n    let mut results = Vec::new()\n    for handle in handles {\n        results.extend(handle.join())\n    }\n    \n    return results\n}\n\n// Pipeline with stages\nfn parallel_pipeline(input: Stream<Data>) -> Stream<Output> {\n    input\n        .parallel_map(stage1, workers: 4)\n        .parallel_filter(stage2, workers: 2)\n        .parallel_flat_map(stage3, workers: 4)\n        .collect()\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected type\n"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 12,
          "line_number": 601,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n#[test]\nfn test_concurrent_access() {\n    let shared = Arc::new(Mutex::new(Vec::new()))\n    let handles = Vec::new()\n    \n    // Spawn concurrent writers\n    for i in range(100) {\n        let shared = shared.clone()\n        handles.push(spawn move {\n            let mut vec = shared.lock()\n            vec.push(i)\n        })\n    }\n    \n    // Wait for completion\n    for handle in handles {\n        handle.join()\n    }\n    \n    // Verify all writes succeeded\n    let vec = shared.lock()\n    assert_eq!(vec.len(), 100)\n}\n\n#[test]\nasync fn test_async_operations() {\n    let results = join_all(vec![\n        async_operation(1),\n        async_operation(2),\n        async_operation(3)\n    ]).await\n    \n    assert!(results.all(|r| r.is_ok()))\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected RightParen, found Identifier(\"move\")\n"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 13,
          "line_number": 645,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// 1. Choose the right abstraction\n// Threads: OS parallelism, CPU-bound work\n// Async: I/O-bound work, many concurrent tasks\n// Channels: Decoupled communication\n// Shared state: When necessary, with proper synchronization\n\n// 2. Avoid contention\nlet shards = (0..16).map(|_| Mutex::new(HashMap::new()))\nfn get_shard(key: &str) -> &Mutex<HashMap> {\n    let hash = hash(key)\n    return &shards[hash % 16]\n}\n\n// 3. Use work stealing\nlet queue = WorkStealingQueue::new()\n// Threads steal work from other threads when idle\n\n// 4. Batch operations\ninstead_of {\n    for item in items {\n        channel.send(item)  // Many small sends\n    }\n}\n\ndo {\n    channel.send(items)  // One batch send\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected '|' after lambda parameters\n"
        }
      ]
    },
    "ch04-00-command-line-tools": {
      "chapter": "ch04-00-command-line-tools",
      "total_examples": 14,
      "working_examples": 14,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ‚ùå BROKEN\n\n// File: word_counter.ruchy\n// Simple word counter tool\n\n// Get filename from user\nprintln(\"Word Counter Tool\")\nprint(\"Enter filename: \")\nlet filename = input()\n\n// Read and process file\nlet content = read_file(filename)\nlet words = content.split_whitespace()\nlet word_count = words.len()\nlet char_count = content.len()\nlet line_count = content.lines().len()\n\n// Display results\nprintln(\"\\nFile Analysis: \" + filename)\nprintln(\"Characters: \" + char_count.to_s())\nprintln(\"Words: \" + word_count.to_s())  \nprintln(\"Lines: \" + line_count.to_s())\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 2,
          "line_number": 78,
          "code": "// Status: ‚ùå BROKEN\n\nlet name = input(\"What's your name? \")\nlet age = input(\"How old are you? \").to_i()\nlet is_student = input(\"Are you a student? (y/n) \") == \"y\"\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 3,
          "line_number": 93,
          "code": "// Status: ‚ùå BROKEN\n\n// Reading files\nlet content = read_file(\"data.txt\")\nlet lines = read_lines(\"data.txt\")\n\n// Writing files\nwrite_file(\"output.txt\", \"Hello, World!\")\nappend_file(\"log.txt\", \"New entry: \" + timestamp())\n\n// File information\nlet exists = file_exists(\"config.txt\")\nlet size = file_size(\"data.txt\")\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 4,
          "line_number": 116,
          "code": "// Status: ‚ùå BROKEN\n\n// Usage: ruchy run script.ruchy file1.txt file2.txt\nlet args = command_args()\nlet program_name = args[0]\nlet first_file = args[1]\nlet second_file = args[2]\n\nprintln(\"Processing: \" + first_file + \" and \" + second_file)\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 5,
          "line_number": 136,
          "code": "// Status: ‚ùå BROKEN\n\n// File: text_processor.ruchy\n// Processes text files with various operations\n\nprintln(\"=== Text Processor ===\")\nlet filename = input(\"Enter filename: \")\n\nif !file_exists(filename) {\n    println(\"Error: File '\" + filename + \"' not found!\")\n    exit(1)\n}\n\nlet content = read_file(filename)\nlet lines = content.lines()\n\nprintln(\"\\nChoose operation:\")\nprintln(\"1. Count lines\")\nprintln(\"2. Find and replace\")\nprintln(\"3. Convert to uppercase\") \nprintln(\"4. Remove empty lines\")\n\nlet choice = input(\"Enter choice (1-4): \").to_i()\n\nmatch choice {\n    1 => {\n        println(\"Total lines: \" + lines.len().to_s())\n    }\n    2 => {\n        let find = input(\"Find: \")\n        let replace = input(\"Replace with: \")\n        let new_content = content.replace(find, replace)\n        let output_file = filename.replace(\".txt\", \"_modified.txt\")\n        write_file(output_file, new_content)\n        println(\"Saved to: \" + output_file)\n    }\n    3 => {\n        let upper_content = content.to_uppercase()\n        let output_file = filename.replace(\".txt\", \"_upper.txt\")\n        write_file(output_file, upper_content)\n        println(\"Saved to: \" + output_file)\n    }\n    4 => {\n        let clean_lines = lines.filter(|line| !line.trim().is_empty())\n        let clean_content = clean_lines.join(\"\\n\")\n        let output_file = filename.replace(\".txt\", \"_clean.txt\")\n        write_file(output_file, clean_content)\n        println(\"Saved to: \" + output_file)\n    }\n    _ => {\n        println(\"Invalid choice!\")\n    }\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 6,
          "line_number": 198,
          "code": "// Status: ‚ùå BROKEN\n\n// File: log_analyzer.ruchy\n// Analyzes server log files\n\nprintln(\"=== Log Analyzer ===\")\nlet log_file = input(\"Enter log file path: \")\n\nlet lines = read_lines(log_file)\nlet total_requests = lines.len()\n\n// Count different status codes\nlet success_count = 0\nlet error_count = 0\nlet not_found_count = 0\n\nfor line in lines {\n    if line.contains(\" 200 \") {\n        success_count += 1\n    } else if line.contains(\" 404 \") {\n        not_found_count += 1\n    } else if line.contains(\" 500 \") {\n        error_count += 1\n    }\n}\n\n// Calculate percentages\nlet success_percent = (success_count * 100) / total_requests\nlet error_percent = (error_count * 100) / total_requests\nlet not_found_percent = (not_found_count * 100) / total_requests\n\nprintln(\"\\n=== Analysis Results ===\")\nprintln(\"Total Requests: \" + total_requests.to_s())\nprintln(\"Success (200): \" + success_count.to_s() + \" (\" + success_percent.to_s() + \"%)\")\nprintln(\"Not Found (404): \" + not_found_count.to_s() + \" (\" + not_found_percent.to_s() + \"%)\")\nprintln(\"Server Error (500): \" + error_count.to_s() + \" (\" + error_percent.to_s() + \"%)\")\n\n// Find busiest hour\nlet hour_counts = {}\nfor line in lines {\n    let timestamp = extract_hour(line)  // Custom function\n    hour_counts[timestamp] = hour_counts.get(timestamp, 0) + 1\n}\n\nlet busiest_hour = hour_counts.max_by_value().key\nprintln(\"Busiest Hour: \" + busiest_hour.to_s() + \":00\")\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 7,
          "line_number": 253,
          "code": "// Status: ‚ùå BROKEN\n\n// File: batch_renamer.ruchy  \n// Renames multiple files with patterns\n\nprintln(\"=== Batch File Renamer ===\")\nlet directory = input(\"Enter directory path: \")\nlet pattern = input(\"Enter pattern to find: \")\nlet replacement = input(\"Enter replacement: \")\n\nlet files = list_files(directory)\nlet renamed_count = 0\n\nfor file in files {\n    if file.contains(pattern) {\n        let new_name = file.replace(pattern, replacement)\n        let old_path = join_path(directory, file)\n        let new_path = join_path(directory, new_name)\n        \n        if rename_file(old_path, new_path) {\n            println(\"Renamed: \" + file + \" -> \" + new_name)\n            renamed_count += 1\n        } else {\n            println(\"Failed to rename: \" + file)\n        }\n    }\n}\n\nprintln(\"\\nRenamed \" + renamed_count.to_s() + \" files\")\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 8,
          "line_number": 293,
          "code": "// Status: ‚ùå BROKEN\n\n// Robust file processor with error handling\n\nfn process_file(filename) {\n    // Check if file exists\n    if !file_exists(filename) {\n        println(\"‚ùå Error: File '\" + filename + \"' does not exist\")\n        return false\n    }\n    \n    // Check if file is readable\n    if !file_readable(filename) {\n        println(\"‚ùå Error: Cannot read file '\" + filename + \"' (permission denied?)\")\n        return false\n    }\n    \n    // Try to read file\n    let content = try {\n        read_file(filename)\n    } catch error {\n        println(\"‚ùå Error reading file: \" + error.to_s())\n        return false\n    }\n    \n    // Process content\n    let word_count = content.split_whitespace().len()\n    println(\"‚úÖ File processed: \" + word_count.to_s() + \" words\")\n    return true\n}\n\n// Main program\nlet filename = input(\"Enter filename: \")\nif process_file(filename) {\n    println(\"Processing completed successfully!\")\n} else {\n    println(\"Processing failed!\")\n    exit(1)\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 9,
          "line_number": 343,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Good CLI tool practices\n\nfn show_help() {\n    println(\"File Statistics Tool v1.0\")\n    println(\"\")\n    println(\"Usage:\")\n    println(\"  ruchy run file_stats.ruchy <filename>\")\n    println(\"\")\n    println(\"Examples:\")\n    println(\"  ruchy run file_stats.ruchy document.txt\")\n    println(\"  ruchy run file_stats.ruchy data/*.csv\")\n    println(\"\")\n    println(\"Options:\")\n    println(\"  --help     Show this help message\")\n    println(\"  --verbose  Show detailed output\")\n}\n\nfn process_with_progress(files) {\n    let total = files.len()\n    let mut i = 0\n    \n    while i < total {\n        let file = files[i]\n        let progress = ((i + 1) * 100) / total\n        print(\"\\rProcessing... [\" + progress.to_s() + \"%] \" + file)\n        \n        // Do the actual work\n        process_file(file)\n        \n        // Small delay to show progress\n        sleep(100)  // 100ms\n        i = i + 1\n    }\n    \n    println(\"\\n‚úÖ All files processed!\")\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 10,
          "line_number": 395,
          "code": "// Status: ‚ùå BROKEN\n// Example: Manual line counting implementation\n\nfun main() {\n    // Sample file content for demonstration\n    let content = \"line 1\\nline 2\\nline 3\";\n    \n    // Manual line counting implementation\n    let mut lines = 1;\n    let mut i = 0;\n    while i < content.len() {\n        if content[i] == '\\n' {\n            lines = lines + 1;\n        }\n        i = i + 1;\n    }\n    \n    println(\"File has\", lines, \"lines\");\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 11,
          "line_number": 494,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// task_manager.ruchy - A simple but useful task management tool\n\nlet TASK_FILE = \"tasks.txt\"\n\nfn show_menu() {\n    println(\"\\n=== Task Manager ===\")\n    println(\"1. List tasks\")\n    println(\"2. Add task\")\n    println(\"3. Complete task\")\n    println(\"4. Delete task\")\n    println(\"5. Quit\")\n}\n\nfn load_tasks() {\n    if file_exists(TASK_FILE) {\n        return read_lines(TASK_FILE)\n    }\n    return []\n}\n\nfn save_tasks(tasks) {\n    let content = tasks.join(\"\\n\")\n    write_file(TASK_FILE, content)\n}\n\nfn list_tasks(tasks) {\n    if tasks.is_empty() {\n        println(\"\\nüìù No tasks yet!\")\n        return\n    }\n    \n    println(\"\\nüìã Your Tasks (\" + tasks.len().to_s() + \" items):\")\n    let mut i = 0\n    while i < tasks.len() {\n        let task = tasks[i]\n        let status = if task.starts_with(\"‚úÖ\") { \"DONE\" } else { \"PENDING\" }\n        println((i + 1).to_s() + \". \" + task)\n        i = i + 1\n    }\n}\n\nfn add_task(tasks) {\n    let new_task = input(\"\\nWhat do you want to add? \")\n    tasks.push(\"üìå \" + new_task)\n    save_tasks(tasks)\n    println(\"‚úÖ Task added!\")\n}\n\nfn complete_task(tasks) {\n    list_tasks(tasks)\n    let index = input(\"\\nWhich task to complete? (number): \").to_i() - 1\n    \n    if index >= 0 && index < tasks.len() {\n        tasks[index] = tasks[index].replace(\"üìå\", \"‚úÖ\")\n        save_tasks(tasks)\n        println(\"üéâ Task completed!\")\n    } else {\n        println(\"‚ùå Invalid task number\")\n    }\n}\n\n// Main program loop\nlet tasks = load_tasks()\n\nloop {\n    show_menu()\n    let choice = input(\"\\nChoose option: \")\n    \n    match choice {\n        \"1\" => list_tasks(tasks)\n        \"2\" => add_task(tasks)\n        \"3\" => complete_task(tasks)\n        \"4\" => {\n            list_tasks(tasks)\n            let index = input(\"Which task to delete? (number): \").to_i() - 1\n            if index >= 0 && index < tasks.len() {\n                tasks.remove(index)\n                save_tasks(tasks)\n                println(\"üóëÔ∏è  Task deleted!\")\n            }\n        }\n        \"5\" => {\n            println(\"üëã Goodbye!\")\n            break\n        }\n        _ => println(\"‚ùå Invalid choice\")\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 12,
          "line_number": 611,
          "code": "// Status: ‚ùå BROKEN\n// ‚ùå This demonstrates what NOT to do - no error handling\n\nfun main() {\n    // Example of code that would fail without proper error checking\n    println(\"Example: Unsafe file operations\");\n    println(\"This pattern would crash if file doesn't exist:\");\n    println(\"// let content = read_file(\\\"missing.txt\\\");\");\n    \n    // Better approach would include error checking\n    println(\"Always check if operations can fail before using them\");\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 13,
          "line_number": 630,
          "code": "// Status: ‚ùå BROKEN\n\n// ‚ùå Confusing and unhelpful\nprintln(\"Enter thing:\")\nlet thing = input()\n// What thing? What format?\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 14,
          "line_number": 644,
          "code": "// Status: ‚ùå BROKEN\n\n// ‚ùå Only works on your computer\nlet data = read_file(\"/Users/noah/Desktop/data.txt\")\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch12-00-traits-generics": {
      "chapter": "ch12-00-traits-generics",
      "total_examples": 11,
      "working_examples": 0,
      "failing_examples": 11,
      "examples": [
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Define behavior with traits\ntrait Serializable {\n    fn serialize(self) -> String\n    fn deserialize(String) -> Self\n}\n\n// Generic function works with any Serializable type\nfn save_to_file<T: Serializable>(item: T, path: String) {\n    let serialized = item.serialize()\n    write_file(path, serialized)\n}\n\nfn load_from_file<T: Serializable>(path: String) -> T {\n    let content = read_file(path)\n    return T::deserialize(content)\n}\n\n// Implement trait for your types\nstruct User {\n    name: String\n    email: String\n    age: i32\n}\n\nimpl Serializable for User {\n    fn serialize(self) -> String {\n        return to_json(self)\n    }\n    \n    fn deserialize(data: String) -> User {\n        return parse_json(data)\n    }\n}\n\n// Now it just works!\nlet user = User{name: \"Alice\", email: \"alice@example.com\", age: 30}\nsave_to_file(user, \"user.json\")  // Generic function, specific type\nlet loaded: User = load_from_file(\"user.json\")  // Type safe!",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected Greater, found Colon\n"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 2,
          "line_number": 84,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Simple trait\ntrait Drawable {\n    fn draw(self)\n}\n\n// Trait with multiple methods\ntrait Container {\n    fn len(self) -> i32\n    fn is_empty(self) -> bool {\n        return self.len() == 0  // Default implementation\n    }\n    fn clear(mut self)\n}\n\n// Traits with associated types\ntrait Iterator {\n    type Item\n    \n    fn next(mut self) -> Option<Item>\n    \n    fn collect(mut self) -> Vec<Item> {\n        let result = Vec::new()\n        while let Some(item) = self.next() {\n            result.push(item)\n        }\n        return result\n    }\n}\n\n// Traits with constraints\ntrait Comparable: Eq {\n    fn compare(self, other: Self) -> Ordering\n}\n\n// Trait inheritance\ntrait Animal {\n    fn speak(self)\n}\n\ntrait Dog: Animal {\n    fn wag_tail(self)\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected 'fun' or 'fn' keyword\n"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 3,
          "line_number": 138,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\nstruct Point {\n    x: f64\n    y: f64\n}\n\nimpl Drawable for Point {\n    fn draw(self) {\n        println(\"Point at (\" + self.x.to_s() + \", \" + self.y.to_s() + \")\")\n    }\n}\n\nstruct Circle {\n    center: Point\n    radius: f64\n}\n\nimpl Drawable for Circle {\n    fn draw(self) {\n        println(\"Circle at (\" + self.center.x.to_s() + \", \" + self.center.y.to_s() + \") with radius \" + self.radius.to_s())\n    }\n}\n\n// Now both types can be drawn\nlet p = Point{x: 10, y: 20}\nlet c = Circle{center: p, radius: 5}\n\np.draw()  // Trait method\nc.draw()  // Same interface, different implementation\n\n// Implement traits for existing types\nimpl Drawable for String {\n    fn draw(self) {\n        println(\"Text: \" + self)\n    }\n}\n\n\"Hello\".draw()  // Extension methods!",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected RightBrace, found Identifier(\"y\")\n"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 4,
          "line_number": 187,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Simple generic function\nfn swap<T>(a: mut T, b: mut T) {\n    let temp = a\n    a = b\n    b = temp\n}\n\n// Multiple type parameters\nfn pair<K, V>(key: K, value: V) -> (K, V) {\n    return (key, value)\n}\n\n// Trait bounds\nfn print_all<T: Display>(items: Vec<T>) {\n    for item in items {\n        println(item)  // Works because T implements Display\n    }\n}\n\n// Multiple bounds\nfn process<T: Clone + Debug + Send>(item: T) {\n    let copy = item.clone()\n    debug(copy)\n    send_to_thread(item)\n}\n\n// Where clauses for complex bounds\nfn complex_function<T, U>(x: T, y: U) -> Vec<T>\nwhere\n    T: Clone + From<U>,\n    U: Display + Into<String>\n{\n    let converted: T = T::from(y)\n    return vec![x.clone(), converted]\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected type\n"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 5,
          "line_number": 234,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Generic struct\nstruct Pair<T> {\n    first: T\n    second: T\n}\n\nimpl<T> Pair<T> {\n    fn new(first: T, second: T) -> Pair<T> {\n        return Pair{first, second}\n    }\n    \n    fn swap(mut self) {\n        let temp = self.first\n        self.first = self.second\n        self.second = temp\n    }\n}\n\n// Generic enum\nenum Option<T> {\n    Some(T)\n    None\n}\n\nenum Result<T, E> {\n    Ok(T)\n    Err(E)\n}\n\n// Generic with constraints\nstruct SortedVec<T: Ord> {\n    items: Vec<T>\n}\n\nimpl<T: Ord> SortedVec<T> {\n    fn insert(mut self, item: T) {\n        let pos = self.items.binary_search(item)\n        self.items.insert(pos, item)\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected RightBrace, found Identifier(\"second\")\n"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 6,
          "line_number": 286,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Custom collection with traits\nstruct Cache<K: Hash + Eq, V> {\n    map: HashMap<K, V>\n    max_size: usize\n    access_order: Vec<K>\n}\n\nimpl<K: Hash + Eq + Clone, V: Clone> Cache<K, V> {\n    fn new(max_size: usize) -> Cache<K, V> {\n        return Cache{\n            map: HashMap::new(),\n            max_size,\n            access_order: Vec::new()\n        }\n    }\n    \n    fn get(mut self, key: K) -> Option<V> {\n        if let Some(value) = self.map.get(key) {\n            // Update access order\n            self.access_order.retain(|k| k != key)\n            self.access_order.push(key.clone())\n            return Some(value.clone())\n        }\n        return None\n    }\n    \n    fn put(mut self, key: K, value: V) {\n        if self.map.len() >= self.max_size && !self.map.contains_key(key) {\n            // Evict least recently used\n            let lru = self.access_order.remove(0)\n            self.map.remove(lru)\n        }\n        \n        self.map.insert(key.clone(), value)\n        self.access_order.push(key)\n    }\n}\n\n// Use with any hashable types\nlet cache: Cache<String, User> = Cache::new(100)\ncache.put(\"alice\", alice_user)\n\nlet cache2: Cache<i32, Vec<String>> = Cache::new(50)\ncache2.put(1, vec![\"data\"])",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected Greater, found Colon\n"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 7,
          "line_number": 342,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Trait for plugins\ntrait Plugin {\n    fn name(self) -> String\n    fn execute(self, context: Context) -> Result<(), Error>\n}\n\nstruct LogPlugin {\n    level: String\n}\n\nimpl Plugin for LogPlugin {\n    fn name(self) -> String {\n        return \"Logger\"\n    }\n    \n    fn execute(self, context: Context) -> Result<(), Error> {\n        log(self.level, context.message)\n        return Ok(())\n    }\n}\n\n// Store different plugin types\nlet plugins: Vec<Box<dyn Plugin>> = vec![\n    Box::new(LogPlugin{level: \"INFO\"}),\n    Box::new(MetricsPlugin{...}),\n    Box::new(CachePlugin{...})\n]\n\n// Execute all plugins\nfor plugin in plugins {\n    plugin.execute(context)?\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected type\n"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 8,
          "line_number": 384,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Generic builder\nstruct Builder<T> {\n    value: T\n}\n\nimpl<T> Builder<T> {\n    fn new(initial: T) -> Builder<T> {\n        return Builder{value: initial}\n    }\n    \n    fn with<F>(mut self, f: F) -> Builder<T>\n    where F: FnOnce(mut T) -> T\n    {\n        self.value = f(self.value)\n        return self\n    }\n    \n    fn build(self) -> T {\n        return self.value\n    }\n}\n\n// Use with any type\nlet config = Builder::new(Config::default())\n    .with(|c| { c.port = 8080; c })\n    .with(|c| { c.host = \"localhost\"; c })\n    .with(|c| { c.workers = 4; c })\n    .build()\n\nlet user = Builder::new(User::new())\n    .with(|u| { u.name = \"Alice\"; u })\n    .with(|u| { u.role = Role::Admin; u })\n    .build()",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected LeftBrace, found Less\n"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 9,
          "line_number": 427,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Associated types pattern\ntrait Graph {\n    type Node\n    type Edge\n    \n    fn nodes(self) -> Vec<Node>\n    fn edges(self) -> Vec<Edge>\n    fn neighbors(self, node: Node) -> Vec<Node>\n}\n\nstruct SocialNetwork {\n    users: Vec<User>\n    connections: Vec<Friendship>\n}\n\nimpl Graph for SocialNetwork {\n    type Node = User\n    type Edge = Friendship\n    \n    fn nodes(self) -> Vec<User> {\n        return self.users\n    }\n    \n    fn edges(self) -> Vec<Friendship> {\n        return self.connections\n    }\n    \n    fn neighbors(self, user: User) -> Vec<User> {\n        self.connections\n            .filter(|f| f.from == user.id || f.to == user.id)\n            .map(|f| self.get_user(f.other_id(user.id)))\n            .collect()\n    }\n}\n\n// Phantom types for compile-time guarantees\nstruct Id<T> {\n    value: String\n    _phantom: PhantomData<T>\n}\n\nimpl<T> Id<T> {\n    fn new(value: String) -> Id<T> {\n        return Id{value, _phantom: PhantomData}\n    }\n}\n\n// Type-safe IDs\nlet user_id: Id<User> = Id::new(\"user_123\")\nlet post_id: Id<Post> = Id::new(\"post_456\")\n\n// Won't compile - type safety!\n// let wrong = user_id == post_id",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected 'fun' or 'fn' keyword\n"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 10,
          "line_number": 492,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Generics are monomorphized - no runtime cost\nfn generic_add<T: Add>(a: T, b: T) -> T {\n    return a + b  // Compiles to specific add instruction\n}\n\n// This generates two functions at compile time:\nlet int_result = generic_add(5, 10)      // Generates add_i32\nlet float_result = generic_add(5.0, 10.0) // Generates add_f64\n\n// Trait bounds are checked at compile time\nfn process<T: Send + Sync>(item: T) {\n    // Can safely send to another thread\n    spawn(|| {\n        use_item(item)\n    })\n}\n\n// Inline hints for performance\n#[inline]\nfn hot_path<T: Copy>(x: T) -> T {\n    return x  // Will be inlined\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected Greater, found Colon\n"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 11,
          "line_number": 524,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Static dispatch (faster)\nfn static_dispatch<T: Display>(item: T) {\n    println(item)  // Direct call, no indirection\n}\n\n// Dynamic dispatch (flexible)\nfn dynamic_dispatch(item: Box<dyn Display>) {\n    println(item)  // Virtual call through vtable\n}\n\n// Choose based on needs:\n// - Static: Known types, performance critical\n// - Dynamic: Plugin systems, heterogeneous collections",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected Greater, found Colon\n"
        }
      ]
    },
    "appendix-c-troubleshooting": {
      "chapter": "appendix-c-troubleshooting",
      "total_examples": 20,
      "working_examples": 8,
      "failing_examples": 12,
      "examples": [
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 1,
          "line_number": 25,
          "code": "// Status: ‚ùå BROKEN\n\n// ‚ùå Error\nlet x = 42\nlet y = 24\n\n// ‚úÖ Fixed\nlet x = 42;\nlet y = 24;\n\n// Note: Semicolons needed for statements, not expressions\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 2,
          "line_number": 44,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// ‚ùå Error\nif condition {\n    do_something()\n// Missing closing brace\n\n// ‚úÖ Fixed  \nif condition {\n    do_something()\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected end of input\n"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 3,
          "line_number": 62,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// ‚ùå Error\nlet 123invalid = \"nope\"\nlet my-var = \"no hyphens\"\nlet fn = \"keyword\"\n\n// ‚úÖ Fixed\nlet invalid_123 = \"ok\"\nlet my_var = \"underscores ok\"\nlet function_name = \"not keyword\"",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected identifier after 'let' or 'let mut'\n"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 4,
          "line_number": 82,
          "code": "// Status: ‚ùå BROKEN\n\n// ‚ùå Error\nlet x: i32 = \"string\"\n\n\n\n// ‚úÖ Fixed\nlet x: i32 = 42\n// or\nlet x = \"string\"  // Let compiler infer type\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 5,
          "line_number": 101,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// ‚ùå Error\nlet s = String::from(\"hello\")\nlet r = &s\nlet moved = *r  // Cannot move out of borrowed content\n\n// ‚úÖ Fixed\nlet s = String::from(\"hello\")\nlet r = &s\nlet copied = r.clone()  // Clone instead of move",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: Star\n"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 6,
          "line_number": 119,
          "code": "// Status: ‚ùå BROKEN\n\n// ‚ùå Error\nlet s = String::from(\"hello\")\ntakes_ownership(s)\nprintln(s)  \n\n// ‚úÖ Fixed - Option 1: Clone\nlet s = String::from(\"hello\")\ntakes_ownership(s.clone())\nprintln(s)  // s still valid\n\n// ‚úÖ Fixed - Option 2: Borrow\nlet s = String::from(\"hello\")\nborrows_value(&s)\nprintln(s)  // s still valid\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 7,
          "line_number": 145,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// ‚ùå Error\nfn dangle() -> &String {\n    let s = String::from(\"hello\")\n    &s  // s goes out of scope\n}\n\n// ‚úÖ Fixed - Return owned value\nfn not_dangle() -> String {\n    let s = String::from(\"hello\")\n    s  // Move ownership\n}\n\n// ‚úÖ Fixed - Use static lifetime\nfn static_str() -> &'static str {\n    \"hello\"  // String literals have static lifetime\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected type\n"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 8,
          "line_number": 170,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// ‚ùå Error\nlet mut s = String::from(\"hello\")\nlet r1 = &mut s\nlet r2 = &mut s  // Error: Requires run access to \"ruchy\", run again with the --allow-run flag\nprintln(r1)\nprintln(r2)\n\n// ‚úÖ Fixed - Use references sequentially\nlet mut s = String::from(\"hello\")\n{\n    let r1 = &mut s\n    // r1 scope ends here\n}\nlet r2 = &mut s  // Now ok",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: Mut\n"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 9,
          "line_number": 197,
          "code": "// Status: ‚ùå BROKEN\n\n// ‚ùå Runtime panic\nlet v = vec![1, 2, 3]\nlet item = v[5]  // Panic: index out of bounds\n\n// ‚úÖ Safe access\nlet v = vec![1, 2, 3]\nmatch v.get(5) {\n    Some(item) => println(\"Item: {}\", item),\n    None => println(\"Index out of bounds\"),\n}\n\n// ‚úÖ Or use safe indexing\nif let Some(item) = v.get(5) {\n    println(\"Item: {}\", item)\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 10,
          "line_number": 222,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// ‚ùå Runtime panic\nlet maybe_value: Option<i32> = None\nlet value = maybe_value.unwrap()  // Panic: called unwrap on None\n\n// ‚úÖ Safe handling\nlet maybe_value: Option<i32> = None\nmatch maybe_value {\n    Some(value) => println(\"Value: {}\", value),\n    None => println(\"No value\"),\n}\n\n// ‚úÖ Or provide default\nlet value = maybe_value.unwrap_or(0)",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected type\n"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 11,
          "line_number": 244,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// ‚ùå Runtime panic\nfn divide(a: i32, b: i32) -> i32 {\n    a / b  // Panic if b is 0\n}\n\n// ‚úÖ Safe division\nfn safe_divide(a: i32, b: i32) -> Option<i32> {\n    if b != 0 {\n        Some(a / b)\n    } else {\n        None\n    }\n}\n\n// ‚úÖ Or return Result\nfn divide_result(a: i32, b: i32) -> Result<i32, String> {\n    if b != 0 {\n        Ok(a / b)\n    } else {\n        Err(\"Division by zero\".to_string())\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected type\n"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 12,
          "line_number": 277,
          "code": "// Status: ‚ùå BROKEN\n\n// ‚ùå Infinite recursion causes stack overflow\nfn infinite_recursion(n: i32) -> i32 {\n    infinite_recursion(n + 1)  // No base case\n}\n\n// ‚úÖ Proper recursion with base case\nfn factorial(n: i32) -> i32 {\n    if n <= 1 {\n        1  // Base case\n    } else {\n        n * factorial(n - 1)\n    }\n}\n\n// ‚úÖ Or use iteration\nfn factorial_iterative(n: i32) -> i32 {\n    let mut result = 1\n    for i in 1..=n {\n        result *= i\n    }\n    result\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 13,
          "line_number": 309,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// ‚ùå May cause stack overflow\nfn large_array() {\n    let big_array: [i32; 1_000_000] = [0; 1_000_000]  // 4MB on stack\n}\n\n// ‚úÖ Use heap allocation\nfn large_vector() {\n    let big_vector: Vec<i32> = vec![0; 1_000_000]  // Allocated on heap\n}\n\n// ‚úÖ Or use Box for single large items\nfn boxed_array() {\n    let big_array: Box<[i32; 1_000_000]> = Box::new([0; 1_000_000])\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected RightBracket, found Semicolon\n"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 14,
          "line_number": 334,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// ‚ùå Inefficient - unnecessary clones\nfn process_strings(strings: Vec<String>) -> Vec<String> {\n    strings.iter()\n        .map(|s| s.clone().to_uppercase())  // Unnecessary clone\n        .collect()\n}\n\n// ‚úÖ More efficient - work with references\nfn process_strings_efficient(strings: &[String]) -> Vec<String> {\n    strings.iter()\n        .map(|s| s.to_uppercase())  // to_uppercase() works on &str\n        .collect()\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected type\n"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 15,
          "line_number": 356,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// ‚ùå Inefficient - creates many temporary strings\nfn concat_inefficient(strings: &[&str]) -> String {\n    let mut result = String::new()\n    for s in strings {\n        result = result + s  // Creates new string each time\n    }\n    result\n}\n\n// ‚úÖ Efficient - reuses buffer\nfn concat_efficient(strings: &[&str]) -> String {\n    let mut result = String::new()\n    for s in strings {\n        result.push_str(s)  // Appends to existing string\n    }\n    result\n}\n\n// ‚úÖ Even better - pre-allocate capacity\nfn concat_with_capacity(strings: &[&str]) -> String {\n    let total_len: usize = strings.iter().map(|s| s.len()).sum()\n    let mut result = String::with_capacity(total_len)\n    for s in strings {\n        result.push_str(s)\n    }\n    result\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected type\n"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 16,
          "line_number": 392,
          "code": "// Status: ‚ùå BROKEN\n\n// ‚ùå Wrong collection for use case\nuse std::collections::VecDeque\n\nlet mut list = Vec::new()\n// Frequent insertions at beginning - O(n) for each insert\nfor i in 0..1000 {\n    list.insert(0, i)\n}\n\n// ‚úÖ Better collection choice\nlet mut deque = VecDeque::new()\n// Efficient insertion at front - O(1)\nfor i in 0..1000 {\n    deque.push_front(i)\n}\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 17,
          "line_number": 432,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// ‚ùå Error: no method named `json` found for type `Response`\nlet response = reqwest::get(url).await?\nlet data = response.json().await?  // Feature not enabled\n\n// ‚úÖ Enable required features in Cargo.toml\n// [dependencies]\n// reqwest = { version = \"0.11\", features = [\"json\"] }",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: Question\n"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 18,
          "line_number": 551,
          "code": "// Status: ‚ùå BROKEN\n\n// Simple debug prints\nprintln!(\"Debug: x = {}\", x)\nprintln!(\"Debug: {:?}\", complex_struct)  // Debug formatting\nprintln!(\"Debug: {:#?}\", nested_struct)  // Pretty debug formatting\n\n// Conditional debug prints\n#[cfg(debug_assertions)]\nprintln!(\"This only prints in debug builds\")\n\n// Debug macro\ndebug!(\"Variable state: x={}, y={}\", x, y)\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 19,
          "line_number": 587,
          "code": "// Status: ‚ùå BROKEN\n\nuse log::{debug, info, warn, error}\n\nfn main() {\n    env_logger::init()\n    \n    debug!(\"This is a debug message\")\n    info!(\"This is info\")\n    warn!(\"This is a warning\")\n    error!(\"This is an error\")\n}\n\n// Control log level with environment variable\n// RUST_LOG=debug cargo run\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 20,
          "line_number": 610,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n#[cfg(test)]\nmod tests {\n    use super::*\n    \n    #[test]\n    fn test_with_debug_output() {\n        let result = my_function(42)\n        \n        // Print for debugging (use -- --nocapture to see output)\n        println!(\"Result: {:?}\", result)\n        \n        assert_eq!(result, expected)\n    }\n    \n    // Run with: cargo test -- --nocapture\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: Hash\n"
        }
      ]
    },
    "ch05-00-data-processing": {
      "chapter": "ch05-00-data-processing",
      "total_examples": 10,
      "working_examples": 3,
      "failing_examples": 7,
      "examples": [
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// File: sales_analyzer.ruchy\n// Analyzes sales data from CSV file\n\nprintln(\"=== Sales Data Analyzer ===\")\n\n// Read CSV data (simplified - in practice you'd use CSV parser)\nlet sales_data = [\n    [\"Date\", \"Product\", \"Amount\", \"Region\"],\n    [\"2024-01-15\", \"Laptop\", \"1299\", \"North\"],\n    [\"2024-01-16\", \"Mouse\", \"25\", \"South\"], \n    [\"2024-01-17\", \"Keyboard\", \"79\", \"North\"],\n    [\"2024-01-18\", \"Laptop\", \"1299\", \"East\"],\n    [\"2024-01-19\", \"Monitor\", \"399\", \"West\"]\n]\n\n// Process data\nlet total_sales = 0\nlet product_counts = {}\nlet region_sales = {}\n\nfor row in sales_data[1..] {  // Skip header\n    let product = row[1]\n    let amount = row[2].to_f()\n    let region = row[3]\n    \n    // Calculate totals\n    total_sales += amount\n    \n    // Count products\n    product_counts[product] = product_counts.get(product, 0) + 1\n    \n    // Sum by region\n    region_sales[region] = region_sales.get(region, 0) + amount\n}\n\n// Display results\nprintln(\"Total Sales: $\" + total_sales.to_s())\nprintln(\"Average Sale: $\" + (total_sales / (sales_data.len() - 1)).to_s())\n\nprintln(\"\\nTop Products:\")\nfor product, count in product_counts.items() {\n    println(\"  \" + product + \": \" + count.to_s() + \" sales\")\n}\n\nprintln(\"\\nSales by Region:\")\nfor region, amount in region_sales.items() {\n    println(\"  \" + region + \": $\" + amount.to_s())\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: RightBracket\n"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 2,
          "line_number": 112,
          "code": "// Status: ‚ùå BROKEN\n\n// Arrays for sequences\nlet sales_amounts = [1299, 25, 79, 1299, 399]\nlet monthly_revenue = [45000, 52000, 48000, 61000]\n\n// Dictionaries for key-value mapping  \nlet customer_orders = {\n    \"alice@email.com\": 5,\n    \"bob@email.com\": 2,\n    \"carol@email.com\": 8\n}\n\n// Arrays of dictionaries for structured records\nlet transactions = [\n    {\"id\": 1001, \"amount\": 1299, \"customer\": \"alice@email.com\"},\n    {\"id\": 1002, \"amount\": 25, \"customer\": \"bob@email.com\"},\n    {\"id\": 1003, \"amount\": 79, \"customer\": \"alice@email.com\"}\n]\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 3,
          "line_number": 141,
          "code": "// Status: ‚ùå BROKEN\n\n// Sum and averages\nlet total = numbers.sum()\nlet average = numbers.sum() / numbers.len()\nlet maximum = numbers.max()\nlet minimum = numbers.min()\n\n// Grouping and counting\nfn group_by_field(records, field) {\n    let groups = {}\n    for record in records {\n        let key = record[field]\n        if !groups.has_key(key) {\n            groups[key] = []\n        }\n        groups[key].push(record)\n    }\n    return groups\n}\n\n// Filtering and transformation\nlet high_value = transactions.filter(|t| t.amount > 100)\nlet customer_ids = transactions.map(|t| t.customer)\nlet amounts_only = transactions.map(|t| t.amount)\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 4,
          "line_number": 176,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// CSV-like processing (simplified)\nfn parse_csv_line(line) {\n    return line.split(\",\").map(|field| field.trim())\n}\n\nfn load_csv(filename) {\n    let lines = read_lines(filename)\n    let header = parse_csv_line(lines[0])\n    let data = []\n    \n    for line in lines[1..] {\n        let fields = parse_csv_line(line)\n        let record = {}\n        for i, field in fields.enumerate() {\n            record[header[i]] = field\n        }\n        data.push(record)\n    }\n    \n    return data\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: RightBracket\n"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 5,
          "line_number": 209,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// File: customer_analytics.ruchy\n// Analyzes customer purchase patterns\n\nprintln(\"=== Customer Analytics Tool ===\")\n\n// Sample customer data (in practice, load from file)\nlet customers = [\n    {\"name\": \"Alice\", \"email\": \"alice@email.com\", \"orders\": 5, \"total_spent\": 2500, \"signup_date\": \"2023-06-15\"},\n    {\"name\": \"Bob\", \"email\": \"bob@email.com\", \"orders\": 2, \"total_spent\": 150, \"signup_date\": \"2024-01-20\"},\n    {\"name\": \"Carol\", \"email\": \"carol@email.com\", \"orders\": 8, \"total_spent\": 4200, \"signup_date\": \"2023-03-10\"},\n    {\"name\": \"David\", \"email\": \"david@email.com\", \"orders\": 1, \"total_spent\": 75, \"signup_date\": \"2024-02-01\"}\n]\n\n// Calculate key metrics\nlet total_customers = customers.len()\nlet total_revenue = customers.map(|c| c.total_spent).sum()\nlet average_order_value = total_revenue / customers.map(|c| c.orders).sum()\nlet average_customer_value = total_revenue / total_customers\n\nprintln(\"Customer Base: \" + total_customers.to_s() + \" customers\")\nprintln(\"Total Revenue: $\" + total_revenue.to_s())\nprintln(\"Average Order Value: $\" + average_order_value.to_s())\nprintln(\"Average Customer Value: $\" + average_customer_value.to_s())\n\n// Segment customers\nlet vip_customers = customers.filter(|c| c.total_spent > 1000)\nlet new_customers = customers.filter(|c| c.signup_date.starts_with(\"2024\"))\nlet frequent_buyers = customers.filter(|c| c.orders > 5)\n\nprintln(f\"\\nCustomer Segments:\")\nprintln(\"VIP Customers (>$1000): \" + vip_customers.len().to_s())\nprintln(\"New Customers (2024): \" + new_customers.len().to_s())\nprintln(\"Frequent Buyers (>5 orders): \" + frequent_buyers.len().to_s())\n\n// Top customers by spending\nlet top_spenders = customers.sort_by(|c| -c.total_spent)[..3]\nprintln(f\"\\nTop Spenders:\")\nfor i, customer in top_spenders.enumerate() {\n    println(\"  \" + (i+1).to_s() + \". \" + customer.name + \": $\" + customer.total_spent.to_s() + \" (\" + customer.orders.to_s() + \" orders)\")\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: DotDot\n"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 6,
          "line_number": 259,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// File: advanced_log_analyzer.ruchy\n// Comprehensive log file analysis\n\nprintln(\"=== Advanced Log Analyzer ===\")\n\n// Sample log entries (in practice, read from file)\nlet log_entries = [\n    \"2024-08-19 10:15:32 INFO User login: alice@email.com\",\n    \"2024-08-19 10:16:45 ERROR Database connection failed\", \n    \"2024-08-19 10:17:12 INFO User login: bob@email.com\",\n    \"2024-08-19 10:18:33 WARN Slow query detected: 2.5s\",\n    \"2024-08-19 10:19:44 ERROR 404 Not Found: /api/users/999\",\n    \"2024-08-19 10:20:15 INFO User logout: alice@email.com\"\n]\n\n// Parse log entries\nfn parse_log_entry(entry) {\n    let parts = entry.split(\" \")\n    return {\n        \"date\": parts[0],\n        \"time\": parts[1], \n        \"level\": parts[2],\n        \"message\": parts[3..].join(\" \")\n    }\n}\n\nlet parsed_logs = log_entries.map(parse_log_entry)\n\n// Analyze by level\nlet level_counts = {}\nfor log in parsed_logs {\n    let level = log.level\n    level_counts[level] = level_counts.get(level, 0) + 1\n}\n\nprintln(\"Log Level Summary:\")\nfor level, count in level_counts.items() {\n    let emoji = match level {\n        \"INFO\" => \"‚ÑπÔ∏è\",\n        \"WARN\" => \"‚ö†Ô∏è\", \n        \"ERROR\" => \"‚ùå\",\n        _ => \"üìù\"\n    }\n    println(\"  \" + emoji + \" \" + level + \": \" + count.to_s() + \" entries\")\n}\n\n// Find errors and warnings\nlet issues = parsed_logs.filter(|log| log.level == \"ERROR\" || log.level == \"WARN\")\nprintln(\"\\nIssues Found (\" + issues.len().to_s() + \"):\")\nfor issue in issues {\n    println(\"  \" + issue.time + \" \" + issue.level + \": \" + issue.message)\n}\n\n// Extract user activity\nlet user_actions = parsed_logs.filter(|log| log.message.contains(\"User\"))\nprintln(\"\\nUser Activity (\" + user_actions.len().to_s() + \" actions):\")\nfor action in user_actions {\n    println(\"  \" + action.time + \": \" + action.message)\n}\n\n// Time-based analysis\nlet hours = parsed_logs.map(|log| log.time.split(\":\")[0])\nlet hour_counts = {}\nfor hour in hours {\n    hour_counts[hour] = hour_counts.get(hour, 0) + 1\n}\n\nlet busiest_hour = hour_counts.max_by_value()\nprintln(\"\\nBusiest Hour: \" + busiest_hour.key + \":xx (\" + busiest_hour.value.to_s() + \" entries)\")",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: RightBracket\n"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 7,
          "line_number": 338,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// File: finance_processor.ruchy\n// Processes financial transactions and generates reports\n\nprintln(\"=== Financial Data Processor ===\")\n\n// Transaction data structure\nlet transactions = [\n    {\"date\": \"2024-01-15\", \"type\": \"income\", \"category\": \"salary\", \"amount\": 5000, \"description\": \"Monthly salary\"},\n    {\"date\": \"2024-01-16\", \"type\": \"expense\", \"category\": \"rent\", \"amount\": 1200, \"description\": \"Apartment rent\"},\n    {\"date\": \"2024-01-17\", \"type\": \"expense\", \"category\": \"groceries\", \"amount\": 85, \"description\": \"Weekly shopping\"},\n    {\"date\": \"2024-01-18\", \"type\": \"expense\", \"category\": \"utilities\", \"amount\": 150, \"description\": \"Electricity bill\"},\n    {\"date\": \"2024-01-20\", \"type\": \"income\", \"category\": \"freelance\", \"amount\": 800, \"description\": \"Web design project\"}\n]\n\n// Calculate totals\nlet total_income = transactions.filter(|t| t.type == \"income\").map(|t| t.amount).sum()\nlet total_expenses = transactions.filter(|t| t.type == \"expense\").map(|t| t.amount).sum()\nlet net_income = total_income - total_expenses\n\nprintln(f\"Financial Summary:\")\nprintln(\"Total Income: $\" + total_income.to_s())\nprintln(\"Total Expenses: $\" + total_expenses.to_s())\nprintln(\"Net Income: $\" + net_income.to_s())\nprintln(\"Savings Rate: \" + (net_income * 100 / total_income).to_s() + \"%\")\n\n// Expense breakdown by category\nlet expense_categories = {}\nfor transaction in transactions.filter(|t| t.type == \"expense\") {\n    let category = transaction.category\n    expense_categories[category] = expense_categories.get(category, 0) + transaction.amount\n}\n\nprintln(f\"\\nExpense Breakdown:\")\nfor category, amount in expense_categories.items() {\n    let percentage = (amount * 100) / total_expenses\n    println(\"  \" + category.capitalize() + \": $\" + amount.to_s() + \" (\" + percentage.to_s() + \"%)\")\n}\n\n// Budget analysis\nlet budget_limits = {\n    \"rent\": 1500,\n    \"groceries\": 400, \n    \"utilities\": 200,\n    \"entertainment\": 300\n}\n\nprintln(f\"\\nBudget Analysis:\")\nfor category, limit in budget_limits.items() {\n    let spent = expense_categories.get(category, 0)\n    let remaining = limit - spent\n    let status = if remaining >= 0 { \"‚úÖ Under budget\" } else { \"‚ùå Over budget\" }\n    println(\"  \" + category.capitalize() + \": $\" + spent.to_s() + \"/$\" + limit.to_s() + \" - \" + status)\n}\n\n// Monthly trend (if we had multiple months of data)\nprintln(\"\\nTransaction History (\" + transactions.len().to_s() + \" transactions):\")\nfor transaction in transactions.sort_by(|t| t.date) {\n    let emoji = if transaction.type == \"income\" { \"üí∞\" } else { \"üí∏\" }\n    println(\"  \" + transaction.date + \" \" + emoji + \" $\" + transaction.amount.to_s() + \" - \" + transaction.description)\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected method name or 'await' after '.'\n"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 8,
          "line_number": 410,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Simple bar chart function\nfn draw_bar_chart(data, title) {\n    println(\"\\n\" + title)\n    println(\"=\" * title.len())\n    \n    let max_value = data.values().max()\n    let max_bar_width = 50\n    \n    for key, value in data.items() {\n        let bar_width = (value * max_bar_width) / max_value\n        let bar = \"‚ñà\" * bar_width.to_i()\n        println(key + \" ‚îÇ\" + bar + \" \" + value.to_s())\n    }\n}\n\n// Usage example\nlet monthly_sales = {\n    \"January\": 45000,\n    \"February\": 52000,\n    \"March\": 48000,\n    \"April\": 61000,\n    \"May\": 58000\n}\n\ndraw_bar_chart(monthly_sales, \"Monthly Sales Report\")",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Expected In, found Comma\n"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 9,
          "line_number": 462,
          "code": "// Status: ‚ùå BROKEN\n\nlet sales_data = load_csv(\"sales.csv\")\nlet total = sales_data.map(|row| row.amount.to_f()).sum()\nlet average = total / sales_data.len()\nprintln(\"Average sale: $\" + average.to_s())\n\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 10,
          "line_number": 555,
          "code": "// Status: ‚ùå BROKEN\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// expense_tracker.ruchy - Track and analyze personal expenses\n\nlet EXPENSES_FILE = \"expenses.csv\"\n\nfn save_expense(date, category, amount, description) {\n    let entry = date + \",\" + category + \",\" + amount.to_s() + \",\" + description + \"\\n\"\n    append_file(EXPENSES_FILE, entry)\n}\n\nfn load_expenses() {\n    if !file_exists(EXPENSES_FILE) {\n        // Create header if file doesn't exist\n        write_file(EXPENSES_FILE, \"Date,Category,Amount,Description\\n\")\n        return []\n    }\n    \n    let lines = read_lines(EXPENSES_FILE)[1..]  // Skip header\n    let expenses = []\n    \n    for line in lines {\n        let parts = line.split(\",\")\n        expenses.push({\n            \"date\": parts[0],\n            \"category\": parts[1], \n            \"amount\": parts[2].to_f(),\n            \"description\": parts[3]\n        })\n    }\n    \n    return expenses\n}\n\nfn analyze_expenses(expenses) {\n    let total = expenses.map(|e| e.amount).sum()\n    let average = total / expenses.len()\n    \n    // Category breakdown\n    let categories = {}\n    for expense in expenses {\n        categories[expense.category] = categories.get(expense.category, 0) + expense.amount\n    }\n    \n    println(\"\\nüí∞ Expense Analysis (\" + expenses.len().to_s() + \" transactions)\")\n    println(\"Total Spent: $\" + total.to_s())\n    println(\"Average Transaction: $\" + average.to_s())\n    \n    println(f\"\\nüìä Spending by Category:\")\n    for category, amount in categories.items().sort_by(|item| -item.value) {\n        let percentage = (amount * 100) / total\n        println(\"  \" + category + \": $\" + amount.to_s() + \" (\" + percentage.to_s() + \"%)\")\n    }\n    \n    // Recent transactions\n    let recent = expenses.sort_by(|e| -e.date)[..5]  // Last 5\n    println(f\"\\nüïí Recent Transactions:\")\n    for expense in recent {\n        println(\"  \" + expense.date + \" $\" + expense.amount.to_s() + \" \" + expense.category + \" \" + expense.description)\n    }\n}\n\nfn main_menu() {\n    println(\"\\n=== Personal Expense Tracker ===\")\n    println(\"1. Add expense\")\n    println(\"2. View analysis\") \n    println(\"3. Export data\")\n    println(\"4. Quit\")\n    \n    let choice = input(\"\\nChoose option: \")\n    \n    match choice {\n        \"1\" => {\n            let date = input(\"Date (YYYY-MM-DD): \")\n            let category = input(\"Category: \")\n            let amount = input(\"Amount: $\").to_f()\n            let description = input(\"Description: \")\n            \n            save_expense(date, category, amount, description)\n            println(\"‚úÖ Expense added!\")\n        }\n        \"2\" => {\n            let expenses = load_expenses()\n            if expenses.is_empty() {\n                println(\"üìù No expenses recorded yet\")\n            } else {\n                analyze_expenses(expenses)\n            }\n        }\n        \"3\" => {\n            println(\"üìÅ Data exported to: \" + EXPENSES_FILE)\n            println(\"Open in spreadsheet application for advanced analysis\")\n        }\n        \"4\" => {\n            println(\"üí∏ Happy budgeting!\")\n            return false\n        }\n        _ => {\n            println(\"‚ùå Invalid choice\")\n        }\n    }\n    \n    return true\n}\n\n// Main program loop\nwhile main_menu() {\n    // Continue until user quits\n}",
          "passed": false,
          "status": "broken",
          "error": "Parse error: Unexpected token: RightBracket\n"
        }
      ]
    },
    "ch01-02-hello-world": {
      "chapter": "ch01-02-hello-world",
      "total_examples": 8,
      "working_examples": 8,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ‚ùå BROKEN\nfun main() {\n    println(\"Hello, World!\");\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 2,
          "line_number": 83,
          "code": "// Status: ‚ùå BROKEN\nfun main() {\n    println(\"Hello\", \"World\", \"from\", \"Ruchy\");\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 3,
          "line_number": 100,
          "code": "// Status: ‚ùå BROKEN\nfun main() {\n    let name = \"Alice\";\n    println(\"Hello,\", name);\n    \n    // String concatenation (interpolation coming in future versions)\n    println(\"Hello, \" + name + \"!\");\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 4,
          "line_number": 122,
          "code": "// Status: ‚ùå BROKEN\nfun main() {\n    println(\"The answer is\", 42);\n    println(\"Pi is approximately\", 3.14159);\n    println(\"Is Ruchy awesome?\", true);\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 5,
          "line_number": 144,
          "code": "// Status: ‚ùå BROKEN\n// ‚ùå This won't work - intentional error example\n// println(Hello, World!);\n//\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Always use quotes for literal text.\n\nfun main() {\n    // ‚úÖ Correct way:\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 6,
          "line_number": 161,
          "code": "// Status: ‚ùå BROKEN\n// ‚ùå Quotes don't match - intentional error example\n// println(\"Hello, World!');\n//\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n// Use either \"...\" or '...' but be consistent.\n\nfun main() {\n    // ‚úÖ Correct way:\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 7,
          "line_number": 178,
          "code": "// Status: ‚ùå BROKEN\n// ‚ùå Wrong capitalization - intentional error example\n// PrintLn(\"Hello, World!\");\n//\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n\nfun main() {\n    // ‚úÖ Correct way:\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 8,
          "line_number": 201,
          "code": "// Status: ‚ùå BROKEN\nfun main() {\n    println(\"Hello, World!\");\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch02-00-variables-types": {
      "chapter": "ch02-00-variables-types",
      "total_examples": 9,
      "working_examples": 9,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ‚ùå BROKEN\nfun main() {\n    let name = \"Alice\"\n    let age = 25\n    let is_learning = true\n\n    println(\"Hi\", name, \", you're\", age, \"years old!\")\n    println(\"Currently learning Ruchy:\", is_learning)\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 2,
          "line_number": 83,
          "code": "// Status: ‚ùå BROKEN\nfun main() {\n    // Text data\n    let first_name = \"John\"\n    let last_name = \"Doe\"\n    let full_name = first_name + \" \" + last_name\n\n    // Numeric data\n    let score = 95\n    let percentage = 95.5\n    let temperature = -10\n\n    // Boolean (true/false) data\n    let is_student = true\n    let has_graduated = false\n    let is_enrolled = !has_graduated\n\n    println(\"Student:\", full_name)\n    println(\"Score:\", score, \"(\", percentage, \"%)\")\n    println(\"Temperature:\", temperature, \"¬∞C\")\n    println(\"Status: student=\", is_student, \", graduated=\", has_graduated)\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 3,
          "line_number": 113,
          "code": "// Status: ‚ùå BROKEN\nfun main() {\n    // Store user information\n    let username = \"programmer2024\"\n    let mut login_count = 1\n    let mut is_premium = false\n\n    // Use variables in calculations\n    let welcome_bonus = 100\n    let total_points = welcome_bonus + (login_count * 10)\n\n    // Update information (use mut for mutable variables)\n    login_count = login_count + 1\n    is_premium = total_points > 150\n\n    println(\"Welcome back,\", username, \"!\")\n    println(\"Logins:\", login_count, \", Points:\", total_points)\n    println(\"Premium status:\", is_premium)\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 4,
          "line_number": 140,
          "code": "// Status: ‚ùå BROKEN\nfun main() {\n    // Store multiple values\n    let favorite_languages = [\"Python\", \"Rust\", \"Ruchy\"]\n    let daily_temperatures = [22.5, 25.0, 23.8, 26.2]\n    let task_completed = [true, false, true, true]\n\n    // Access items by index (starting from 0)\n    println(\"First language:\", favorite_languages[0])\n    println(\"Today's temp:\", daily_temperatures[0], \"¬∞C\")\n\n    // Get list length\n    println(\"I know\", favorite_languages.len(), \"languages\")\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 5,
          "line_number": 163,
          "code": "// Status: ‚ùå BROKEN\n// ‚ùå This won't work\nfun main() {\n    user_name = \"Alice\"  // Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 6,
          "line_number": 175,
          "code": "// Status: ‚ùå BROKEN\n// ‚ùå This might not work as expected\nfun main() {\n    let age = \"25\"  // String, not number\n    let next_year = age + 1  // Can't add number to string\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 7,
          "line_number": 189,
          "code": "// Status: ‚ùå BROKEN\n// ‚ùå These are different variables\nfun main() {\n    let userName = \"Alice\"\n    let username = \"Bob\"\n    println(userName)  // Prints \"Alice\", not \"Bob\"\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 8,
          "line_number": 211,
          "code": "// Status: ‚ùå BROKEN\nfun main() {\n    let name = \"Alice\"\n    let age = 25\n    println(\"Hi\", name, \", age\", age)\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 9,
          "line_number": 277,
          "code": "// Status: ‚ùå BROKEN\nfun main() {\n    // Personal profile\n    let name = \"Alex\"\n    let age = 28\n    let city = \"San Francisco\"\n    let hobby = \"rock climbing\"\n    let goal = \"master Ruchy in 30 days\"\n\n    // Data calculator  \n    let num1 = 15\n    let num2 = 25\n    let sum = num1 + num2\n    let difference = num1 - num2\n    let average = (num1 + num2) / 2\n\n    // Text manipulation\n    let first_name = \"Alex\"\n    let last_name = \"Johnson\"\n    let username = first_name + \"_\" + last_name\n    let email = username + \"@example.com\"\n\n    // Boolean logic\n    let is_adult = age >= 18\n    let lives_in_tech_city = city == \"San Francisco\"\n    let ready_for_job = is_adult && lives_in_tech_city\n\n    println(\"Profile:\", name, age, city)\n    println(\"Math:\", sum, difference, average)\n    println(\"Contact:\", username, email)\n    println(\"Status:\", is_adult, lives_in_tech_city, ready_for_job)\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch03-00-functions": {
      "chapter": "ch03-00-functions",
      "total_examples": 12,
      "working_examples": 12,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ‚ùå BROKEN\nfun main() {\n    // Organize calculations\n    let name = \"Alice\"  \n    let a = 15\n    let b = 27\n\n    // Reusable greeting logic\n    let greeting = \"Hello, \" + name + \"! Welcome to Ruchy!\"\n\n    // Reusable calculation logic  \n    let sum = a + b\n    let result_message = a + \" + \" + b + \" = \" + sum\n\n    println(greeting)\n    println(result_message)\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 2,
          "line_number": 66,
          "code": "// Status: ‚ùå BROKEN\nfun main() {\n    // Store inputs\n    let input1 = 10\n    let input2 = 20\n\n    // Organize calculations  \n    let sum = input1 + input2\n    let product = input1 * input2\n    let average = sum / 2\n\n    // Organize output\n    let result = \"Sum: \" + sum + \", Product: \" + product + \", Average: \" + average\n    println(result)\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 3,
          "line_number": 90,
          "code": "// Status: ‚ùå BROKEN\nfun main() {\n    // Template: greeting with name\n    let user_name = \"Alice\"\n    let greeting_template = \"Hello, \" + user_name + \"! Welcome!\"\n\n    // Template: calculation display\n    let num1 = 15\n    let num2 = 27  \n    let operation = \"addition\"\n    let calc_result = num1 + num2\n    let calc_display = operation + \": \" + num1 + \" + \" + num2 + \" = \" + calc_result\n    \n    println(greeting_template)\n    println(calc_display)\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 4,
          "line_number": 115,
          "code": "// Status: ‚ùå BROKEN\nfun main() {\n    // Input section\n    let temperature_f = 68\n    let user_location = \"San Francisco\"\n\n    // Processing section  \n    let temperature_c = (temperature_f - 32) * 5 / 9\n    let is_comfortable = temperature_c > 18 && temperature_c < 25\n\n    // Output section\n    let weather_report = \"Weather in \" + user_location + \": \" + temperature_f + \"¬∞F (\" + temperature_c + \"¬∞C)\"\n    let comfort_message = if is_comfortable { \"Perfect weather!\" } else { \"Dress accordingly\" }\n\n    println(weather_report)\n    println(comfort_message)\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 5,
          "line_number": 142,
          "code": "// Status: ‚ùå BROKEN\n// Mathematical operations\nfun square(x) {\n    x * x\n}\n\nfun circle_area(radius) {\n    let pi = 3.14159\n    pi * square(radius)\n}\n\n// Text processing\nfun make_username(first_name, last_name) {\n    first_name + \"_\" + last_name\n}\n\nfun shout(message) {\n    message + \"!!!\"\n}\n\nfun main() {\n    // Use them together\n    let area = circle_area(5)\n    let username = make_username(\"Alice\", \"Johnson\") \n    let excited = shout(\"I love functions\")\n\n    println(\"Circle area:\", area)\n    println(\"Username:\", username)\n    println(excited)\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 6,
          "line_number": 180,
          "code": "// Status: ‚ùå BROKEN\nfun is_even(number) {\n    number % 2 == 0\n}\n\nfun grade_letter(score) {\n    if score >= 90 {\n        \"A\"\n    } else if score >= 80 {\n        \"B\"\n    } else if score >= 70 {\n        \"C\"\n    } else if score >= 60 {\n        \"D\"\n    } else {\n        \"F\"\n    }\n}\n\nfun describe_number(n) {\n    let even_odd = if is_even(n) { \"even\" } else { \"odd\" }\n    let size = if n > 100 { \"large\" } else { \"small\" }\n    n + \" is a \" + size + \" \" + even_odd + \" number\"\n}\n\nfun main() {\n    // Test your functions\n    println(describe_number(42))   // \"42 is a small even number\"\n    println(describe_number(150))  // \"150 is a large even number\"\n    println(grade_letter(85))      // \"B\"\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 7,
          "line_number": 219,
          "code": "// Status: ‚ùå BROKEN\nfun calculate_total(prices) {\n    let mut total = 0.0\n    let mut i = 0\n    while i < prices.len() {\n        total = total + prices[i]\n        i = i + 1\n    }\n    total\n}\n\nfun find_max(numbers) {\n    let mut max_val = numbers[0]\n    let mut i = 0\n    while i < numbers.len() {\n        if numbers[i] > max_val {\n            max_val = numbers[i]\n        }\n        i = i + 1\n    }\n    max_val\n}\n\nfun count_words(text) {\n    let words = text.split(\" \")\n    words.len()\n}\n\nfun main() {\n    // Real-world usage\n    let shopping_cart = [19.99, 5.50, 12.00, 8.75]\n    let test_scores = [85, 92, 78, 96, 88]\n    let essay = \"Functions make code reusable and testable\"\n\n    println(\"Total cost: $\", calculate_total(shopping_cart))\n    println(\"Highest score:\", find_max(test_scores))\n    println(\"Word count:\", count_words(essay))\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 8,
          "line_number": 266,
          "code": "// Status: ‚ùå BROKEN\n// ‚ùå This returns nothing (unit type)\nfun bad_add(a, b) {\n    a + b;\n    // The semicolon makes this a statement, returns ()\n}\n\n// ‚úÖ This returns the sum\nfun good_add(a, b) {\n    a + b  // No semicolon - this is an expression\n}\n\nfun main() {\n    println(good_add(2, 3))\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 9,
          "line_number": 288,
          "code": "// Status: ‚ùå BROKEN\nfun greet(name, age) {\n    \"Hi \" + name + \", you're \" + age + \" years old\"\n}\n\nfun main() {\n    // ‚ùå This won't work\n    let msg = greet(\"Alice\")  // Missing age parameter\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 10,
          "line_number": 305,
          "code": "// Status: ‚ùå BROKEN\n// ‚ùå Parameters are read-only\nfun bad_function(x) {\n    x = x + 1  // Error: Requires run access to \"ruchy\", run again with the --allow-run flag\n    x\n}\n\n// ‚úÖ Create new variables inside functions\nfun good_function(x) {\n    let result = x + 1\n    result\n}\n\nfun main() {\n    println(good_function(5))\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 11,
          "line_number": 334,
          "code": "// Status: ‚ùå BROKEN\nfun add(a, b) {\n    a + b\n}\n\nfun main() {\n    let result = add(10, 20)\n    println(result)\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 12,
          "line_number": 426,
          "code": "// Status: ‚ùå BROKEN\n// Personal calculator\nfun celsius_to_fahrenheit(celsius) {\n    (celsius * 9 / 5) + 32\n}\n\nfun calculate_bmi(weight_kg, height_m) {\n    weight_kg / (height_m * height_m)\n}\n\nfun apply_discount(price, discount_percent) {\n    let discount = price * (discount_percent / 100)\n    price - discount\n}\n\n// Text tools\nfun word_count(text) {\n    let words = text.split(\" \")\n    words.len()\n}\n\nfun get_initials(full_name) {\n    let words = full_name.split(\" \")\n    let mut initials = \"\"\n    let mut i = 0\n    while i < words.len() {\n        let word = words[i]\n        initials = initials + word[0]\n        i = i + 1\n    }\n    initials\n}\n\n// Decision makers\nfun recommend_activity(energy_level, available_time) {\n    if energy_level > 7 && available_time > 60 {\n        \"Go for a run or hit the gym!\"\n    } else if energy_level > 5 && available_time > 30 {\n        \"Perfect time for a walk\"\n    } else {\n        \"Maybe just relax and read\"\n    }\n}\n\nfun main() {\n    // Test your functions!\n    println(celsius_to_fahrenheit(20))  // 68\n    println(calculate_bmi(70, 1.75))    // 22.86\n    println(get_initials(\"Alice Johnson\"))  // \"AJ\"\n    println(recommend_activity(8, 45))\n}\n\n\n// Error: Requires run access to \"ruchy\", run again with the --allow-run flag",
          "passed": true,
          "status": "working"
        }
      ]
    }
  }
}