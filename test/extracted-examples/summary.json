{
  "timestamp": "2025-08-23T21:21:38.044Z",
  "ruchy_version": "ruchy 1.5.0",
  "chapters_processed": 36,
  "examples_found": 381,
  "examples_working": 76,
  "examples_failing": 305,
  "success_rate": 20,
  "chapters": {
    "ch02-00-variables-types-tdd": {
      "chapter": "ch02-00-variables-types-tdd",
      "total_examples": 8,
      "working_examples": 5,
      "failing_examples": 3,
      "examples": [
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 1,
          "line_number": 17,
          "code": "fun main() {\n    let x = 42;\n    println(x);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 2,
          "line_number": 33,
          "code": "fun main() {\n    let name = \"Ruchy\";\n    println(name);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 3,
          "line_number": 49,
          "code": "fun main() {\n    let x = 10;\n    let y = 20;\n    let sum = x + y;\n    println(sum);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 4,
          "line_number": 67,
          "code": "fun main() {\n    let pi = 3.14159;\n    let radius = 5.0;\n    let area = pi * radius * radius;\n    println(area);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 5,
          "line_number": 109,
          "code": "fun main() {\n    let outer = 100;\n    // outer is accessible here\n    println(outer);\n}\n// outer is NOT accessible here",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 6,
          "line_number": 133,
          "code": "let result = value1 + value2;",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected expression, found `let` statement\n --> /tmp/.tmpQG3MbC/main.rs:1:63\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let result = value1 + value2 ; if let Some (s) = (& result as & dyn std :: ...\n  |                                                               ^^^\n  |\n  = note: only supported directly in conditions of `if` and `while` expressions\n\nerror[E0425]: cannot find value `value1` in this scope\n --> /tmp/.tmpQG3MbC/main.rs:1:76\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let result = value1 + value2 ; if let Some (s) = (& result as & dyn std :: ...\n  |                                                                            ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `value2` in this scope\n --> /tmp/.tmpQG3MbC/main.rs:1:85\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let result = value1 + value2 ; if let Some (s) = (& result as & dyn std :: ...\n  |                                                                                     ^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpQG3MbC/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let result = value1 + value2 ; if let Some (s) = (& result as & dyn std :: ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 7,
          "line_number": 138,
          "code": "let step1 = initial_value * factor;\nlet step2 = step1 + adjustment;\nlet final_result = step2 / divisor;",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `else`, `{`, or an operator, found `}`\n --> /tmp/.tmpXExJ8V/main.rs:1:170\n  |\n1 | ... adjustment ; let final_result = step2 / divisor } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < Strin...\n  |                                                     ^ expected one of 8 possible tokens\n\nerror[E0425]: cannot find value `initial_value` in this scope\n --> /tmp/.tmpXExJ8V/main.rs:1:77\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let step1 = initial_value * factor ; let step2 = step1 + adjustment ; let...\n  |                                                                             ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `factor` in this scope\n --> /tmp/.tmpXExJ8V/main.rs:1:93\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let step1 = initial_value * factor ; let step2 = step1 + adjustment ; let...\n  |                                                                                             ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `adjustment` in this scope\n --> /tmp/.tmpXExJ8V/main.rs:1:122\n  |\n1 | ...p1 = initial_value * factor ; let step2 = step1 + adjustment ; let final_result = step2 / divisor } ; if let Some (s) = (& result as &...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpXExJ8V/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let step1 = initial_value * factor ; let step2 = step1 + adjustment ; let...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 8,
          "line_number": 145,
          "code": "let PI = 3.14159;\nlet GRAVITY = 9.81;",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmp9SZT9A/main.rs:1:109\n  |\n1 | ...I = 3.14159f64 ; let GRAVITY = 9.81f64 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp9SZT9A/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let PI = 3.14159f64 ; let GRAVITY = 9.81f64 } ; if let Some (s) = (& resu...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch10-00-performance-optimization": {
      "chapter": "ch10-00-performance-optimization",
      "total_examples": 11,
      "working_examples": 0,
      "failing_examples": 11,
      "examples": [
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 1,
          "line_number": 88,
          "code": "// Status: ✅ WORKING\n\n// File: optimize_data_processing.ruchy\n// Before and after optimization\n\nuse std::perf;\nuse std::parallel;\n\n// Naive version - slow\nfun process_data_naive(data) {\n    let results = []\n    for item in data {\n        // Expensive computation\n        let processed = expensive_transform(item)\n        for existing in results {\n            if similar(processed, existing) {\n                processed.merge(existing)\n            }\n        }\n        results.push(processed)\n    }\n    return results\n}\n\n// Optimized version - fast\nfun process_data_optimized(data) {\n    // 1. Parallel processing\n    let results = parallel::map(data, |item| {\n        expensive_transform(item)\n    })\n    \n    // 2. Use hash map for lookups\n    let lookup = {}\n    for item in results {\n        let key = item.hash_key()\n        if lookup.has_key(key) {\n            lookup[key].merge(item)\n        } else {\n            lookup[key] = item\n        }\n    }\n    \n    return lookup.values()\n}\n\n// Benchmark both versions\nlet data = generate_test_data(10000)\n\nlet naive_time = perf::measure {\n    process_data_naive(data)\n}\n\nlet optimized_time = perf::measure {\n    process_data_optimized(data)\n}\n\nprintln(f\"Naive: {naive_time}ms\")\nprintln(f\"Optimized: {optimized_time}ms\")\nprintln(f\"Speedup: {naive_time / optimized_time:.1}x\")\n// Output: Speedup: 42.3x",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0432]: unresolved import `std::perf`\n --> /tmp/.tmp4MWtOt/main.rs:1:963\n  |\n1 | ...eturn lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; l...\n  |                                                      ^^^^^^^^^^^ no `perf` in the root\n\nerror[E0432]: unresolved import `std::parallel`\n --> /tmp/.tmp4MWtOt/main.rs:1:983\n  |\n1 | ... } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: ...\n  |                                                  ^^^^^^^^^^^^^^^ no `parallel` in the root\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp4MWtOt/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4MWtOt/main.rs:1:207\n  |\n1 | ... { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4MWtOt/main.rs:1:257\n  |\n1 | ... { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ...\n  |       ^^                                                                                                                                                                                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4MWtOt/main.rs:1:334\n  |\n1 | ...; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed...\n  |                                  ^^                                                                      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { if similar (processed , existing) { { processed . merge (existing) } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4MWtOt/main.rs:1:372\n  |\n1 | ...in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; retur...\n  |                                                       ^^                            ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { processed . merge (existing) } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4MWtOt/main.rs:1:647\n  |\n1 | ... { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4MWtOt/main.rs:1:774\n  |\n1 | ... { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ...\n  |       ^^                                                                                                                                 ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4MWtOt/main.rs:1:837\n  |\n1 | ...= item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return l...\n  |                                                       ^^                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { lookup [key] . merge (item) } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4MWtOt/main.rs:1:878\n  |\n1 | ...s_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () ...\n  |                                                           ^^                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { lookup [key] = item } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp4MWtOt/main.rs:1:977\n  |\n1 | ... . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_tim...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp4MWtOt/main.rs:1:1001\n  |\n1 | ...main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { ...\n  |                                                        ^ help: remove this semicolon\n\nerror[E0277]: `T` is not an iterator\n --> /tmp/.tmp4MWtOt/main.rs:1:250\n  |\n1 | ...T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results...\n  |                                                         ^^^^ `T` is not an iterator\n  |\n  = note: required for `T` to implement `IntoIterator`\nhelp: consider further restricting type parameter `T` with trait `Iterator`\n  |\n1 | use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive (data) } ; let optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n  |                                                                                                                                                                                           +++++++++++++++++++++\n\nerror[E0425]: cannot find function `expensive_transform` in this scope\n --> /tmp/.tmp4MWtOt/main.rs:1:277\n  |\n1 | ...] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existi...\n  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `similar` in this scope\n --> /tmp/.tmp4MWtOt/main.rs:1:339\n  |\n1 | ...ransform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results ....\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `parallel`\n --> /tmp/.tmp4MWtOt/main.rs:1:665\n  |\n1 | ...(data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in...\n  |                                        ^^^^^^^^ use of unresolved module or unlinked crate `parallel`\n  |\n  = help: you might be missing a crate named `parallel`\n\nerror[E0425]: cannot find function `expensive_transform` in this scope\n --> /tmp/.tmp4MWtOt/main.rs:1:700\n  |\n1 | ...results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let lookup = () ; for item in results { { { let key = i...\n  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `has_key` found for unit type `()` in the current scope\n --> /tmp/.tmp4MWtOt/main.rs:1:821\n  |\n1 | ...s { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } ...\n  |                                                       ^^^^^^^ method not found in `()`\n\nerror[E0599]: no method named `values` found for unit type `()` in the current scope\n --> /tmp/.tmp4MWtOt/main.rs:1:928\n  |\n1 | ... { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let data...\n  |                                                       ^^^^^^ method not found in `()`\n\nerror[E0425]: cannot find function `generate_test_data` in this scope\n --> /tmp/.tmp4MWtOt/main.rs:1:1014\n  |\n1 | ...: perf ; ; use std :: parallel ; ; let data = generate_test_data (10000i32) ; let naive_time = perf :: measure ; { process_data_naive ...\n  |                                                  ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 10 previous errors; 11 warnings emitted\n\nSome errors have detailed explanations: E0277, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: has_key()"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 2,
          "line_number": 164,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: ColonColon\n// CPU profiling\nlet profiler = perf::CpuProfiler::new()\nprofiler.start()\n\n// Your code here\ncomplex_operation()\n\nprofiler.stop()\nlet report = profiler.report()\n\nprintln(\"=== CPU Profile ===\")\nfor func in report.top_functions(10) {\n    println(f\"{func.name}: {func.self_time}ms ({func.percent}%)\")\n}\n\n// Memory profiling\nlet mem_profiler = perf::MemoryProfiler::new()\nmem_profiler.start()\n\n// Your code here\nmemory_intensive_operation()\n\nmem_profiler.stop()\nlet mem_report = mem_profiler.report()\n\nprintln(\"\\n=== Memory Profile ===\")\nprintln(\"Peak memory: \" + format_size(mem_report.peak_usage))\nprintln(\"Allocations: \" + mem_report.allocation_count.to_s())\nprintln(\"Largest allocation: \" + format_size(mem_report.largest_allocation))\n\n// Flame graph generation\nprofiler.generate_flamegraph(\"profile.svg\")\nprintln(\"Flame graph saved to profile.svg\")",
          "passed": false,
          "status": "broken",
          "error": "\nthread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:\n\"perf::CpuProfiler\" is not a valid Ident\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 3,
          "line_number": 210,
          "code": "// Status: ✅ WORKING\n\n// Micro-benchmarks\nuse std::bench;\n\nbench::suite(\"String Operations\", {\n    \"concatenation\" => || {\n        let s = \"\"\n        for i in range(1000) {\n            s += i.to_s()\n        }\n    },\n    \n    \"string builder\" => || {\n        let builder = StringBuilder::new()\n        for i in range(1000) {\n            builder.append(i.to_s())\n        }\n        builder.to_string()\n    },\n    \n    \"join\" => || {\n        range(1000).map(|i| i.to_s()).join(\"\")\n    }\n})\n\n// Results:\n// String Operations\n//   concatenation:  2.3ms ± 0.1ms\n//   string builder: 0.4ms ± 0.02ms  [FASTEST]\n//   join:          0.6ms ± 0.03ms\n\n// Custom benchmarks\nfun benchmark_algorithm(name, func, data) {\n    let times = []\n    \n    // Warmup\n    for i in range(5) {\n        func(data)\n    }\n    \n    // Measure\n    for i in range(100) {\n        let time = perf::measure {\n            func(data)\n        }\n        times.push(time)\n    }\n    \n    let avg = times.mean()\n    let std = times.std_dev()\n    println(f\"{name}: {avg:.2}ms ± {std:.2}ms\")\n}",
          "passed": false,
          "status": "broken",
          "error": "\nthread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:\n\"string builder\" is not a valid Ident\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 4,
          "line_number": 275,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: ColonColon\n// Parallel map\nlet data = range(1, 1000000)\nlet results = parallel::map(data, |n| {\n    expensive_computation(n)\n})\n\n// Parallel reduce\nlet sum = parallel::reduce(data, 0, |acc, n| {\n    acc + n\n})\n\n// Thread pool\nlet pool = parallel::ThreadPool::new(num_cpus())\n\nfor task in tasks {\n    pool.execute(|| {\n        process_task(task)\n    })\n}\n\npool.wait()\n\n// Parallel pipeline\nparallel::pipeline()\n    .stage(|item| fetch_data(item))      // I/O bound\n    .stage(|data| parse_data(data))      // CPU bound\n    .stage(|parsed| transform(parsed))   // CPU bound\n    .stage(|result| save_result(result)) // I/O bound\n    .process(items)\n\n// Async concurrency\nlet futures = []\nfor url in urls {\n    futures.push(async {\n        http::get(url).await()\n    })\n}\n\nlet responses = async::wait_all(futures)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 5,
          "line_number": 327,
          "code": "// Status: ✅ WORKING\n\n// File: algorithm_optimization.ruchy\n// Common optimization patterns\n\n// 1. Cache computed values\nlet fibonacci_cache = {}\nfun fibonacci_memo(n) {\n    if fibonacci_cache.has_key(n) {\n        return fibonacci_cache[n]\n    }\n    \n    let result = if n <= 1 {\n        n\n    } else {\n        fibonacci_memo(n - 1) + fibonacci_memo(n - 2)\n    }\n    \n    fibonacci_cache[n] = result\n    return result\n}\n\n// 2. Use better data structures\nfun find_duplicates_naive(items) {\n    let duplicates = []\n    for i in range(items.len()) {\n        for j in range(i + 1, items.len()) {\n            if items[i] == items[j] {\n                duplicates.push(items[i])\n            }\n        }\n    }\n    return duplicates  // O(n²)\n}\n\nfun find_duplicates_optimized(items) {\n    let seen = Set::new()\n    let duplicates = Set::new()\n    \n    for item in items {\n        if seen.contains(item) {\n            duplicates.add(item)\n        }\n        seen.add(item)\n    }\n    return duplicates.to_array()  // O(n)\n}\n\n// 3. Batch operations\nfun save_records_naive(records) {\n    for record in records {\n        database.insert(record)  // N database calls\n    }\n}\n\nfun save_records_optimized(records) {\n    database.insert_batch(records)  // 1 database call\n}\n\n// 4. Early termination\nfun find_first_match(items, predicate) {\n    for item in items {\n        if predicate(item) {\n            return item  // Stop as soon as found\n        }\n    }\n    return null\n}",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `fibonacci_cache` in this scope\n --> /tmp/.tmpUvtsDN/main.rs:1:205\n  |\n1 | ... :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n ...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `fibonacci_cache` in this scope\n --> /tmp/.tmpUvtsDN/main.rs:1:246\n  |\n1 | ... { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `fibonacci_cache` in this scope\n --> /tmp/.tmpUvtsDN/main.rs:1:381\n  |\n1 | ...(n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `range` in this scope\n --> /tmp/.tmpUvtsDN/main.rs:1:651\n  |\n1 | ...) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::slice::range;\n  |\n\nerror[E0425]: cannot find function `range` in this scope\n --> /tmp/.tmpUvtsDN/main.rs:1:687\n  |\n1 | ...[] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . p...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::slice::range;\n  |\n\nerror[E0425]: cannot find value `database` in this scope\n --> /tmp/.tmpUvtsDN/main.rs:1:1416\n  |\n1 | ...> (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Ad...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `database` in this scope\n --> /tmp/.tmpUvtsDN/main.rs:1:1630\n  |\n1 | ...d :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add <...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `null` in this scope\n --> /tmp/.tmpUvtsDN/main.rs:1:1930\n  |\n1 | ...if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n  |                                                         ^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::ptr::null;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpUvtsDN/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpUvtsDN/main.rs:1:237\n  |\n1 | ...(n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { ...\n  |                                                        ^^                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { return fibonacci_cache [n] } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpUvtsDN/main.rs:1:302\n  |\n1 | ... return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32)...\n  |                                                                    ^^ ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { n } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpUvtsDN/main.rs:1:317\n  |\n1 | ...esult = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; r...\n  |                                          ^^                                                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpUvtsDN/main.rs:1:608\n  |\n1 | ... { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } ...\n  |       ^^                                                                                                                                                                                                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpUvtsDN/main.rs:1:676\n  |\n1 | ...n ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; ret...\n  |            ^^                                                                                                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpUvtsDN/main.rs:1:723\n  |\n1 | ...ge (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } }...\n  |                                     ^^                                                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpUvtsDN/main.rs:1:753\n  |\n1 | ..., items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_dupl...\n  |                                                      ^^                             ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { duplicates . push (items [i]) } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpUvtsDN/main.rs:1:1003\n  |\n1 | ... { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } ...\n  |       ^^                                                                                                                                                                                                             ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpUvtsDN/main.rs:1:1119\n  |\n1 | ... ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_ar...\n  |                                                         ^^                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { duplicates . add (item) } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpUvtsDN/main.rs:1:1388\n  |\n1 | ...Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : st...\n  |                                         ^^                                                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { for record in records { { database . insert (record) } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpUvtsDN/main.rs:1:1414\n  |\n1 | ...ne > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops ::...\n  |                                                        ^^                          ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { database . insert (record) } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpUvtsDN/main.rs:1:1628\n  |\n1 | ... :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < ...\n  |                                                    ^^                                 ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { database . insert_batch (records) } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpUvtsDN/main.rs:1:1875\n  |\n1 | ... predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacc...\n  |                                                 ^^                                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { if predicate (item) { { return item } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpUvtsDN/main.rs:1:1899\n  |\n1 | ... : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = ...\n  |                                                               ^^           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { return item } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n  |\n\nerror[E0369]: binary operation `<=` cannot be applied to type `T`\n --> /tmp/.tmpUvtsDN/main.rs:1:292\n  |\n1 | ... (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n...\n  |                                                                - ^^ ---- i32\n  |                                                                |\n  |                                                                T\n  |\nhelp: consider further restricting type parameter `T` with trait `PartialOrd`\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n  |                                                                                                                                                                                       +++++++++++++++++++++++++++\n\nerror[E0369]: cannot subtract `i32` from `T`\n --> /tmp/.tmpUvtsDN/main.rs:1:337\n  |\n1 | ...let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = resul...\n  |                                                                 - ^ ---- i32\n  |                                                                 |\n  |                                                                 T\n  |\nhelp: consider further restricting type parameter `T` with trait `Sub`\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Sub<i32> > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n  |                                                                                                                                                                                       ++++++++++++++++++++\n\nerror[E0369]: cannot subtract `i32` from `T`\n --> /tmp/.tmpUvtsDN/main.rs:1:365\n  |\n1 | ...{ n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn...\n  |                                                                 - ^ ---- i32\n  |                                                                 |\n  |                                                                 T\n  |\nhelp: consider further restricting type parameter `T` with trait `Sub`\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Sub<i32, Output = T> > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n  |                                                                                                                                                                                       ++++++++++++++++++++++++++++++++\n\nerror[E0599]: no method named `len` found for type parameter `T` in the current scope\n --> /tmp/.tmpUvtsDN/main.rs:1:666\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()...\n  |       - method `len` not found for this type parameter                                                                                                                                                             ^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           +++++++++++++++++++\n\nerror[E0599]: no method named `len` found for type parameter `T` in the current scope\n --> /tmp/.tmpUvtsDN/main.rs:1:713\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()...\n  |       - method `len` not found for this type parameter                                                                                                                                                                                                            ^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           +++++++++++++++++++\n\nerror[E0608]: cannot index into a value of type `T`\n --> /tmp/.tmpUvtsDN/main.rs:1:734\n  |\n1 | ... ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; retu...\n  |                                                                     ^^^\n\nerror[E0608]: cannot index into a value of type `T`\n --> /tmp/.tmpUvtsDN/main.rs:1:747\n  |\n1 | ...j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates...\n  |                                                                     ^^^\n\nerror[E0608]: cannot index into a value of type `T`\n --> /tmp/.tmpUvtsDN/main.rs:1:780\n  |\n1 | ...n ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optim...\n  |                                                                     ^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `Set`\n --> /tmp/.tmpUvtsDN/main.rs:1:1018\n  |\n1 | ... Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . ...\n  |                                                       ^^^ use of undeclared type `Set`\n\nerror[E0433]: failed to resolve: use of undeclared type `Set`\n --> /tmp/.tmpUvtsDN/main.rs:1:1053\n  |\n1 | ... { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . ad...\n  |                                                       ^^^ use of undeclared type `Set`\n\nerror[E0277]: `T` is not an iterator\n --> /tmp/.tmpUvtsDN/main.rs:1:1081\n  |\n1 | ... () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add ...\n  |                                                         ^^^^^ `T` is not an iterator\n  |\n  = note: required for `T` to implement `IntoIterator`\nhelp: consider further restricting type parameter `T` with trait `Iterator`\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      +++++++++++++++++++++\n\nerror[E0277]: `T` is not an iterator\n --> /tmp/.tmpUvtsDN/main.rs:1:1404\n  |\n1 | ...ebug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std...\n  |                                                        ^^^^^^^ `T` is not an iterator\n  |\n  = note: required for `T` to implement `IntoIterator`\nhelp: consider further restricting type parameter `T` with trait `Iterator`\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpUvtsDN/main.rs:1:1390\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } ...\n  |       -                                                                                                                                                -     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |       |                                                                                                                                                |\n  |       expected this type parameter                                                                                                                     expected `T` because of return type\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: the caller chooses a type for `T` which can be different from `()`\n  = note: `for` loops evaluate to unit type `()`\nhelp: consider returning a value here\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } /* `T` value */ } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       +++++++++++++++\n\nerror[E0277]: `T` is not an iterator\n --> /tmp/.tmpUvtsDN/main.rs:1:1867\n  |\n1 | ...e > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main (...\n  |                                                         ^^^^^ `T` is not an iterator\n  |\n  = note: required for `T` to implement `IntoIterator`\nhelp: consider further restricting type parameter `T` with trait `Iterator`\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let fibonacci_cache = () ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        +++++++++++++++++++++\n\nerror[E0618]: expected function, found `T`\n --> /tmp/.tmpUvtsDN/main.rs:1:1880\n  |\n1 | ...e > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main (...\n  |                     ---------                                        ^^^^^^^^^-------\n  |                     |                                                |\n  |                     `predicate` has type `T`                         call expression requires function\n\nwarning: unused variable: `fibonacci_cache`\n --> /tmp/.tmpUvtsDN/main.rs:1:1956\n  |\n1 | ... } fn main () { let fibonacci_cache = () ; }\n  |                        ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_fibonacci_cache`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\nerror: aborting due to 23 previous errors; 16 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0369, E0425, E0433, E0599, E0608, E0618.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: len()"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 6,
          "line_number": 405,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected RightParen, found Colon\n// File: memory_optimization.ruchy\n// Reduce memory usage\n\n// 1. Use generators for large datasets\nfun read_large_file_naive(path) {\n    return read_file(path).lines()  // Loads entire file\n}\n\nfun read_large_file_optimized(path) {\n    // Generator - yields lines one at a time\n    return generate {\n        let file = open(path)\n        while !file.eof() {\n            yield file.read_line()\n        }\n        file.close()\n    }\n}\n\n// 2. Object pooling\nlet connection_pool = Pool::new(\n    create: || Database::connect(),\n    reset: |conn| conn.clear()\n)\n\nfun handle_request(request) {\n    let conn = connection_pool.acquire()\n    let result = conn.query(request.sql)\n    connection_pool.release(conn)\n    return result\n}\n\n// 3. Weak references for caches\nlet cache = WeakMap::new()\n\nfun get_cached_data(key) {\n    if cache.has(key) {\n        return cache.get(key)\n    }\n    \n    let data = expensive_load(key)\n    cache.set(key, data)\n    return data\n}\n\n// 4. Compact data structures\nstruct CompactUser {\n    id: u32,        // 4 bytes instead of 8\n    flags: u8,      // Bit flags instead of booleans\n    name: String    // Single allocation\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 7,
          "line_number": 467,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: ColonColon\n// File: io_optimization.ruchy\n// Speed up I/O operations\n\n// 1. Buffered I/O\nfun process_file_naive(path) {\n    let file = open(path)\n    while !file.eof() {\n        let byte = file.read_byte()  // Syscall for each byte\n        process(byte)\n    }\n}\n\nfun process_file_optimized(path) {\n    let file = BufferedReader::new(open(path), 8192)\n    while !file.eof() {\n        let byte = file.read_byte()  // Reads from buffer\n        process(byte)\n    }\n}\n\n// 2. Async I/O\nasync fun fetch_all_naive(urls) {\n    let results = []\n    for url in urls {\n        let data = http::get(url).await()  // Sequential\n        results.push(data)\n    }\n    return results\n}\n\nasync fun fetch_all_optimized(urls) {\n    let futures = urls.map(|url| {\n        http::get(url)  // Concurrent\n    })\n    return async::wait_all(futures)\n}\n\n// 3. Memory-mapped files\nfun process_huge_file(path) {\n    let mmap = MemoryMap::open(path)\n    \n    // Process in parallel chunks\n    parallel::for_chunks(mmap, 1_000_000, |chunk| {\n        process_chunk(chunk)\n    })\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 8,
          "line_number": 526,
          "code": "// Status: ✅ WORKING\n\n// File: query_optimizer.ruchy\n// Optimize database queries\n\nuse std::db;\nuse std::perf;\n\nlet database = db::connect(\"postgres://localhost/myapp\")\n\n// Enable query logging\ndatabase.log_queries(true)\n\n// Analyze slow queries\nfun analyze_query(sql) {\n    let plan = database.explain(sql)\n    println(\"Query: \" + sql)\n    println(\"Execution plan: \" + plan)\n    \n    // Find missing indexes\n    if plan.contains(\"Seq Scan\") {\n        println(\"⚠️  Sequential scan detected - consider adding index\")\n        \n        // Suggest index\n        let table = extract_table(sql)\n        let where_clause = extract_where(sql)\n        println(f\"Suggested: CREATE INDEX ON {table} ({where_clause.column})\")\n    }\n    \n    // Check for N+1 queries\n    let query_log = database.get_recent_queries(100)\n    let patterns = find_patterns(query_log)\n    \n    for pattern in patterns {\n        if pattern.count > 10 && pattern.similar {\n            println(\"⚠️  N+1 query pattern detected: \" + pattern.example)\n            println(\"Consider using JOIN or batch loading\")\n        }\n    }\n}\n\n// Optimize ORM queries\nfun get_users_with_posts_naive() {\n    let users = database.query(\"SELECT * FROM users\")\n    for user in users {\n        user.posts = database.query(\n            \"SELECT * FROM posts WHERE user_id = ?\", \n            [user.id]\n        )  // N+1 problem\n    }\n    return users\n}\n\nfun get_users_with_posts_optimized() {\n    // Single query with JOIN\n    return database.query(\"\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    \").group_by(|row| row.user_id)\n}\n\n// Benchmark improvements\nlet naive_time = perf::measure {\n    get_users_with_posts_naive()\n}\n\nlet optimized_time = perf::measure {\n    get_users_with_posts_optimized()\n}\n\nprintln(f\"Improvement: {naive_time / optimized_time:.1}x faster\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0432]: unresolved import `std::db`\n --> /tmp/.tmpVLMkqc/main.rs:1:1437\n  |\n1 | ... []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect (\"postgres://localhost/myapp\") ; ...\n  |                                          ^^^^^^^--\n  |                                          |      |\n  |                                          |      help: a similar name exists in the module: `dbg`\n  |                                          no `db` in the root\n\nerror[E0432]: unresolved import `std::perf`\n --> /tmp/.tmpVLMkqc/main.rs:1:1455\n  |\n1 | ... unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect (\"postgres://localhost/myapp\") ; databa...\n  |                                                      ^^^^^^^^^^^ no `perf` in the root\n\nerror[E0425]: cannot find value `database` in this scope\n --> /tmp/.tmpVLMkqc/main.rs:1:216\n  |\n1 | ...:: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! (\"{}\" , \"Query: \" + sql) ; println ! (\"{}\" ,...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `database` in this scope\n --> /tmp/.tmpVLMkqc/main.rs:1:627\n  |\n1 | ..., where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ;...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `database` in this scope\n --> /tmp/.tmpVLMkqc/main.rs:1:992\n  |\n1 | ...fn get_users_with_posts_naive () { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = d...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `database` in this scope\n --> /tmp/.tmpVLMkqc/main.rs:1:1074\n  |\n1 | ...M users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `database` in this scope\n --> /tmp/.tmpVLMkqc/main.rs:1:1228\n  |\n1 | ... } fn get_users_with_posts_optimized () { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JO...\n  |                                                       ^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpVLMkqc/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: f...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpVLMkqc/main.rs:1:201\n  |\n1 | ... { { { let plan = database . explain (sql) ; { println ! (\"{}\" , \"Query: \" + sql) ; println ! (\"{}\" , \"Execution plan: \" + plan) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" + pattern . example) ; println ! (\"Consider using JOIN or batch loading\") } } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! (\"{}\" , \"Query: \" + sql) ; println ! (\"{}\" , \"Execution plan: \" + plan) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" + pattern . example) ; println ! (\"Consider using JOIN or batch loading\") } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect (\"postgres://localhost/myapp\") ; database . log_queries (true) ; let naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {{naive_time / optimized_time:.1}}x faster\") ; }\n1 + use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { let plan = database . explain (sql) ; { println ! (\"{}\" , \"Query: \" + sql) ; println ! (\"{}\" , \"Execution plan: \" + plan) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" + pattern . example) ; println ! (\"Consider using JOIN or batch loading\") } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect (\"postgres://localhost/myapp\") ; database . log_queries (true) ; let naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {{naive_time / optimized_time:.1}}x faster\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpVLMkqc/main.rs:1:737\n  |\n1 | ... { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" + pattern . example) ; println ! (\"Consider using JOIN or batch loading\") } } } } ...\n  |       ^^                                                                                                                                                                                             ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! (\"{}\" , \"Query: \" + sql) ; println ! (\"{}\" , \"Execution plan: \" + plan) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" + pattern . example) ; println ! (\"Consider using JOIN or batch loading\") } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect (\"postgres://localhost/myapp\") ; database . log_queries (true) ; let naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {{naive_time / optimized_time:.1}}x faster\") ; }\n1 + use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! (\"{}\" , \"Query: \" + sql) ; println ! (\"{}\" , \"Execution plan: \" + plan) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" + pattern . example) ; println ! (\"Consider using JOIN or batch loading\") } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect (\"postgres://localhost/myapp\") ; database . log_queries (true) ; let naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {{naive_time / optimized_time:.1}}x faster\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpVLMkqc/main.rs:1:976\n  |\n1 | ... { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } ...\n  |       ^^                                                                                                                                                                                                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! (\"{}\" , \"Query: \" + sql) ; println ! (\"{}\" , \"Execution plan: \" + plan) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" + pattern . example) ; println ! (\"Consider using JOIN or batch loading\") } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect (\"postgres://localhost/myapp\") ; database . log_queries (true) ; let naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {{naive_time / optimized_time:.1}}x faster\") ; }\n1 + use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! (\"{}\" , \"Query: \" + sql) ; println ! (\"{}\" , \"Execution plan: \" + plan) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" + pattern . example) ; println ! (\"Consider using JOIN or batch loading\") } } } } } } } } fn get_users_with_posts_naive () { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } fn get_users_with_posts_optimized () { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect (\"postgres://localhost/myapp\") ; database . log_queries (true) ; let naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {{naive_time / optimized_time:.1}}x faster\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpVLMkqc/main.rs:1:1057\n  |\n1 | ...r user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users }...\n  |                      ^^                                                                                             ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! (\"{}\" , \"Query: \" + sql) ; println ! (\"{}\" , \"Execution plan: \" + plan) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" + pattern . example) ; println ! (\"Consider using JOIN or batch loading\") } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect (\"postgres://localhost/myapp\") ; database . log_queries (true) ; let naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {{naive_time / optimized_time:.1}}x faster\") ; }\n1 + use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! (\"{}\" , \"Query: \" + sql) ; println ! (\"{}\" , \"Execution plan: \" + plan) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" + pattern . example) ; println ! (\"Consider using JOIN or batch loading\") } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect (\"postgres://localhost/myapp\") ; database . log_queries (true) ; let naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {{naive_time / optimized_time:.1}}x faster\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpVLMkqc/main.rs:1:1219\n  |\n1 | ... { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } ...\n  |       ^^                                                                                                                                                                                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! (\"{}\" , \"Query: \" + sql) ; println ! (\"{}\" , \"Execution plan: \" + plan) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" + pattern . example) ; println ! (\"Consider using JOIN or batch loading\") } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect (\"postgres://localhost/myapp\") ; database . log_queries (true) ; let naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {{naive_time / optimized_time:.1}}x faster\") ; }\n1 + use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! (\"{}\" , \"Query: \" + sql) ; println ! (\"{}\" , \"Execution plan: \" + plan) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" + pattern . example) ; println ! (\"Consider using JOIN or batch loading\") } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect (\"postgres://localhost/myapp\") ; database . log_queries (true) ; let naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {{naive_time / optimized_time:.1}}x faster\") ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpVLMkqc/main.rs:1:1449\n  |\n1 | ...(& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect (\"postgres://localhost/myapp\") ...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpVLMkqc/main.rs:1:1469\n  |\n1 | ... } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect (\"postgres://localhost/myapp\") ; database . log_que...\n  |                                                        ^ help: remove this semicolon\n\nerror[E0369]: cannot add `T` to `&str`\n --> /tmp/.tmpVLMkqc/main.rs:1:273\n  |\n1 | ...let plan = database . explain (sql) ; { println ! (\"{}\" , \"Query: \" + sql) ; println ! (\"{}\" , \"Execution plan: \" + plan) ; if plan . ...\n  |                                                              --------- ^ --- T\n  |                                                              |\n  |                                                              &str\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpVLMkqc/main.rs:1:300\n  |\n1 | ...Query: \" + sql) ; println ! (\"{}\" , \"Execution plan: \" + plan) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential...\n  |                                  --    ^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                                  |\n  |                                  required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `extract_table` in this scope\n --> /tmp/.tmpVLMkqc/main.rs:1:455\n  |\n1 | ...ected - consider adding index\") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! (\"Suggested...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `extract_where` in this scope\n --> /tmp/.tmpVLMkqc/main.rs:1:498\n  |\n1 | ...le = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `find_patterns` in this scope\n --> /tmp/.tmpVLMkqc/main.rs:1:683\n  |\n1 | ... . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && ...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpVLMkqc/main.rs:1:809\n  |\n1 | ...println ! (\"{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" + pattern . example) ; println ! (\"Consider using JOIN or batch loading\") ...\n  |                --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                |\n  |                required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpVLMkqc/main.rs:1:711\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! (\"{}\" , \"Query: \" + sql) ; println ! (\"{}\" , \"Execution plan: \" + plan) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" + pattern . example) ; println ! (\"Consider using JOIN or batch loading\") } } } } } ...\n  |       - expected this type parameter                                                                                                               - expected `T` because of return type                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: the caller chooses a type for `T` which can be different from `()`\n  = note: `for` loops evaluate to unit type `()`\nhelp: consider returning a value here\n  |\n1 | use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! (\"{}\" , \"Query: \" + sql) ; println ! (\"{}\" , \"Execution plan: \" + plan) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let query_log = database . get_recent_queries (100i32) ; let patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" + pattern . example) ; println ! (\"Consider using JOIN or batch loading\") } } } } /* `T` value */ } } } } fn get_users_with_posts_naive () { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let database = db :: connect (\"postgres://localhost/myapp\") ; database . log_queries (true) ; let naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {{naive_time / optimized_time:.1}}x faster\") ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     +++++++++++++++\n\nerror: aborting due to 14 previous errors; 8 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0369, E0425, E0432.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "IMPORT_ERROR",
          "rootCause": "Missing dependency or import path issue"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 9,
          "line_number": 609,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: ColonColon\n// File: web_server_optimization.ruchy\n// High-performance web server\n\nuse std::net::http;\nuse std::cache;\n\nlet app = http::Server::new(\"0.0.0.0:8080\")\n\n// Response caching\nlet response_cache = cache::LRU::new(1000)\n\napp.use(|req, res, next| {\n    let cache_key = req.method + \":\" + req.path + \":\" + req.query_string\n    \n    if req.method == \"GET\" && response_cache.has(cache_key) {\n        let cached = response_cache.get(cache_key)\n        return res\n            .status(200)\n            .header(\"X-Cache\", \"HIT\")\n            .send(cached)\n    }\n    \n    // Capture response for caching\n    let original_send = res.send\n    res.send = |body| {\n        if req.method == \"GET\" && res.status == 200 {\n            response_cache.set(cache_key, body, ttl: 60)\n        }\n        original_send(body)\n    }\n    \n    next()\n})\n\n// Static file serving with ETags\napp.static(\"/static\", \"./public\", {\n    maxAge: 86400,  // 1 day\n    etag: true,\n    gzip: true\n})\n\n// Database connection pooling\nlet db_pool = ConnectionPool::new(\n    url: \"postgres://localhost/myapp\",\n    min: 5,\n    max: 20\n)\n\n// Async request handling\napp.get(\"/api/data\", async |req, res| {\n    let conn = db_pool.acquire().await()\n    let data = conn.query(\"SELECT * FROM data\").await()\n    db_pool.release(conn)\n    \n    res.json(data)\n})\n\n// Enable HTTP/2\napp.enable_http2()\n\n// Compression middleware\napp.use(compression({\n    level: 6,\n    threshold: 1024,  // Only compress > 1KB\n    types: [\"text/*\", \"application/json\", \"application/javascript\"]\n}))\n\nprintln(\"🚀 Optimized server running with:\")\nprintln(\"  • Response caching\")\nprintln(\"  • Connection pooling\")  \nprintln(\"  • HTTP/2 support\")\nprintln(\"  • Gzip compression\")\n\napp.listen()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 10,
          "line_number": 694,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: ColonColon\n// File: data_pipeline_optimization.ruchy\n// Optimize large-scale data processing\n\nuse std::parallel;\nuse std::stream;\n\nfun process_dataset(input_file, output_file) {\n    let start = perf::Timer::start()\n    \n    // Stream processing to avoid loading all data\n    let input = stream::FileStream::new(input_file)\n    let output = stream::FileWriter::new(output_file)\n    \n    input\n        // Parse in parallel\n        .parallel_map(|line| {\n            parse_record(line)\n        }, workers: num_cpus())\n        \n        // Filter early to reduce data\n        .filter(|record| {\n            record.is_valid() && record.value > threshold\n        })\n        \n        // Batch for efficient processing\n        .batch(1000)\n        \n        // Process batches in parallel\n        .parallel_map(|batch| {\n            let enriched = enrich_batch(batch)\n            let transformed = transform_batch(enriched)\n            return transformed\n        })\n        \n        // Flatten batches\n        .flatten()\n        \n        // Write with buffering\n        .for_each(|record| {\n            output.write_line(to_json(record))\n        })\n    \n    let duration = start.elapsed()\n    let records = input.count()\n    let throughput = records / duration.seconds()\n    \n    println(\"Processed \" + records.to_s() + \" records in \" + duration.to_s())\n    println(f\"Throughput: {throughput:.0} records/second\")\n}\n\n// Monitor performance\nlet monitor = perf::Monitor::new()\n\nmonitor.track(\"cpu_usage\", || system::cpu_usage())\nmonitor.track(\"memory_usage\", || system::memory_usage())\nmonitor.track(\"disk_io\", || system::disk_io_rate())\n\nprocess_dataset(\"input.jsonl\", \"output.jsonl\")\n\nmonitor.report()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 11,
          "line_number": 767,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: ColonColon\n// 1. Measure first\nperf::profile {\n    suspicious_function()\n}\n\n// 2. Optimize the right thing\n// Focus on the bottleneck, not random code\n\n// 3. Use the right algorithm\n// O(n) beats O(n²) even with overhead\n\n// 4. Batch operations\n// 1 operation on 1000 items > 1000 operations on 1 item\n\n// 5. Cache expensive computations\nlet cache = memoize(expensive_function)\n\n// 6. Parallelize independent work\nparallel::map(items, process)\n\n// 7. Use async for I/O\nasync::wait_all(io_operations)\n\n// 8. Profile in production\n// Dev performance ≠ Production performance",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch04-00-modules-tdd": {
      "chapter": "ch04-00-modules-tdd",
      "total_examples": 6,
      "working_examples": 2,
      "failing_examples": 4,
      "examples": [
        {
          "file": "src/ch04-00-modules-tdd.md",
          "example_number": 1,
          "line_number": 17,
          "code": "mod math {\n    pub fun add(a: i32, b: i32) -> i32 {\n        a + b\n    }\n}\n\nfun main() {\n    let result = math::add(5, 3);\n    println(result);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-modules-tdd.md",
          "example_number": 2,
          "line_number": 39,
          "code": "mod utils {\n    pub fun greet() {\n        println(\"Hello from module!\");\n    }\n}\n\nfun main() {\n    utils::greet();\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-modules-tdd.md",
          "example_number": 3,
          "line_number": 76,
          "code": "mod module_name {\n    pub fun public_function() {\n        // Accessible from outside\n    }\n    \n    fun private_function() {\n        // Only accessible within module\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected expression, found keyword `mod`\n --> /tmp/.tmp3R83VK/main.rs:1:63\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = mod module_name { { pub fn public_function () { () } ; fn private_function ...\n  |                                                               ^^^ expected expression\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp3R83VK/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = mod module_name { { pub fn public_function () { () } ; fn private_function ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-modules-tdd.md",
          "example_number": 4,
          "line_number": 89,
          "code": "fun main() {\n    module_name::public_function();  // Works\n    // module_name::private_function();  // Would fail - not public\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp5mz1D1/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5mz1D1/main.rs:1:50\n  |\n1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }\n  |                                                  ^^                                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }\n1 + use std :: collections :: HashMap ; fn main () { module_name :: public_function () }\n  |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `module_name`\n --> /tmp/.tmp5mz1D1/main.rs:1:52\n  |\n1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }\n  |                                                    ^^^^^^^^^^^ use of unresolved module or unlinked crate `module_name`\n  |\n  = help: you might be missing a crate named `module_name`\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0433`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-modules-tdd.md",
          "example_number": 5,
          "line_number": 113,
          "code": "mod math {\n    pub fun add(a: i32, b: i32) -> i32 { a + b }\n    pub fun subtract(a: i32, b: i32) -> i32 { a - b }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected expression, found keyword `mod`\n --> /tmp/.tmpy0INfR/main.rs:1:63\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = mod math { { pub fn add (a : i32 , b : i32) -> i32 { { a + b } } ; pub fn s...\n  |                                                               ^^^ expected expression\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpy0INfR/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = mod math { { pub fn add (a : i32 , b : i32) -> i32 { { a + b } } ; pub fn s...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-modules-tdd.md",
          "example_number": 6,
          "line_number": 122,
          "code": "mod strings {\n    pub fun greet() { println(\"Hello!\"); }\n    pub fun farewell() { println(\"Goodbye!\"); }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected expression, found keyword `mod`\n --> /tmp/.tmphQzXgD/main.rs:1:63\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = mod strings { { pub fn greet () { { println ! (\"Hello!\") } } ; pub fn farew...\n  |                                                               ^^^ expected expression\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmphQzXgD/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = mod strings { { pub fn greet () { { println ! (\"Hello!\") } } ; pub fn farew...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch09-00-collections-tdd": {
      "chapter": "ch09-00-collections-tdd",
      "total_examples": 10,
      "working_examples": 4,
      "failing_examples": 6,
      "examples": [
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 1,
          "line_number": 17,
          "code": "fun main() {\n    println(\"Counting to 5:\");\n    for i in 0..5 {\n        println(i);\n    }\n    println(\"Done counting\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 2,
          "line_number": 42,
          "code": "fun main() {\n    let mut sum = 0;\n    let mut i = 1;\n    while i <= 5 {\n        sum = sum + i;\n        i = i + 1;\n    }\n    println(\"Sum of 1-5:\");\n    println(sum);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 3,
          "line_number": 65,
          "code": "fun main() {\n    println(\"Pattern:\");\n    for row in 0..3 {\n        for col in 0..3 {\n            if (row + col) % 2 == 0 {\n                print(\"*\");\n            } else {\n                print(\" \");\n            }\n        }\n        println(\"\");\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 4,
          "line_number": 110,
          "code": "for variable in start..end {\n    // Process each value\n    println(variable);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `start` in this scope\n --> /tmp/.tmp8VZSnR/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! (\"{}\" , variable) } } ; if let S...\n  |                                                                               ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `end` in this scope\n --> /tmp/.tmp8VZSnR/main.rs:1:88\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! (\"{}\" , variable) } } ; if let S...\n  |                                                                                        ^^^ not found in this scope\n  |\nhelp: you might have meant to write `.` instead of `..`\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! (\"{}\" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for variable in start.end { { println ! (\"{}\" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp8VZSnR/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! (\"{}\" , variable) } } ; if let S...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp8VZSnR/main.rs:1:94\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! (\"{}\" , variable) } } ; if let S...\n  |                                                                                              ^^                           ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! (\"{}\" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { println ! (\"{}\" , variable) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 5,
          "line_number": 118,
          "code": "let mut accumulator = initial_value;\nlet mut counter = start;\nwhile counter <= end {\n    accumulator = update(accumulator, counter);\n    counter = counter + 1;\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `initial_value` in this scope\n --> /tmp/.tmpVEbFPD/main.rs:1:87\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut accumulator = initial_value ; let mut counter = start ; while cou...\n  |                                                                                       ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `start` in this scope\n --> /tmp/.tmpVEbFPD/main.rs:1:121\n  |\n1 | ...mut accumulator = initial_value ; let mut counter = start ; while counter <= end { { accumulator = update (accumulator , counter) ; co...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `end` in this scope\n --> /tmp/.tmpVEbFPD/main.rs:1:146\n  |\n1 | ...l_value ; let mut counter = start ; while counter <= end { { accumulator = update (accumulator , counter) ; counter = counter + 1i32 }...\n  |                                                         ^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpVEbFPD/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut accumulator = initial_value ; let mut counter = start ; while cou...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `update` in this scope\n --> /tmp/.tmpVEbFPD/main.rs:1:168\n  |\n1 | ...er = start ; while counter <= end { { accumulator = update (accumulator , counter) ; counter = counter + 1i32 } } } ; if let Some (s) ...\n  |                                                        ^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 6,
          "line_number": 128,
          "code": "for outer in 0..height {\n    for inner in 0..width {\n        // Process (outer, inner) coordinate\n        process(outer, inner);\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `height` in this scope\n --> /tmp/.tmp1k3RHR/main.rs:1:84\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (out...\n  |                                                                                    ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `width` in this scope\n --> /tmp/.tmp1k3RHR/main.rs:1:116\n  |\n1 | ...or outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn s...\n  |                                                        ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp1k3RHR/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (out...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp1k3RHR/main.rs:1:93\n  |\n1 | ...ult = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as ...\n  |                                        ^^                                                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { for inner in 0i32 .. width { { process (outer , inner) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp1k3RHR/main.rs:1:124\n  |\n1 | ...r in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: a...\n  |                                                         ^^                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { process (outer , inner) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `process` in this scope\n --> /tmp/.tmp1k3RHR/main.rs:1:126\n  |\n1 | ... 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 7,
          "line_number": 152,
          "code": "for i in 1..10 {\n    let result = process(i);\n    println(result);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpPdNVlo/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! (\"{}\" , r...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpPdNVlo/main.rs:1:88\n  |\n1 | ...et result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! (\"{}\" , result) } } } ; if let Some (s) = (& result as &...\n  |                                         ^^                                                        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! (\"{}\" , result) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { let result = process (i) ; println ! (\"{}\" , result) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `process` in this scope\n --> /tmp/.tmpPdNVlo/main.rs:1:105\n  |\n1 | ...result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! (\"{}\" , result) } } } ; if let Some (s) = (& result as & dy...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 8,
          "line_number": 160,
          "code": "let mut total = 0;\nfor value in 1..100 {\n    total = total + value;\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 9,
          "line_number": 168,
          "code": "for row in 0..height {\n    for col in 0..width {\n        let value = calculate(row, col);\n        display(value);\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `height` in this scope\n --> /tmp/.tmpY3IgfC/main.rs:1:82\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = ca...\n  |                                                                                  ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `width` in this scope\n --> /tmp/.tmpY3IgfC/main.rs:1:112\n  |\n1 | ... = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let...\n  |                                                        ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpY3IgfC/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = ca...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpY3IgfC/main.rs:1:91\n  |\n1 | ... in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) ...\n  |                         ^^                                                                                        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpY3IgfC/main.rs:1:120\n  |\n1 | ...eight { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result a...\n  |                                         ^^                                                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { let value = calculate (row , col) ; display (value) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `calculate` in this scope\n --> /tmp/.tmpY3IgfC/main.rs:1:136\n  |\n1 | ...ht { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as &...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `display` in this scope\n --> /tmp/.tmpY3IgfC/main.rs:1:160\n  |\n1 | ..... width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any)...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 10,
          "line_number": 178,
          "code": "let mut count = 0;\nfor i in 1..100 {\n    if condition(i) {\n        count = count + 1;\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpaOccxZ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { c...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpaOccxZ/main.rs:1:114\n  |\n1 | ... count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & dyn...\n  |                                              ^^                                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { if condition (i) { { count = count + 1i32 } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpaOccxZ/main.rs:1:135\n  |\n1 | ... 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & dyn std :: ...\n  |                                                           ^^                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { count = count + 1i32 } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `condition` in this scope\n --> /tmp/.tmpaOccxZ/main.rs:1:119\n  |\n1 | ...mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 1 previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch19-00-real-world-projects": {
      "chapter": "ch19-00-real-world-projects",
      "total_examples": 4,
      "working_examples": 0,
      "failing_examples": 4,
      "examples": [
        {
          "file": "src/ch19-00-real-world-projects.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected type\n// taskmaster.ruchy - Complete task management system\nuse std::cli::{App, Arg, SubCommand};\nuse std::fs;\nuse std::chrono::{DateTime, Local};\n\n#[derive(Serialize, Deserialize, Clone)]\nstruct Task {\n    id: String,\n    title: String,\n    description: Option<String>,\n    status: TaskStatus,\n    priority: Priority,\n    due_date: Option<DateTime<Local>>,\n    tags: Vec<String>,\n    created_at: DateTime<Local>,\n    completed_at: Option<DateTime<Local>>,\n}\n\n#[derive(Serialize, Deserialize, Clone)]\nenum TaskStatus {\n    Todo,\n    InProgress,\n    Done,\n    Archived\n}\n\n#[derive(Serialize, Deserialize, Clone)]\nenum Priority {\n    Low,\n    Medium,\n    High,\n    Critical\n}\n\nstruct TaskStore {\n    path: PathBuf,\n    tasks: Vec<Task>,\n}\n\nimpl TaskStore {\n    fun load(path: PathBuf) -> Result<Self> {\n        let tasks = if path.exists() {\n            let content = fs::read_to_string(&path)?;\n            serde_json::from_str(&content)?\n        } else {\n            Vec::new()\n        };\n        \n        Ok(TaskStore { path, tasks })\n    }\n    \n    fun save(&self) -> Result<()> {\n        let json = serde_json::to_string_pretty(&self.tasks)?;\n        fs::write(&self.path, json)?;\n        Ok(())\n    }\n    \n    fun add(&mut self, task: Task) -> Result<()> {\n        self.tasks.push(task);\n        self.save()\n    }\n    \n    fun find(&self, id: &str) -> Option<&Task> {\n        self.tasks.iter().find(|t| t.id == id)\n    }\n    \n    fun update<F>(&mut self, id: &str, updater: F) -> Result<()>\n    where F: FnOnce(&mut Task)\n    {\n        if let Some(task) = self.tasks.iter_mut().find(|t| t.id == id) {\n            updater(task);\n            self.save()?;\n        }\n        Ok(())\n    }\n    \n    fun list(&self, filter: Option<TaskFilter>) -> Vec<&Task> {\n        self.tasks.iter()\n            .filter(|t| {\n                if let Some(ref f) = filter {\n                    f.matches(t)\n                } else {\n                    true\n                }\n            })\n            .collect()\n    }\n}\n\nstruct TaskFilter {\n    status: Option<TaskStatus>,\n    priority: Option<Priority>,\n    tags: Vec<String>,\n    search: Option<String>,\n}\n\nimpl TaskFilter {\n    fun matches(&self, task: &Task) -> bool {\n        if let Some(ref status) = self.status {\n            if task.status != *status {\n                return false;\n            }\n        }\n        \n        if let Some(ref priority) = self.priority {\n            if task.priority != *priority {\n                return false;\n            }\n        }\n        \n        if !self.tags.is_empty() {\n            if !self.tags.iter().any(|tag| task.tags.contains(tag)) {\n                return false;\n            }\n        }\n        \n        if let Some(ref search) = self.search {\n            let search_lower = search.to_lowercase();\n            if !task.title.to_lowercase().contains(&search_lower) &&\n               !task.description.as_ref()\n                   .map(|d| d.to_lowercase().contains(&search_lower))\n                   .unwrap_or(false) {\n                return false;\n            }\n        }\n        \n        true\n    }\n}\n\nfun main() -> Result<()> {\n    let app = App::new(\"taskmaster\")\n        .version(\"1.0.0\")\n        .author(\"Your Name\")\n        .about(\"Powerful task management from the command line\")\n        .subcommand(\n            SubCommand::with_name(\"add\")\n                .about(\"Add a new task\")\n                .arg(Arg::with_name(\"title\").required(true))\n                .arg(Arg::with_name(\"description\").short(\"d\").takes_value(true))\n                .arg(Arg::with_name(\"priority\").short(\"p\").takes_value(true))\n                .arg(Arg::with_name(\"due\").long(\"due\").takes_value(true))\n                .arg(Arg::with_name(\"tags\").short(\"t\").multiple(true))\n        )\n        .subcommand(\n            SubCommand::with_name(\"list\")\n                .about(\"List tasks\")\n                .arg(Arg::with_name(\"status\").short(\"s\").takes_value(true))\n                .arg(Arg::with_name(\"priority\").short(\"p\").takes_value(true))\n                .arg(Arg::with_name(\"tags\").short(\"t\").multiple(true))\n        )\n        .subcommand(\n            SubCommand::with_name(\"done\")\n                .about(\"Mark task as done\")\n                .arg(Arg::with_name(\"id\").required(true))\n        )\n        .get_matches();\n    \n    let store_path = dirs::home_dir()\n        .unwrap()\n        .join(\".taskmaster\")\n        .join(\"tasks.json\");\n    \n    let mut store = TaskStore::load(store_path)?;\n    \n    match app.subcommand() {\n        (\"add\", Some(matches)) => {\n            let task = Task {\n                id: generate_id(),\n                title: matches.value_of(\"title\").unwrap().to_string(),\n                description: matches.value_of(\"description\").map(String::from),\n                status: TaskStatus::Todo,\n                priority: matches.value_of(\"priority\")\n                    .and_then(|p| p.parse().ok())\n                    .unwrap_or(Priority::Medium),\n                due_date: matches.value_of(\"due\")\n                    .and_then(|d| parse_date(d).ok()),\n                tags: matches.values_of(\"tags\")\n                    .map(|tags| tags.map(String::from).collect())\n                    .unwrap_or_default(),\n                created_at: Local::now(),\n                completed_at: None,\n            };\n            \n            store.add(task)?;\n            println!(\"✅ Task added successfully!\");\n        }\n        \n        (\"list\", Some(matches)) => {\n            let filter = TaskFilter {\n                status: matches.value_of(\"status\").and_then(|s| s.parse().ok()),\n                priority: matches.value_of(\"priority\").and_then(|p| p.parse().ok()),\n                tags: matches.values_of(\"tags\")\n                    .map(|tags| tags.map(String::from).collect())\n                    .unwrap_or_default(),\n                search: None,\n            };\n            \n            let tasks = store.list(Some(filter));\n            \n            for task in tasks {\n                let status_emoji = match task.status {\n                    TaskStatus::Todo => \"⬜\",\n                    TaskStatus::InProgress => \"🔄\",\n                    TaskStatus::Done => \"✅\",\n                    TaskStatus::Archived => \"📦\",\n                };\n                \n                let priority_marker = match task.priority {\n                    Priority::Critical => \"🔴\",\n                    Priority::High => \"🟠\",\n                    Priority::Medium => \"🟡\",\n                    Priority::Low => \"🟢\",\n                };\n                \n                println!(\"{} {} {} {}\", \n                    status_emoji, \n                    priority_marker,\n                    task.id[..8].to_string(),\n                    task.title\n                );\n                \n                if let Some(ref desc) = task.description {\n                    println!(\"    {}\", desc);\n                }\n                \n                if !task.tags.is_empty() {\n                    println!(\"    Tags: {}\", task.tags.join(\", \"));\n                }\n            }\n        }\n        \n        (\"done\", Some(matches)) => {\n            let id = matches.value_of(\"id\").unwrap();\n            store.update(id, |task| {\n                task.status = TaskStatus::Done;\n                task.completed_at = Some(Local::now());\n            })?;\n            println!(\"✅ Task marked as done!\");\n        }\n        \n        _ => {\n            println!(\"Use --help for usage information\");\n        }\n    }\n    \n    Ok(())\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch19-00-real-world-projects.md",
          "example_number": 2,
          "line_number": 291,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected RightBrace, found ColonColon\n// api_server.ruchy - Complete web service\nuse warp::{Filter, Reply, Rejection};\nuse sqlx::{PgPool, FromRow};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Deserialize, Serialize, FromRow)]\nstruct User {\n    id: i32,\n    username: String,\n    email: String,\n    created_at: chrono::DateTime<chrono::Utc>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct CreateUser {\n    username: String,\n    email: String,\n    password: String,\n}\n\n#[derive(Clone)]\nstruct AppState {\n    db: PgPool,\n    jwt_secret: String,\n}\n\nasync fun create_user(\n    user: CreateUser,\n    state: AppState,\n) -> Result<impl Reply, Rejection> {\n    let hashed_password = hash_password(&user.password)?;\n    \n    let result = sqlx::query_as!(\n        User,\n        r#\"\n        INSERT INTO users (username, email, password_hash)\n        VALUES ($1, $2, $3)\n        RETURNING id, username, email, created_at\n        \"#,\n        user.username,\n        user.email,\n        hashed_password\n    )\n    .fetch_one(&state.db)\n    .await\n    .map_err(|e| reject::custom(DatabaseError(e)))?;\n    \n    Ok(warp::reply::json(&result))\n}\n\nasync fun get_user(\n    id: i32,\n    state: AppState,\n) -> Result<impl Reply, Rejection> {\n    let user = sqlx::query_as!(\n        User,\n        \"SELECT id, username, email, created_at FROM users WHERE id = $1\",\n        id\n    )\n    .fetch_one(&state.db)\n    .await\n    .map_err(|e| reject::custom(DatabaseError(e)))?;\n    \n    Ok(warp::reply::json(&user))\n}\n\nasync fun list_users(\n    state: AppState,\n) -> Result<impl Reply, Rejection> {\n    let users = sqlx::query_as!(\n        User,\n        \"SELECT id, username, email, created_at FROM users ORDER BY created_at DESC\"\n    )\n    .fetch_all(&state.db)\n    .await\n    .map_err(|e| reject::custom(DatabaseError(e)))?;\n    \n    Ok(warp::reply::json(&users))\n}\n\nfun with_state(\n    state: AppState,\n) -> impl Filter<Extract = (AppState,), Error = Infallible> + Clone {\n    warp::any().map(move || state.clone())\n}\n\nfun routes(state: AppState) -> impl Filter<Extract = impl Reply> + Clone {\n    let users_create = warp::path(\"users\")\n        .and(warp::post())\n        .and(warp::body::json())\n        .and(with_state(state.clone()))\n        .and_then(create_user);\n    \n    let users_get = warp::path!(\"users\" / i32)\n        .and(warp::get())\n        .and(with_state(state.clone()))\n        .and_then(get_user);\n    \n    let users_list = warp::path(\"users\")\n        .and(warp::get())\n        .and(with_state(state.clone()))\n        .and_then(list_users);\n    \n    let health = warp::path(\"health\")\n        .and(warp::get())\n        .map(|| \"OK\");\n    \n    users_create\n        .or(users_get)\n        .or(users_list)\n        .or(health)\n        .with(warp::cors().allow_any_origin())\n        .with(warp::log(\"api\"))\n        .recover(handle_rejection)\n}\n\nasync fun handle_rejection(err: Rejection) -> Result<impl Reply, Infallible> {\n    let code;\n    let message;\n    \n    if err.is_not_found() {\n        code = StatusCode::NOT_FOUND;\n        message = \"Not Found\";\n    } else if let Some(DatabaseError(_)) = err.find() {\n        code = StatusCode::INTERNAL_SERVER_ERROR;\n        message = \"Database Error\";\n    } else {\n        code = StatusCode::INTERNAL_SERVER_ERROR;\n        message = \"Internal Server Error\";\n    }\n    \n    let json = warp::reply::json(&ErrorResponse {\n        message: message.to_string(),\n    });\n    \n    Ok(warp::reply::with_status(json, code))\n}\n\n#[tokio::main]\nasync fun main() -> Result<()> {\n    env_logger::init();\n    \n    let database_url = env::var(\"DATABASE_URL\")\n        .expect(\"DATABASE_URL must be set\");\n    \n    let pool = PgPool::connect(&database_url).await?;\n    \n    // Run migrations\n    sqlx::migrate!(\"./migrations\").run(&pool).await?;\n    \n    let state = AppState {\n        db: pool,\n        jwt_secret: env::var(\"JWT_SECRET\")\n            .expect(\"JWT_SECRET must be set\"),\n    };\n    \n    let routes = routes(state);\n    \n    println!(\"🚀 Server running on http://localhost:3030\");\n    \n    warp::serve(routes)\n        .run(([0, 0, 0, 0], 3030))\n        .await;\n    \n    Ok(())\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch19-00-real-world-projects.md",
          "example_number": 3,
          "line_number": 470,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected ',' or '}' in import list\n// sysmon.ruchy - System monitoring dashboard\nuse sysinfo::{System, SystemExt, ProcessExt, CpuExt};\nuse tui::{Terminal, Frame, backend::CrosstermBackend};\nuse crossterm::event::{self, Event, KeyCode};\n\nstruct App {\n    system: System,\n    cpu_history: Vec<f32>,\n    memory_history: Vec<f32>,\n    selected_process: Option<usize>,\n    processes: Vec<ProcessInfo>,\n}\n\n#[derive(Clone)]\nstruct ProcessInfo {\n    pid: u32,\n    name: String,\n    cpu_usage: f32,\n    memory: u64,\n    status: String,\n}\n\nimpl App {\n    fun new() -> Self {\n        let mut system = System::new_all();\n        system.refresh_all();\n        \n        App {\n            system,\n            cpu_history: Vec::with_capacity(60),\n            memory_history: Vec::with_capacity(60),\n            selected_process: None,\n            processes: Vec::new(),\n        }\n    }\n    \n    fun update(&mut self) {\n        self.system.refresh_all();\n        \n        // Update CPU history\n        let cpu_usage = self.system.global_cpu_info().cpu_usage();\n        self.cpu_history.push(cpu_usage);\n        if self.cpu_history.len() > 60 {\n            self.cpu_history.remove(0);\n        }\n        \n        // Update memory history\n        let used_memory = self.system.used_memory();\n        let total_memory = self.system.total_memory();\n        let memory_usage = (used_memory as f32 / total_memory as f32) * 100.0;\n        self.memory_history.push(memory_usage);\n        if self.memory_history.len() > 60 {\n            self.memory_history.remove(0);\n        }\n        \n        // Update process list\n        self.processes = self.system.processes()\n            .iter()\n            .map(|(pid, process)| ProcessInfo {\n                pid: pid.as_u32(),\n                name: process.name().to_string(),\n                cpu_usage: process.cpu_usage(),\n                memory: process.memory(),\n                status: format!(\"{:?}\", process.status()),\n            })\n            .collect();\n        \n        // Sort by CPU usage\n        self.processes.sort_by(|a, b| \n            b.cpu_usage.partial_cmp(&a.cpu_usage).unwrap()\n        );\n    }\n    \n    fun draw(&self, frame: &mut Frame<impl Backend>) {\n        let chunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Length(3),\n                Constraint::Percentage(30),\n                Constraint::Percentage(30),\n                Constraint::Percentage(40),\n            ])\n            .split(frame.size());\n        \n        // Header\n        let header = Paragraph::new(\"System Monitor - Press 'q' to quit\")\n            .style(Style::default().fg(Color::Cyan))\n            .block(Block::default().borders(Borders::ALL));\n        frame.render_widget(header, chunks[0]);\n        \n        // CPU Chart\n        let cpu_data: Vec<(f64, f64)> = self.cpu_history\n            .iter()\n            .enumerate()\n            .map(|(i, &val)| (i as f64, val as f64))\n            .collect();\n        \n        let cpu_chart = Chart::new(vec![\n            Dataset::default()\n                .name(\"CPU\")\n                .marker(symbols::Marker::Dot)\n                .style(Style::default().fg(Color::Yellow))\n                .data(&cpu_data),\n        ])\n        .block(Block::default().title(\"CPU Usage\").borders(Borders::ALL))\n        .x_axis(Axis::default()\n            .bounds([0.0, 60.0])\n            .labels(vec![\"60s\", \"30s\", \"Now\"]))\n        .y_axis(Axis::default()\n            .bounds([0.0, 100.0])\n            .labels(vec![\"0%\", \"50%\", \"100%\"]));\n        \n        frame.render_widget(cpu_chart, chunks[1]);\n        \n        // Memory Chart\n        let memory_data: Vec<(f64, f64)> = self.memory_history\n            .iter()\n            .enumerate()\n            .map(|(i, &val)| (i as f64, val as f64))\n            .collect();\n        \n        let memory_chart = Chart::new(vec![\n            Dataset::default()\n                .name(\"Memory\")\n                .marker(symbols::Marker::Dot)\n                .style(Style::default().fg(Color::Blue))\n                .data(&memory_data),\n        ])\n        .block(Block::default().title(\"Memory Usage\").borders(Borders::ALL))\n        .x_axis(Axis::default()\n            .bounds([0.0, 60.0])\n            .labels(vec![\"60s\", \"30s\", \"Now\"]))\n        .y_axis(Axis::default()\n            .bounds([0.0, 100.0])\n            .labels(vec![\"0%\", \"50%\", \"100%\"]));\n        \n        frame.render_widget(memory_chart, chunks[2]);\n        \n        // Process List\n        let processes: Vec<ListItem> = self.processes\n            .iter()\n            .take(10)\n            .map(|p| {\n                let content = format!(\"{:5} {:20} {:6.1}% {:8}\",\n                    p.pid,\n                    p.name,\n                    p.cpu_usage,\n                    format_bytes(p.memory)\n                );\n                ListItem::new(content)\n            })\n            .collect();\n        \n        let process_list = List::new(processes)\n            .block(Block::default()\n                .title(\"Top Processes (PID | Name | CPU | Memory)\")\n                .borders(Borders::ALL))\n            .highlight_style(Style::default().bg(Color::DarkGray));\n        \n        frame.render_widget(process_list, chunks[3]);\n    }\n}\n\n#[tokio::main]\nasync fun main() -> Result<()> {\n    // Setup terminal\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backend = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backend)?;\n    \n    let mut app = App::new();\n    let mut last_update = Instant::now();\n    \n    loop {\n        // Update data every second\n        if last_update.elapsed() >= Duration::from_secs(1) {\n            app.update();\n            last_update = Instant::now();\n        }\n        \n        // Draw UI\n        terminal.draw(|f| app.draw(f))?;\n        \n        // Handle events\n        if event::poll(Duration::from_millis(100))? {\n            if let Event::Key(key) = event::read()? {\n                match key.code {\n                    KeyCode::Char('q') => break,\n                    KeyCode::Up => {\n                        if let Some(selected) = &mut app.selected_process {\n                            if *selected > 0 {\n                                *selected -= 1;\n                            }\n                        }\n                    }\n                    KeyCode::Down => {\n                        if let Some(selected) = &mut app.selected_process {\n                            if *selected < app.processes.len() - 1 {\n                                *selected += 1;\n                            }\n                        } else {\n                            app.selected_process = Some(0);\n                        }\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n    \n    // Restore terminal\n    disable_raw_mode()?;\n    execute!(terminal.backend_mut(), LeaveAlternateScreen)?;\n    terminal.show_cursor()?;\n    \n    Ok(())\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch19-00-real-world-projects.md",
          "example_number": 4,
          "line_number": 736,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: Dot\n// 1. Project structure\nmy-project/\n├── src/\n│   ├── main.rs\n│   ├── lib.rs\n│   ├── models/\n│   ├── handlers/\n│   └── utils/\n├── tests/\n├── benches/\n├── docs/\n├── Cargo.toml\n├── README.md\n└── .github/\n    └── workflows/\n\n// 2. Error handling\ntype Result<T> = std::result::Result<T, Error>;\n\n#[derive(Debug, thiserror::Error)]\nenum Error {\n    #[error(\"Database error: {0}\")]\n    Database(#[from] sqlx::Error),\n    \n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n    \n    #[error(\"Invalid input: {0}\")]\n    InvalidInput(String),\n}\n\n// 3. Configuration\n#[derive(Debug, Deserialize)]\nstruct Config {\n    server: ServerConfig,\n    database: DatabaseConfig,\n    #[serde(default)]\n    features: Features,\n}\n\nimpl Config {\n    fun load() -> Result<Self> {\n        // Try multiple sources\n        let config = config::Config::builder()\n            .add_source(config::File::with_name(\"config\"))\n            .add_source(config::Environment::with_prefix(\"APP\"))\n            .build()?;\n        \n        Ok(config.try_deserialize()?)\n    }\n}\n\n// 4. Logging\nfun init_logging() {\n    tracing_subscriber::fmt()\n        .with_env_filter(EnvFilter::from_default_env())\n        .with_target(false)\n        .with_thread_ids(true)\n        .with_file(true)\n        .with_line_number(true)\n        .init();\n}\n\n// 5. Testing\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fun test_functionality() {\n        // Arrange\n        let input = prepare_test_data();\n        \n        // Act\n        let result = function_under_test(input);\n        \n        // Assert\n        assert_eq!(result, expected);\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "conclusion": {
      "chapter": "conclusion",
      "total_examples": 2,
      "working_examples": 1,
      "failing_examples": 1,
      "examples": [
        {
          "file": "src/conclusion.md",
          "example_number": 1,
          "line_number": 190,
          "code": "fun calculate(x: i32, y: i32) -> i32 {\n    return x + y;\n}\n\nfun main() {\n    let result = calculate(10, 20);\n    println(result);  // Output: 30\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/conclusion.md",
          "example_number": 2,
          "line_number": 202,
          "code": "// Arrays - NOT YET\nlet arr = [1, 2, 3];\n\n// User Input - NOT YET  \nlet name = input(\"Enter name: \");\n\n// File I/O - NOT YET\nlet contents = fs::read_to_string(\"file.txt\");\n\n// Closures - NOT YET\nlet add_one = |x| x + 1;",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpE7tlcJ/main.rs:1:220\n  |\n1 | ...e.txt\") ; let add_one = | x | x + 1i32 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n --> /tmp/.tmpE7tlcJ/main.rs:1:155\n  |\n1 | ...= input (\"Enter name: \") ; let contents = fs :: read_to_string (\"file.txt\") ; let add_one = | x | x + 1i32 } ; if let Some (s) = (& re...\n  |                                              ^^ use of unresolved module or unlinked crate `fs`\n  |\n  = help: you might be missing a crate named `fs`\nhelp: consider importing this module\n  |\n1 + use std::fs;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpE7tlcJ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let arr = vec ! [1i32 , 2i32 , 3i32] ; let name = input (\"Enter name: \") ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmpE7tlcJ/main.rs:1:115\n  |\n1 | ...{ let arr = vec ! [1i32 , 2i32 , 3i32] ; let name = input (\"Enter name: \") ; let contents = fs :: read_to_string (\"file.txt\") ; let ad...\n  |                                                        ^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch11-00-advanced-patterns": {
      "chapter": "ch11-00-advanced-patterns",
      "total_examples": 12,
      "working_examples": 0,
      "failing_examples": 12,
      "examples": [
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected field name\n// File: event_system.ruchy\n// Event-driven architecture with multiple patterns\n\nuse std::patterns;\n\n// Observer pattern for events\nclass EventBus {\n    let subscribers = {}\n    \n    fun on(event, handler) {\n        if !subscribers.has_key(event) {\n            subscribers[event] = []\n        }\n        subscribers[event].push(handler)\n        \n        // Return unsubscribe function (closure pattern)\n        return || {\n            subscribers[event] = subscribers[event].filter(|h| h != handler)\n        }\n    }\n    \n    fun emit(event, data) {\n        if subscribers.has_key(event) {\n            for handler in subscribers[event] {\n                spawn { handler(data) }  // Async pattern\n            }\n        }\n    }\n}\n\n// Singleton pattern for global event bus\nlet events = EventBus::singleton()\n\n// Decorator pattern for logging\nfun with_logging(handler) {\n    return |data| {\n        println(\"[\" + current_datetime() + \"] Event triggered: \" + data)\n        let result = handler(data)\n        println(\"[\" + current_datetime() + \"] Event completed\")\n        return result\n    }\n}\n\n// Usage combining patterns\nlet unsubscribe = events.on(\"user.login\", with_logging(|user| {\n    println(\"User \" + user.name + \" logged in\")\n    update_last_login(user)\n}))\n\nevents.emit(\"user.login\", {name: \"Alice\", id: 123})",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 2,
          "line_number": 97,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected field name\n// Fluent interface for configuration\nclass ServerBuilder {\n    let config = {\n        port: 8080,\n        host: \"localhost\",\n        threads: 4,\n        timeout: 30000,\n        middleware: [],\n        routes: {}\n    }\n    \n    fun port(p) {\n        config.port = p\n        return self  // Enable chaining\n    }\n    \n    fun host(h) {\n        config.host = h\n        return self\n    }\n    \n    fun threads(t) {\n        config.threads = t\n        return self\n    }\n    \n    fun use(middleware) {\n        config.middleware.push(middleware)\n        return self\n    }\n    \n    fun route(path, handler) {\n        config.routes[path] = handler\n        return self\n    }\n    \n    fun build() {\n        validate_config()\n        return Server::new(config)\n    }\n}\n\n// Clean, readable configuration\nlet server = ServerBuilder::new()\n    .port(3000)\n    .host(\"0.0.0.0\")\n    .threads(8)\n    .use(cors())\n    .use(auth())\n    .use(logging())\n    .route(\"/\", home_handler)\n    .route(\"/api\", api_handler)\n    .build()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 3,
          "line_number": 163,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected field name\n// Different compression strategies\nclass CompressionContext {\n    let strategy\n    \n    fun set_strategy(s) {\n        strategy = s\n    }\n    \n    fun compress(data) {\n        return strategy.compress(data)\n    }\n}\n\nclass GzipStrategy {\n    fun compress(data) {\n        return gzip::compress(data, level: 6)\n    }\n}\n\nclass BrotliStrategy {\n    fun compress(data) {\n        return brotli::compress(data, quality: 4)\n    }\n}\n\nclass NoCompressionStrategy {\n    fun compress(data) {\n        return data\n    }\n}\n\n// Choose strategy based on context\nlet compressor = CompressionContext::new()\n\nif file_size > mb(10) {\n    compressor.set_strategy(BrotliStrategy::new())  // Better for large files\n} else if client_supports_gzip {\n    compressor.set_strategy(GzipStrategy::new())\n} else {\n    compressor.set_strategy(NoCompressionStrategy::new())\n}\n\nlet compressed = compressor.compress(file_data)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 4,
          "line_number": 219,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected field name\n// Middleware chain for request processing\nclass MiddlewareChain {\n    let middlewares = []\n    \n    fun use(middleware) {\n        middlewares.push(middleware)\n    }\n    \n    fun execute(request, response) {\n        let index = 0\n        \n        fun next() {\n            if index < middlewares.len() {\n                let middleware = middlewares[index]\n                index += 1\n                middleware(request, response, next)\n            }\n        }\n        \n        next()\n    }\n}\n\n// Define middleware\nfun auth_middleware(req, res, next) {\n    let token = req.header(\"Authorization\")\n    if !token {\n        return res.status(401).json({error: \"Unauthorized\"})\n    }\n    \n    req.user = validate_token(token)\n    next()\n}\n\nfun rate_limit_middleware(req, res, next) {\n    let key = req.ip\n    if rate_limiter.exceeded(key) {\n        return res.status(429).json({error: \"Too many requests\"})\n    }\n    \n    rate_limiter.increment(key)\n    next()\n}\n\nfun cache_middleware(req, res, next) {\n    let cache_key = req.url\n    if cache.has(cache_key) {\n        return res.send(cache.get(cache_key))\n    }\n    \n    // Intercept response to cache it\n    let original_send = res.send\n    res.send = |data| {\n        cache.set(cache_key, data)\n        original_send(data)\n    }\n    \n    next()\n}\n\n// Build the chain\nlet chain = MiddlewareChain::new()\nchain.use(rate_limit_middleware)\nchain.use(auth_middleware)\nchain.use(cache_middleware)\nchain.use(route_handler)\n\nchain.execute(request, response)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 5,
          "line_number": 302,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Function parameters must be simple identifiers (destructuring patterns not supported)\n// Function composition\nfun compose(...functions) {\n    return |x| {\n        let result = x\n        for f in functions.reverse() {\n            result = f(result)\n        }\n        return result\n    }\n}\n\n// Pipeline operator\nfun pipeline(value, ...functions) {\n    let result = value\n    for f in functions {\n        result = f(result)\n    }\n    return result\n}\n\n// Example: Data transformation pipeline\nlet process_data = compose(\n    validate,\n    normalize,\n    enrich,\n    transform,\n    format\n)\n\nlet result = process_data(raw_data)\n\n// Or using pipeline\nlet result = pipeline(\n    raw_data,\n    validate,\n    normalize,\n    enrich,\n    transform,\n    format\n)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 6,
          "line_number": 355,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected field name\n// Result monad for error handling\nclass Result {\n    let value\n    let error\n    \n    static fun ok(val) {\n        return Result{value: val, error: null}\n    }\n    \n    static fun err(e) {\n        return Result{value: null, error: e}\n    }\n    \n    fun is_ok() {\n        return error == null\n    }\n    \n    fun map(f) {\n        if is_ok() {\n            return Result::ok(f(value))\n        }\n        return self\n    }\n    \n    fun flat_map(f) {\n        if is_ok() {\n            return f(value)\n        }\n        return self\n    }\n    \n    fun unwrap_or(default) {\n        if is_ok() {\n            return value\n        }\n        return default\n    }\n}\n\n// Chain operations safely\nfun process_user(id) {\n    return fetch_user(id)\n        .map(|user| validate_user(user))\n        .flat_map(|user| enrich_user_data(user))\n        .map(|user| format_user(user))\n        .unwrap_or({error: \"Processing failed\"})\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 7,
          "line_number": 415,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected field name\n// Lazy sequences\nclass LazySeq {\n    let generator\n    let cache = []\n    let index = 0\n    \n    fun next() {\n        if index >= cache.len() {\n            let value = generator()\n            if value != null {\n                cache.push(value)\n            }\n        }\n        \n        if index < cache.len() {\n            let value = cache[index]\n            index += 1\n            return value\n        }\n        \n        return null\n    }\n    \n    fun take(n) {\n        let result = []\n        for i in range(n) {\n            let value = next()\n            if value == null {\n                break\n            }\n            result.push(value)\n        }\n        return result\n    }\n    \n    fun map(f) {\n        return LazySeq::new(|| {\n            let value = next()\n            if value != null {\n                return f(value)\n            }\n            return null\n        })\n    }\n    \n    fun filter(predicate) {\n        return LazySeq::new(|| {\n            loop {\n                let value = next()\n                if value == null {\n                    return null\n                }\n                if predicate(value) {\n                    return value\n                }\n            }\n        })\n    }\n}\n\n// Infinite sequence\nlet fibonacci = LazySeq::new(|| {\n    static let a = 0\n    static let b = 1\n    let next = a\n    a = b\n    b = next + b\n    return next\n})\n\n// Only computes what's needed\nlet first_10_even = fibonacci\n    .filter(|n| n % 2 == 0)\n    .take(10)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 8,
          "line_number": 504,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected field name\n// Generic repository interface\nclass Repository {\n    fun find(id)\n    fun find_all()\n    fun find_where(conditions)\n    fun save(entity)\n    fun delete(id)\n}\n\n// Concrete implementation\nclass UserRepository < Repository {\n    let db\n    \n    fun find(id) {\n        let row = db.query_one(\"SELECT * FROM users WHERE id = ?\", [id])\n        return row ? User::from_row(row) : null\n    }\n    \n    fun find_where(conditions) {\n        let query = QueryBuilder::new(\"users\")\n            .where(conditions)\n            .build()\n        \n        return db.query(query).map(|row| User::from_row(row))\n    }\n    \n    fun save(user) {\n        if user.id {\n            db.execute(\"UPDATE users SET ... WHERE id = ?\", user.to_row())\n        } else {\n            user.id = db.execute(\"INSERT INTO users ... VALUES ...\", user.to_row())\n        }\n        return user\n    }\n}\n\n// Use repository in service layer\nclass UserService {\n    let repository\n    \n    fun get_active_users() {\n        return repository.find_where({active: true})\n    }\n    \n    fun create_user(data) {\n        let user = User::new(data)\n        user.validate()\n        return repository.save(user)\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 9,
          "line_number": 567,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected field name\n// Event sourcing system\nclass EventStore {\n    let events = []\n    let snapshots = {}\n    let projections = {}\n    \n    fun append(event) {\n        event.id = generate_id()\n        event.timestamp = current_time()\n        event.version = events.len() + 1\n        \n        events.push(event)\n        update_projections(event)\n        \n        // Create snapshot every 100 events\n        if events.len() % 100 == 0 {\n            create_snapshot()\n        }\n    }\n    \n    fun replay(from_version = 0) {\n        let state = snapshots.get_latest_before(from_version) || {}\n        \n        for event in events.filter(|e| e.version > from_version) {\n            state = apply_event(state, event)\n        }\n        \n        return state\n    }\n    \n    fun get_projection(name) {\n        return projections[name]\n    }\n}\n\n// Domain events\nclass OrderPlaced {\n    let order_id\n    let customer_id\n    let items\n    let total\n}\n\nclass PaymentReceived {\n    let order_id\n    let amount\n    let method\n}\n\n// Event handlers update projections\nfun handle_order_placed(event) {\n    projections.orders[event.order_id] = {\n        status: \"pending\",\n        customer: event.customer_id,\n        total: event.total\n    }\n    \n    projections.customer_orders[event.customer_id].push(event.order_id)\n}\n\n// Rebuild state from events\nlet current_state = event_store.replay()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 10,
          "line_number": 642,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected field name\n// Command side - writes\nclass CommandBus {\n    let handlers = {}\n    \n    fun register(command_type, handler) {\n        handlers[command_type] = handler\n    }\n    \n    fun dispatch(command) {\n        let handler = handlers[command.type]\n        if !handler {\n            throw \"No handler for command: \" + command.type\n        }\n        \n        return handler(command)\n    }\n}\n\n// Query side - reads\nclass QueryBus {\n    let handlers = {}\n    \n    fun register(query_type, handler) {\n        handlers[query_type] = handler\n    }\n    \n    fun query(query) {\n        let handler = handlers[query.type]\n        if !handler {\n            throw \"No handler for query: \" + query.type\n        }\n        \n        return handler(query)\n    }\n}\n\n// Commands modify state\ncommand_bus.register(\"CreateOrder\", |cmd| {\n    let order = Order::new(cmd.data)\n    order.validate()\n    event_store.append(OrderPlaced::new(order))\n    return order.id\n})\n\n// Queries read projections\nquery_bus.register(\"GetOrdersByCustomer\", |query| {\n    return read_model.get_customer_orders(query.customer_id)\n})\n\n// Usage\nlet order_id = command_bus.dispatch({\n    type: \"CreateOrder\",\n    data: {customer: 123, items: [...]}\n})\n\nlet orders = query_bus.query({\n    type: \"GetOrdersByCustomer\",\n    customer_id: 123\n})",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 11,
          "line_number": 716,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected field name\n// Actor system\nclass Actor {\n    let mailbox = Queue::new()\n    let running = true\n    \n    fun receive(message) {\n        mailbox.push(message)\n    }\n    \n    fun start() {\n        spawn {\n            while running {\n                let message = mailbox.pop()\n                if message {\n                    handle_message(message)\n                }\n                sleep(1)\n            }\n        }\n    }\n    \n    fun handle_message(message) {\n        // Override in subclass\n    }\n}\n\n// Concrete actor\nclass WorkerActor < Actor {\n    let state = {}\n    \n    fun handle_message(message) {\n        match message.type {\n            \"process\" => {\n                let result = process_work(message.data)\n                message.reply_to.receive({\n                    type: \"result\",\n                    data: result\n                })\n            }\n            \"get_state\" => {\n                message.reply_to.receive({\n                    type: \"state\",\n                    data: state\n                })\n            }\n            \"shutdown\" => {\n                running = false\n            }\n        }\n    }\n}\n\n// Actor system\nlet system = ActorSystem::new()\nlet worker = system.spawn(WorkerActor)\n\nworker.send({\n    type: \"process\",\n    data: work_item,\n    reply_to: self\n})",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 12,
          "line_number": 790,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected field name\nclass CircuitBreaker {\n    let failure_threshold = 5\n    let timeout = 30000\n    let failure_count = 0\n    let last_failure_time = 0\n    let state = \"closed\"  // closed, open, half_open\n    \n    fun call(operation) {\n        if state == \"open\" {\n            if current_time() - last_failure_time > timeout {\n                state = \"half_open\"\n            } else {\n                throw \"Circuit breaker is open\"\n            }\n        }\n        \n        try {\n            let result = operation()\n            \n            if state == \"half_open\" {\n                state = \"closed\"\n                failure_count = 0\n            }\n            \n            return result\n        } catch error {\n            failure_count += 1\n            last_failure_time = current_time()\n            \n            if failure_count >= failure_threshold {\n                state = \"open\"\n                println(\"Circuit breaker opened after \" + failure_count.to_s() + \" failures\")\n            }\n            \n            throw error\n        }\n    }\n}\n\n// Use circuit breaker for external service\nlet api_breaker = CircuitBreaker::new()\n\nfun call_external_api(data) {\n    return api_breaker.call(|| {\n        http::post(\"https://api.external.com/endpoint\")\n            .json(data)\n            .timeout(5000)\n            .send()\n    })\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "appendix-b-syntax-reference": {
      "chapter": "appendix-b-syntax-reference",
      "total_examples": 35,
      "working_examples": 1,
      "failing_examples": 34,
      "examples": [
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 1,
          "line_number": 23,
          "code": "// Status: ✅ WORKING\n\n// Single line comment\n\n/* \n   Multi-line comment\n   Can span multiple lines\n*/\n\n/// Documentation comment for the following item\nfun documented_function() {}\n\n//! Inner documentation comment for containing item",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 2,
          "line_number": 45,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected '(' or '[' after macro name\n// Valid identifiers\nvariable_name\ncamelCase\nPascalCase\n_private\n_internal\nsnake_case_123\nτ  // Unicode allowed\n\n// Keywords (reserved)\nlet mut fn if else match while for loop break continue\nreturn true false null struct enum trait impl use mod\nasync await type where const static pub super self",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 3,
          "line_number": 70,
          "code": "// Status: ✅ WORKING\n\n// Integers\n42          // Decimal\n0xFF        // Hexadecimal  \n0o77        // Octal\n0b1010      // Binary\n1_000_000   // With separators\n\n// Floating point\n3.14\n2.0\n1e6         // Scientific notation\n1.5e-10\n\n// Type suffixes\n42i32       // 32-bit integer\n3.14f64     // 64-bit float\n100u8       // Unsigned 8-bit",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `xFF` in this scope\n --> /tmp/.tmpxI0kPA/main.rs:1:80\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...\n  |                                                                                ^^^ not found in this scope\n\nerror[E0425]: cannot find value `o77` in this scope\n --> /tmp/.tmpxI0kPA/main.rs:1:93\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...\n  |                                                                                             ^^^ not found in this scope\n\nerror[E0425]: cannot find value `b1010` in this scope\n --> /tmp/.tmpxI0kPA/main.rs:1:106\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...\n  |                                                                                                          ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `_000_000` in this scope\n --> /tmp/.tmpxI0kPA/main.rs:1:121\n  |\n1 | ... ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f64 ; 2f64 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; i32 ; 3.14f64 ; ...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `e6` in this scope\n --> /tmp/.tmpxI0kPA/main.rs:1:156\n  |\n1 | ...2 ; b1010 ; 1i32 ; _000_000 ; 3.14f64 ; 2f64 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; i32 ; 3.14f64 ; f64 ; 100i32 ; u8 } ; if let Som...\n  |                                                          ^^ not found in this scope\n\nerror[E0423]: expected value, found builtin type `i32`\n --> /tmp/.tmpxI0kPA/main.rs:1:188\n  |\n1 | ... ; 3.14f64 ; 2f64 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; i32 ; 3.14f64 ; f64 ; 100i32 ; u8 } ; if let Some (s) = (& result as & dyn ...\n  |                                                               ^^^ not a value\n\nerror[E0423]: expected value, found builtin type `f64`\n --> /tmp/.tmpxI0kPA/main.rs:1:204\n  |\n1 | ...4 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; i32 ; 3.14f64 ; f64 ; 100i32 ; u8 } ; if let Some (s) = (& result as & dyn std :: any :: An...\n  |                                                               ^^^ not a value\n\nerror[E0423]: expected value, found builtin type `u8`\n --> /tmp/.tmpxI0kPA/main.rs:1:219\n  |\n1 | ...; 0.00000000015f64 ; 42i32 ; i32 ; 3.14f64 ; f64 ; 100i32 ; u8 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_...\n  |                                                                ^^ not a value\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpxI0kPA/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 8 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0423, E0425.\nFor more information about an error, try `rustc --explain E0423`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 4,
          "line_number": 98,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected '[' after '#'\n// String literals\n\"hello world\"\n\"unicode: αβγ\"\n\"escapes: \\n \\t \\r \\\\ \\\" \\'\"\n\n// Raw strings (no escapes)\nr\"raw string with \\n literal backslashes\"\nr#\"can contain \"quotes\" with # delimiters\"#\nr##\"even more \"# nested # delimiters\"##\n\n// Multi-line strings\n\"line one\\\nline two\"\n\n// Format strings\n\"Hello, \" + name + \"!\"\n\"Result: \" + value.to_s()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 5,
          "line_number": 125,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected Arrow, found Bang\n'a'         // ASCII character\n'\\n'        // Escape sequence\n'\\x41'      // Hex escape\n'\\u{1F600}' // Unicode escape",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 6,
          "line_number": 141,
          "code": "// Status: ✅ WORKING\n\n// Boolean\nlet flag: bool = true\n\n// Integers\nlet small: i8 = -128           // 8-bit signed\nlet byte: u8 = 255             // 8-bit unsigned  \nlet short: i16 = -32768        // 16-bit signed\nlet word: u16 = 65535          // 16-bit unsigned\nlet int: i32 = -2147483648     // 32-bit signed\nlet uint: u32 = 4294967295     // 32-bit unsigned\nlet long: i64 = -9223372036854775808  // 64-bit signed\nlet ulong: u64 = 18446744073709551615 // 64-bit unsigned\nlet size: isize = -1           // Pointer-sized signed\nlet usize: usize = 1           // Pointer-sized unsigned\n\n// Floating point\nlet single: f32 = 3.14         // 32-bit float\nlet double: f64 = 2.718281828  // 64-bit float\n\n// Character\nlet ch: char = 'A'             // Unicode scalar value\n\n// String\nlet text: str = \"hello\"        // String slice\nlet owned: String = \"world\"    // Owned string",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected expression, found `let` statement\n --> /tmp/.tmp37fIv4/main.rs:1:243\n  |\n1 | ...nt = - 2147483648i64 ; let uint = 4294967295i64 ; let long = - ! let ulong = ! let size = - 1i32 ; let usize = 1i32 ; let single = 3.1...\n  |                                                                     ^^^\n  |\n  = note: only supported directly in conditions of `if` and `while` expressions\n\nerror: expected expression, found `let` statement\n --> /tmp/.tmp37fIv4/main.rs:1:257\n  |\n1 | ...648i64 ; let uint = 4294967295i64 ; let long = - ! let ulong = ! let size = - 1i32 ; let usize = 1i32 ; let single = 3.14f64 ; let dou...\n  |                                                                     ^^^\n  |\n  = note: only supported directly in conditions of `if` and `while` expressions\n\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmp37fIv4/main.rs:1:405\n  |\n1 | ...t text = \"hello\" ; let owned = \"world\" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp37fIv4/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let flag = true ; let small = - 128i32 ; let byte = 255i32 ; let short = ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 7,
          "line_number": 177,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected RightBracket, found Semicolon\n// Arrays (fixed size)\nlet arr: [i32; 5] = [1, 2, 3, 4, 5]\nlet zeros: [i32; 100] = [0; 100]\n\n// Slices (dynamic size)\nlet slice: &[i32] = &arr[1..3]\n\n// Tuples\nlet tuple: (i32, str, bool) = (42, \"hello\", true)\nlet unit: () = ()  // Unit type\n\n// Vectors (dynamic arrays)\nlet vec: Vec<i32> = vec![1, 2, 3, 4, 5]\n\n// Hash maps\nlet map: HashMap<String, i32> = HashMap::new()\n\n// Options\nlet maybe: Option<i32> = Some(42)\nlet nothing: Option<i32> = None\n\n// Results  \nlet ok: Result<i32, String> = Ok(42)\nlet err: Result<i32, String> = Err(\"error message\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 8,
          "line_number": 213,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected identifier after 'let' or 'let mut'\n// Immutable by default\nlet x = 42\nlet name = \"Alice\"\n\n// Explicit type annotation\nlet count: i32 = 100\nlet score: f64 = 95.5\n\n// Mutable variables\nlet mut counter = 0\ncounter += 1\n\n// Pattern destructuring\nlet (x, y) = (10, 20)\nlet [first, second, ..] = [1, 2, 3, 4, 5]\n\n// Shadowing\nlet x = 42\nlet x = \"now a string\"  // Shadows previous x",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 9,
          "line_number": 242,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: Const\n// Compile-time constants\nconst MAX_SIZE: usize = 1024\nconst PI: f64 = 3.14159265359\n\n// Static variables\nstatic GLOBAL_COUNTER: AtomicUsize = AtomicUsize::new(0)\nstatic mut GLOBAL_STATE: i32 = 0  // Unsafe to mutate",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 10,
          "line_number": 261,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected identifier after 'let' or 'let mut'\n// If expressions\nlet result = if condition {\n    \"true branch\"\n} else {\n    \"false branch\"\n}\n\n// Multiple conditions\nif x > 0 {\n    \"positive\"\n} else if x < 0 {\n    \"negative\"  \n} else {\n    \"zero\"\n}\n\n// Let-else pattern\nlet Some(value) = optional else {\n    return Err(\"No value\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 11,
          "line_number": 291,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected FatArrow, found If\n// Match expressions\nmatch value {\n    0 => \"zero\",\n    1 | 2 => \"one or two\",\n    3..=10 => \"three through ten\",\n    n if n > 100 => \"big number\",\n    _ => \"something else\"\n}\n\n// Destructuring patterns\nmatch point {\n    Point { x: 0, y: 0 } => \"origin\",\n    Point { x, y: 0 } => \"on x-axis at \" + x.to_s() + \",\",\n    Point { x: 0, y } => \"on y-axis at \" + y.to_s() + \",\",\n    Point { x, y } => \"point at (\" + x.to_s() + \", \" + y.to_s() + \")\"\n}\n\n// Guards\nmatch number {\n    n if n < 0 => \"negative\",\n    n if n > 0 => \"positive\", \n    _ => \"zero\"\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `value` in this scope\n --> /tmp/.tmpotiNdP/main.rs:1:71\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { match value { 0i32 => \"zero\" , 1i32 | 2i32 => \"one or two\" , 3i32 ..= 10i...\n  |                                                                       ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `point` in this scope\n --> /tmp/.tmpotiNdP/main.rs:1:234\n  |\n1 | ...=> \"big number\" , _ => \"something else\" , } ; match point { Point { x : 0i32 , y : 0i32 } => \"origin\" , Point { x , y : 0i32 } => \"on ...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Point` in this scope\n --> /tmp/.tmpotiNdP/main.rs:1:242\n  |\n1 | ...number\" , _ => \"something else\" , } ; match point { Point { x : 0i32 , y : 0i32 } => \"origin\" , Point { x , y : 0i32 } => \"on x-axis a...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Point` in this scope\n --> /tmp/.tmpotiNdP/main.rs:1:286\n  |\n1 | ...point { Point { x : 0i32 , y : 0i32 } => \"origin\" , Point { x , y : 0i32 } => \"on x-axis at \" + x . to_s () + \",\" , Point { x : 0i32 ,...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Point` in this scope\n --> /tmp/.tmpotiNdP/main.rs:1:350\n  |\n1 | ...y : 0i32 } => \"on x-axis at \" + x . to_s () + \",\" , Point { x : 0i32 , y } => \"on y-axis at \" + y . to_s () + \",\" , Point { x , y } =>...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Point` in this scope\n --> /tmp/.tmpotiNdP/main.rs:1:414\n  |\n1 | ...0i32 , y } => \"on y-axis at \" + y . to_s () + \",\" , Point { x , y } => \"point at (\" + x . to_s () + \", \" + y . to_s () + \")\" , } ; mat...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `number` in this scope\n --> /tmp/.tmpotiNdP/main.rs:1:499\n  |\n1 | ... x . to_s () + \", \" + y . to_s () + \")\" , } ; match number { n if n < 0i32 => \"negative\" , n if n > 0i32 => \"positive\" , _ => \"zero\" ,...\n  |                                                        ^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpotiNdP/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { match value { 0i32 => \"zero\" , 1i32 | 2i32 => \"one or two\" , 3i32 ..= 10i...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmpotiNdP/main.rs:1:342\n  |\n1 | ...0i32 } => \"origin\" , Point { x , y : 0i32 } => \"on x-axis at \" + x . to_s () + \",\" , Point { x : 0i32 , y } => \"on y-axis at \" + y . t...\n  |                                                   ----------------------------- ^ --- &str\n  |                                                   |\n  |                                                   str\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmpotiNdP/main.rs:1:406\n  |\n1 | ... x . to_s () + \",\" , Point { x : 0i32 , y } => \"on y-axis at \" + y . to_s () + \",\" , Point { x , y } => \"point at (\" + x . to_s () + \"...\n  |                                                   ----------------------------- ^ --- &str\n  |                                                   |\n  |                                                   str\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmpotiNdP/main.rs:1:460\n  |\n1 | ...s at \" + y . to_s () + \",\" , Point { x , y } => \"point at (\" + x . to_s () + \", \" + y . to_s () + \")\" , } ; match number { n if n < 0i...\n  |                                                    -------------------------- ^ ---- &str\n  |                                                    |\n  |                                                    str\n\nerror: aborting due to 10 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0369, E0422, E0425.\nFor more information about an error, try `rustc --explain E0369`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 12,
          "line_number": 324,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected identifier after 'for'\n// Infinite loop\nloop {\n    // Code here\n    if condition {\n        break\n    }\n}\n\n// While loop\nwhile condition {\n    // Code here\n}\n\n// For loop with iterators\nfor item in collection {\n    // Process item\n}\n\n// For loop with range\nfor i in 0..10 {\n    println(\"Count: \" + i.to_s())\n}\n\n// For loop with enumerate\nfor (index, item) in collection.enumerate() {\n    println(index.to_s() + \": \" + item)\n}\n\n// Loop labels and break/continue\n'outer: loop {\n    loop {\n        if condition {\n            break 'outer  // Break outer loop\n        }\n        if other_condition {\n            continue 'outer  // Continue outer loop\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 13,
          "line_number": 377,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected FatArrow, found Char('+')\n// Basic function\nfun greet(name: String) -> String {\n    return \"Hello, \" + name + \"!\"\n}\n\n// Implicit return (no semicolon)\nfun add(a: i32, b: i32) -> i32 {\n    a + b  // Last expression is returned\n}\n\n// Unit return type (no return value)\nfun print_message(msg: String) {\n    println(msg)\n}\n\n// Multiple parameters\nfun calculate(x: f64, y: f64, operation: char) -> f64 {\n    match operation {\n        '+' => x + y,\n        '-' => x - y,\n        '*' => x * y,\n        '/' => x / y,\n        _ => panic(\"Invalid operation\")\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 14,
          "line_number": 412,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected type\n// By value (move)\nfun take_ownership(s: String) {\n    // s is moved here\n}\n\n// By reference (borrow)\nfun borrow_value(s: &String) -> usize {\n    s.len()  // s is borrowed\n}\n\n// Mutable reference\nfun modify_value(s: &mut String) {\n    s.push_str(\" modified\")\n}\n\n// Default parameters\nfun connect(host: String, port: u16 = 8080, timeout: u64 = 5000) {\n    // Implementation\n}\n\n// Variable arguments\nfun sum(numbers: &[i32]) -> i32 {\n    numbers.iter().sum()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 15,
          "line_number": 446,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected type\n// Closure syntax\nlet add = |a, b| a + b\nlet result = add(5, 3)\n\n// Explicit types\nlet multiply: fn(i32, i32) -> i32 = |a, b| a * b\n\n// Capturing environment\nlet x = 10\nlet add_x = |y| x + y  // Captures x\nlet result = add_x(5)  // 15\n\n// Move capture\nlet name = String::from(\"Alice\")\nlet greeter = move |greeting| {\n    greeting + \", \" + name + \"!\"  // name is moved into closure\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 16,
          "line_number": 473,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected type\n// Function as parameter\nfun apply_operation(x: i32, y: i32, op: fn(i32, i32) -> i32) -> i32 {\n    op(x, y)\n}\n\n// Function returning function\nfun make_adder(n: i32) -> impl Fn(i32) -> i32 {\n    move |x| x + n\n}\n\n// Generic function\nfun map_over<T, U, F>(items: Vec<T>, f: F) -> Vec<U>\nwhere F: Fn(T) -> U\n{\n    items.into_iter().map(f).collect()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 17,
          "line_number": 501,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected LeftBrace, found LeftParen\n// Basic struct\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\n// Tuple struct\nstruct Color(u8, u8, u8)\n\n// Unit struct\nstruct Marker\n\n// Generic struct\nstruct Container<T> {\n    value: T,\n}\n\n// Struct with lifetime\nstruct Excerpt<'a> {\n    text: &'a str,\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 18,
          "line_number": 532,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected field name\n// Creating instances\nlet origin = Point { x: 0.0, y: 0.0 }\nlet red = Color(255, 0, 0)\n\n// Field access\nlet x_coord = origin.x\n\n// Struct update syntax\nlet point2 = Point { x: 1.0, ..origin }\n\n// Destructuring\nlet Point { x, y } = origin\nlet Color(r, g, b) = red",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 19,
          "line_number": 555,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected RightBrace, found LeftBrace\n// Basic enum\nenum Direction {\n    North,\n    South,\n    East,\n    West,\n}\n\n// Enum with data\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\n// Generic enum\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 20,
          "line_number": 586,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected Colon, found Comma\nimpl Point {\n    // Associated function (constructor)\n    fun new(x: f64, y: f64) -> Point {\n        Point { x, y }\n    }\n    \n    // Method (takes &self)\n    fun distance_from_origin(&self) -> f64 {\n        (self.x.powi(2) + self.y.powi(2)).sqrt()\n    }\n    \n    // Mutable method (takes &mut self)\n    fun translate(&mut self, dx: f64, dy: f64) {\n        self.x += dx\n        self.y += dy\n    }\n    \n    // Consuming method (takes self)\n    fun into_tuple(self) -> (f64, f64) {\n        (self.x, self.y)\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 21,
          "line_number": 620,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected 'fun' or 'fn' keyword\n// Basic trait\ntrait Draw {\n    fun draw(&self)\n}\n\n// Trait with default implementation\ntrait Summary {\n    fun summarize_author(&self) -> String\n    \n    fun summarize(&self) -> String {\n        \"(Read more from \" + self.summarize_author() + \"...)\"\n    }\n}\n\n// Trait with associated types\ntrait Iterator {\n    type Item\n    \n    fun next(&mut self) -> Option<Self::Item>\n}\n\n// Trait with generic parameters\ntrait From<T> {\n    fun from(value: T) -> Self\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 22,
          "line_number": 655,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected Greater, found Colon\nimpl Draw for Point {\n    fun draw(&self) {\n        println(\"Drawing point at (\" + self.x.to_s() + \", \" + self.y.to_s() + \")\")\n    }\n}\n\n// Conditional implementation\nimpl<T: Display> ToString for T {\n    fun to_string(&self) -> String {\n        // Implementation\n    }\n}\n\n// Blanket implementation\nimpl<T: Clone> Clone for Box<T> {\n    fun clone(&self) -> Box<T> {\n        // Implementation  \n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 23,
          "line_number": 686,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected Greater, found Colon\nfun largest<T: PartialOrd>(list: &[T]) -> &T {\n    let mut largest = &list[0]\n    for item in list {\n        if item > largest {\n            largest = item\n        }\n    }\n    largest\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 24,
          "line_number": 705,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected LeftBrace, found Less\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Point<T> {\n    fun new(x: T, y: T) -> Point<T> {\n        Point { x, y }\n    }\n}\n\nimpl Point<f64> {\n    fun distance_from_origin(&self) -> f64 {\n        (self.x.powi(2) + self.y.powi(2)).sqrt()\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 25,
          "line_number": 731,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected Greater, found Colon\n// Single bound\nfun print_it<T: Display>(item: T) {\n    println(\"{}\", item)\n}\n\n// Multiple bounds\nfun compare_and_print<T: Display + PartialOrd>(a: T, b: T) {\n    if a > b {\n        println(\"a is greater\")\n    } else {\n        println(\"b is greater or equal\")\n    }\n}\n\n// Where clause\nfun some_function<T, U>(t: T, u: U) -> i32\nwhere\n    T: Display + Clone,\n    U: Clone + Debug,\n{\n    // Implementation\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 26,
          "line_number": 765,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected LeftBrace, found Semicolon\n// Inline module\nmod network {\n    fun connect() {\n        // Implementation\n    }\n    \n    pub fun public_function() {\n        // Can be called from outside module\n    }\n}\n\n// File-based modules\nmod utils;  // Looks for utils.rs or utils/mod.rs\n\n// Nested modules\nmod graphics {\n    pub mod shapes {\n        pub fun draw_circle() {}\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 27,
          "line_number": 795,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected 'fn', 'struct', 'enum', 'trait', 'impl', or 'mod' after 'pub'\npub fun public_function() {}           // Public\nfun private_function() {}              // Private to module\n\npub struct PublicStruct {\n    pub public_field: i32,            // Public field\n    private_field: i32,               // Private field\n}\n\npub(crate) fun crate_visible() {}      // Visible within crate\npub(super) fun parent_visible() {}     // Visible to parent module\npub(in crate::utils) fun limited() {} // Visible within specific path",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 28,
          "line_number": 816,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected 'fn', 'struct', 'enum', 'trait', 'impl', or 'mod' after 'pub'\nuse std::collections::HashMap         // Single import\nuse std::fs::{File, OpenOptions}      // Multiple imports\nuse std::io::*                        // Glob import\nuse std::collections::HashMap as Map  // Alias\n\n// Re-exports\npub use internal::public_api\n\n// Conditional compilation\n#[cfg(unix)]\nuse unix_specific::module\n\n#[cfg(windows)]  \nuse windows_specific::module",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 29,
          "line_number": 842,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected enum name\n// Result type\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n\n// Option type\nenum Option<T> {\n    Some(T),\n    None,\n}\n\n// Using ? operator\nfun read_file(path: &str) -> Result<String, std::io::Error> {\n    let content = std::fs::read_to_string(path)?\n    Ok(content.to_uppercase())\n}\n\n// Combining with match\nmatch result {\n    Ok(value) => println(\"Success: {}\", value),\n    Err(error) => eprintln(\"Error: {}\", error),\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 30,
          "line_number": 875,
          "code": "// Status: ✅ WORKING\n\n// Unconditional panic\npanic!(\"Something went wrong!\")\n\n// Conditional panic\nassert!(condition, \"Condition must be true\")\nassert_eq!(left, right, \"Values must be equal\")\n\n// Debug assertions (only in debug builds)\ndebug_assert!(expensive_check())",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 31,
          "line_number": 897,
          "code": "// Status: ✅ WORKING\n\n// Function-like macros\nprintln!(\"Hello, {}!\", name)\nvec![1, 2, 3, 4, 5]\nformat!(\"Value: {}\", x)\n\n// Attribute-like macros\n#[derive(Debug, Clone)]\nstruct MyStruct {}\n\n#[cfg(test)]\nmod tests {}\n\n// Derive macros\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\nstruct Point { x: i32, y: i32 }",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 32,
          "line_number": 923,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected '(' or '[' after macro name\n// Declarative macro\nmacro_rules! say_hello {\n    () => {\n        println!(\"Hello!\")\n    };\n    ($name:expr) => {\n        println!(\"Hello, {}!\", $name)\n    };\n}\n\n// Usage\nsay_hello!()\nsay_hello!(\"World\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 33,
          "line_number": 948,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: RightParen\n// Conditional compilation\n#[cfg(target_os = \"linux\")]\nfun linux_only() {}\n\n#[cfg(feature = \"network\")]\nmod networking {}\n\n// Testing\n#[test]\nfun test_function() {}\n\n#[ignore]\n#[test]\nfun expensive_test() {}\n\n// Documentation\n#[doc = \"This is a documented function\"]\nfun documented() {}\n\n// Deprecation\n#[deprecated(note = \"Use new_function instead\")]\nfun old_function() {}\n\n// Allow/deny lints\n#[allow(dead_code)]\nfun unused_function() {}\n\n#[deny(missing_docs)]\nmod well_documented {}\n\n// Inline hints\n#[inline]\nfun small_function() {}\n\n#[inline(always)]\nfun always_inline() {}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 34,
          "line_number": 996,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected type\n// Async function\nasync fun fetch_data(url: &str) -> Result<String, reqwest::Error> {\n    let response = reqwest::get(url).await?\n    let text = response.text().await?\n    Ok(text)\n}\n\n// Async blocks\nlet future = async {\n    let result = some_async_operation().await\n    process_result(result)\n}\n\n// Async closures\nlet async_closure = async |x| {\n    expensive_async_operation(x).await\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 35,
          "line_number": 1023,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected 'fun' or 'fn' keyword\nuse futures::{Future, Stream}\n\n// Implementing Future\nimpl Future for MyFuture {\n    type Output = i32\n    \n    fun poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n        // Implementation\n    }\n}\n\n// Working with streams\nlet stream = async_stream::stream! {\n    for i in 0..10 {\n        yield i\n        tokio::time::sleep(Duration::from_millis(100)).await\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch10-00-input-output-tdd": {
      "chapter": "ch10-00-input-output-tdd",
      "total_examples": 10,
      "working_examples": 7,
      "failing_examples": 3,
      "examples": [
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 1,
          "line_number": 17,
          "code": "fun main() {\n    println(\"=== Output Demo ===\");\n    println(\"Number: \");\n    println(42);\n    println(\"Boolean: \");\n    println(true);\n    println(\"=== End Demo ===\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 2,
          "line_number": 42,
          "code": "fun main() {\n    let name = \"Alice\";\n    let age = 30;\n    let height = 5.6;\n    \n    println(\"=== User Profile ===\");\n    println(\"Name:\");\n    println(name);\n    println(\"Age:\");\n    println(age);\n    println(\"Height:\");\n    println(height);\n    println(\"================\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 3,
          "line_number": 75,
          "code": "fun display_menu() {\n    println(\"=== Main Menu ===\");\n    println(\"1. View Profile\");\n    println(\"2. Settings\");\n    println(\"3. Exit\");\n    println(\"=================\");\n}\n\nfun main() {\n    display_menu();\n    println(\"Menu displayed successfully\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 4,
          "line_number": 123,
          "code": "println(\"text message\");\nprintln(variable);\nprintln(42);\nprintln(true);",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `variable` in this scope\n --> /tmp/.tmpmMoijq/main.rs:1:112\n  |\n1 | ...= { println ! (\"text message\") ; println ! (\"{}\" , variable) ; println ! (\"{}\" , 42i32) ; println ! (\"{}\" , true) } ; if let Some (s) ...\n  |                                                       ^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpmMoijq/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"text message\") ; println ! (\"{}\" , variable) ; println ! (\"{}...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 5,
          "line_number": 131,
          "code": "let data = value;\nprintln(\"Label:\");\nprintln(data);",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `value` in this scope\n --> /tmp/.tmpJanrMP/main.rs:1:76\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let data = value ; println ! (\"Label:\") ; println ! (\"{}\" , data) } ; if ...\n  |                                                                            ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpJanrMP/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let data = value ; println ! (\"Label:\") ; println ! (\"{}\" , data) } ; if ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 6,
          "line_number": 138,
          "code": "fun display_options() {\n    println(\"=== Menu ===\");\n    println(\"1. Option One\");\n    println(\"2. Option Two\");\n    println(\"============\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 7,
          "line_number": 162,
          "code": "let value = 100;\nprintln(\"Result:\");\nprintln(value);",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 8,
          "line_number": 169,
          "code": "fun display_report(title: &str, data: i32) {\n    println(\"=== Report ===\");\n    println(title);\n    println(data);\n    println(\"==============\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 9,
          "line_number": 179,
          "code": "println(\"Processing...\");\n// ... do work ...\nprintln(\"Complete!\");",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 10,
          "line_number": 186,
          "code": "fun show_options() {\n    println(\"Choose an option:\");\n    println(\"1. Start\");\n    println(\"2. Stop\");\n    println(\"3. Help\");\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch18-00-deployment-devops": {
      "chapter": "ch18-00-deployment-devops",
      "total_examples": 8,
      "working_examples": 0,
      "failing_examples": 8,
      "examples": [
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ✅ WORKING\n\n// deploy.ruchy - One-command deployment\nuse std::deploy;\n\nlet config = DeployConfig {\n    app: \"my-app\",\n    environment: env::var(\"DEPLOY_ENV\"),  // staging/production\n    strategy: BlueGreen,\n    health_check: \"/health\",\n    rollback_on_failure: true\n}\n\n// Build and test\ndeploy::build()\n    .test()\n    .security_scan()\n    .create_artifact()\n\n// Deploy with zero downtime\nlet deployment = deploy::start(config)\n    .provision_infrastructure()\n    .deploy_new_version()\n    .run_smoke_tests()\n    .switch_traffic()\n    .verify_metrics()\n\nif deployment.is_healthy() {\n    deployment.commit()\n    println(\"✅ Deployment successful!\")\n} else {\n    deployment.rollback()\n    println(\"⚠️  Rolled back to previous version\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0432]: unresolved import `std::deploy`\n --> /tmp/.tmpWuWBeS/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: deploy ; ; let config = DeployConfig { app : \"my-app\" . to_str...\n  |                                                                     ^^^^^^^^^^^^^ no `deploy` in the root\n\nerror[E0422]: cannot find struct, variant or union type `DeployConfig` in this scope\n --> /tmp/.tmpWuWBeS/main.rs:1:100\n  |\n1 | ...et result = { use std :: deploy ; ; let config = DeployConfig { app : \"my-app\" . to_string () , environment : env :: var (\"DEPLOY_ENV\"...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `env`\n --> /tmp/.tmpWuWBeS/main.rs:1:161\n  |\n1 | ... \"my-app\" . to_string () , environment : env :: var (\"DEPLOY_ENV\") , strategy : BlueGreen , health_check : \"/health\" . to_string () , ...\n  |                                             ^^^ use of unresolved module or unlinked crate `env`\n  |\n  = help: you might be missing a crate named `env`\nhelp: consider importing this module\n  |\n1 + use std::env;\n  |\n\nerror[E0425]: cannot find value `BlueGreen` in this scope\n --> /tmp/.tmpWuWBeS/main.rs:1:200\n  |\n1 | ...ironment : env :: var (\"DEPLOY_ENV\") , strategy : BlueGreen , health_check : \"/health\" . to_string () , rollback_on_failure : true , }...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpWuWBeS/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: deploy ; ; let config = DeployConfig { app : \"my-app\" . to_str...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpWuWBeS/main.rs:1:85\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: deploy ; ; let config = DeployConfig { app : \"my-app\" . to_str...\n  |                                                                                     ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nerror: aborting due to 4 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\n\n",
          "errorCategory": "IMPORT_ERROR",
          "rootCause": "Missing dependency or import path issue"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 2,
          "line_number": 278,
          "code": "// Status: ✅ WORKING\n\n// blue_green.ruchy\nfun deploy_blue_green(new_version: String) {\n    // Current production is \"blue\"\n    let blue = Environment::current()\n    \n    // Provision identical \"green\" environment\n    let green = Environment::provision(new_version)\n    \n    // Deploy to green\n    green.deploy()\n    green.run_health_checks()\n    green.run_smoke_tests()\n    \n    // Verify green is healthy\n    if !green.is_healthy() {\n        green.destroy()\n        panic!(\"Green environment unhealthy\")\n    }\n    \n    // Switch traffic to green\n    LoadBalancer::switch_to(green)\n    \n    // Monitor for issues\n    sleep(Duration::from_mins(5))\n    \n    if green.error_rate() > 0.01 {\n        // Rollback\n        LoadBalancer::switch_to(blue)\n        green.destroy()\n        panic!(\"High error rate, rolled back\")\n    }\n    \n    // Success - green is now production\n    blue.destroy()\n    println!(\"✅ Deployed version {}\", new_version)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 3,
          "line_number": 328,
          "code": "// Status: ✅ WORKING\n\n// canary.ruchy\nfun deploy_canary(new_version: String) {\n    let deployment = CanaryDeployment::new(new_version)\n    \n    // Start with 5% traffic\n    deployment.set_traffic_percentage(5)\n    deployment.deploy()\n    \n    // Monitor metrics\n    let baseline = Metrics::baseline()\n    \n    // Gradually increase traffic\n    for percentage in [5, 10, 25, 50, 100] {\n        deployment.set_traffic_percentage(percentage)\n        \n        sleep(Duration::from_mins(10))\n        \n        let current = Metrics::current()\n        if current.error_rate > baseline.error_rate * 1.1 {\n            deployment.rollback()\n            panic!(\"Error rate increased by >10%\")\n        }\n        \n        if current.p99_latency > baseline.p99_latency * 1.2 {\n            deployment.rollback()\n            panic!(\"Latency increased by >20%\")\n        }\n        \n        println!(\"✅ Canary at {}% - metrics healthy\", percentage)\n    }\n    \n    deployment.finalize()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 4,
          "line_number": 375,
          "code": "// Status: ✅ WORKING\n\n// feature_flags.ruchy\nuse feature_flags::{Client, Flag};\n\nlet flags = Client::new(\"api_key\")\n\n// Define feature flag\nlet new_algorithm = Flag::new(\"new-algorithm\")\n    .default(false)\n    .rollout_percentage(10)  // 10% of users\n    .targeting_rules([\n        Rule::new(\"beta_users\", true),\n        Rule::new(\"internal_users\", true)\n    ])\n\n// Use in code\nif flags.is_enabled(new_algorithm, user) {\n    use_new_algorithm()\n} else {\n    use_old_algorithm()\n}\n\n// Gradual rollout\nfor percentage in [10, 25, 50, 75, 100] {\n    flags.set_rollout(new_algorithm, percentage)\n    monitor_metrics()\n    \n    if metrics_degraded() {\n        flags.disable(new_algorithm)\n        break\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0432]: unresolved import `feature_flags`\n --> /tmp/.tmpM25kxp/main.rs:1:69\n  |\n1 | ...n main () { let result = { use feature_flags :: { Client , Flag } ; ; let flags = Client :: new (\"api_key\") ; let new_algorithm = Flag...\n  |                                   ^^^^^^^^^^^^^ use of unresolved module or unlinked crate `feature_flags`\n  |\nhelp: you might be missing a crate named `feature_flags`, add it to your project and import it in your code\n  |\n1 + extern crate feature_flags;\n  |\n\nerror[E0425]: cannot find value `user` in this scope\n --> /tmp/.tmpM25kxp/main.rs:1:388\n  |\n1 | ...\" , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percen...\n  |                                                         ^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpM25kxp/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let flags = Client :: new (\"ap...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpM25kxp/main.rs:1:106\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let flags = Client :: new (\"ap...\n  |                                                                                                          ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpM25kxp/main.rs:1:396\n  |\n1 | ...ue)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage i...\n  |                                                           ^^                    ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let flags = Client :: new (\"api_key\") ; let new_algorithm = Flag :: new (\"new-algorithm\") . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new (\"beta_users\" , true) , Rule :: new (\"internal_users\" , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let flags = Client :: new (\"api_key\") ; let new_algorithm = Flag :: new (\"new-algorithm\") . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new (\"beta_users\" , true) , Rule :: new (\"internal_users\" , true)]) ; if flags . is_enabled (new_algorithm , user) { use_new_algorithm () } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpM25kxp/main.rs:1:430\n  |\n1 | ..._algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 7...\n  |                                                           ^^                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let flags = Client :: new (\"api_key\") ; let new_algorithm = Flag :: new (\"new-algorithm\") . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new (\"beta_users\" , true) , Rule :: new (\"internal_users\" , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let flags = Client :: new (\"api_key\") ; let new_algorithm = Flag :: new (\"new-algorithm\") . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new (\"beta_users\" , true) , Rule :: new (\"internal_users\" , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { use_old_algorithm () } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Rule`\n --> /tmp/.tmpM25kxp/main.rs:1:271\n  |\n1 | ...lout_percentage (10i32) . targeting_rules (vec ! [Rule :: new (\"beta_users\" , true) , Rule :: new (\"internal_users\" , true)]) ; if fla...\n  |                                                      ^^^^ use of undeclared type `Rule`\n\nerror[E0433]: failed to resolve: use of undeclared type `Rule`\n --> /tmp/.tmpM25kxp/main.rs:1:307\n  |\n1 | ...rules (vec ! [Rule :: new (\"beta_users\" , true) , Rule :: new (\"internal_users\" , true)]) ; if flags . is_enabled (new_algorithm , use...\n  |                                                      ^^^^ use of undeclared type `Rule`\n\nerror[E0425]: cannot find function `use_new_algorithm` in this scope\n --> /tmp/.tmpM25kxp/main.rs:1:398\n  |\n1 | ...ew_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 ,...\n  |                             ^^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists: `new_algorithm`\n\nerror[E0425]: cannot find function `use_old_algorithm` in this scope\n --> /tmp/.tmpM25kxp/main.rs:1:432\n  |\n1 | ..., user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i...\n  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `monitor_metrics` in this scope\n --> /tmp/.tmpM25kxp/main.rs:1:579\n  |\n1 | ...s . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `metrics_degraded` in this scope\n --> /tmp/.tmpM25kxp/main.rs:1:603\n  |\n1 | ...orithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some...\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 8 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "IMPORT_ERROR",
          "rootCause": "Missing dependency or import path issue"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 5,
          "line_number": 479,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected ',' or closing delimiter in macro arguments\n// metrics.ruchy\nuse metrics::{counter, gauge, histogram};\n\n// Application metrics\ncounter!(\"requests_total\", 1, \"endpoint\" => \"/api/users\")\nhistogram!(\"request_duration_seconds\", duration.as_secs_f64())\ngauge!(\"active_connections\", connections.len() as f64)\n\n// Prometheus endpoint\n#[get(\"/metrics\")]\nasync fun metrics_endpoint() -> String {\n    prometheus::gather()\n}\n\n// Grafana dashboard configuration\nlet dashboard = json!({\n    \"title\": \"Application Metrics\",\n    \"panels\": [\n        {\n            \"title\": \"Request Rate\",\n            \"targets\": [{\n                \"expr\": \"rate(requests_total[5m])\"\n            }]\n        },\n        {\n            \"title\": \"Error Rate\",\n            \"targets\": [{\n                \"expr\": \"rate(requests_total{status=~'5..'}[5m])\"\n            }]\n        },\n        {\n            \"title\": \"P99 Latency\",\n            \"targets\": [{\n                \"expr\": \"histogram_quantile(0.99, request_duration_seconds)\"\n            }]\n        }\n    ]\n})",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 6,
          "line_number": 528,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected type\n// logging.ruchy\nuse tracing::{info, warn, error, debug, span, Level};\n\n// Structured logging\n#[instrument]\nasync fun process_request(req: Request) -> Result<Response, Error> {\n    let span = span!(Level::INFO, \"request\", \n        method = %req.method(),\n        path = %req.path(),\n        request_id = %generate_id()\n    );\n    \n    let _enter = span.enter();\n    \n    info!(\"Processing request\");\n    \n    let result = match handle_request(req).await {\n        Ok(response) => {\n            info!(status = response.status(), \"Request successful\");\n            Ok(response)\n        }\n        Err(e) => {\n            error!(error = ?e, \"Request failed\");\n            Err(e)\n        }\n    };\n    \n    result\n}\n\n// Log aggregation config\nlet config = json!({\n    \"sinks\": {\n        \"elasticsearch\": {\n            \"type\": \"elasticsearch\",\n            \"endpoints\": [\"http://elasticsearch:9200\"],\n            \"index\": \"logs-%Y.%m.%d\"\n        },\n        \"s3\": {\n            \"type\": \"aws_s3\",\n            \"bucket\": \"my-app-logs\",\n            \"compression\": \"gzip\"\n        }\n    }\n})",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 7,
          "line_number": 584,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected ',' or '}' in import list\n// tracing.ruchy\nuse opentelemetry::{global, sdk, trace::Tracer};\n\n// Initialize tracing\nlet tracer = global::tracer(\"my-app\")\n\n// Trace requests\n#[instrument(skip(db))]\nasync fun handle_request(req: Request, db: &Database) -> Result<Response> {\n    let span = tracer.start(\"handle_request\")\n    \n    // Trace database query\n    let user = db.with_span(\"fetch_user\", |db| {\n        db.query_one(\"SELECT * FROM users WHERE id = $1\", &[req.user_id()])\n    }).await?\n    \n    // Trace external API call\n    let data = http_client.with_span(\"fetch_external_data\", |client| {\n        client.get(\"https://api.example.com/data\").send()\n    }).await?\n    \n    span.end()\n    \n    Ok(Response::new(data))\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 8,
          "line_number": 676,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: Question\n// secrets.ruchy\nuse vault::Client;\n\n// Vault integration\nlet vault = Client::new(\"https://vault.example.com\")\n    .auth_kubernetes()  // Use K8s service account\n\n// Fetch secrets\nlet db_password = vault.read(\"secret/database/password\").await?\nlet api_key = vault.read(\"secret/external/api_key\").await?\n\n// Rotate secrets\nvault.rotate(\"secret/database/password\").await?\n\n// Environment injection\nenv::set_var(\"DATABASE_URL\", \n    format!(\"postgres://user:{}@host/db\", db_password))",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch01-03-interpreter-scripting": {
      "chapter": "ch01-03-interpreter-scripting",
      "total_examples": 15,
      "working_examples": 3,
      "failing_examples": 12,
      "examples": [
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 1,
          "line_number": 28,
          "code": "// Status: ✅ WORKING\nruchy -e \"2 + 2\"",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `ruchy` in this scope\n --> /tmp/.tmpBljFhU/main.rs:1:65\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"2 + 2\" } ; if let Some (s) = (& result as & dyn std :: any :...\n  |                                                                 ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `e` in this scope\n --> /tmp/.tmpBljFhU/main.rs:1:73\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"2 + 2\" } ; if let Some (s) = (& result as & dyn std :: any :...\n  |                                                                         ^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpBljFhU/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"2 + 2\" } ; if let Some (s) = (& result as & dyn std :: any :...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 2,
          "line_number": 39,
          "code": "// Status: ✅ WORKING\nruchy -e \"let name = \\\"World\\\"; \\\"Hello \\\" + name + \\\"!\\\"\"",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `ruchy` in this scope\n --> /tmp/.tmpdagvaR/main.rs:1:65\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"let name = \\\"World\\\"; \\\"Hello \\\" + name + \\\"!\\\"\" } ; if let ...\n  |                                                                 ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `e` in this scope\n --> /tmp/.tmpdagvaR/main.rs:1:73\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"let name = \\\"World\\\"; \\\"Hello \\\" + name + \\\"!\\\"\" } ; if let ...\n  |                                                                         ^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpdagvaR/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"let name = \\\"World\\\"; \\\"Hello \\\" + name + \\\"!\\\"\" } ; if let ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 3,
          "line_number": 50,
          "code": "// Status: ✅ WORKING\nruchy -e \"let nums = [1, 2, 3]; nums[1]\"",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `ruchy` in this scope\n --> /tmp/.tmpEL1lab/main.rs:1:65\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"let nums = [1, 2, 3]; nums[1]\" } ; if let Some (s) = (& resu...\n  |                                                                 ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `e` in this scope\n --> /tmp/.tmpEL1lab/main.rs:1:73\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"let nums = [1, 2, 3]; nums[1]\" } ; if let Some (s) = (& resu...\n  |                                                                         ^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpEL1lab/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"let nums = [1, 2, 3]; nums[1]\" } ; if let Some (s) = (& resu...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 4,
          "line_number": 79,
          "code": "// Status: ✅ WORKING\nfun main() {\n    // Integer values\n    let small_int = 42\n    let result = small_int * 2\n\n    // Floating point numbers  \n    let pi = 3.14159\n    let area = pi * 5.0 * 5.0\n\n    // String operations\n    let greeting = \"Hello\"\n    let name = \"Ruchy\"\n\n    // Arrays with indexing\n    let data = [1, 2, 3, 4, 5]\n    println(data[2])\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpZFgkaZ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let small_int = 42i32 ; { let result = small_int * 2i32 ; let pi = 3.14159f64 ; let ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpZFgkaZ/main.rs:1:50\n  |\n1 | ... { { { let small_int = 42i32 ; { let result = small_int * 2i32 ; let pi = 3.14159f64 ; let area = pi * 5f64 * 5f64 ; let greeting = \"Hello\" ; let name = \"Ruchy\" ; let data = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32] ; println ! (\"{}\" , data [2i32]) } } } }\n  |       ^^                                                                                                                                                                                                                                                      ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let small_int = 42i32 ; { let result = small_int * 2i32 ; let pi = 3.14159f64 ; let area = pi * 5f64 * 5f64 ; let greeting = \"Hello\" ; let name = \"Ruchy\" ; let data = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32] ; println ! (\"{}\" , data [2i32]) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let small_int = 42i32 ; { let result = small_int * 2i32 ; let pi = 3.14159f64 ; let area = pi * 5f64 * 5f64 ; let greeting = \"Hello\" ; let name = \"Ruchy\" ; let data = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32] ; println ! (\"{}\" , data [2i32]) } } }\n  |\n\nerror[E0277]: the type `[i32]` cannot be indexed by `i32`\n --> /tmp/.tmpZFgkaZ/main.rs:1:288\n  |\n1 | ...32 , 5i32] ; println ! (\"{}\" , data [2i32]) } } } }\n  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `Vec<i32>` to implement `Index<i32>`\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 5,
          "line_number": 125,
          "code": "// Status: ✅ WORKING\n// calculator.ruchy - Basic calculator functionality\n\nfun add(a, b) {\n    a + b\n}\n\nfun subtract(a, b) {\n    a - b\n}\n\nfun multiply(a, b) {\n    a * b\n}\n\nfun divide(a, b) {\n    if b == 0 {\n        println(\"Error: Division by zero\")\n        0\n    } else {\n        a / b\n    }\n}\n\nfun main() {\n    // Test our calculator\n    let x = 10\n    let y = 3\n\n    println(\"Addition:\")\n    println(add(x, y))\n    println(\"Subtraction:\")\n    println(subtract(x, y))\n    println(\"Multiplication:\")\n    println(multiply(x, y))\n    println(\"Division:\")\n    println(divide(x, y))\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpptH9W7/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Disp...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpptH9W7/main.rs:1:197\n  |\n1 | ...isplay + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ...\n  |                                                                  ^^     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! (\"Addition:\") ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\") ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\") ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\") ; println ! (\"{}\" , divide (x , y)) } } } }\n1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { a + b } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! (\"Addition:\") ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\") ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\") ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\") ; println ! (\"{}\" , divide (x , y)) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpptH9W7/main.rs:1:374\n  |\n1 | ...isplay + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ...\n  |                                                                  ^^     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! (\"Addition:\") ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\") ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\") ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\") ; println ! (\"{}\" , divide (x , y)) } } } }\n1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { a - b } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! (\"Addition:\") ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\") ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\") ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\") ; println ! (\"{}\" , divide (x , y)) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpptH9W7/main.rs:1:551\n  |\n1 | ...isplay + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: op...\n  |                                                                  ^^     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! (\"Addition:\") ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\") ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\") ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\") ; println ! (\"{}\" , divide (x , y)) } } } }\n1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { a * b } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! (\"Addition:\") ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\") ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\") ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\") ; println ! (\"{}\" , divide (x , y)) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpptH9W7/main.rs:1:726\n  |\n1 | ...(a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\") ; 0i32 } } else { { a / b } } } } fn main () { { { let...\n  |                           ^^                                                                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! (\"Addition:\") ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\") ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\") ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\") ; println ! (\"{}\" , divide (x , y)) } } } }\n1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { if b == 0i32 { { println ! (\"Error: Division by zero\") ; 0i32 } } else { { a / b } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! (\"Addition:\") ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\") ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\") ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\") ; println ! (\"{}\" , divide (x , y)) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpptH9W7/main.rs:1:801\n  |\n1 | ...2 { { println ! (\"Error: Division by zero\") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; printl...\n  |                                                                  ^^     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! (\"Addition:\") ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\") ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\") ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\") ; println ! (\"{}\" , divide (x , y)) } } } }\n1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\") ; 0i32 } } else { a / b } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! (\"Addition:\") ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\") ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\") ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\") ; println ! (\"{}\" , divide (x , y)) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpptH9W7/main.rs:1:830\n  |\n1 | ... { { { let x = 10i32 ; { let y = 3i32 ; println ! (\"Addition:\") ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\") ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\") ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\") ; println ! (\"{}\" , divide (x , y)) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! (\"Addition:\") ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\") ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\") ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\") ; println ! (\"{}\" , divide (x , y)) } } } }\n1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\") ; 0i32 } } else { { a / b } } } } fn main () { { let x = 10i32 ; { let y = 3i32 ; println ! (\"Addition:\") ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\") ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\") ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\") ; println ! (\"{}\" , divide (x , y)) } } }\n  |\n\nerror[E0369]: cannot subtract `T` from `T`\n --> /tmp/.tmpptH9W7/main.rs:1:378\n  |\n1 | ...splay + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: o...\n  |                                                                   - ^ - T\n  |                                                                   |\n  |                                                                   T\n  |\nhelp: consider further restricting type parameter `T` with trait `Sub`\n  |\n1 | use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Sub<Output = T> > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! (\"Addition:\") ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\") ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\") ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\") ; println ! (\"{}\" , divide (x , y)) } } } }\n  |                                                                                                                                                                                                                                                                                                                                                             +++++++++++++++++++++++++++\n\nerror[E0369]: binary operation `==` cannot be applied to type `T`\n --> /tmp/.tmpptH9W7/main.rs:1:733\n  |\n1 | ...+ std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\") ; 0i32 } } else { { a ...\n  |                                                                - ^^ ---- i32\n  |                                                                |\n  |                                                                T\n  |\nhelp: consider further restricting type parameter `T` with trait `PartialEq`\n  |\n1 | use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialEq<i32> > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! (\"Addition:\") ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\") ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\") ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\") ; println ! (\"{}\" , divide (x , y)) } } } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ++++++++++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpptH9W7/main.rs:1:785\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\") ; 0i32 } ...\n  |       - expected this type parameter                                                                                                                     - expected `T` because of return type                          ^^^^ expected type parameter `T`, found `i32`\n  |\n  = note: expected type parameter `T`\n                       found type `i32`\n  = note: the caller chooses a type for `T` which can be different from `i32`\n\nerror[E0369]: cannot divide `T` by `T`\n --> /tmp/.tmpptH9W7/main.rs:1:805\n  |\n1 | ... { { println ! (\"Error: Division by zero\") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println...\n  |                                                                   - ^ - T\n  |                                                                   |\n  |                                                                   T\n  |\nhelp: consider further restricting type parameter `T` with trait `Div`\n  |\n1 | use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Div<Output = T> > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\") ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let y = 3i32 ; println ! (\"Addition:\") ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\") ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\") ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\") ; println ! (\"{}\" , divide (x , y)) } } } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             +++++++++++++++++++++++++++\n\nerror: aborting due to 4 previous errors; 7 warnings emitted\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 6,
          "line_number": 177,
          "code": "// Status: ✅ WORKING\n// data_processing.ruchy - Array manipulation examples\n\nfun main() {\n    let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    // Access elements\n    println(\"First:\")\n    println(numbers[0])\n    println(\"Last:\")\n    println(numbers[9])\n\n    // Simple iteration (manual)\n    let mut sum = 0\n    let mut i = 0\n    while i < 10 {\n        sum = sum + numbers[i]\n        i = i + 1\n    }\n    println(\"Sum:\")\n    println(sum)\n\n    // Calculate average\n    let average = sum / 10\n    println(\"Average:\")\n    println(average)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp8u4tEa/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let numbers = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32 , 6i32 , 7i32 , 8i32 , 9i32 , ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp8u4tEa/main.rs:1:50\n  |\n1 | ... { { { let numbers = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32 , 6i32 , 7i32 , 8i32 , 9i32 , 10i32] ; { println ! (\"First:\") ; println ! (\"{}\" , numbers [0i32]) ; println ! (\"Last:\") ; println ! (\"{}\" , numbers [9i32]) ; let mut sum = 0i32 ; let mut i = 0i32 ; while i < 10i32 { { sum = sum + numbers [i] ; i = i + 1i32 } } ; println ! (\"Sum:\") ; println ! (\"{}\" , sum) ; let average = sum / 10i32 ; println ! (\"Average:\") ; println ! (\"{}\" , average) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let numbers = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32 , 6i32 , 7i32 , 8i32 , 9i32 , 10i32] ; { println ! (\"First:\") ; println ! (\"{}\" , numbers [0i32]) ; println ! (\"Last:\") ; println ! (\"{}\" , numbers [9i32]) ; let mut sum = 0i32 ; let mut i = 0i32 ; while i < 10i32 { { sum = sum + numbers [i] ; i = i + 1i32 } } ; println ! (\"Sum:\") ; println ! (\"{}\" , sum) ; let average = sum / 10i32 ; println ! (\"Average:\") ; println ! (\"{}\" , average) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let numbers = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32 , 6i32 , 7i32 , 8i32 , 9i32 , 10i32] ; { println ! (\"First:\") ; println ! (\"{}\" , numbers [0i32]) ; println ! (\"Last:\") ; println ! (\"{}\" , numbers [9i32]) ; let mut sum = 0i32 ; let mut i = 0i32 ; while i < 10i32 { { sum = sum + numbers [i] ; i = i + 1i32 } } ; println ! (\"Sum:\") ; println ! (\"{}\" , sum) ; let average = sum / 10i32 ; println ! (\"Average:\") ; println ! (\"{}\" , average) } } }\n  |\n\nerror[E0277]: the type `[i32]` cannot be indexed by `i32`\n --> /tmp/.tmp8u4tEa/main.rs:1:199\n  |\n1 | ...irst:\") ; println ! (\"{}\" , numbers [0i32]) ; println ! (\"Last:\") ; println ! (\"{}\" , numbers [9i32]) ; let mut sum = 0i32 ; let mut i...\n  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `Vec<i32>` to implement `Index<i32>`\n\nerror[E0277]: the type `[i32]` cannot be indexed by `i32`\n --> /tmp/.tmp8u4tEa/main.rs:1:257\n  |\n1 | ...Last:\") ; println ! (\"{}\" , numbers [9i32]) ; let mut sum = 0i32 ; let mut i = 0i32 ; while i < 10i32 { { sum = sum + numbers [i] ; i ...\n  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `Vec<i32>` to implement `Index<i32>`\n\nerror[E0277]: the type `[i32]` cannot be indexed by `i32`\n --> /tmp/.tmp8u4tEa/main.rs:1:347\n  |\n1 | ...ile i < 10i32 { { sum = sum + numbers [i] ; i = i + 1i32 } } ; println ! (\"Sum:\") ; println ! (\"{}\" , sum) ; let average = sum / 10i32...\n  |                                           ^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `Vec<i32>` to implement `Index<i32>`\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 7,
          "line_number": 215,
          "code": "// Status: ✅ WORKING\n// scoping.ruchy - Variable scope examples\n\nlet global_var = \"I'm global\"\n\nfun demonstrate_scope() {\n    let local_var = \"I'm local\"\n    println(global_var)  // Can access global\n    println(local_var)   // Can access local\n    \n    // Nested function\n    fun nested() {\n        println(global_var)  // Can access global\n        println(local_var)   // Can access parent local\n        let nested_var = \"I'm nested\"\n        println(nested_var)\n    }\n    \n    nested()\n}\n\nfun main() {\n    demonstrate_scope()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0434]: can't capture dynamic environment in a fn item\n --> /tmp/.tmpwAd2ht/main.rs:1:229\n  |\n1 | ...sted () { { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; { let nested_var = \"I'm nested\" ; println ! (\"{}\" , nested_...\n  |                                                                  ^^^^^^^^^\n  |\n  = help: use the `|| { ... }` closure form instead\n\nerror[E0425]: cannot find value `global_var` in this scope\n --> /tmp/.tmpwAd2ht/main.rs:1:117\n  |\n1 | ... local\" ; { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; fn nested () { { println ! (\"{}\" , global_var) ; println ! ...\n  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `local_var`\n\nerror[E0425]: cannot find value `global_var` in this scope\n --> /tmp/.tmpwAd2ht/main.rs:1:197\n  |\n1 | ...sted () { { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; { let nested_var = \"I'm nested\" ; println ! (\"{}\" , nested_...\n  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `local_var`\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpwAd2ht/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn demonstrate_scope () { { { let local_var = \"I'm local\" ; { println ! (\"{}\" , global_var) ; println...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpwAd2ht/main.rs:1:63\n  |\n1 | ... { { { let local_var = \"I'm local\" ; { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; fn nested () { { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; { let nested_var = \"I'm nested\" ; println ! (\"{}\" , nested_var) } } } ; nested () } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                      ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn demonstrate_scope () { { { let local_var = \"I'm local\" ; { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; fn nested () { { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; { let nested_var = \"I'm nested\" ; println ! (\"{}\" , nested_var) } } } ; nested () } } } } fn main () { let global_var = \"I'm global\" ; { demonstrate_scope () } }\n1 + use std :: collections :: HashMap ; fn demonstrate_scope () { { let local_var = \"I'm local\" ; { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; fn nested () { { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; { let nested_var = \"I'm nested\" ; println ! (\"{}\" , nested_var) } } } ; nested () } } } fn main () { let global_var = \"I'm global\" ; { demonstrate_scope () } }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpwAd2ht/main.rs:1:312\n  |\n1 | ... \"I'm nested\" ; println ! (\"{}\" , nested_var) } } } ; nested () } } } } fn main () { let global_var = \"I'm global\" ; { demonstrate_sco...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpwAd2ht/main.rs:1:377\n  |\n1 | ...) } } } } fn main () { let global_var = \"I'm global\" ; { demonstrate_scope () } }\n  |                                                           ^^                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn demonstrate_scope () { { { let local_var = \"I'm local\" ; { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; fn nested () { { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; { let nested_var = \"I'm nested\" ; println ! (\"{}\" , nested_var) } } } ; nested () } } } } fn main () { let global_var = \"I'm global\" ; { demonstrate_scope () } }\n1 + use std :: collections :: HashMap ; fn demonstrate_scope () { { { let local_var = \"I'm local\" ; { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; fn nested () { { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; { let nested_var = \"I'm nested\" ; println ! (\"{}\" , nested_var) } } } ; nested () } } } } fn main () { let global_var = \"I'm global\" ; demonstrate_scope () }\n  |\n\nwarning: unused variable: `global_var`\n --> /tmp/.tmpwAd2ht/main.rs:1:349\n  |\n1 | ...} } } } fn main () { let global_var = \"I'm global\" ; { demonstrate_scope () } }\n  |                             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_global_var`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\nerror: aborting due to 3 previous errors; 5 warnings emitted\n\nSome errors have detailed explanations: E0425, E0434.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 8,
          "line_number": 252,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let arr = [1, 2, 3]\n\n    // Unsafe - may cause error if index is out of bounds\n    // println(arr[5])\n\n    // Better approach\n    if 5 < arr.len() {\n        println(arr[5])\n    } else {\n        println(\"Index out of bounds\")\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpyA7MEu/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{}\" , ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpyA7MEu/main.rs:1:50\n  |\n1 | ... { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{}\" , arr [5i32]) } } else { { println ! (\"Index out of bounds\") } } } } }\n  |       ^^                                                                                                                                                      ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{}\" , arr [5i32]) } } else { { println ! (\"Index out of bounds\") } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{}\" , arr [5i32]) } } else { { println ! (\"Index out of bounds\") } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpyA7MEu/main.rs:1:118\n  |\n1 | ...! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{}\" , arr [5i32]) } } else { { println ! (\"Index out of bounds\") } } }...\n  |                                                      ^^                             ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{}\" , arr [5i32]) } } else { { println ! (\"Index out of bounds\") } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { println ! (\"{}\" , arr [5i32]) } else { { println ! (\"Index out of bounds\") } } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpyA7MEu/main.rs:1:161\n  |\n1 | ...() { { println ! (\"{}\" , arr [5i32]) } } else { { println ! (\"Index out of bounds\") } } } } }\n  |                                                    ^^                                 ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{}\" , arr [5i32]) } } else { { println ! (\"Index out of bounds\") } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{}\" , arr [5i32]) } } else { println ! (\"Index out of bounds\") } } } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpyA7MEu/main.rs:1:103\n  |\n1 | ...let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{}\" , arr [5i32]) } } else { { println ! (\"Index out of ...\n  |                                              ----   ^^^^^^^^^^^^ expected `i32`, found `usize`\n  |                                              |\n  |                                              expected because this is `i32`\n  |\nhelp: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len ().try_into().unwrap() { { println ! (\"{}\" , arr [5i32]) } } else { { println ! (\"Index out of bounds\") } } } } }\n  |                                                                                                                   ++++++++++++++++++++\n\nerror[E0277]: the type `[i32]` cannot be indexed by `i32`\n --> /tmp/.tmpyA7MEu/main.rs:1:143\n  |\n1 | ... . len () { { println ! (\"{}\" , arr [5i32]) } } else { { println ! (\"Index out of bounds\") } } } } }\n  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `Vec<i32>` to implement `Index<i32>`\n\nerror: aborting due to 2 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 9,
          "line_number": 277,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let x = 5\n    // x = 10  // Error! x is immutable\n\n    // Use mut for mutable variables\n    let mut y = 5\n    y = 10  // OK\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 10,
          "line_number": 297,
          "code": "// Status: ✅ WORKING\nfun get_double(x) {\n    x * 2  // This is returned (no semicolon)\n}\n\nfun process_and_print(x) {\n    let doubled = x * 2\n    println(\"Doubled:\")\n    println(doubled)\n    // No explicit return - returns unit type ()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpJiSpcw/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn get_double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpJiSpcw/main.rs:1:196\n  |\n1 | ...mt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } } fn process_and_print < T : std :: ops :: Add < Output = T ...\n  |                                                                 ^^        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn get_double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } } fn process_and_print < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; { println ! (\"Doubled:\") ; println ! (\"{}\" , doubled) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn get_double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { x * 2i32 } fn process_and_print < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; { println ! (\"Doubled:\") ; println ! (\"{}\" , doubled) } } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpJiSpcw/main.rs:1:377\n  |\n1 | ...Clone > (x : T) -> T { { { let doubled = x * 2i32 ; { println ! (\"Doubled:\") ; println ! (\"{}\" , doubled) } } } } fn main () { }\n  |                           ^^                                                                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn get_double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } } fn process_and_print < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; { println ! (\"Doubled:\") ; println ! (\"{}\" , doubled) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn get_double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } } fn process_and_print < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { let doubled = x * 2i32 ; { println ! (\"Doubled:\") ; println ! (\"{}\" , doubled) } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpJiSpcw/main.rs:1:202\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } ...\n  |       -                                                                                                                                                -   ^^^^ expected type parameter `T`, found `i32`\n  |       |                                                                                                                                                |\n  |       expected this type parameter                                                                                                                     expected because this is `T`\n  |\n  = note: expected type parameter `T`\n                       found type `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpJiSpcw/main.rs:1:399\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; ...\n  |       -                                                                                                                                                                -   ^^^^ expected type parameter `T`, found `i32`\n  |       |                                                                                                                                                                |\n  |       expected this type parameter                                                                                                                                     expected because this is `T`\n  |\n  = note: expected type parameter `T`\n                       found type `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpJiSpcw/main.rs:1:433\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; { println ! (\"Doubled:\") ; println ! (\"{}\" , doubled) } ...\n  |       - expected this type parameter                                                                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 11,
          "line_number": 361,
          "code": "// Status: ✅ WORKING\n// Good: Clear, functional style\nfun calculate_tax(income, rate) {\n    income * rate\n}\n\n// Avoid: Complex nested logic (for now)",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 12,
          "line_number": 376,
          "code": "// Status: ✅ WORKING\n// Good\nlet user_count = 42\nlet total_price = calculate_price(items)\n\n// Avoid\nlet x = 42\nlet y = calc(z)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpSExsEr/main.rs:1:167\n  |\n1 | ...ms) ; let x = 42i32 ; let y = calc (z) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0425]: cannot find value `items` in this scope\n --> /tmp/.tmpSExsEr/main.rs:1:125\n  |\n1 | ..._count = 42i32 ; let total_price = calculate_price (items) ; let x = 42i32 ; let y = calc (z) } ; if let Some (s) = (& result as & dyn...\n  |                                                        ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpSExsEr/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let user_count = 42i32 ; let total_price = calculate_price (items) ; let ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `calculate_price` in this scope\n --> /tmp/.tmpSExsEr/main.rs:1:108\n  |\n1 | ...= { let user_count = 42i32 ; let total_price = calculate_price (items) ; let x = 42i32 ; let y = calc (z) } ; if let Some (s) = (& res...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 13,
          "line_number": 394,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let grades = [95, 87, 92, 78, 89]\n    let first_grade = grades[0]\n    let last_grade = grades[4]\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpU9kJqC/main.rs:1:182\n  |\n1 | ...0i32] ; let last_grade = grades [4i32] } } } }\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpU9kJqC/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let first_grade = gra...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpU9kJqC/main.rs:1:50\n  |\n1 | ... { { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let first_grade = grades [0i32] ; let last_grade = grades [4i32] } } } }\n  |       ^^                                                                                                                                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let first_grade = grades [0i32] ; let last_grade = grades [4i32] } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let first_grade = grades [0i32] ; let last_grade = grades [4i32] } } }\n  |\n\nerror[E0277]: the type `[i32]` cannot be indexed by `i32`\n --> /tmp/.tmpU9kJqC/main.rs:1:143\n  |\n1 | ...89i32] ; { let first_grade = grades [0i32] ; let last_grade = grades [4i32] } } } }\n  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `Vec<i32>` to implement `Index<i32>`\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 14,
          "line_number": 410,
          "code": "// Status: ✅ WORKING\n// Add functions\nfun double(n) { n * 2 }\n\nfun main() {\n    // Start simple\n    let x = 5\n\n    // Combine\n    let result = double(x)\n    println(result)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp4moqE5/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: D...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4moqE5/main.rs:1:192\n  |\n1 | ...mt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } } fn main () { { { let x = 5i32 ; { let result = double (x) ...\n  |                                                                 ^^        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } } fn main () { { { let x = 5i32 ; { let result = double (x) ; println ! (\"{}\" , result) } } } }\n1 + use std :: collections :: HashMap ; fn double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { n * 2i32 } fn main () { { { let x = 5i32 ; { let result = double (x) ; println ! (\"{}\" , result) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4moqE5/main.rs:1:220\n  |\n1 | ...{ n * 2i32 } } fn main () { { { let x = 5i32 ; { let result = double (x) ; println ! (\"{}\" , result) } } } }\n  |                                ^^                                                                          ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } } fn main () { { { let x = 5i32 ; { let result = double (x) ; println ! (\"{}\" , result) } } } }\n1 + use std :: collections :: HashMap ; fn double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } } fn main () { { let x = 5i32 ; { let result = double (x) ; println ! (\"{}\" , result) } } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp4moqE5/main.rs:1:198\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } ...\n  |       -                                                                                                                                                -   ^^^^ expected type parameter `T`, found `i32`\n  |       |                                                                                                                                                |\n  |       expected this type parameter                                                                                                                     expected because this is `T`\n  |\n  = note: expected type parameter `T`\n                       found type `i32`\n\nerror: aborting due to 1 previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 15,
          "line_number": 433,
          "code": "// Status: ✅ WORKING\n// test_calculator.ruchy\nfun add(a, b) { a + b }\n\nfun main() {\n    // Test cases\n    let test1 = add(2, 3) == 5\n    let test2 = add(0, 0) == 0\n    let test3 = add(-1, 1) == 0\n\n    if test1 && test2 && test3 {\n        println(\"All tests passed!\")\n    } else {\n        println(\"Some tests failed\")\n    }\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch17-00-documentation": {
      "chapter": "ch17-00-documentation",
      "total_examples": 10,
      "working_examples": 0,
      "failing_examples": 10,
      "examples": [
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected RightBrace, found Identifier(\"items\")\n/// A high-performance cache with automatic eviction.\n/// \n/// # Examples\n/// \n/// ```\n/// let cache = Cache::new(100)  // Max 100 items\n/// cache.insert(\"key\", \"value\")\n/// assert_eq!(cache.get(\"key\"), Some(\"value\"))\n/// ```\n/// \n/// # Performance\n/// \n/// - Insert: O(1) amortized\n/// - Get: O(1)\n/// - Memory: O(n) where n is cache size\n/// \n/// # Thread Safety\n/// \n/// This cache is thread-safe using internal locking.\n/// For better performance with multiple threads, consider\n/// using `ShardedCache` instead.\npub struct Cache<K, V> {\n    /// Maximum number of items before eviction starts\n    capacity: usize\n    \n    /// Current items in cache\n    items: HashMap<K, V>\n    \n    /// Access order for LRU eviction\n    order: LinkedList<K>\n}\n\nimpl<K, V> Cache<K, V> {\n    /// Creates a new cache with the specified capacity.\n    /// \n    /// # Arguments\n    /// \n    /// * `capacity` - Maximum items to store before eviction\n    /// \n    /// # Panics\n    /// \n    /// Panics if capacity is 0.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// let cache = Cache::new(1000)\n    /// ```\n    pub fn new(capacity: usize) -> Self {\n        assert!(capacity > 0, \"Capacity must be positive\")\n        // Implementation\n    }\n    \n    /// Inserts a key-value pair, evicting LRU item if at capacity.\n    /// \n    /// Returns the evicted value if any.\n    /// \n    /// # Complexity\n    /// \n    /// O(1) amortized time complexity.\n    pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n        // Implementation with inline comments for complex parts\n        \n        // Update access order for LRU\n        self.update_access_order(&key)\n        \n        // Check capacity and evict if necessary\n        if self.items.len() >= self.capacity {\n            // Evict least recently used\n            let lru = self.order.pop_front()\n            // ...\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 2,
          "line_number": 121,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected type\n/// Single line summary of what this does.\n/// \n/// More detailed explanation that provides context,\n/// use cases, and important information.\n/// \n/// # Arguments\n/// \n/// * `param1` - Description of first parameter\n/// * `param2` - Description of second parameter\n/// \n/// # Returns\n/// \n/// Description of return value and what it represents.\n/// \n/// # Errors\n/// \n/// * `ErrorType1` - When this error occurs\n/// * `ErrorType2` - When that error occurs\n/// \n/// # Examples\n/// \n/// ```\n/// let result = function(arg1, arg2)?\n/// assert_eq!(result, expected)\n/// ```\n/// \n/// # Safety\n/// \n/// This function is safe to call from multiple threads.\n/// \n/// # Performance\n/// \n/// Time: O(n log n)\n/// Space: O(n)\npub fn documented_function(param1: Type1, param2: Type2) -> Result<Return, Error> {\n    // Implementation\n}\n\n// Module-level documentation\n//! # Module Name\n//! \n//! This module provides functionality for...\n//! \n//! ## Overview\n//! \n//! Explain the module's purpose and main components.\n//! \n//! ## Usage\n//! \n//! ```\n//! use mylib::module\n//! \n//! let thing = module::Thing::new()\n//! thing.do_stuff()\n//! ```\n\n// Inner documentation\nimpl Struct {\n    fn method(&self) {\n        //! This method does...\n        \n        // Regular comment for implementation details\n        let temp = calculate_something()\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 3,
          "line_number": 199,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected RightParen, found Integer(5)\n/// Calculates the factorial of a number.\n/// \n/// # Examples\n/// \n/// ```\n/// assert_eq!(factorial(0), 1)\n/// assert_eq!(factorial(5), 120)\n/// assert_eq!(factorial(10), 3628800)\n/// ```\n/// \n/// ```should_panic\n/// factorial(-1)  // Panics on negative input\n/// ```\n/// \n/// ```no_run\n/// // Example that shouldn't be executed during tests\n/// let huge = factorial(1000000)\n/// ```\n/// \n/// ```ignore\n/// // Example that's temporarily broken\n/// let result = factorial(non_existent_var)\n/// ```\npub fn factorial(n: i32) -> i32 {\n    assert!(n >= 0, \"Factorial undefined for negative numbers\")\n    if n <= 1 { 1 } else { n * factorial(n - 1) }\n}\n\n// Run doc tests\n$ ruchy test --doc\n   Doc-tests mylib\nrunning 4 doc tests\ntest src/lib.rs - factorial (line 5) ... ok\ntest src/lib.rs - factorial (line 9) ... ok\ntest src/lib.rs - factorial (line 13) ... ok\ntest src/lib.rs - factorial (line 17) ... ignored\n\ntest result: ok. 3 passed; 0 failed; 1 ignored",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 4,
          "line_number": 250,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected type\n/// Configuration for the application.\n/// \n/// This struct holds all configuration values needed to run\n/// the application. It can be loaded from files, environment\n/// variables, or command-line arguments.\n/// \n/// # Example Configuration File\n/// \n/// ```toml\n/// [server]\n/// host = \"localhost\"\n/// port = 8080\n/// \n/// [database]\n/// url = \"postgres://localhost/myapp\"\n/// pool_size = 20\n/// ```\n#[derive(Deserialize, Serialize, Debug)]\npub struct Config {\n    /// Server configuration\n    pub server: ServerConfig,\n    \n    /// Database configuration  \n    pub database: DatabaseConfig,\n    \n    /// Optional cache configuration\n    pub cache: Option<CacheConfig>,\n}\n\n/// Server configuration options.\n#[derive(Deserialize, Serialize, Debug)]\npub struct ServerConfig {\n    /// Host to bind to (default: \"127.0.0.1\")\n    #[serde(default = \"default_host\")]\n    pub host: String,\n    \n    /// Port to listen on (default: 8080)\n    #[serde(default = \"default_port\")]\n    pub port: u16,\n    \n    /// Number of worker threads (default: CPU cores)\n    #[serde(default = \"num_cpus\")]\n    pub workers: usize,\n}\n\n// Generate HTML documentation\n$ ruchy doc --open\nDocumenting mylib v0.1.0\n    Finished documentation\n    Opening docs/mylib/index.html",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 5,
          "line_number": 313,
          "code": "// Status: ✅ WORKING\n\n//! # System Architecture\n//! \n//! ## Overview\n//! \n//! This application follows a layered architecture:\n//! \n//! ```text\n//! ┌─────────────────────────────────┐\n//! │          HTTP Layer             │\n//! │  (Handlers, Middleware, Routes) │\n//! └─────────────┬───────────────────┘\n//!               │\n//! ┌─────────────▼───────────────────┐\n//! │        Service Layer            │\n//! │   (Business Logic, Validation)  │\n//! └─────────────┬───────────────────┘\n//!               │\n//! ┌─────────────▼───────────────────┐\n//! │      Repository Layer           │\n//! │    (Database Access, Caching)   │\n//! └─────────────┬───────────────────┘\n//!               │\n//! ┌─────────────▼───────────────────┐\n//! │         Data Layer              │\n//! │    (PostgreSQL, Redis, S3)      │\n//! └─────────────────────────────────┘\n//! ```\n//! \n//! ## Data Flow\n//! \n//! 1. Request enters through HTTP handler\n//! 2. Handler validates input and calls service\n//! 3. Service applies business logic\n//! 4. Repository handles data persistence\n//! 5. Response flows back through layers\n//! \n//! ## Key Design Decisions\n//! \n//! ### Why Layered Architecture?\n//! \n//! - **Separation of Concerns**: Each layer has a single responsibility\n//! - **Testability**: Layers can be tested independently with mocks\n//! - **Flexibility**: Easy to swap implementations (e.g., database)\n//! \n//! ### Why Event Sourcing?\n//! \n//! - **Audit Trail**: Complete history of all changes\n//! - **Time Travel**: Can reconstruct state at any point\n//! - **Event Replay**: Easy to fix bugs in event processing\n\n/// Module containing HTTP handlers\npub mod handlers {\n    //! HTTP request handlers.\n    //! \n    //! Each handler is responsible for:\n    //! - Request validation\n    //! - Calling appropriate service\n    //! - Response formatting\n}\n\n/// Module containing business logic\npub mod services {\n    //! Business logic layer.\n    //! \n    //! Services contain all business rules and orchestrate\n    //! operations across multiple repositories.\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected item, found `{`\n --> /tmp/.tmpGLg93B/main.rs:1:80\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { mod handlers { { } } ; mod services { { } } } ; if let Some (s) = (& resu...\n  |                                                                                ^ expected item\n  |\n  = note: for a full list of items that can appear in modules, see <https://doc.rust-lang.org/reference/items.html>\n\nerror: expected item, found `{`\n --> /tmp/.tmpGLg93B/main.rs:1:103\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { mod handlers { { } } ; mod services { { } } } ; if let Some (s) = (& resu...\n  |                                                                                                       ^ expected item\n  |\n  = note: for a full list of items that can appear in modules, see <https://doc.rust-lang.org/reference/items.html>\n\nerror: expected item, found `}`\n --> /tmp/.tmpGLg93B/main.rs:1:109\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { mod handlers { { } } ; mod services { { } } } ; if let Some (s) = (& resu...\n  |                                                                                                             ^ expected item\n  |\n  = note: for a full list of items that can appear in modules, see <https://doc.rust-lang.org/reference/items.html>\n\nerror: aborting due to 3 previous errors\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 6,
          "line_number": 510,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Empty program\n/// # Examples Section\n/// \n/// ## Basic Usage\n/// \n/// The simplest way to use this library:\n/// \n/// ```\n/// use mylib::Thing;\n/// \n/// let thing = Thing::default();\n/// thing.process()?;\n/// ```\n/// \n/// ## Advanced Usage\n/// \n/// For more control, configure manually:\n/// \n/// ```\n/// use mylib::{Thing, Config};\n/// \n/// let config = Config::builder()\n///     .timeout(5000)\n///     .retries(3)\n///     .build()?;\n/// \n/// let thing = Thing::with_config(config);\n/// ```\n/// \n/// ## Error Handling\n/// \n/// All operations return `Result`:\n/// \n/// ```\n/// match thing.risky_operation() {\n///     Ok(value) => println!(\"Success: {}\", value),\n///     Err(e) => eprintln!(\"Error: {}\", e),\n/// }\n/// ```\n/// \n/// ## Complete Example\n/// \n/// Here's a full working program:\n/// \n/// ```no_run\n/// use mylib::{Thing, Config, Error};\n/// \n/// fn main() -> Result<(), Error> {\n///     let config = Config::from_env()?;\n///     let thing = Thing::with_config(config);\n///     \n///     for item in thing.process_all()? {\n///         println!(\"Processed: {:?}\", item);\n///     }\n///     \n///     Ok(())\n/// }\n/// ```",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 7,
          "line_number": 580,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: Comma\n// Generate interactive documentation site\n$ ruchy doc --format html --output docs/\n\n// With search, examples, and playground\n$ ruchy doc --features search,playground,examples\n\n// Serve documentation locally\n$ ruchy doc --serve --port 8080\nServing documentation at http://localhost:8080",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 8,
          "line_number": 600,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: RightBracket\n/// Interactive API endpoint documentation\n/// \n/// <playground>\n/// {\n///   \"endpoint\": \"/api/users\",\n///   \"method\": \"POST\",\n///   \"body\": {\n///     \"name\": \"Alice\",\n///     \"email\": \"alice@example.com\"\n///   }\n/// }\n/// </playground>\n#[post(\"/api/users\")]\npub async fun create_user(user: Json<User>) -> Result<Json<User>, Error> {\n    // Implementation\n}\n\n// Generates interactive API tester in docs",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 9,
          "line_number": 631,
          "code": "// Status: ✅ WORKING\n\n// Generate documentation from code\n#[doc_gen]\nimpl ConfigBuilder {\n    // Automatically documents builder pattern\n}\n\n// Generate diagrams from code\n#[diagram(sequence)]\nasync fun request_flow() {\n    client.send_request()\n    server.validate()\n    server.process()\n    server.respond()\n}\n\n// Generates:\n// Client -> Server: send_request()\n// Server -> Server: validate()\n// Server -> Server: process()\n// Server -> Client: respond()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0670]: `async fn` is not permitted in Rust 2015\n --> /tmp/.tmp0ux6k6/main.rs:1:37\n  |\n1 | use std :: collections :: HashMap ; async fn request_flow () { { client . send_request () ; server . validate () ; server . process () ; ...\n  |                                     ^^^^^ to use `async fn`, switch to Rust 2018 or later\n  |\n  = help: pass `--edition 2024` to `rustc`\n  = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n\nerror[E0425]: cannot find value `client` in this scope\n --> /tmp/.tmp0ux6k6/main.rs:1:66\n  |\n1 | use std :: collections :: HashMap ; async fn request_flow () { { client . send_request () ; server . validate () ; server . process () ; ...\n  |                                                                  ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `server` in this scope\n --> /tmp/.tmp0ux6k6/main.rs:1:93\n  |\n1 | use std :: collections :: HashMap ; async fn request_flow () { { client . send_request () ; server . validate () ; server . process () ; ...\n  |                                                                                             ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `server` in this scope\n --> /tmp/.tmp0ux6k6/main.rs:1:116\n  |\n1 | ...{ client . send_request () ; server . validate () ; server . process () ; server . respond () } } fn main () { impl ConfigBuilder { } ; }\n  |                                                        ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `server` in this scope\n --> /tmp/.tmp0ux6k6/main.rs:1:138\n  |\n1 | ...t () ; server . validate () ; server . process () ; server . respond () } } fn main () { impl ConfigBuilder { } ; }\n  |                                                        ^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `ConfigBuilder` in this scope\n --> /tmp/.tmp0ux6k6/main.rs:1:180\n  |\n1 | ... () ; server . respond () } } fn main () { impl ConfigBuilder { } ; }\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp0ux6k6/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; async fn request_flow () { { client . send_request () ; server . validate () ; server . process () ; ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp0ux6k6/main.rs:1:198\n  |\n1 | ... respond () } } fn main () { impl ConfigBuilder { } ; }\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nerror: aborting due to 6 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425, E0670.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 10,
          "line_number": 663,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: DotDotDot\n// Check documentation quality\n$ ruchy doc-lint\nChecking documentation...\n\n⚠️  Missing documentation: src/internal.rs:15 `fun process()`\n⚠️  Broken link: src/lib.rs:42 `[Config](../config.html)`\n⚠️  Outdated example: src/api.rs:88 (code changed)\n❌  Missing examples: src/client.rs `struct Client`\n\nDocumentation score: 87/100\n\n// Enforce in CI\n$ ruchy doc-lint --min-score 90",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch06-00-file-operations": {
      "chapter": "ch06-00-file-operations",
      "total_examples": 10,
      "working_examples": 0,
      "failing_examples": 10,
      "examples": [
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected In, found Comma\n// File: desktop_organizer.ruchy\n// Organizes files by type into folders\n\nprintln(\"=== Desktop Organizer ===\")\n\n// Define organization rules\nlet file_categories = {\n    \"Documents\": [\".pdf\", \".doc\", \".docx\", \".txt\"],\n    \"Images\": [\".jpg\", \".jpeg\", \".png\", \".gif\", \".svg\"],\n    \"Videos\": [\".mp4\", \".avi\", \".mov\", \".mkv\"],\n    \"Code\": [\".py\", \".js\", \".rs\", \".ruchy\", \".cpp\"],\n    \"Data\": [\".csv\", \".json\", \".xml\", \".xlsx\"]\n}\n\nlet source_dir = \"~/Desktop\"\nlet files = list_files(source_dir)\n\nprintln(\"Found \" + files.len().to_s() + \" files to organize\")\n\n// Organize files\nfor file in files {\n    let extension = get_extension(file).lower()\n    \n    for category, extensions in file_categories.items() {\n        if extensions.contains(extension) {\n            let target_dir = join_path(source_dir, category)\n            \n            // Create category folder if needed\n            if !dir_exists(target_dir) {\n                create_dir(target_dir)\n                println(\"Created folder: \" + category)\n            }\n            \n            // Move file to appropriate folder\n            let source = join_path(source_dir, file)\n            let destination = join_path(target_dir, file)\n            \n            move_file(source, destination)\n            println(\"  Moved \" + file + \" -> \" + category + \"/\")\n            break\n        }\n    }\n}\n\nprintln(\"✅ Desktop organized!\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: struct literal body without path\n --> /tmp/.tmpPrn2kV/main.rs:1:129\n  |\n1 | ... = { Documents : vec ! [\".pdf\" , \".doc\" , \".docx\" , \".txt\"] , Images : vec ! [\".jpg\" , \".jpeg\" , \".png\" , \".gif\" , \".svg\"] , Videos : vec ! [\".mp4\" , \".avi\" , \".mov\" , \".mkv\"] , Code : vec ! [\".py\" , \".js\" , \".rs\" , \".ruchy\" , \".cpp\"] , Data : vec ! [\".csv\" , \".json\" , \".xml\" , \".xlsx\"] , } ; ...\n  |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\nhelp: you might have forgotten to add the struct literal inside the block\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Desktop Organizer ===\") ; let file_categories = { SomeStruct { Documents : vec ! [\".pdf\" , \".doc\" , \".docx\" , \".txt\"] , Images : vec ! [\".jpg\" , \".jpeg\" , \".png\" , \".gif\" , \".svg\"] , Videos : vec ! [\".mp4\" , \".avi\" , \".mov\" , \".mkv\"] , Code : vec ! [\".py\" , \".js\" , \".rs\" , \".ruchy\" , \".cpp\"] , Data : vec ! [\".csv\" , \".json\" , \".xml\" , \".xlsx\"] , } } ; let source_dir = \"~/Desktop\" ; let files = list_files (source_dir) ; println ! (\"{}\" , \"Found \" + files . len () . to_s () + \" files to organize\") ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{}\" , \"Created folder: \" + category) } } ; let source = join_path (source_dir , file) ; let destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{}\" , \"  Moved \" + file + \" -> \" + category + \"/\") ; break } } } } } } } } } ; println ! (\"✅ Desktop organized!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |                                                                                                                                 ++++++++++++                                                                                                                                                                                                                                                                                                  +\n\nerror[E0425]: cannot find function `create_dir` in this scope\n --> /tmp/.tmpPrn2kV/main.rs:1:836\n  |\n1 | ... , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{}\" , \"Created folder: \" + category) } } ; let...\n  |                                                      ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::create_dir;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpPrn2kV/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Desktop Organizer ===\") ; let file_categories = { Documen...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpPrn2kV/main.rs:1:589\n  |\n1 | ... { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{}\" , \"Created folder: \" + category) } } ; let source = join_path (source_dir , file) ; let destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{}\" , \"  Moved \" + file + \" -> \" + category + \"/\") ; break } } } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Desktop Organizer ===\") ; let file_categories = { Documents : vec ! [\".pdf\" , \".doc\" , \".docx\" , \".txt\"] , Images : vec ! [\".jpg\" , \".jpeg\" , \".png\" , \".gif\" , \".svg\"] , Videos : vec ! [\".mp4\" , \".avi\" , \".mov\" , \".mkv\"] , Code : vec ! [\".py\" , \".js\" , \".rs\" , \".ruchy\" , \".cpp\"] , Data : vec ! [\".csv\" , \".json\" , \".xml\" , \".xlsx\"] , } ; let source_dir = \"~/Desktop\" ; let files = list_files (source_dir) ; println ! (\"{}\" , \"Found \" + files . len () . to_s () + \" files to organize\") ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{}\" , \"Created folder: \" + category) } } ; let source = join_path (source_dir , file) ; let destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{}\" , \"  Moved \" + file + \" -> \" + category + \"/\") ; break } } } } } } } } } ; println ! (\"✅ Desktop organized!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Desktop Organizer ===\") ; let file_categories = { Documents : vec ! [\".pdf\" , \".doc\" , \".docx\" , \".txt\"] , Images : vec ! [\".jpg\" , \".jpeg\" , \".png\" , \".gif\" , \".svg\"] , Videos : vec ! [\".mp4\" , \".avi\" , \".mov\" , \".mkv\"] , Code : vec ! [\".py\" , \".js\" , \".rs\" , \".ruchy\" , \".cpp\"] , Data : vec ! [\".csv\" , \".json\" , \".xml\" , \".xlsx\"] , } ; let source_dir = \"~/Desktop\" ; let files = list_files (source_dir) ; println ! (\"{}\" , \"Found \" + files . len () . to_s () + \" files to organize\") ; for file in files { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{}\" , \"Created folder: \" + category) } } ; let source = join_path (source_dir , file) ; let destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{}\" , \"  Moved \" + file + \" -> \" + category + \"/\") ; break } } } } } } } } ; println ! (\"✅ Desktop organized!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpPrn2kV/main.rs:1:703\n  |\n1 | ... { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{}\" , \"Created folder: \" + category) } } ; let source = join_path (source_dir , file) ; let destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{}\" , \"  Moved \" + file + \" -> \" + category + \"/\") ; break } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Desktop Organizer ===\") ; let file_categories = { Documents : vec ! [\".pdf\" , \".doc\" , \".docx\" , \".txt\"] , Images : vec ! [\".jpg\" , \".jpeg\" , \".png\" , \".gif\" , \".svg\"] , Videos : vec ! [\".mp4\" , \".avi\" , \".mov\" , \".mkv\"] , Code : vec ! [\".py\" , \".js\" , \".rs\" , \".ruchy\" , \".cpp\"] , Data : vec ! [\".csv\" , \".json\" , \".xml\" , \".xlsx\"] , } ; let source_dir = \"~/Desktop\" ; let files = list_files (source_dir) ; println ! (\"{}\" , \"Found \" + files . len () . to_s () + \" files to organize\") ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{}\" , \"Created folder: \" + category) } } ; let source = join_path (source_dir , file) ; let destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{}\" , \"  Moved \" + file + \" -> \" + category + \"/\") ; break } } } } } } } } } ; println ! (\"✅ Desktop organized!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Desktop Organizer ===\") ; let file_categories = { Documents : vec ! [\".pdf\" , \".doc\" , \".docx\" , \".txt\"] , Images : vec ! [\".jpg\" , \".jpeg\" , \".png\" , \".gif\" , \".svg\"] , Videos : vec ! [\".mp4\" , \".avi\" , \".mov\" , \".mkv\"] , Code : vec ! [\".py\" , \".js\" , \".rs\" , \".ruchy\" , \".cpp\"] , Data : vec ! [\".csv\" , \".json\" , \".xml\" , \".xlsx\"] , } ; let source_dir = \"~/Desktop\" ; let files = list_files (source_dir) ; println ! (\"{}\" , \"Found \" + files . len () . to_s () + \" files to organize\") ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{}\" , \"Created folder: \" + category) } } ; let source = join_path (source_dir , file) ; let destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{}\" , \"  Moved \" + file + \" -> \" + category + \"/\") ; break } } } } } } } } ; println ! (\"✅ Desktop organized!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpPrn2kV/main.rs:1:744\n  |\n1 | ... { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{}\" , \"Created folder: \" + category) } } ; let source = join_path (source_dir , file) ; let destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{}\" , \"  Moved \" + file + \" -> \" + category + \"/\") ; break } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Desktop Organizer ===\") ; let file_categories = { Documents : vec ! [\".pdf\" , \".doc\" , \".docx\" , \".txt\"] , Images : vec ! [\".jpg\" , \".jpeg\" , \".png\" , \".gif\" , \".svg\"] , Videos : vec ! [\".mp4\" , \".avi\" , \".mov\" , \".mkv\"] , Code : vec ! [\".py\" , \".js\" , \".rs\" , \".ruchy\" , \".cpp\"] , Data : vec ! [\".csv\" , \".json\" , \".xml\" , \".xlsx\"] , } ; let source_dir = \"~/Desktop\" ; let files = list_files (source_dir) ; println ! (\"{}\" , \"Found \" + files . len () . to_s () + \" files to organize\") ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{}\" , \"Created folder: \" + category) } } ; let source = join_path (source_dir , file) ; let destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{}\" , \"  Moved \" + file + \" -> \" + category + \"/\") ; break } } } } } } } } } ; println ! (\"✅ Desktop organized!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Desktop Organizer ===\") ; let file_categories = { Documents : vec ! [\".pdf\" , \".doc\" , \".docx\" , \".txt\"] , Images : vec ! [\".jpg\" , \".jpeg\" , \".png\" , \".gif\" , \".svg\"] , Videos : vec ! [\".mp4\" , \".avi\" , \".mov\" , \".mkv\"] , Code : vec ! [\".py\" , \".js\" , \".rs\" , \".ruchy\" , \".cpp\"] , Data : vec ! [\".csv\" , \".json\" , \".xml\" , \".xlsx\"] , } ; let source_dir = \"~/Desktop\" ; let files = list_files (source_dir) ; println ! (\"{}\" , \"Found \" + files . len () . to_s () + \" files to organize\") ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{}\" , \"Created folder: \" + category) } } ; let source = join_path (source_dir , file) ; let destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{}\" , \"  Moved \" + file + \" -> \" + category + \"/\") ; break } } } } } } } } ; println ! (\"✅ Desktop organized!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `list_files` in this scope\n --> /tmp/.tmpPrn2kV/main.rs:1:463\n  |\n1 | ... , } ; let source_dir = \"~/Desktop\" ; let files = list_files (source_dir) ; println ! (\"{}\" , \"Found \" + files . len () . to_s () + \" ...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmpPrn2kV/main.rs:1:543\n  |\n1 | ...s (source_dir) ; println ! (\"{}\" , \"Found \" + files . len () . to_s () + \" files to organize\") ; for file in files { { { let extension...\n  |                                       ----------------------------------- ^ -------------------- &str\n  |                                       |\n  |                                       str\n\nerror[E0425]: cannot find function `get_extension` in this scope\n --> /tmp/.tmpPrn2kV/main.rs:1:609\n  |\n1 | ...ize\") ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . ite...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpPrn2kV/main.rs:1:765\n  |\n1 | ...ons . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (t...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `dir_exists` in this scope\n --> /tmp/.tmpPrn2kV/main.rs:1:808\n  |\n1 | ..._dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{}\" , \"Created fol...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `_` to `&str`\n --> /tmp/.tmpPrn2kV/main.rs:1:899\n  |\n1 | ...r) { { create_dir (target_dir) ; println ! (\"{}\" , \"Created folder: \" + category) } } ; let source = join_path (source_dir , file) ; l...\n  |                                                       ------------------ ^ -------- _\n  |                                                       |\n  |                                                       &str\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpPrn2kV/main.rs:1:930\n  |\n1 | ...\"Created folder: \" + category) } } ; let source = join_path (source_dir , file) ; let destination = join_path (target_dir , file) ; mo...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpPrn2kV/main.rs:1:980\n  |\n1 | ...join_path (source_dir , file) ; let destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{}\" ,...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `move_file` in this scope\n --> /tmp/.tmpPrn2kV/main.rs:1:1012\n  |\n1 | ...let destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{}\" , \"  Moved \" + file + \" -> \" + ca...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `_` to `&str`\n --> /tmp/.tmpPrn2kV/main.rs:1:1076\n  |\n1 | ...) ; move_file (source , destination) ; println ! (\"{}\" , \"  Moved \" + file + \" -> \" + category + \"/\") ; break } } } } } } } } } ; prin...\n  |                                                             ---------- ^ ---- _\n  |                                                             |\n  |                                                             &str\n\nerror: aborting due to 12 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0369, E0425.\nFor more information about an error, try `rustc --explain E0369`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 2,
          "line_number": 91,
          "code": "// Status: ✅ WORKING\n\n// Current directory operations\nlet current_dir = get_current_dir()\nset_current_dir(\"/home/user/projects\")\n\n// Path operations\nlet full_path = absolute_path(\"data.txt\")\nlet parent = parent_dir(full_path)\nlet filename = file_name(full_path)\nlet extension = file_extension(full_path)\n\n// Path joining and normalization\nlet project_path = join_path(home_dir(), \"projects\", \"my_app\")\nlet clean_path = normalize_path(\".././data//file.txt\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpzZMdBW/main.rs:1:438\n  |\n1 | ...normalize_path (\".././data//file.txt\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0425]: cannot find function `set_current_dir` in this scope\n --> /tmp/.tmpzZMdBW/main.rs:1:104\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let current_dir = get_current_dir () ; set_current_dir (\"/home/user/proje...\n  |                                                                                                        ^^^^^^^^^^^^^^^\n  |\nhelp: a local variable with a similar name exists\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { let current_dir = get_current_dir () ; set_current_dir (\"/home/user/projects\") ; let full_path = absolute_path (\"data.txt\") ; let parent = parent_dir (full_path) ; let filename = file_name (full_path) ; let extension = file_extension (full_path) ; let project_path = join_path (home_dir () , \"projects\" , \"my_app\") ; let clean_path = normalize_path (\".././data//file.txt\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { let current_dir = get_current_dir () ; current_dir (\"/home/user/projects\") ; let full_path = absolute_path (\"data.txt\") ; let parent = parent_dir (full_path) ; let filename = file_name (full_path) ; let extension = file_extension (full_path) ; let project_path = join_path (home_dir () , \"projects\" , \"my_app\") ; let clean_path = normalize_path (\".././data//file.txt\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\nhelp: consider importing this function\n  |\n1 + use std::env::set_current_dir;\n  |\n\nerror[E0425]: cannot find function `home_dir` in this scope\n --> /tmp/.tmpzZMdBW/main.rs:1:343\n  |\n1 | ...ension (full_path) ; let project_path = join_path (home_dir () , \"projects\" , \"my_app\") ; let clean_path = normalize_path (\".././data/...\n  |                                                       ^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::env::home_dir;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpzZMdBW/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let current_dir = get_current_dir () ; set_current_dir (\"/home/user/proje...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `get_current_dir` in this scope\n --> /tmp/.tmpzZMdBW/main.rs:1:83\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let current_dir = get_current_dir () ; set_current_dir (\"/home/user/proje...\n  |                                                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `absolute_path` in this scope\n --> /tmp/.tmpzZMdBW/main.rs:1:162\n  |\n1 | ...t_dir (\"/home/user/projects\") ; let full_path = absolute_path (\"data.txt\") ; let parent = parent_dir (full_path) ; let filename = file...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `parent_dir` in this scope\n --> /tmp/.tmpzZMdBW/main.rs:1:204\n  |\n1 | ... (\"data.txt\") ; let parent = parent_dir (full_path) ; let filename = file_name (full_path) ; let extension = file_extension (full_path...\n  |                                 ^^^^^^^^^^ help: a local variable with a similar name exists: `current_dir`\n\nerror[E0425]: cannot find function `file_name` in this scope\n --> /tmp/.tmpzZMdBW/main.rs:1:244\n  |\n1 | ... parent = parent_dir (full_path) ; let filename = file_name (full_path) ; let extension = file_extension (full_path) ; let project_pat...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_extension` in this scope\n --> /tmp/.tmpzZMdBW/main.rs:1:284\n  |\n1 | ...ename = file_name (full_path) ; let extension = file_extension (full_path) ; let project_path = join_path (home_dir () , \"projects\" , ...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpzZMdBW/main.rs:1:332\n  |\n1 | ...= file_extension (full_path) ; let project_path = join_path (home_dir () , \"projects\" , \"my_app\") ; let clean_path = normalize_path (\"...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 9 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 3,
          "line_number": 117,
          "code": "// Status: ✅ WORKING\n\n// Check file properties\nlet exists = file_exists(\"config.json\")\nlet size = file_size(\"data.csv\")  // In bytes\nlet modified = file_modified_time(\"log.txt\")\nlet is_read_only = is_readonly(\"system.conf\")\n\n// File type checking\nlet is_file = is_file(path)\nlet is_dir = is_directory(path)\nlet is_symlink = is_symbolic_link(path)\n\n// Permissions (Unix-like systems)\nlet can_read = is_readable(path)\nlet can_write = is_writable(path)\nlet can_execute = is_executable(path)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmp6NAOWL/main.rs:1:462\n  |\n1 | ...let can_execute = is_executable (path) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0423]: expected value, found built-in attribute `path`\n --> /tmp/.tmp6NAOWL/main.rs:1:264\n  |\n1 | ...nly = is_readonly (\"system.conf\") ; let is_file = is_file (path) ; let is_dir = is_directory (path) ; let is_symlink = is_symbolic_lin...\n  |                                                               ^^^^ not a value\n\nerror[E0423]: expected value, found built-in attribute `path`\n --> /tmp/.tmp6NAOWL/main.rs:1:299\n  |\n1 | ... let is_file = is_file (path) ; let is_dir = is_directory (path) ; let is_symlink = is_symbolic_link (path) ; let can_read = is_readab...\n  |                                                               ^^^^ not a value\n\nerror[E0423]: expected value, found built-in attribute `path`\n --> /tmp/.tmp6NAOWL/main.rs:1:342\n  |\n1 | ...= is_directory (path) ; let is_symlink = is_symbolic_link (path) ; let can_read = is_readable (path) ; let can_write = is_writable (pa...\n  |                                                               ^^^^ not a value\n\nerror[E0423]: expected value, found built-in attribute `path`\n --> /tmp/.tmp6NAOWL/main.rs:1:378\n  |\n1 | ...nk = is_symbolic_link (path) ; let can_read = is_readable (path) ; let can_write = is_writable (path) ; let can_execute = is_executabl...\n  |                                                               ^^^^ not a value\n\nerror[E0423]: expected value, found built-in attribute `path`\n --> /tmp/.tmp6NAOWL/main.rs:1:415\n  |\n1 | ...n_read = is_readable (path) ; let can_write = is_writable (path) ; let can_execute = is_executable (path) } ; if let Some (s) = (& res...\n  |                                                               ^^^^ not a value\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp6NAOWL/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let exists = file_exists (\"config.json\") ; let size = file_size (\"data.cs...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmp6NAOWL/main.rs:1:78\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let exists = file_exists (\"config.json\") ; let size = file_size (\"data.cs...\n  |                                                                              ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_size` in this scope\n --> /tmp/.tmp6NAOWL/main.rs:1:119\n  |\n1 | ...exists = file_exists (\"config.json\") ; let size = file_size (\"data.csv\") ; let modified = file_modified_time (\"log.txt\") ; let is_read...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_modified_time` in this scope\n --> /tmp/.tmp6NAOWL/main.rs:1:159\n  |\n1 | ...ize = file_size (\"data.csv\") ; let modified = file_modified_time (\"log.txt\") ; let is_read_only = is_readonly (\"system.conf\") ; let is...\n  |                                                  ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_readonly` in this scope\n --> /tmp/.tmp6NAOWL/main.rs:1:211\n  |\n1 | ...e_modified_time (\"log.txt\") ; let is_read_only = is_readonly (\"system.conf\") ; let is_file = is_file (path) ; let is_dir = is_director...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_file` in this scope\n --> /tmp/.tmp6NAOWL/main.rs:1:255\n  |\n1 | ...only = is_readonly (\"system.conf\") ; let is_file = is_file (path) ; let is_dir = is_directory (path) ; let is_symlink = is_symbolic_li...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_directory` in this scope\n --> /tmp/.tmp6NAOWL/main.rs:1:285\n  |\n1 | ...\") ; let is_file = is_file (path) ; let is_dir = is_directory (path) ; let is_symlink = is_symbolic_link (path) ; let can_read = is_re...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_symbolic_link` in this scope\n --> /tmp/.tmp6NAOWL/main.rs:1:324\n  |\n1 | ...s_dir = is_directory (path) ; let is_symlink = is_symbolic_link (path) ; let can_read = is_readable (path) ; let can_write = is_writab...\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_readable` in this scope\n --> /tmp/.tmp6NAOWL/main.rs:1:365\n  |\n1 | ...mlink = is_symbolic_link (path) ; let can_read = is_readable (path) ; let can_write = is_writable (path) ; let can_execute = is_execut...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_writable` in this scope\n --> /tmp/.tmp6NAOWL/main.rs:1:402\n  |\n1 | ... can_read = is_readable (path) ; let can_write = is_writable (path) ; let can_execute = is_executable (path) } ; if let Some (s) = (& ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 15 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0423, E0425.\nFor more information about an error, try `rustc --explain E0423`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 4,
          "line_number": 145,
          "code": "// Status: ✅ WORKING\n\n// Create and remove directories\ncreate_dir(\"new_folder\")\ncreate_dir_all(\"path/to/nested/folder\")  // Creates parent dirs\nremove_dir(\"empty_folder\")\nremove_dir_all(\"folder_with_contents\")  // Recursive delete\n\n// List directory contents\nlet all_items = list_dir(\".\")\nlet files_only = list_files(\".\")\nlet dirs_only = list_directories(\".\")\n\n// Recursive directory walking\nfun walk_directory(dir) {\n    let items = list_dir(dir)\n    for item in items {\n        let path = join_path(dir, item)\n        if is_directory(path) {\n            walk_directory(path)  // Recurse into subdirectory\n        } else {\n            process_file(path)\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find function `create_dir` in this scope\n --> /tmp/.tmpLouw9e/main.rs:1:406\n  |\n1 | ... process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\") ; create_dir_all (\"path/to/nested/folder\") ; remove_dir (\"...\n  |                                                      ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::create_dir;\n  |\n\nerror[E0425]: cannot find function `create_dir_all` in this scope\n --> /tmp/.tmpLouw9e/main.rs:1:434\n  |\n1 | ... } } } fn main () { create_dir (\"new_folder\") ; create_dir_all (\"path/to/nested/folder\") ; remove_dir (\"empty_folder\") ; remove_dir_al...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::create_dir_all;\n  |\n\nerror[E0425]: cannot find function `remove_dir` in this scope\n --> /tmp/.tmpLouw9e/main.rs:1:477\n  |\n1 | ...er\") ; create_dir_all (\"path/to/nested/folder\") ; remove_dir (\"empty_folder\") ; remove_dir_all (\"folder_with_contents\") ; let all_item...\n  |                                                      ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::remove_dir;\n  |\n\nerror[E0425]: cannot find function `remove_dir_all` in this scope\n --> /tmp/.tmpLouw9e/main.rs:1:507\n  |\n1 | ...nested/folder\") ; remove_dir (\"empty_folder\") ; remove_dir_all (\"folder_with_contents\") ; let all_items = list_dir (\".\") ; let files_o...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::remove_dir_all;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpLouw9e/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpLouw9e/main.rs:1:202\n  |\n1 | ... { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } ...\n  |       ^^                                                                                                                                                                                        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\") ; create_dir_all (\"path/to/nested/folder\") ; remove_dir (\"empty_folder\") ; remove_dir_all (\"folder_with_contents\") ; let all_items = list_dir (\".\") ; let files_only = list_files (\".\") ; let dirs_only = list_directories (\".\") ; }\n1 + use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } fn main () { create_dir (\"new_folder\") ; create_dir_all (\"path/to/nested/folder\") ; remove_dir (\"empty_folder\") ; remove_dir_all (\"folder_with_contents\") ; let all_items = list_dir (\".\") ; let files_only = list_files (\".\") ; let dirs_only = list_directories (\".\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpLouw9e/main.rs:1:255\n  |\n1 | ... { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } ...\n  |       ^^                                                                                                                             ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\") ; create_dir_all (\"path/to/nested/folder\") ; remove_dir (\"empty_folder\") ; remove_dir_all (\"folder_with_contents\") ; let all_items = list_dir (\".\") ; let files_only = list_files (\".\") ; let dirs_only = list_directories (\".\") ; }\n1 + use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } fn main () { create_dir (\"new_folder\") ; create_dir_all (\"path/to/nested/folder\") ; remove_dir (\"empty_folder\") ; remove_dir_all (\"folder_with_contents\") ; let all_items = list_dir (\".\") ; let files_only = list_files (\".\") ; let dirs_only = list_directories (\".\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpLouw9e/main.rs:1:320\n  |\n1 | ...h = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main...\n  |                                                          ^^                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\") ; create_dir_all (\"path/to/nested/folder\") ; remove_dir (\"empty_folder\") ; remove_dir_all (\"folder_with_contents\") ; let all_items = list_dir (\".\") ; let files_only = list_files (\".\") ; let dirs_only = list_directories (\".\") ; }\n1 + use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { walk_directory (path) } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\") ; create_dir_all (\"path/to/nested/folder\") ; remove_dir (\"empty_folder\") ; remove_dir_all (\"folder_with_contents\") ; let all_items = list_dir (\".\") ; let files_only = list_files (\".\") ; let dirs_only = list_directories (\".\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpLouw9e/main.rs:1:355\n  |\n1 | ..._directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\") ; ...\n  |                                                           ^^                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\") ; create_dir_all (\"path/to/nested/folder\") ; remove_dir (\"empty_folder\") ; remove_dir_all (\"folder_with_contents\") ; let all_items = list_dir (\".\") ; let files_only = list_files (\".\") ; let dirs_only = list_directories (\".\") ; }\n1 + use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { process_file (path) } } } } } } } fn main () { create_dir (\"new_folder\") ; create_dir_all (\"path/to/nested/folder\") ; remove_dir (\"empty_folder\") ; remove_dir_all (\"folder_with_contents\") ; let all_items = list_dir (\".\") ; let files_only = list_files (\".\") ; let dirs_only = list_directories (\".\") ; }\n  |\n\nerror[E0425]: cannot find function `list_dir` in this scope\n --> /tmp/.tmpLouw9e/main.rs:1:218\n  |\n1 | ...: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpLouw9e/main.rs:1:270\n  |\n1 | ...st_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else {...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_directory` in this scope\n --> /tmp/.tmpLouw9e/main.rs:1:298\n  |\n1 | ...ems { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } ...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: cannot add `()` to `()`\n --> /tmp/.tmpLouw9e/main.rs:1:338\n  |\n1 | ... , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (...\n  |                                          --------------  ^^^^ no implementation for `() + ()`\n  |                                          |\n  |                                          required by a bound introduced by this call\n  |\n  = help: the trait `Add` is not implemented for `()`\nnote: required by a bound in `walk_directory`\n --> /tmp/.tmpLouw9e/main.rs:1:61\n  |\n1 | ...ap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt ...\n  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `walk_directory`\n\nerror[E0277]: cannot multiply `()` by `()`\n --> /tmp/.tmpLouw9e/main.rs:1:338\n  |\n1 | ... , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (...\n  |                                          --------------  ^^^^ no implementation for `() * ()`\n  |                                          |\n  |                                          required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `()`\nnote: required by a bound in `walk_directory`\n --> /tmp/.tmpLouw9e/main.rs:1:96\n  |\n1 | ... ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T {...\n  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `walk_directory`\n\nerror[E0277]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmpLouw9e/main.rs:1:338\n  |\n1 | ... if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folde...\n  |                                --------------  ^^^^ the trait `std::fmt::Display` is not implemented for `()`\n  |                                |\n  |                                required by a bound introduced by this call\n  |\nnote: required by a bound in `walk_directory`\n --> /tmp/.tmpLouw9e/main.rs:1:131\n  |\n1 | ...std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (di...\n  |                                       ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `walk_directory`\n\nerror[E0425]: cannot find function `process_file` in this scope\n --> /tmp/.tmpLouw9e/main.rs:1:357\n  |\n1 | ...ry (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\") ; create_d...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpLouw9e/main.rs:1:235\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } ...\n  |       -                                                                                                                                            -                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |       |                                                                                                                                            |\n  |       expected this type parameter                                                                                                                 expected `T` because of return type\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: the caller chooses a type for `T` which can be different from `()`\n  = note: `for` loops evaluate to unit type `()`\nhelp: consider returning a value here\n  |\n1 | use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } /* `T` value */ } } } fn main () { create_dir (\"new_folder\") ; create_dir_all (\"path/to/nested/folder\") ; remove_dir (\"empty_folder\") ; remove_dir_all (\"folder_with_contents\") ; let all_items = list_dir (\".\") ; let files_only = list_files (\".\") ; let dirs_only = list_directories (\".\") ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                   +++++++++++++++\n\nerror[E0425]: cannot find function `list_dir` in this scope\n --> /tmp/.tmpLouw9e/main.rs:1:565\n  |\n1 | ...dir_all (\"folder_with_contents\") ; let all_items = list_dir (\".\") ; let files_only = list_files (\".\") ; let dirs_only = list_directori...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `list_files` in this scope\n --> /tmp/.tmpLouw9e/main.rs:1:599\n  |\n1 | ...let all_items = list_dir (\".\") ; let files_only = list_files (\".\") ; let dirs_only = list_directories (\".\") ; }\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `list_directories` in this scope\n --> /tmp/.tmpLouw9e/main.rs:1:634\n  |\n1 | ...iles_only = list_files (\".\") ; let dirs_only = list_directories (\".\") ; }\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 15 previous errors; 5 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 5,
          "line_number": 182,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected In, found Comma\n// File: smart_backup.ruchy\n// Creates timestamped backups of important files\n\nprintln(\"=== Smart Backup System ===\")\n\nlet backup_config = {\n    \"documents\": [\"~/Documents\", \"*.doc\", \"*.pdf\", \"*.txt\"],\n    \"code\": [\"~/Projects\", \"*.py\", \"*.js\", \"*.rs\"],\n    \"config\": [\"~/.config\", \"*.conf\", \"*.json\", \"*.yaml\"]\n}\n\nlet backup_root = \"~/Backups\"\nlet timestamp = current_datetime().format(\"%Y%m%d_%H%M%S\")\nlet backup_dir = join_path(backup_root, \"backup_\" + timestamp)\n\ncreate_dir_all(backup_dir)\nprintln(\"Creating backup at: \" + backup_dir)\n\nlet total_files = 0\nlet total_size = 0\n\nfor category, config in backup_config.items() {\n    let source_dir = expand_home(config[0])\n    let patterns = config[1..]\n    \n    let category_dir = join_path(backup_dir, category)\n    create_dir(category_dir)\n    \n    println(\"\\n📁 Backing up \" + category + \"...\")\n    \n    for pattern in patterns {\n        let files = glob(join_path(source_dir, pattern))\n        \n        for file in files {\n            let size = file_size(file)\n            let relative_path = relative_to(file, source_dir)\n            let backup_path = join_path(category_dir, relative_path)\n            \n            // Create parent directories\n            let parent = parent_dir(backup_path)\n            if !dir_exists(parent) {\n                create_dir_all(parent)\n            }\n            \n            // Copy file to backup\n            copy_file(file, backup_path)\n            total_files += 1\n            total_size += size\n            \n            println(\"  ✓ \" + relative_path + \" (\" + format_size(size) + \")\")\n        }\n    }\n}\n\nprintln(\"\\n✅ Backup complete!\")\nprintln(\"Files backed up: \" + total_files.to_s())\nprintln(\"Total size: \" + format_size(total_size))\nprintln(\"Location: \" + backup_dir)\n\n// Create backup summary\nlet summary = \"Backup Summary\\n==============\\nDate: \" + timestamp + \"\\nFiles: \" + total_files.to_s() + \"\\nSize: \" + format_size(total_size) + \"\\nCategories: \" + backup_config.keys().join(\", \") + \"\\n\"\n\nwrite_file(join_path(backup_dir, \"summary.txt\"), summary)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 6,
          "line_number": 256,
          "code": "// Status: ✅ WORKING\n\n// File: find_duplicates.ruchy\n// Finds duplicate files based on content hash\n\nprintln(\"=== Duplicate File Finder ===\")\n\nlet search_dir = input(\"Enter directory to search: \")\nlet min_size = input(\"Minimum file size (bytes, 0 for all): \").to_i()\n\nprintln(\"\\nScanning \" + search_dir + \"...\")\n\n// Build file hash map\nlet file_hashes = {}\nlet duplicates = []\n\nfun hash_file(path) {\n    let content = read_bytes(path)\n    return sha256(content)\n}\n\nfun scan_directory(dir) {\n    let items = list_dir(dir)\n    \n    for item in items {\n        let path = join_path(dir, item)\n        \n        if is_directory(path) {\n            scan_directory(path)  // Recurse\n        } else if is_file(path) {\n            let size = file_size(path)\n            \n            if size >= min_size {\n                let hash = hash_file(path)\n                \n                if file_hashes.has_key(hash) {\n                    // Found duplicate\n                    duplicates.push({\n                        \"original\": file_hashes[hash],\n                        \"duplicate\": path,\n                        \"size\": size,\n                        \"hash\": hash\n                    })\n                } else {\n                    file_hashes[hash] = path\n                }\n            }\n        }\n    }\n}\n\nscan_directory(search_dir)\n\nif duplicates.is_empty() {\n    println(\"\\n✅ No duplicate files found!\")\n} else {\n    println(\"\\n⚠️  Found \" + duplicates.len().to_s() + \" duplicate files:\")\n    \n    let total_wasted = 0\n    \n    for dup in duplicates {\n        println(\"\\nOriginal: \" + dup.original)\n        println(\"Duplicate: \" + dup.duplicate)\n        println(\"Size: \" + format_size(dup.size))\n        total_wasted += dup.size\n    }\n    \n    println(\"\\nTotal space wasted: \" + format_size(total_wasted))\n    \n    let action = input(\"\\nDelete duplicates? (y/n): \")\n    if action.lower() == \"y\" {\n        for dup in duplicates {\n            remove_file(dup.duplicate)\n            println(\"Deleted: \" + dup.duplicate)\n        }\n        println(\"\\n✅ Freed \" + format_size(total_wasted) + \" of space!\")\n    }\n}",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: struct literal body without path\n --> /tmp/.tmpskQvTx/main.rs:1:749\n  |\n1 | ...h) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes...\n  |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\nhelp: you might have forgotten to add the struct literal inside the block\n  |\n1 | use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ SomeStruct { original : file_hashes [hash] , duplicate : path , size : size , hash : hash , } }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let search_dir = input (\"Enter directory to search: \") ; let min_size = input (\"Minimum file size (bytes, 0 for all): \") . to_i () ; println ! (\"{}\" , \"\\nScanning \" + search_dir + \"...\") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{}\" , \"\\n⚠\\u{fe0f}  Found \" + duplicates . len () . to_s () + \" duplicate files:\") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , \"\\nOriginal: \" + dup . original) ; println ! (\"{}\" , \"Duplicate: \" + dup . duplicate) ; println ! (\"{}\" , \"Size: \" + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! (\"{}\" , \"\\nTotal space wasted: \" + format_size (total_wasted)) ; let action = input (\"\\nDelete duplicates? (y/n): \") ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , \"Deleted: \" + dup . duplicate) } } ; println ! (\"{}\" , \"\\n✅ Freed \" + format_size (total_wasted) + \" of space!\") } } } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ++++++++++++                                                                                    +\n\nerror[E0425]: cannot find value `min_size` in this scope\n --> /tmp/.tmpskQvTx/main.rs:1:649\n  |\n1 | ...th) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { du...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `file_hashes` in this scope\n --> /tmp/.tmpskQvTx/main.rs:1:697\n  |\n1 | ... min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] ,...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `duplicates` in this scope\n --> /tmp/.tmpskQvTx/main.rs:1:730\n  |\n1 | ...file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size ...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `file_hashes` in this scope\n --> /tmp/.tmpskQvTx/main.rs:1:846\n  |\n1 | ...th , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `remove_file` in this scope\n --> /tmp/.tmpskQvTx/main.rs:1:1856\n  |\n1 | ... . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , \"Deleted: \" + dup . duplicate) } } ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::remove_file;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpskQvTx/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpskQvTx/main.rs:1:198\n  |\n1 | ...Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: o...\n  |                                      ^^                                                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let search_dir = input (\"Enter directory to search: \") ; let min_size = input (\"Minimum file size (bytes, 0 for all): \") . to_i () ; println ! (\"{}\" , \"\\nScanning \" + search_dir + \"...\") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{}\" , \"\\n⚠\\u{fe0f}  Found \" + duplicates . len () . to_s () + \" duplicate files:\") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , \"\\nOriginal: \" + dup . original) ; println ! (\"{}\" , \"Duplicate: \" + dup . duplicate) ; println ! (\"{}\" , \"Size: \" + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! (\"{}\" , \"\\nTotal space wasted: \" + format_size (total_wasted)) ; let action = input (\"\\nDelete duplicates? (y/n): \") ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , \"Deleted: \" + dup . duplicate) } } ; println ! (\"{}\" , \"\\n✅ Freed \" + format_size (total_wasted) + \" of space!\") } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { let content = read_bytes (path) ; return sha256 (content) } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let search_dir = input (\"Enter directory to search: \") ; let min_size = input (\"Minimum file size (bytes, 0 for all): \") . to_i () ; println ! (\"{}\" , \"\\nScanning \" + search_dir + \"...\") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{}\" , \"\\n⚠\\u{fe0f}  Found \" + duplicates . len () . to_s () + \" duplicate files:\") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , \"\\nOriginal: \" + dup . original) ; println ! (\"{}\" , \"Duplicate: \" + dup . duplicate) ; println ! (\"{}\" , \"Size: \" + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! (\"{}\" , \"\\nTotal space wasted: \" + format_size (total_wasted)) ; let action = input (\"\\nDelete duplicates? (y/n): \") ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , \"Deleted: \" + dup . duplicate) } } ; println ! (\"{}\" , \"\\n✅ Freed \" + format_size (total_wasted) + \" of space!\") } } } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpskQvTx/main.rs:1:431\n  |\n1 | ... { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let search_dir = input (\"Enter directory to search: \") ; let min_size = input (\"Minimum file size (bytes, 0 for all): \") . to_i () ; println ! (\"{}\" , \"\\nScanning \" + search_dir + \"...\") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{}\" , \"\\n⚠\\u{fe0f}  Found \" + duplicates . len () . to_s () + \" duplicate files:\") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , \"\\nOriginal: \" + dup . original) ; println ! (\"{}\" , \"Duplicate: \" + dup . duplicate) ; println ! (\"{}\" , \"Size: \" + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! (\"{}\" , \"\\nTotal space wasted: \" + format_size (total_wasted)) ; let action = input (\"\\nDelete duplicates? (y/n): \") ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , \"Deleted: \" + dup . duplicate) } } ; println ! (\"{}\" , \"\\n✅ Freed \" + format_size (total_wasted) + \" of space!\") } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let search_dir = input (\"Enter directory to search: \") ; let min_size = input (\"Minimum file size (bytes, 0 for all): \") . to_i () ; println ! (\"{}\" , \"\\nScanning \" + search_dir + \"...\") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{}\" , \"\\n⚠\\u{fe0f}  Found \" + duplicates . len () . to_s () + \" duplicate files:\") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , \"\\nOriginal: \" + dup . original) ; println ! (\"{}\" , \"Duplicate: \" + dup . duplicate) ; println ! (\"{}\" , \"Size: \" + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! (\"{}\" , \"\\nTotal space wasted: \" + format_size (total_wasted)) ; let action = input (\"\\nDelete duplicates? (y/n): \") ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , \"Deleted: \" + dup . duplicate) } } ; println ! (\"{}\" , \"\\n✅ Freed \" + format_size (total_wasted) + \" of space!\") } } } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpskQvTx/main.rs:1:484\n  |\n1 | ... { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let search_dir = input (\"Enter directory to search: \") ; let min_size = input (\"Minimum file size (bytes, 0 for all): \") . to_i () ; println ! (\"{}\" , \"\\nScanning \" + search_dir + \"...\") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{}\" , \"\\n⚠\\u{fe0f}  Found \" + duplicates . len () . to_s () + \" duplicate files:\") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , \"\\nOriginal: \" + dup . original) ; println ! (\"{}\" , \"Duplicate: \" + dup . duplicate) ; println ! (\"{}\" , \"Size: \" + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! (\"{}\" , \"\\nTotal space wasted: \" + format_size (total_wasted)) ; let action = input (\"\\nDelete duplicates? (y/n): \") ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , \"Deleted: \" + dup . duplicate) } } ; println ! (\"{}\" , \"\\n✅ Freed \" + format_size (total_wasted) + \" of space!\") } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let search_dir = input (\"Enter directory to search: \") ; let min_size = input (\"Minimum file size (bytes, 0 for all): \") . to_i () ; println ! (\"{}\" , \"\\nScanning \" + search_dir + \"...\") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{}\" , \"\\n⚠\\u{fe0f}  Found \" + duplicates . len () . to_s () + \" duplicate files:\") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , \"\\nOriginal: \" + dup . original) ; println ! (\"{}\" , \"Duplicate: \" + dup . duplicate) ; println ! (\"{}\" , \"Size: \" + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! (\"{}\" , \"\\nTotal space wasted: \" + format_size (total_wasted)) ; let action = input (\"\\nDelete duplicates? (y/n): \") ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , \"Deleted: \" + dup . duplicate) } } ; println ! (\"{}\" , \"\\n✅ Freed \" + format_size (total_wasted) + \" of space!\") } } } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpskQvTx/main.rs:1:549\n  |\n1 | ...h = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size ...\n  |                                                          ^^                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let search_dir = input (\"Enter directory to search: \") ; let min_size = input (\"Minimum file size (bytes, 0 for all): \") . to_i () ; println ! (\"{}\" , \"\\nScanning \" + search_dir + \"...\") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{}\" , \"\\n⚠\\u{fe0f}  Found \" + duplicates . len () . to_s () + \" duplicate files:\") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , \"\\nOriginal: \" + dup . original) ; println ! (\"{}\" , \"Duplicate: \" + dup . duplicate) ; println ! (\"{}\" , \"Size: \" + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! (\"{}\" , \"\\nTotal space wasted: \" + format_size (total_wasted)) ; let action = input (\"\\nDelete duplicates? (y/n): \") ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , \"Deleted: \" + dup . duplicate) } } ; println ! (\"{}\" , \"\\n✅ Freed \" + format_size (total_wasted) + \" of space!\") } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { scan_directory (path) } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let search_dir = input (\"Enter directory to search: \") ; let min_size = input (\"Minimum file size (bytes, 0 for all): \") . to_i () ; println ! (\"{}\" , \"\\nScanning \" + search_dir + \"...\") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{}\" , \"\\n⚠\\u{fe0f}  Found \" + duplicates . len () . to_s () + \" duplicate files:\") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , \"\\nOriginal: \" + dup . original) ; println ! (\"{}\" , \"Duplicate: \" + dup . duplicate) ; println ! (\"{}\" , \"Size: \" + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! (\"{}\" , \"\\nTotal space wasted: \" + format_size (total_wasted)) ; let action = input (\"\\nDelete duplicates? (y/n): \") ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , \"Deleted: \" + dup . duplicate) } } ; println ! (\"{}\" , \"\\n✅ Freed \" + format_size (total_wasted) + \" of space!\") } } } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpskQvTx/main.rs:1:604\n  |\n1 | ... { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let search_dir = input (\"Enter directory to search: \") ; let min_size = input (\"Minimum file size (bytes, 0 for all): \") . to_i () ; println ! (\"{}\" , \"\\nScanning \" + search_dir + \"...\") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{}\" , \"\\n⚠\\u{fe0f}  Found \" + duplicates . len () . to_s () + \" duplicate files:\") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , \"\\nOriginal: \" + dup . original) ; println ! (\"{}\" , \"Duplicate: \" + dup . duplicate) ; println ! (\"{}\" , \"Size: \" + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! (\"{}\" , \"\\nTotal space wasted: \" + format_size (total_wasted)) ; let action = input (\"\\nDelete duplicates? (y/n): \") ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , \"Deleted: \" + dup . duplicate) } } ; println ! (\"{}\" , \"\\n✅ Freed \" + format_size (total_wasted) + \" of space!\") } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let search_dir = input (\"Enter directory to search: \") ; let min_size = input (\"Minimum file size (bytes, 0 for all): \") . to_i () ; println ! (\"{}\" , \"\\nScanning \" + search_dir + \"...\") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{}\" , \"\\n⚠\\u{fe0f}  Found \" + duplicates . len () . to_s () + \" duplicate files:\") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , \"\\nOriginal: \" + dup . original) ; println ! (\"{}\" , \"Duplicate: \" + dup . duplicate) ; println ! (\"{}\" , \"Size: \" + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! (\"{}\" , \"\\nTotal space wasted: \" + format_size (total_wasted)) ; let action = input (\"\\nDelete duplicates? (y/n): \") ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , \"Deleted: \" + dup . duplicate) } } ; println ! (\"{}\" , \"\\n✅ Freed \" + format_size (total_wasted) + \" of space!\") } } } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpskQvTx/main.rs:1:660\n  |\n1 | ... { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } ...\n  |       ^^                                                                                                                                                                                                                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let search_dir = input (\"Enter directory to search: \") ; let min_size = input (\"Minimum file size (bytes, 0 for all): \") . to_i () ; println ! (\"{}\" , \"\\nScanning \" + search_dir + \"...\") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{}\" , \"\\n⚠\\u{fe0f}  Found \" + duplicates . len () . to_s () + \" duplicate files:\") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , \"\\nOriginal: \" + dup . original) ; println ! (\"{}\" , \"Duplicate: \" + dup . duplicate) ; println ! (\"{}\" , \"Size: \" + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! (\"{}\" , \"\\nTotal space wasted: \" + format_size (total_wasted)) ; let action = input (\"\\nDelete duplicates? (y/n): \") ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , \"Deleted: \" + dup . duplicate) } } ; println ! (\"{}\" , \"\\n✅ Freed \" + format_size (total_wasted) + \" of space!\") } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let search_dir = input (\"Enter directory to search: \") ; let min_size = input (\"Minimum file size (bytes, 0 for all): \") . to_i () ; println ! (\"{}\" , \"\\nScanning \" + search_dir + \"...\") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{}\" , \"\\n⚠\\u{fe0f}  Found \" + duplicates . len () . to_s () + \" duplicate files:\") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , \"\\nOriginal: \" + dup . original) ; println ! (\"{}\" , \"Duplicate: \" + dup . duplicate) ; println ! (\"{}\" , \"Size: \" + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! (\"{}\" , \"\\nTotal space wasted: \" + format_size (total_wasted)) ; let action = input (\"\\nDelete duplicates? (y/n): \") ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , \"Deleted: \" + dup . duplicate) } } ; println ! (\"{}\" , \"\\n✅ Freed \" + format_size (total_wasted) + \" of space!\") } } } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpskQvTx/main.rs:1:728\n  |\n1 | ..._key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { fi...\n  |                  ^^                                                                                                      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let search_dir = input (\"Enter directory to search: \") ; let min_size = input (\"Minimum file size (bytes, 0 for all): \") . to_i () ; println ! (\"{}\" , \"\\nScanning \" + search_dir + \"...\") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{}\" , \"\\n⚠\\u{fe0f}  Found \" + duplicates . len () . to_s () + \" duplicate files:\") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , \"\\nOriginal: \" + dup . original) ; println ! (\"{}\" , \"Duplicate: \" + dup . duplicate) ; println ! (\"{}\" , \"Size: \" + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! (\"{}\" , \"\\nTotal space wasted: \" + format_size (total_wasted)) ; let action = input (\"\\nDelete duplicates? (y/n): \") ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , \"Deleted: \" + dup . duplicate) } } ; println ! (\"{}\" , \"\\n✅ Freed \" + format_size (total_wasted) + \" of space!\") } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let search_dir = input (\"Enter directory to search: \") ; let min_size = input (\"Minimum file size (bytes, 0 for all): \") . to_i () ; println ! (\"{}\" , \"\\nScanning \" + search_dir + \"...\") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{}\" , \"\\n⚠\\u{fe0f}  Found \" + duplicates . len () . to_s () + \" duplicate files:\") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , \"\\nOriginal: \" + dup . original) ; println ! (\"{}\" , \"Duplicate: \" + dup . duplicate) ; println ! (\"{}\" , \"Size: \" + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! (\"{}\" , \"\\nTotal space wasted: \" + format_size (total_wasted)) ; let action = input (\"\\nDelete duplicates? (y/n): \") ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , \"Deleted: \" + dup . duplicate) } } ; println ! (\"{}\" , \"\\n✅ Freed \" + format_size (total_wasted) + \" of space!\") } } } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpskQvTx/main.rs:1:844\n  |\n1 | ... : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (...\n  |                                                        ^^                         ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let search_dir = input (\"Enter directory to search: \") ; let min_size = input (\"Minimum file size (bytes, 0 for all): \") . to_i () ; println ! (\"{}\" , \"\\nScanning \" + search_dir + \"...\") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{}\" , \"\\n⚠\\u{fe0f}  Found \" + duplicates . len () . to_s () + \" duplicate files:\") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , \"\\nOriginal: \" + dup . original) ; println ! (\"{}\" , \"Duplicate: \" + dup . duplicate) ; println ! (\"{}\" , \"Size: \" + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! (\"{}\" , \"\\nTotal space wasted: \" + format_size (total_wasted)) ; let action = input (\"\\nDelete duplicates? (y/n): \") ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , \"Deleted: \" + dup . duplicate) } } ; println ! (\"{}\" , \"\\n✅ Freed \" + format_size (total_wasted) + \" of space!\") } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { file_hashes [hash] = path } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let search_dir = input (\"Enter directory to search: \") ; let min_size = input (\"Minimum file size (bytes, 0 for all): \") . to_i () ; println ! (\"{}\" , \"\\nScanning \" + search_dir + \"...\") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{}\" , \"\\n⚠\\u{fe0f}  Found \" + duplicates . len () . to_s () + \" duplicate files:\") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , \"\\nOriginal: \" + dup . original) ; println ! (\"{}\" , \"Duplicate: \" + dup . duplicate) ; println ! (\"{}\" , \"Size: \" + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! (\"{}\" , \"\\nTotal space wasted: \" + format_size (total_wasted)) ; let action = input (\"\\nDelete duplicates? (y/n): \") ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , \"Deleted: \" + dup . duplicate) } } ; println ! (\"{}\" , \"\\n✅ Freed \" + format_size (total_wasted) + \" of space!\") } } } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpskQvTx/main.rs:1:1261\n  |\n1 | ...earch_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{}\" , \"\\n⚠\\u{fe0f}  F...\n  |                                               ^^                                            ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let search_dir = input (\"Enter directory to search: \") ; let min_size = input (\"Minimum file size (bytes, 0 for all): \") . to_i () ; println ! (\"{}\" , \"\\nScanning \" + search_dir + \"...\") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{}\" , \"\\n⚠\\u{fe0f}  Found \" + duplicates . len () . to_s () + \" duplicate files:\") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , \"\\nOriginal: \" + dup . original) ; println ! (\"{}\" , \"Duplicate: \" + dup . duplicate) ; println ! (\"{}\" , \"Size: \" + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! (\"{}\" , \"\\nTotal space wasted: \" + format_size (total_wasted)) ; let action = input (\"\\nDelete duplicates? (y/n): \") ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , \"Deleted: \" + dup . duplicate) } } ; println ! (\"{}\" , \"\\n✅ Freed \" + format_size (total_wasted) + \" of space!\") } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let search_dir = input (\"Enter directory to search: \") ; let min_size = input (\"Minimum file size (bytes, 0 for all): \") . to_i () ; println ! (\"{}\" , \"\\nScanning \" + search_dir + \"...\") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { println ! (\"\\n✅ No duplicate files found!\") } else { { println ! (\"{}\" , \"\\n⚠\\u{fe0f}  Found \" + duplicates . len () . to_s () + \" duplicate files:\") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , \"\\nOriginal: \" + dup . original) ; println ! (\"{}\" , \"Duplicate: \" + dup . duplicate) ; println ! (\"{}\" , \"Size: \" + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! (\"{}\" , \"\\nTotal space wasted: \" + format_size (total_wasted)) ; let action = input (\"\\nDelete duplicates? (y/n): \") ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , \"Deleted: \" + dup . duplicate) } } ; println ! (\"{}\" , \"\\n✅ Freed \" + format_size (total_wasted) + \" of space!\") } } } } } } ; }\n  |\n\nerror[E0425]: cannot find function `read_bytes` in this scope\n --> /tmp/.tmpskQvTx/main.rs:1:216\n  |\n1 | ...bug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `sha256` in this scope\n --> /tmp/.tmpskQvTx/main.rs:1:243\n  |\n1 | ...-> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + ...\n  |                                                        ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `list_dir` in this scope\n --> /tmp/.tmpskQvTx/main.rs:1:447\n  |\n1 | ...: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpskQvTx/main.rs:1:499\n  |\n1 | ...st_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else {...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_directory` in this scope\n --> /tmp/.tmpskQvTx/main.rs:1:527\n  |\n1 | ...ems { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let ...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: cannot add `()` to `()`\n --> /tmp/.tmpskQvTx/main.rs:1:567\n  |\n1 | ... , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >...\n  |                                          --------------  ^^^^ no implementation for `() + ()`\n  |                                          |\n  |                                          required by a bound introduced by this call\n  |\n  = help: the trait `Add` is not implemented for `()`\nnote: required by a bound in `scan_directory`\n --> /tmp/.tmpskQvTx/main.rs:1:290\n  |\n1 | ... } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt ...\n  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `scan_directory`\n\nerror[E0277]: cannot multiply `()` by `()`\n --> /tmp/.tmpskQvTx/main.rs:1:567\n  |\n1 | ... , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >...\n  |                                          --------------  ^^^^ no implementation for `() * ()`\n  |                                          |\n  |                                          required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `()`\nnote: required by a bound in `scan_directory`\n --> /tmp/.tmpskQvTx/main.rs:1:325\n  |\n1 | ... ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T {...\n  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `scan_directory`\n\nerror[E0277]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmpskQvTx/main.rs:1:567\n  |\n1 | ... if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size...\n  |                                --------------  ^^^^ the trait `std::fmt::Display` is not implemented for `()`\n  |                                |\n  |                                required by a bound introduced by this call\n  |\nnote: required by a bound in `scan_directory`\n --> /tmp/.tmpskQvTx/main.rs:1:360\n  |\n1 | ...std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (di...\n  |                                       ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `scan_directory`\n\nerror[E0425]: cannot find function `is_file` in this scope\n --> /tmp/.tmpskQvTx/main.rs:1:587\n  |\n1 | ...ory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let ha...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_size` in this scope\n --> /tmp/.tmpskQvTx/main.rs:1:619\n  |\n1 | ...th) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_h...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpskQvTx/main.rs:1:464\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } ...\n  |       -                                                                                                                                            -                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |       |                                                                                                                                            |\n  |       expected this type parameter                                                                                                                 expected `T` because of return type\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: the caller chooses a type for `T` which can be different from `()`\n  = note: `for` loops evaluate to unit type `()`\nhelp: consider returning a value here\n  |\n1 | use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } /* `T` value */ } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let search_dir = input (\"Enter directory to search: \") ; let min_size = input (\"Minimum file size (bytes, 0 for all): \") . to_i () ; println ! (\"{}\" , \"\\nScanning \" + search_dir + \"...\") ; let file_hashes = () ; let duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{}\" , \"\\n⚠\\u{fe0f}  Found \" + duplicates . len () . to_s () + \" duplicate files:\") ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , \"\\nOriginal: \" + dup . original) ; println ! (\"{}\" , \"Duplicate: \" + dup . duplicate) ; println ! (\"{}\" , \"Size: \" + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! (\"{}\" , \"\\nTotal space wasted: \" + format_size (total_wasted)) ; let action = input (\"\\nDelete duplicates? (y/n): \") ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , \"Deleted: \" + dup . duplicate) } } ; println ! (\"{}\" , \"\\n✅ Freed \" + format_size (total_wasted) + \" of space!\") } } } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                +++++++++++++++\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmpskQvTx/main.rs:1:978\n  |\n1 | ...\"=== Duplicate File Finder ===\") ; let search_dir = input (\"Enter directory to search: \") ; let min_size = input (\"Minimum file size (...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmpskQvTx/main.rs:1:1033\n  |\n1 | ...ut (\"Enter directory to search: \") ; let min_size = input (\"Minimum file size (bytes, 0 for all): \") . to_i () ; println ! (\"{}\" , \"\\n...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmpskQvTx/main.rs:1:1139\n  |\n1 | ..., 0 for all): \") . to_i () ; println ! (\"{}\" , \"\\nScanning \" + search_dir + \"...\") ; let file_hashes = () ; let duplicates = vec ! [] ...\n  |                                                   -------------------------- ^ ----- &str\n  |                                                   |\n  |                                                   str\n\nerror[E0599]: no method named `to_s` found for type `usize` in the current scope\n --> /tmp/.tmpskQvTx/main.rs:1:1384\n  |\n1 | ...}\" , \"\\n⚠\\u{fe0f}  Found \" + duplicates . len () . to_s () + \" duplicate files:\") ; { let total_wasted = 0i32 ; { for dup in duplicate...\n  |                                                       ^^^^ method not found in `usize`\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmpskQvTx/main.rs:1:1392\n  |\n1 | ...else { { println ! (\"{}\" , \"\\n⚠\\u{fe0f}  Found \" + duplicates . len () . to_s () + \" duplicate files:\") ; { let total_wasted = 0i32 ; ...\n  |                               ----------------------------------------------------- ^ ------------------- &str\n  |                               |\n  |                               str\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpskQvTx/main.rs:1:1491\n  |\n1 | ...duplicates { { println ! (\"{}\" , \"\\nOriginal: \" + dup . original) ; println ! (\"{}\" , \"Duplicate: \" + dup . duplicate) ; println ! (\"{...\n  |                               --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                               |\n  |                               required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpskQvTx/main.rs:1:1544\n  |\n1 | ... . original) ; println ! (\"{}\" , \"Duplicate: \" + dup . duplicate) ; println ! (\"{}\" , \"Size: \" + format_size (dup . size)) ; total_was...\n  |                               --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                               |\n  |                               required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpskQvTx/main.rs:1:1608\n  |\n1 | ... dup . duplicate) ; println ! (\"{}\" , \"Size: \" + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! (\"{}\" , \"\\nTot...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpskQvTx/main.rs:1:1597\n  |\n1 | ...duplicate) ; println ! (\"{}\" , \"Size: \" + format_size (dup . size)) ; total_wasted += dup . size } } ; println ! (\"{}\" , \"\\nTotal spac...\n  |                             --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                             |\n  |                             required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpskQvTx/main.rs:1:1714\n  |\n1 | ...} ; println ! (\"{}\" , \"\\nTotal space wasted: \" + format_size (total_wasted)) ; let action = input (\"\\nDelete duplicates? (y/n): \") ; i...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpskQvTx/main.rs:1:1687\n  |\n1 | ...} ; println ! (\"{}\" , \"\\nTotal space wasted: \" + format_size (total_wasted)) ; let action = input (\"\\nDelete duplicates? (y/n): \") ; i...\n  |                    --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                    |\n  |                    required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmpskQvTx/main.rs:1:1757\n  |\n1 | ...ted: \" + format_size (total_wasted)) ; let action = input (\"\\nDelete duplicates? (y/n): \") ; if action . lower () == \"y\" { { for dup i...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpskQvTx/main.rs:1:1906\n  |\n1 | ... . duplicate) ; println ! (\"{}\" , \"Deleted: \" + dup . duplicate) } } ; println ! (\"{}\" , \"\\n✅ Freed \" + format_size (total_wasted) + \" ...\n  |                                --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                                |\n  |                                required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpskQvTx/main.rs:1:1976\n  |\n1 | ...uplicate) } } ; println ! (\"{}\" , \"\\n✅ Freed \" + format_size (total_wasted) + \" of space!\") } } } } } } ; }\n  |                                                      ^^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmpskQvTx/main.rs:1:2003\n  |\n1 | ... duplicate) } } ; println ! (\"{}\" , \"\\n✅ Freed \" + format_size (total_wasted) + \" of space!\") } } } } } } ; }\n  |                                        ------------------------------------------ ^ ------------ &str\n  |                                        |\n  |                                        str\n\nerror: aborting due to 32 previous errors; 10 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0369, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_s()"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 7,
          "line_number": 344,
          "code": "// Status: ✅ WORKING\n\n// File: log_rotator.ruchy\n// Manages log files with size-based rotation\n\nprintln(\"=== Log Rotation System ===\")\n\nlet log_config = {\n    \"max_size\": 10 * 1024 * 1024,  // 10MB\n    \"max_backups\": 5,\n    \"compress\": true\n}\n\nlet log_dir = \"/var/log/myapp\"\nlet log_files = glob(join_path(log_dir, \"*.log\"))\n\nfor log_file in log_files {\n    let size = file_size(log_file)\n    \n    if size > log_config.max_size {\n        println(\"Rotating \" + log_file + \" (\" + format_size(size) + \")...\")\n        \n        // Shift existing backups\n        for i in range(log_config.max_backups - 1, 0, -1) {\n            let old_backup = log_file + \".\" + i.to_s()\n            let new_backup = log_file + \".\" + (i + 1).to_s()\n            \n            if file_exists(old_backup) {\n                if i == log_config.max_backups - 1 {\n                    // Delete oldest backup\n                    remove_file(old_backup)\n                } else {\n                    // Rename to next number\n                    rename_file(old_backup, new_backup)\n                }\n            }\n        }\n        \n        // Move current log to .1\n        let backup_path = log_file + \".1\"\n        rename_file(log_file, backup_path)\n        \n        // Compress if configured\n        if log_config.compress {\n            compress_file(backup_path, backup_path + \".gz\")\n            remove_file(backup_path)\n            println(\"  Compressed to \" + backup_path + \".gz\")\n        }\n        \n        // Create new empty log file\n        write_file(log_file, \"\")\n        println(\"  Created new \" + log_file)\n    }\n}\n\nprintln(\"\\n✅ Log rotation complete!\")",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: struct literal body without path\n --> /tmp/.tmpdbYh7d/main.rs:1:126\n  |\n1 | ... ===\") ; let log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let log_dir = \"/var/log/...\n  |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\nhelp: you might have forgotten to add the struct literal inside the block\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\") ; let log_config = { SomeStruct { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } } ; let log_dir = \"/var/log/myapp\" ; let log_files = glob (join_path (log_dir , \"*.log\")) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , \"Rotating \" + log_file + \" (\" + format_size (size) + \")...\") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = log_file + \".\" + i . to_s () ; { let new_backup = log_file + \".\" + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = log_file + \".1\" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + \".gz\") ; remove_file (backup_path) ; println ! (\"{}\" , \"  Compressed to \" + backup_path + \".gz\") } } ; write_file (log_file , \"\") ; println ! (\"{}\" , \"  Created new \" + log_file) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |                                                                                                                              ++++++++++++                                                                                   +\n\nerror[E0425]: cannot find function `range` in this scope\n --> /tmp/.tmpdbYh7d/main.rs:1:490\n  |\n1 | ...le + \" (\" + format_size (size) + \")...\") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = log...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::slice::range;\n  |\n\nerror[E0425]: cannot find function `remove_file` in this scope\n --> /tmp/.tmpdbYh7d/main.rs:1:733\n  |\n1 | ... { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } }...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::remove_file;\n  |\n\nerror[E0425]: cannot find function `remove_file` in this scope\n --> /tmp/.tmpdbYh7d/main.rs:1:987\n  |\n1 | ...press_file (backup_path , backup_path + \".gz\") ; remove_file (backup_path) ; println ! (\"{}\" , \"  Compressed to \" + backup_path + \".gz...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::remove_file;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpdbYh7d/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\") ; let log_config = { max_size :...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpdbYh7d/main.rs:1:326\n  |\n1 | ... { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , \"Rotating \" + log_file + \" (\" + format_size (size) + \")...\") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = log_file + \".\" + i . to_s () ; { let new_backup = log_file + \".\" + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = log_file + \".1\" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + \".gz\") ; remove_file (backup_path) ; println ! (\"{}\" , \"  Compressed to \" + backup_path + \".gz\") } } ; write_file (log_file , \"\") ; println ! (\"{}\" , \"  Created new \" + log_file) } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\") ; let log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let log_dir = \"/var/log/myapp\" ; let log_files = glob (join_path (log_dir , \"*.log\")) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , \"Rotating \" + log_file + \" (\" + format_size (size) + \")...\") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = log_file + \".\" + i . to_s () ; { let new_backup = log_file + \".\" + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = log_file + \".1\" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + \".gz\") ; remove_file (backup_path) ; println ! (\"{}\" , \"  Compressed to \" + backup_path + \".gz\") } } ; write_file (log_file , \"\") ; println ! (\"{}\" , \"  Created new \" + log_file) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\") ; let log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let log_dir = \"/var/log/myapp\" ; let log_files = glob (join_path (log_dir , \"*.log\")) ; for log_file in log_files { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , \"Rotating \" + log_file + \" (\" + format_size (size) + \")...\") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = log_file + \".\" + i . to_s () ; { let new_backup = log_file + \".\" + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = log_file + \".1\" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + \".gz\") ; remove_file (backup_path) ; println ! (\"{}\" , \"  Compressed to \" + backup_path + \".gz\") } } ; write_file (log_file , \"\") ; println ! (\"{}\" , \"  Created new \" + log_file) } } } } } } ; println ! (\"\\n✅ Log rotation complete!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpdbYh7d/main.rs:1:548\n  |\n1 | ... { { { let old_backup = log_file + \".\" + i . to_s () ; { let new_backup = log_file + \".\" + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\") ; let log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let log_dir = \"/var/log/myapp\" ; let log_files = glob (join_path (log_dir , \"*.log\")) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , \"Rotating \" + log_file + \" (\" + format_size (size) + \")...\") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = log_file + \".\" + i . to_s () ; { let new_backup = log_file + \".\" + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = log_file + \".1\" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + \".gz\") ; remove_file (backup_path) ; println ! (\"{}\" , \"  Compressed to \" + backup_path + \".gz\") } } ; write_file (log_file , \"\") ; println ! (\"{}\" , \"  Created new \" + log_file) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\") ; let log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let log_dir = \"/var/log/myapp\" ; let log_files = glob (join_path (log_dir , \"*.log\")) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , \"Rotating \" + log_file + \" (\" + format_size (size) + \")...\") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { let old_backup = log_file + \".\" + i . to_s () ; { let new_backup = log_file + \".\" + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } ; { let backup_path = log_file + \".1\" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + \".gz\") ; remove_file (backup_path) ; println ! (\"{}\" , \"  Compressed to \" + backup_path + \".gz\") } } ; write_file (log_file , \"\") ; println ! (\"{}\" , \"  Created new \" + log_file) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpdbYh7d/main.rs:1:687\n  |\n1 | ... { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } }...\n  |       ^^                                                                                                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\") ; let log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let log_dir = \"/var/log/myapp\" ; let log_files = glob (join_path (log_dir , \"*.log\")) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , \"Rotating \" + log_file + \" (\" + format_size (size) + \")...\") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = log_file + \".\" + i . to_s () ; { let new_backup = log_file + \".\" + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = log_file + \".1\" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + \".gz\") ; remove_file (backup_path) ; println ! (\"{}\" , \"  Compressed to \" + backup_path + \".gz\") } } ; write_file (log_file , \"\") ; println ! (\"{}\" , \"  Created new \" + log_file) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\") ; let log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let log_dir = \"/var/log/myapp\" ; let log_files = glob (join_path (log_dir , \"*.log\")) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , \"Rotating \" + log_file + \" (\" + format_size (size) + \")...\") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = log_file + \".\" + i . to_s () ; { let new_backup = log_file + \".\" + i + 1i32 . to_s () ; if file_exists (old_backup) { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } ; { let backup_path = log_file + \".1\" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + \".gz\") ; remove_file (backup_path) ; println ! (\"{}\" , \"  Compressed to \" + backup_path + \".gz\") } } ; write_file (log_file , \"\") ; println ! (\"{}\" , \"  Created new \" + log_file) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpdbYh7d/main.rs:1:731\n  |\n1 | ...ackup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } }...\n  |                                                         ^^                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\") ; let log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let log_dir = \"/var/log/myapp\" ; let log_files = glob (join_path (log_dir , \"*.log\")) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , \"Rotating \" + log_file + \" (\" + format_size (size) + \")...\") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = log_file + \".\" + i . to_s () ; { let new_backup = log_file + \".\" + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = log_file + \".1\" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + \".gz\") ; remove_file (backup_path) ; println ! (\"{}\" , \"  Compressed to \" + backup_path + \".gz\") } } ; write_file (log_file , \"\") ; println ! (\"{}\" , \"  Created new \" + log_file) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\") ; let log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let log_dir = \"/var/log/myapp\" ; let log_files = glob (join_path (log_dir , \"*.log\")) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , \"Rotating \" + log_file + \" (\" + format_size (size) + \")...\") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = log_file + \".\" + i . to_s () ; { let new_backup = log_file + \".\" + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { remove_file (old_backup) } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = log_file + \".1\" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + \".gz\") ; remove_file (backup_path) ; println ! (\"{}\" , \"  Compressed to \" + backup_path + \".gz\") } } ; write_file (log_file , \"\") ; println ! (\"{}\" , \"  Created new \" + log_file) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpdbYh7d/main.rs:1:769\n  |\n1 | ... 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = log_file +...\n  |                                                  ^^                                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\") ; let log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let log_dir = \"/var/log/myapp\" ; let log_files = glob (join_path (log_dir , \"*.log\")) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , \"Rotating \" + log_file + \" (\" + format_size (size) + \")...\") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = log_file + \".\" + i . to_s () ; { let new_backup = log_file + \".\" + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = log_file + \".1\" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + \".gz\") ; remove_file (backup_path) ; println ! (\"{}\" , \"  Compressed to \" + backup_path + \".gz\") } } ; write_file (log_file , \"\") ; println ! (\"{}\" , \"  Created new \" + log_file) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\") ; let log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let log_dir = \"/var/log/myapp\" ; let log_files = glob (join_path (log_dir , \"*.log\")) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , \"Rotating \" + log_file + \" (\" + format_size (size) + \")...\") ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = log_file + \".\" + i . to_s () ; { let new_backup = log_file + \".\" + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { rename_file (old_backup , new_backup) } } } } } } } ; { let backup_path = log_file + \".1\" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + \".gz\") ; remove_file (backup_path) ; println ! (\"{}\" , \"  Compressed to \" + backup_path + \".gz\") } } ; write_file (log_file , \"\") ; println ! (\"{}\" , \"  Created new \" + log_file) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpdbYh7d/main.rs:1:265\n  |\n1 | ...og_dir = \"/var/log/myapp\" ; let log_files = glob (join_path (log_dir , \"*.log\")) ; for log_file in log_files { { { let size = file_siz...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `glob` in this scope\n --> /tmp/.tmpdbYh7d/main.rs:1:259\n  |\n1 | ...} ; let log_dir = \"/var/log/myapp\" ; let log_files = glob (join_path (log_dir , \"*.log\")) ; for log_file in log_files { { { let size =...\n  |                                                         ^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_size` in this scope\n --> /tmp/.tmpdbYh7d/main.rs:1:341\n  |\n1 | ...g\")) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , \"Rotati...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `_` to `&str`\n --> /tmp/.tmpdbYh7d/main.rs:1:430\n  |\n1 | ... if size > log_config . max_size { { println ! (\"{}\" , \"Rotating \" + log_file + \" (\" + format_size (size) + \")...\") ; for i in range (...\n  |                                                           ----------- ^ -------- _\n  |                                                           |\n  |                                                           &str\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpdbYh7d/main.rs:1:450\n  |\n1 | ...rintln ! (\"{}\" , \"Rotating \" + log_file + \" (\" + format_size (size) + \")...\") ; for i in range (log_config . max_backups - 1i32 , 0i32...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpdbYh7d/main.rs:1:647\n  |\n1 | ...() ; { let new_backup = log_file + \".\" + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 ...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpdbYh7d/main.rs:1:660\n  |\n1 | ...ackup = log_file + \".\" + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `rename_file` in this scope\n --> /tmp/.tmpdbYh7d/main.rs:1:771\n  |\n1 | ...- 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = log_file ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `rename_file` in this scope\n --> /tmp/.tmpdbYh7d/main.rs:1:867\n  |\n1 | ... } } } ; { let backup_path = log_file + \".1\" ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (ba...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `compress_file` in this scope\n --> /tmp/.tmpdbYh7d/main.rs:1:935\n  |\n1 | ...e , backup_path) ; if log_config . compress { { compress_file (backup_path , backup_path + \".gz\") ; remove_file (backup_path) ; printl...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `_` to `&str`\n --> /tmp/.tmpdbYh7d/main.rs:1:1052\n  |\n1 | ...) ; remove_file (backup_path) ; println ! (\"{}\" , \"  Compressed to \" + backup_path + \".gz\") } } ; write_file (log_file , \"\") ; println...\n  |                                                      ------------------ ^ ----------- _\n  |                                                      |\n  |                                                      &str\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmpdbYh7d/main.rs:1:1081\n  |\n1 | ..., \"  Compressed to \" + backup_path + \".gz\") } } ; write_file (log_file , \"\") ; println ! (\"{}\" , \"  Created new \" + log_file) } } } } ...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `_` to `&str`\n --> /tmp/.tmpdbYh7d/main.rs:1:1145\n  |\n1 | ... } ; write_file (log_file , \"\") ; println ! (\"{}\" , \"  Created new \" + log_file) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!...\n  |                                                        ---------------- ^ -------- _\n  |                                                        |\n  |                                                        &str\n\nerror: aborting due to 17 previous errors; 6 warnings emitted\n\nSome errors have detailed explanations: E0369, E0425, E0599.\nFor more information about an error, try `rustc --explain E0369`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_s()"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 8,
          "line_number": 410,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: DotDot\n// File: config_manager.ruchy\n// Manages application configuration files\n\nprintln(\"=== Configuration Manager ===\")\n\nlet config_dir = \"~/.config/myapp\"\nlet config_file = join_path(config_dir, \"config.json\")\n\n// Ensure config directory exists\nif !dir_exists(config_dir) {\n    create_dir_all(config_dir)\n    println(\"Created config directory: \" + config_dir)\n}\n\n// Load or create default configuration\nlet config = if file_exists(config_file) {\n    parse_json(read_file(config_file))\n} else {\n    // Default configuration\n    {\n        \"version\": \"1.0\",\n        \"theme\": \"dark\",\n        \"auto_save\": true,\n        \"backup_interval\": 3600,\n        \"recent_files\": [],\n        \"window\": {\n            \"width\": 1200,\n            \"height\": 800,\n            \"maximized\": false\n        }\n    }\n}\n\nfun save_config() {\n    let json = to_json_pretty(config)\n    write_file(config_file, json)\n    println(\"✅ Configuration saved\")\n}\n\nfun update_setting(key, value) {\n    config[key] = value\n    save_config()\n}\n\nfun add_recent_file(path) {\n    if !config.recent_files.contains(path) {\n        config.recent_files.insert(0, path)\n        // Keep only last 10 files\n        if config.recent_files.len() > 10 {\n            config.recent_files = config.recent_files[..10]\n        }\n        save_config()\n    }\n}\n\n// Interactive configuration editor\nloop {\n    println(\"\\n=== Current Configuration ===\")\n    for key, value in config.items() {\n        println(key + \": \" + value.to_s())\n    }\n    \n    println(\"\\nOptions:\")\n    println(\"1. Change theme\")\n    println(\"2. Toggle auto-save\")\n    println(\"3. Set backup interval\")\n    println(\"4. Clear recent files\")\n    println(\"5. Reset to defaults\")\n    println(\"6. Exit\")\n    \n    let choice = input(\"\\nChoice: \")\n    \n    match choice {\n        \"1\" => {\n            let theme = input(\"Theme (light/dark): \")\n            update_setting(\"theme\", theme)\n        }\n        \"2\" => {\n            config.auto_save = !config.auto_save\n            save_config()\n        }\n        \"3\" => {\n            let interval = input(\"Backup interval (seconds): \").to_i()\n            update_setting(\"backup_interval\", interval)\n        }\n        \"4\" => {\n            config.recent_files = []\n            save_config()\n        }\n        \"5\" => {\n            // Reset to defaults\n            remove_file(config_file)\n            println(\"Configuration reset!\")\n            break\n        }\n        \"6\" => break\n        _ => println(\"Invalid choice\")\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 9,
          "line_number": 522,
          "code": "// Status: ✅ WORKING\n\nfun safe_file_operation(path) {\n    // Check permissions first\n    if !file_exists(path) {\n        println(\"Error: File not found: \" + path)\n        return false\n    }\n    \n    if !is_readable(path) {\n        println(\"Error: No read permission for: \" + path)\n        return false\n    }\n    \n    // Try operation with error handling\n    try {\n        let content = read_file(path)\n        process_content(content)\n        return true\n    } catch error {\n        println(\"Error processing file: \" + error.to_s())\n        \n        // Log error for debugging\n        let error_log = \"errors.log\"\n        let timestamp = current_datetime()\n        append_file(error_log, timestamp.to_s() + \": \" + path + \" - \" + error.to_s() + \"\\n\")\n        \n        return false\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0423]: expected value, found macro `try`\n --> /tmp/.tmpJrbch5/main.rs:1:420\n  |\n1 | ...or: No read permission for: \" + path) ; return false } } ; try ; { { let content = read_file (path) ; { process_content (content) ; re...\n  |                                                               ^^^ not a value\n\nerror[E0425]: cannot find value `catch` in this scope\n --> /tmp/.tmpJrbch5/main.rs:1:513\n  |\n1 | ...; { process_content (content) ; return true } } } ; catch ; error ; { println ! (\"{}\" , \"Error processing file: \" + error . to_s ()) ;...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpJrbch5/main.rs:1:521\n  |\n1 | ...ess_content (content) ; return true } } } ; catch ; error ; { println ! (\"{}\" , \"Error processing file: \" + error . to_s ()) ; { let e...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpJrbch5/main.rs:1:577\n  |\n1 | ...r ; { println ! (\"{}\" , \"Error processing file: \" + error . to_s ()) ; { let error_log = \"errors.log\" ; { let timestamp = current_date...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpJrbch5/main.rs:1:738\n  |\n1 | ...r_log , timestamp . to_s () + \": \" + path + \" - \" + error . to_s () + \"\\n\") ; return false } } } } } fn main () { }\n  |                                                        ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpJrbch5/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn safe_file_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + st...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpJrbch5/main.rs:1:215\n  |\n1 | ... fmt :: Debug + Clone > (path : T) -> T { { if ! file_exists (path) { { println ! (\"{}\" , \"Error: File not found: \" + path) ; return f...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `T` to `&str`\n --> /tmp/.tmpJrbch5/main.rs:1:282\n  |\n1 | ...{ { if ! file_exists (path) { { println ! (\"{}\" , \"Error: File not found: \" + path) ; return false } } ; if ! is_readable (path) { { p...\n  |                                                      ------------------------- ^ ---- T\n  |                                                      |\n  |                                                      &str\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpJrbch5/main.rs:1:299\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { if ! file_exists (path) { { println ! (\"{}\" , \"Error: File not found: \" + path) ; return false } ...\n  |       - expected this type parameter                                                                                                                - expected `T` because of return type                                                          ^^^^^ expected type parameter `T`, found `bool`\n  |\n  = note: expected type parameter `T`\n                       found type `bool`\n  = note: the caller chooses a type for `T` which can be different from `bool`\n\nerror[E0425]: cannot find function `is_readable` in this scope\n --> /tmp/.tmpJrbch5/main.rs:1:316\n  |\n1 | ...e not found: \" + path) ; return false } } ; if ! is_readable (path) { { println ! (\"{}\" , \"Error: No read permission for: \" + path) ; ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `T` to `&str`\n --> /tmp/.tmpJrbch5/main.rs:1:391\n  |\n1 | ...if ! is_readable (path) { { println ! (\"{}\" , \"Error: No read permission for: \" + path) ; return false } } ; try ; { { let content = r...\n  |                                                  --------------------------------- ^ ---- T\n  |                                                  |\n  |                                                  &str\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmpJrbch5/main.rs:1:444\n  |\n1 | ...ath) ; return false } } ; try ; { { let content = read_file (path) ; { process_content (content) ; return true } } } ; catch ; error ;...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `process_content` in this scope\n --> /tmp/.tmpJrbch5/main.rs:1:465\n  |\n1 | ...; try ; { { let content = read_file (path) ; { process_content (content) ; return true } } } ; catch ; error ; { println ! (\"{}\" , \"Er...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: unreachable statement\n --> /tmp/.tmpJrbch5/main.rs:1:513\n  |\n1 | ...th) ; { process_content (content) ; return true } } } ; catch ; error ; { println ! (\"{}\" , \"Error processing file: \" + error . to_s (...\n  |                                        -----------         ^^^^^^^ unreachable statement\n  |                                        |\n  |                                        any code following this expression is unreachable\n  |\n  = note: `#[warn(unreachable_code)]` on by default\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpJrbch5/main.rs:1:549\n  |\n1 | ...rror ; { println ! (\"{}\" , \"Error processing file: \" + error . to_s ()) ; { let error_log = \"errors.log\" ; { let timestamp = current_d...\n  |                         --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                         |\n  |                         required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `current_datetime` in this scope\n --> /tmp/.tmpJrbch5/main.rs:1:647\n  |\n1 | ...t error_log = \"errors.log\" ; { let timestamp = current_datetime () ; append_file (error_log , timestamp . to_s () + \": \" + path + \" - ...\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpJrbch5/main.rs:1:716\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { if ! file_exists (path) { { println ! (\"{}\" , \"Error: File not found: \" + path) ; return false } } ; if ! is_readable (path) { { println ! (\"{}\" , \"Error: No read permission for: \" + path) ; return false } } ; try ; { { let content = read_file (path) ; { process_content (content) ; return true } } } ; catch ; error ; { println ! (\"{}\" , \"Error processing file: \" + error . to_s ()) ; { let error_log = \"errors.log\" ; { let timestamp = current_datetime () ; append_file (error_log , timestamp . to_s () + \": \" + ...\n  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpJrbch5/main.rs:1:730\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { if ! file_exists (path) { { println ! (\"{}\" , \"Error: File not found: \" + path) ; return false } } ; if ! is_readable (path) { { println ! (\"{}\" , \"Error: No read permission for: \" + path) ; return false } } ; try ; { { let content = read_file (path) ; { process_content (content) ; return true } } } ; catch ; error ; { println ! (\"{}\" , \"Error processing file: \" + error . to_s ()) ; { let error_log = \"errors.log\" ; { let timestamp = current_datetime () ; append_file (error_log , timestamp . to_s () + \": \" + path + \" - \" + ...\n  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^^^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpJrbch5/main.rs:1:756\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { if ! file_exists (path) { { println ! (\"{}\" , \"Error: File not found: \" + path) ; return false } } ; if ! is_readable (path) { { println ! (\"{}\" , \"Error: No read permission for: \" + path) ; return false } } ; try ; { { let content = read_file (path) ; { process_content (content) ; return true } } } ; catch ; error ; { println ! (\"{}\" , \"Error processing file: \" + error . to_s ()) ; { let error_log = \"errors.log\" ; { let timestamp = current_datetime () ; append_file (error_log , timestamp . to_s () + \": \" + path + \" - \" + error . to_s () + \"\\n\") ;...\n  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n\nerror[E0425]: cannot find function `append_file` in this scope\n --> /tmp/.tmpJrbch5/main.rs:1:669\n  |\n1 | ...s.log\" ; { let timestamp = current_datetime () ; append_file (error_log , timestamp . to_s () + \": \" + path + \" - \" + error . to_s () ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 18 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0369, E0423, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 10,
          "line_number": 568,
          "code": "// Status: ✅ WORKING\n\nlet files = list_files(\"data\")\nfor file in files {\n    let size = file_size(file)\n    if size > 1000000 {\n        move_file(file, \"large_files/\" + file)\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpR2Yhvj/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let files = list_files (\"data\") ; for file in files { { { let size = file...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpR2Yhvj/main.rs:1:119\n  |\n1 | ...e in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , \"large_files/\" + file) } } } } } } ; if let ...\n  |                 ^^                                                                                                       ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { let files = list_files (\"data\") ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , \"large_files/\" + file) } } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { let files = list_files (\"data\") ; for file in files { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , \"large_files/\" + file) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpR2Yhvj/main.rs:1:176\n  |\n1 | ... = file_size (file) ; if size > 1000000i32 { { move_file (file , \"large_files/\" + file) } } } } } } ; if let Some (s) = (& result as &...\n  |                                                 ^^                                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { let files = list_files (\"data\") ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , \"large_files/\" + file) } } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { let files = list_files (\"data\") ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { move_file (file , \"large_files/\" + file) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `list_files` in this scope\n --> /tmp/.tmpR2Yhvj/main.rs:1:77\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let files = list_files (\"data\") ; for file in files { { { let size = file...\n  |                                                                             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_size` in this scope\n --> /tmp/.tmpR2Yhvj/main.rs:1:134\n  |\n1 | ...les (\"data\") ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , \"large_files/\" + file)...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `_` to `&str`\n --> /tmp/.tmpR2Yhvj/main.rs:1:211\n  |\n1 | ...ze (file) ; if size > 1000000i32 { { move_file (file , \"large_files/\" + file) } } } } } } ; if let Some (s) = (& result as & dyn std :...\n  |                                                           -------------- ^ ---- _\n  |                                                           |\n  |                                                           &str\n\nerror[E0425]: cannot find function `move_file` in this scope\n --> /tmp/.tmpR2Yhvj/main.rs:1:178\n  |\n1 | ...ize = file_size (file) ; if size > 1000000i32 { { move_file (file , \"large_files/\" + file) } } } } } } ; if let Some (s) = (& result a...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0369, E0425.\nFor more information about an error, try `rustc --explain E0369`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch20-00-tooling": {
      "chapter": "ch20-00-tooling",
      "total_examples": 6,
      "working_examples": 0,
      "failing_examples": 6,
      "examples": [
        {
          "file": "src/ch20-00-tooling.md",
          "example_number": 1,
          "line_number": 150,
          "code": "// Status: ✅ WORKING\n// bad_code.ruchy - Multiple issues for demonstration\nfun calculate_something(x: int) {\n    let unused_var = 42;\n    let y = x + 1;\n    return y;\n}\n\nfun main() {\n    let result=calculate_something(10);\n    println(result);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmplwBwNL/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let y = x + 1i32 ; return y } } } }...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmplwBwNL/main.rs:1:72\n  |\n1 | ...fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let y = x + 1i32 ; return y } } } } fn main () { { { let result = ca...\n  |                                       ^^                                                            ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! (\"{}\" , result) } } }\n1 + use std :: collections :: HashMap ; fn calculate_something (x : i64) { { let unused_var = 42i32 ; { let y = x + 1i32 ; return y } } } fn main () { { { let result = calculate_something (10i32) ; println ! (\"{}\" , result) } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmplwBwNL/main.rs:1:152\n  |\n1 | ...eturn y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! (\"{}\" , result) } } }\n  |                                 ^^                                                                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! (\"{}\" , result) } } }\n1 + use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let y = x + 1i32 ; return y } } } } fn main () { { let result = calculate_something (10i32) ; println ! (\"{}\" , result) } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmplwBwNL/main.rs:1:115\n  |\n1 | ... i64) { { { let unused_var = 42i32 ; { let y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ;...\n  |                                                       ^^^^ expected `i64`, found `i32`\n\nerror[E0277]: cannot add `i32` to `i64`\n --> /tmp/.tmplwBwNL/main.rs:1:113\n  |\n1 | ... i64) { { { let unused_var = 42i32 ; { let y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ;...\n  |                                                     ^ no implementation for `i64 + i32`\n  |\n  = help: the trait `Add<i32>` is not implemented for `i64`\n  = help: the following other types implement trait `Add<Rhs>`:\n            `&i64` implements `Add<i64>`\n            `&i64` implements `Add`\n            `i64` implements `Add<&i64>`\n            `i64` implements `Add`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmplwBwNL/main.rs:1:129\n  |\n1 | ...ate_something (x : i64) { { { let unused_var = 42i32 ; { let y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_s...\n  |                           - help: try adding a return type: `-> i64`                  ^ expected `()`, found `i64`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmplwBwNL/main.rs:1:190\n  |\n1 | ... } } } fn main () { { { let result = calculate_something (10i32) ; println ! (\"{}\" , result) } } }\n  |                                         -------------------  ^^^^^ expected `i64`, found `i32`\n  |                                         |\n  |                                         arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmplwBwNL/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let y = x + 1i32 ; return y } } } }...\n  |                                        ^^^^^^^^^^^^^^^^^^^  -------\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! (\"{}\" , result) } } }\n1 + use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i64) ; println ! (\"{}\" , result) } } }\n  |\n\nerror[E0277]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmplwBwNL/main.rs:1:217\n  |\n1 | ...te_something (10i32) ; println ! (\"{}\" , result) } } }\n  |                                       --    ^^^^^^ `()` cannot be formatted with the default formatter\n  |                                       |\n  |                                       required by this formatting parameter\n  |\n  = help: the trait `std::fmt::Display` is not implemented for `()`\n  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 5 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch20-00-tooling.md",
          "example_number": 2,
          "line_number": 228,
          "code": "// Status: ✅ WORKING\n// Before formatting (messy)\nfun fibonacci(n:int)->int{if n<=1{n}else{fibonacci(n-1)+fibonacci(n-2)}}\n\n// After running: ruchy fmt fibonacci.ruchy\nfun fibonacci(n: int) -> int {\n    if n <= 1 {\n        n\n    } else {\n        fibonacci(n - 1) + fibonacci(n - 2)\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0428]: the name `fibonacci` is defined multiple times\n --> /tmp/.tmp0gfl2Q/main.rs:1:155\n  |\n1 | ... ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { ...\n  |       ----------------------------- previous definition of the value `fibonacci` here                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `fibonacci` redefined here\n  |\n  = note: `fibonacci` must be defined only once in the value namespace of this module\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp0gfl2Q/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp0gfl2Q/main.rs:1:69\n  |\n1 | ...nacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) ...\n  |                             ^^                                                                               ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp0gfl2Q/main.rs:1:86\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n...\n  |                                                                                      ^^ ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { n } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp0gfl2Q/main.rs:1:101\n  |\n1 | ...) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if ...\n  |                                               ^^                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp0gfl2Q/main.rs:1:187\n  |\n1 | ...nacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |                             ^^                                                                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp0gfl2Q/main.rs:1:204\n  |\n1 | ... 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } f...\n  |                                                                    ^^ ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { n } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp0gfl2Q/main.rs:1:219\n  |\n1 | ...) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |                                               ^^                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp0gfl2Q/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n...\n  |                                                                          -    ^^^^ expected `i64`, found `i32`\n  |                                                                          |\n  |                                                                          expected because this is `i64`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i64 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp0gfl2Q/main.rs:1:118\n  |\n1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32...\n  |                                                       ^^^^ expected `i64`, found `i32`\n\nerror[E0277]: cannot subtract `i32` from `i64`\n --> /tmp/.tmp0gfl2Q/main.rs:1:116\n  |\n1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32...\n  |                                                     ^ no implementation for `i64 - i32`\n  |\n  = help: the trait `Sub<i32>` is not implemented for `i64`\n  = help: the following other types implement trait `Sub<Rhs>`:\n            `&i64` implements `Sub<i64>`\n            `&i64` implements `Sub`\n            `i64` implements `Sub<&i64>`\n            `i64` implements `Sub`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp0gfl2Q/main.rs:1:141\n  |\n1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fib...\n  |                                                       ^^^^ expected `i64`, found `i32`\n\nerror[E0277]: cannot subtract `i32` from `i64`\n --> /tmp/.tmp0gfl2Q/main.rs:1:139\n  |\n1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fib...\n  |                                                     ^ no implementation for `i64 - i32`\n  |\n  = help: the trait `Sub<i32>` is not implemented for `i64`\n  = help: the following other types implement trait `Sub<Rhs>`:\n            `&i64` implements `Sub<i64>`\n            `&i64` implements `Sub`\n            `i64` implements `Sub<&i64>`\n            `i64` implements `Sub`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp0gfl2Q/main.rs:1:197\n  |\n1 | ...2) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn ma...\n  |                                                    -    ^^^^ expected `i64`, found `i32`\n  |                                                    |\n  |                                                    expected because this is `i64`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i64 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp0gfl2Q/main.rs:1:236\n  |\n1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |                                                       ^^^^ expected `i64`, found `i32`\n\nerror[E0277]: cannot subtract `i32` from `i64`\n --> /tmp/.tmp0gfl2Q/main.rs:1:234\n  |\n1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |                                                     ^ no implementation for `i64 - i32`\n  |\n  = help: the trait `Sub<i32>` is not implemented for `i64`\n  = help: the following other types implement trait `Sub<Rhs>`:\n            `&i64` implements `Sub<i64>`\n            `&i64` implements `Sub`\n            `i64` implements `Sub<&i64>`\n            `i64` implements `Sub`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp0gfl2Q/main.rs:1:259\n  |\n1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |                                                       ^^^^ expected `i64`, found `i32`\n\nerror[E0277]: cannot subtract `i32` from `i64`\n --> /tmp/.tmp0gfl2Q/main.rs:1:257\n  |\n1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |                                                     ^ no implementation for `i64 - i32`\n  |\n  = help: the trait `Sub<i32>` is not implemented for `i64`\n  = help: the following other types implement trait `Sub<Rhs>`:\n            `&i64` implements `Sub<i64>`\n            `&i64` implements `Sub`\n            `i64` implements `Sub<&i64>`\n            `i64` implements `Sub`\n\nerror: aborting due to 11 previous errors; 7 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0428.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch20-00-tooling.md",
          "example_number": 3,
          "line_number": 270,
          "code": "// Status: ✅ WORKING\n// math_utils.ruchy\nfun add(a: int, b: int) -> int {\n    a + b\n}\n\nfun multiply(a: int, b: int) -> int {\n    a * b\n}\n\n// Tests can be in the same file or separate test files\nfun test_add() {\n    assert_eq(add(2, 3), 5);\n    assert_eq(add(-1, 1), 0);\n    assert_eq(add(0, 0), 0);\n}\n\nfun test_multiply() {\n    assert_eq(multiply(2, 3), 6);\n    assert_eq(multiply(-1, 5), -5);\n    assert_eq(multiply(0, 100), 0);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpE3oKHk/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpE3oKHk/main.rs:1:73\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |                                                                         ^^     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { a + b } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpE3oKHk/main.rs:1:126\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |                                                                                                                              ^^     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { a * b } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpE3oKHk/main.rs:1:168\n  |\n1 | ... { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32...\n  |                                                 ^^^  ----   ---- expected `i64`, found `i32`\n  |                                                      |\n  |                                                      expected `i64`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmpE3oKHk/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |                                        ^^^  -------   -------\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i64 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i64) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nerror[E0423]: expected function, found macro `assert_eq`\n --> /tmp/.tmpE3oKHk/main.rs:1:157\n  |\n1 | ...i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ;...\n  |                                                           ^^^^^^^^^ not a function\n  |\nhelp: use `!` to invoke the macro\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq! (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                                                                                                                                                      +\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpE3oKHk/main.rs:1:207\n  |\n1 | ..._eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply ()...\n  |                                                ^^^  ------   ---- expected `i64`, found `i32`\n  |                                                     |\n  |                                                     expected `i64`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmpE3oKHk/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |                                        ^^^  -------   -------\nhelp: you can convert an `i32` to an `i64`\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add ((- 1i32).into() , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                                                                                                                                                                                                    +      ++++++++\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i64) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nerror[E0423]: expected function, found macro `assert_eq`\n --> /tmp/.tmpE3oKHk/main.rs:1:196\n  |\n1 | ...test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) }...\n  |                                                           ^^^^^^^^^ not a function\n  |\nhelp: use `!` to invoke the macro\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq! (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                                                                                                                                                                                             +\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpE3oKHk/main.rs:1:248\n  |\n1 | ...eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) ,...\n  |                                                 ^^^  ----   ---- expected `i64`, found `i32`\n  |                                                      |\n  |                                                      expected `i64`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmpE3oKHk/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |                                        ^^^  -------   -------\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i64 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i64) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nerror[E0423]: expected function, found macro `assert_eq`\n --> /tmp/.tmpE3oKHk/main.rs:1:237\n  |\n1 | ...32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (mul...\n  |                                                           ^^^^^^^^^ not a function\n  |\nhelp: use `!` to invoke the macro\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                                                                                                                                                                                                                                      +\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpE3oKHk/main.rs:1:313\n  |\n1 | ...2) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (...\n  |                                              ^^^^^^^^  ----   ---- expected `i64`, found `i32`\n  |                                                        |\n  |                                                        expected `i64`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmpE3oKHk/main.rs:1:88\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |                                                                                        ^^^^^^^^  -------   -------\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i64 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i64) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nerror[E0423]: expected function, found macro `assert_eq`\n --> /tmp/.tmpE3oKHk/main.rs:1:302\n  |\n1 | ...(add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32)...\n  |                                                           ^^^^^^^^^ not a function\n  |\nhelp: use `!` to invoke the macro\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq! (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                       +\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpE3oKHk/main.rs:1:357\n  |\n1 | ...tiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main ...\n  |                                             ^^^^^^^^  ------   ---- expected `i64`, found `i32`\n  |                                                       |\n  |                                                       expected `i64`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmpE3oKHk/main.rs:1:88\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |                                                                                        ^^^^^^^^  -------   -------\nhelp: you can convert an `i32` to an `i64`\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply ((- 1i32).into() , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                               +      ++++++++\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i64) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nerror[E0423]: expected function, found macro `assert_eq`\n --> /tmp/.tmpE3oKHk/main.rs:1:346\n  |\n1 | ...ply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100...\n  |                                                           ^^^^^^^^^ not a function\n  |\nhelp: use `!` to invoke the macro\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                   +\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpE3oKHk/main.rs:1:405\n  |\n1 | ...y (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                             ^^^^^^^^  ----   ------ expected `i64`, found `i32`\n  |                                                       |\n  |                                                       expected `i64`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmpE3oKHk/main.rs:1:88\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |                                                                                        ^^^^^^^^  -------   -------\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i64 , 100i32) , 0i32) } } fn main () { }\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i64) , 0i32) } } fn main () { }\n  |\n\nerror[E0423]: expected function, found macro `assert_eq`\n --> /tmp/.tmpE3oKHk/main.rs:1:394\n  |\n1 | ...i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                                           ^^^^^^^^^ not a function\n  |\nhelp: use `!` to invoke the macro\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                   +\n\nerror: aborting due to 12 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0423.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch20-00-tooling.md",
          "example_number": 4,
          "line_number": 342,
          "code": "// Status: ✅ WORKING\n// property_test.ruchy\nfun reverse_string(s: string) -> string {\n    // Implementation details...\n    s  // Placeholder\n}\n\nfun property_test_reverse_twice_is_identity() {\n    // Property: reverse(reverse(s)) == s\n    property_test(|s: string| {\n        assert_eq(reverse_string(reverse_string(s)), s);\n    });\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpSEORgl/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { { ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpSEORgl/main.rs:1:80\n  |\n1 | use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { { ...\n  |                                                                                ^^ ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { s } fn property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpSEORgl/main.rs:1:136\n  |\n1 | ...se_twice_is_identity () { { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } } fn main () { }\n  |                              ^^                                                                             ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } fn main () { }\n  |\n\nerror[E0423]: expected function, found macro `assert_eq`\n --> /tmp/.tmpSEORgl/main.rs:1:161\n  |\n1 | ...everse_twice_is_identity () { { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } } fn main () { }\n  |                                                           ^^^^^^^^^ not a function\n  |\nhelp: use `!` to invoke the macro\n  |\n1 | use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq! (reverse_string (reverse_string (s)) , s) }) } } fn main () { }\n  |                                                                                                                                                                          +\n\nerror[E0425]: cannot find function `property_test` in this scope\n --> /tmp/.tmpSEORgl/main.rs:1:138\n  |\n1 | ... property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } } fn m...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0423, E0425.\nFor more information about an error, try `rustc --explain E0423`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch20-00-tooling.md",
          "example_number": 5,
          "line_number": 428,
          "code": "// Status: ✅ WORKING\n// documented_code.ruchy\n\n/// Calculates the factorial of a positive integer\n/// \n/// # Examples\n/// ```ruchy\n/// let result = factorial(5);\n/// assert_eq(result, 120);\n/// ```\n///\n/// # Panics\n/// Panics if n is negative\nfun factorial(n: int) -> int {\n    if n < 0 {\n        panic(\"Factorial not defined for negative numbers\");\n    }\n    \n    if n == 0 || n == 1 {\n        1\n    } else {\n        n * factorial(n - 1)\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpKcw8Ks/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative number...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpKcw8Ks/main.rs:1:85\n  |\n1 | ...al (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i3...\n  |                                          ^^                                                      ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { panic ! (\"Factorial not defined for negative numbers\") } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpKcw8Ks/main.rs:1:176\n  |\n1 | ...fined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |                                                                   ^^    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { 1i32 } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpKcw8Ks/main.rs:1:194\n  |\n1 | ... } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |                                                         ^^                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { n * factorial (n - 1i32) } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpKcw8Ks/main.rs:1:78\n  |\n1 | use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative number...\n  |                                                                          -   ^^^^ expected `i64`, found `i32`\n  |                                                                          |\n  |                                                                          expected because this is `i64`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i64 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpKcw8Ks/main.rs:1:156\n  |\n1 | ...ial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main ...\n  |                                                    -    ^^^^ expected `i64`, found `i32`\n  |                                                    |\n  |                                                    expected because this is `i64`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i64 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpKcw8Ks/main.rs:1:169\n  |\n1 | ...ed for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |                                                    -    ^^^^ expected `i64`, found `i32`\n  |                                                    |\n  |                                                    expected because this is `i64`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i64 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpKcw8Ks/main.rs:1:178\n  |\n1 | ...) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else ...\n  |         --- expected `i64` because of return type                                                                          ^^^^ expected `i64`, found `i32`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i64 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpKcw8Ks/main.rs:1:215\n  |\n1 | ...n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |                                                       ^^^^ expected `i64`, found `i32`\n\nerror[E0277]: cannot subtract `i32` from `i64`\n --> /tmp/.tmpKcw8Ks/main.rs:1:213\n  |\n1 | ...n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |                                                     ^ no implementation for `i64 - i32`\n  |\n  = help: the trait `Sub<i32>` is not implemented for `i64`\n  = help: the following other types implement trait `Sub<Rhs>`:\n            `&i64` implements `Sub<i64>`\n            `&i64` implements `Sub`\n            `i64` implements `Sub<&i64>`\n            `i64` implements `Sub`\n\nerror: aborting due to 6 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch20-00-tooling.md",
          "example_number": 6,
          "line_number": 479,
          "code": "// Status: ✅ WORKING\n// bench_test.ruchy\nfun fibonacci_recursive(n: int) -> int {\n    if n <= 1 { n } else { fibonacci_recursive(n-1) + fibonacci_recursive(n-2) }\n}\n\nfun fibonacci_iterative(n: int) -> int {\n    let mut a = 0;\n    let mut b = 1;\n    for i in range(n) {\n        let temp = a + b;\n        a = b;\n        b = temp;\n    }\n    a\n}\n\n// Benchmark functions\nfun bench_recursive_fib() {\n    bench(\"fibonacci_recursive_20\", || fibonacci_recursive(20));\n}\n\nfun bench_iterative_fib() {\n    bench(\"fibonacci_iterative_20\", || fibonacci_iterative(20));\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find function `range` in this scope\n --> /tmp/.tmpiAI6zr/main.rs:1:276\n  |\n1 | ... { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_rec...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::slice::range;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpiAI6zr/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpiAI6zr/main.rs:1:79\n  |\n1 | ... i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_...\n  |                   ^^                                                                                                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" , || fibonacci_iterative (20i32)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpiAI6zr/main.rs:1:96\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - ...\n  |                                                                                                ^^ ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { n } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" , || fibonacci_iterative (20i32)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpiAI6zr/main.rs:1:111\n  |\n1 | ... { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n :...\n  |                                     ^^                                                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" , || fibonacci_iterative (20i32)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpiAI6zr/main.rs:1:288\n  |\n1 | ... ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { ben...\n  |                                               ^^                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { let temp = a + b ; { a = b ; b = temp } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" , || fibonacci_iterative (20i32)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpiAI6zr/main.rs:1:374\n  |\n1 | ...} } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { ...\n  |                                    ^^                                                                 ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { bench (\"fibonacci_recursive_20\" , || fibonacci_recursive (20i32)) } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" , || fibonacci_iterative (20i32)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpiAI6zr/main.rs:1:474\n  |\n1 | ...} } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" , || fibonacci_iterative (20i32)) } } fn main () { }\n  |                                    ^^                                                                 ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { bench (\"fibonacci_iterative_20\" , || fibonacci_iterative (20i32)) } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpiAI6zr/main.rs:1:89\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - ...\n  |                                                                                    -    ^^^^ expected `i64`, found `i32`\n  |                                                                                    |\n  |                                                                                    expected because this is `i64`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i64 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" , || fibonacci_iterative (20i32)) } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpiAI6zr/main.rs:1:138\n  |\n1 | ...= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> ...\n  |                                                       ^^^^ expected `i64`, found `i32`\n\nerror[E0277]: cannot subtract `i32` from `i64`\n --> /tmp/.tmpiAI6zr/main.rs:1:136\n  |\n1 | ...= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> ...\n  |                                                     ^ no implementation for `i64 - i32`\n  |\n  = help: the trait `Sub<i32>` is not implemented for `i64`\n  = help: the following other types implement trait `Sub<Rhs>`:\n            `&i64` implements `Sub<i64>`\n            `&i64` implements `Sub`\n            `i64` implements `Sub<&i64>`\n            `i64` implements `Sub`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpiAI6zr/main.rs:1:171\n  |\n1 | ...ci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mu...\n  |                                                       ^^^^ expected `i64`, found `i32`\n\nerror[E0277]: cannot subtract `i32` from `i64`\n --> /tmp/.tmpiAI6zr/main.rs:1:169\n  |\n1 | ...ci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mu...\n  |                                                     ^ no implementation for `i64 - i32`\n  |\n  = help: the trait `Sub<i32>` is not implemented for `i64`\n  = help: the following other types implement trait `Sub<Rhs>`:\n            `&i64` implements `Sub<i64>`\n            `&i64` implements `Sub`\n            `i64` implements `Sub<&i64>`\n            `i64` implements `Sub`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpiAI6zr/main.rs:1:340\n  |\n1 | ...) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn b...\n  |         --- expected `i64` because of return type                                                                              ^ expected `i64`, found `i32`\n  |\nhelp: you can convert an `i32` to an `i64`\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a.into() } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" , || fibonacci_iterative (20i32)) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                     +++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpiAI6zr/main.rs:1:434\n  |\n1 | ...bench (\"fibonacci_recursive_20\" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" , ...\n  |                                         -------------------  ^^^^^ expected `i64`, found `i32`\n  |                                         |\n  |                                         arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpiAI6zr/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - ...\n  |                                        ^^^^^^^^^^^^^^^^^^^  -------\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" , || fibonacci_recursive (20i64)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" , || fibonacci_iterative (20i32)) } } fn main () { }\n  |\n\nerror[E0423]: expected function, found attribute macro `bench`\n --> /tmp/.tmpiAI6zr/main.rs:1:376\n  |\n1 | ...; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" , || fibonacci_recursive (20i32)) } } fn benc...\n  |                                                             ^^^^^ not a function\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpiAI6zr/main.rs:1:534\n  |\n1 | ...bench (\"fibonacci_iterative_20\" , || fibonacci_iterative (20i32)) } } fn main () { }\n  |                                         -------------------  ^^^^^ expected `i64`, found `i32`\n  |                                         |\n  |                                         arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpiAI6zr/main.rs:1:188\n  |\n1 | ...- 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for...\n  |                                                        ^^^^^^^^^^^^^^^^^^^  -------\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" , || fibonacci_iterative (20i64)) } } fn main () { }\n  |\n\nerror[E0423]: expected function, found attribute macro `bench`\n --> /tmp/.tmpiAI6zr/main.rs:1:476\n  |\n1 | ...cci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" , || fibonacci_iterative (20i32)) } } fn main...\n  |                                                             ^^^^^ not a function\n\nerror: aborting due to 11 previous errors; 7 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0423, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch07-00-building-applications": {
      "chapter": "ch07-00-building-applications",
      "total_examples": 9,
      "working_examples": 0,
      "failing_examples": 9,
      "examples": [
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected In, found Comma\n// File: note_keeper.ruchy\n// A complete note-taking application\n\nlet APP_NAME = \"NoteKeeper\"\nlet VERSION = \"1.0.0\"\nlet NOTES_DIR = expand_home(\"~/.notes\")\nlet NOTES_INDEX = join_path(NOTES_DIR, \"index.json\")\n\n// Initialize application\nfun init_app() {\n    if !dir_exists(NOTES_DIR) {\n        create_dir_all(NOTES_DIR)\n        println(\"Created notes directory: \" + NOTES_DIR)\n    }\n    \n    if !file_exists(NOTES_INDEX) {\n        let initial_index = {\n            \"version\": VERSION,\n            \"notes\": [],\n            \"tags\": [],\n            \"last_modified\": current_datetime()\n        }\n        save_index(initial_index)\n    }\n}\n\nfun load_index() {\n    let content = read_file(NOTES_INDEX)\n    return parse_json(content)\n}\n\nfun save_index(index) {\n    index.last_modified = current_datetime()\n    let json = to_json_pretty(index)\n    write_file(NOTES_INDEX, json)\n}\n\nfun create_note() {\n    println(\"\\n📝 Create New Note\")\n    let title = input(\"Title: \")\n    let content = input_multiline(\"Content (end with empty line):\\n\")\n    let tags = input(\"Tags (comma-separated): \").split(\",\").map(|t| t.trim())\n    \n    let note_id = generate_id()\n    let note_file = join_path(NOTES_DIR, note_id + \".md\")\n    \n    let note = {\n        \"id\": note_id,\n        \"title\": title,\n        \"created\": current_datetime(),\n        \"modified\": current_datetime(),\n        \"tags\": tags,\n        \"file\": note_file\n    }\n    \n    // Save note content\n    let markdown = \"# \" + title + \"\\n\\nCreated: \" + note.created + \"\\nTags: \" + tags.join(\", \") + \"\\n\\n---\\n\\n\" + content\n    \n    write_file(note_file, markdown)\n    \n    // Update index\n    let index = load_index()\n    index.notes.push(note)\n    index.tags = index.tags.union(tags)\n    save_index(index)\n    \n    println(\"✅ Note created: \" + title)\n}\n\nfun list_notes(filter_tag = null) {\n    let index = load_index()\n    let notes = index.notes\n    \n    if filter_tag {\n        notes = notes.filter(|n| n.tags.contains(filter_tag))\n        println(f\"\\n📋 Notes tagged '{filter_tag}':\")\n    } else {\n        println(f\"\\n📋 All Notes ({notes.len()} total):\")\n    }\n    \n    if notes.is_empty() {\n        println(\"  No notes found\")\n        return\n    }\n    \n    for i, note in notes.enumerate() {\n        let age = time_ago(note.created)\n        println((i+1).to_s() + \". \" + note.title)\n        println(\"     Tags: \" + note.tags.join(\", \") + \" | Created: \" + age)\n    }\n}\n\nfun search_notes(query) {\n    let index = load_index()\n    let results = []\n    \n    for note in index.notes {\n        // Search in title\n        if note.title.lower().contains(query.lower()) {\n            results.push(note)\n            continue\n        }\n        \n        // Search in content\n        let content = read_file(note.file)\n        if content.lower().contains(query.lower()) {\n            results.push(note)\n        }\n    }\n    \n    println(f\"\\n🔍 Search results for '{query}': {results.len()} matches\")\n    \n    for note in results {\n        println(\"  • \" + note.title)\n        \n        // Show context\n        let content = read_file(note.file)\n        let lines = content.lines()\n        for line in lines {\n            if line.lower().contains(query.lower()) {\n                println(f\"    ...{line.trim()}...\")\n                break\n            }\n        }\n    }\n}\n\nfun view_note(index_num) {\n    let index = load_index()\n    \n    if index_num < 1 || index_num > index.notes.len() {\n        println(\"❌ Invalid note number\")\n        return\n    }\n    \n    let note = index.notes[index_num - 1]\n    let content = read_file(note.file)\n    \n    println(\"\\n\" + \"=\"*50)\n    println(content)\n    println(\"=\"*50)\n}\n\nfun export_notes(format) {\n    let index = load_index()\n    let export_file = \"notes_export_\" + current_date() + \".\" + format\n    \n    match format {\n        \"json\" => {\n            let data = {\n                \"exported\": current_datetime(),\n                \"notes\": []\n            }\n            \n            for note in index.notes {\n                let content = read_file(note.file)\n                data.notes.push({\n                    \"title\": note.title,\n                    \"content\": content,\n                    \"tags\": note.tags,\n                    \"created\": note.created\n                })\n            }\n            \n            write_file(export_file, to_json_pretty(data))\n        }\n        \"markdown\" => {\n            let markdown = f\"# My Notes\nExported: {current_datetime()}\n\n\"\n            for note in index.notes {\n                let content = read_file(note.file)\n                markdown += f\"\n\n---\n\n{content}\n\"\n            }\n            \n            write_file(export_file, markdown)\n        }\n        _ => {\n            println(\"❌ Unsupported format: \" + format)\n            return\n        }\n    }\n    \n    println(\"✅ Exported \" + index.notes.len().to_s() + \" notes to \" + export_file)\n}\n\nfun show_menu() {\n    println(f\"\\n=== {APP_NAME} v{VERSION} ===\")\n    println(\"1. Create note\")\n    println(\"2. List all notes\")\n    println(\"3. Search notes\")\n    println(\"4. View note\")\n    println(\"5. List by tag\")\n    println(\"6. Export notes\")\n    println(\"7. Statistics\")\n    println(\"8. Quit\")\n}\n\nfun show_statistics() {\n    let index = load_index()\n    let total_notes = index.notes.len()\n    let total_tags = index.tags.len()\n    \n    // Calculate word count\n    let total_words = 0\n    for note in index.notes {\n        let content = read_file(note.file)\n        total_words += content.split_whitespace().len()\n    }\n    \n    // Find most used tags\n    let tag_counts = {}\n    for note in index.notes {\n        for tag in note.tags {\n            tag_counts[tag] = tag_counts.get(tag, 0) + 1\n        }\n    }\n    \n    println(f\"\\n📊 NoteKeeper Statistics\")\n    println(\"Total notes: \" + total_notes.to_s())\n    println(\"Total words: \" + total_words.to_s())\n    println(\"Average words per note: \" + (total_words / max(total_notes, 1)).to_s())\n    println(\"Unique tags: \" + total_tags.to_s())\n    \n    if !tag_counts.is_empty() {\n        println(\"\\nTop tags:\")\n        let sorted_tags = tag_counts.items().sort_by(|item| -item.value)\n        for tag, count in sorted_tags[..min(5, sorted_tags.len())] {\n            println(f\"  • {tag}: {count} notes\")\n        }\n    }\n}\n\n// Main application loop\nfun main() {\n    init_app()\n    \n    println(f\"Welcome to {APP_NAME}!\")\n    println(\"Your personal note-taking assistant\")\n    \n    loop {\n        show_menu()\n        let choice = input(\"\\nChoice: \")\n        \n        match choice {\n            \"1\" => create_note()\n            \"2\" => list_notes()\n            \"3\" => {\n                let query = input(\"Search for: \")\n                search_notes(query)\n            }\n            \"4\" => {\n                list_notes()\n                let num = input(\"\\nNote number to view: \").to_i()\n                view_note(num)\n            }\n            \"5\" => {\n                let index = load_index()\n                println(\"\\nAvailable tags:\")\n                for tag in index.tags {\n                    println(\"  • \" + tag)\n                }\n                let tag = input(\"\\nFilter by tag: \")\n                list_notes(tag)\n            }\n            \"6\" => {\n                let format = input(\"Export format (json/markdown): \")\n                export_notes(format)\n            }\n            \"7\" => show_statistics()\n            \"8\" => {\n                println(\"👋 Thanks for using NoteKeeper!\")\n                break\n            }\n            _ => println(\"❌ Invalid choice\")\n        }\n    }\n}\n\n// Run the application\nmain()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 2,
          "line_number": 334,
          "code": "// Status: ✅ WORKING\n\n// Application structure\nlet APP = {\n    \"name\": \"MyApp\",\n    \"version\": \"1.0.0\",\n    \"config_dir\": \"~/.config/myapp\",\n    \"data_dir\": \"~/.local/share/myapp\",\n    \"cache_dir\": \"~/.cache/myapp\"\n}\n\n// Separate concerns into modules\n// models.ruchy - Data structures\nlet User = {\n    \"id\": null,\n    \"name\": \"\",\n    \"email\": \"\",\n    \"created\": null\n}\n\n// services.ruchy - Business logic\nfun create_user(name, email) {\n    let user = User.copy()\n    user.id = generate_uuid()\n    user.name = name\n    user.email = email\n    user.created = current_datetime()\n    return user\n}\n\n// ui.ruchy - User interface\nfun display_user(user) {\n    println(f\"User: {user.name} ({user.email})\")\n    println(\"Member since: \" + user.created)\n}\n\n// main.ruchy - Application entry point\nfun main() {\n    init_app()\n    load_config()\n    run_event_loop()\n    cleanup()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: struct literal body without path\n --> /tmp/.tmpOG1PlP/main.rs:1:685\n  |\n1 | ... = { name : \"MyApp\" , version : \"1.0.0\" , config_dir : \"~/.config/myapp\" , data_dir : \"~/.local/share/myapp\" , cache_dir : \"~/.cache/myapp\" , } ; ...\n  |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\nhelp: you might have forgotten to add the struct literal inside the block\n  |\n1 | use std :: collections :: HashMap ; fn create_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , email : T) -> T { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! (\"User: {} ({})\" , user . name , user . email) ; println ! (\"{}\" , \"Member since: \" + user . created) } } fn main () { let APP = { SomeStruct { name : \"MyApp\" , version : \"1.0.0\" , config_dir : \"~/.config/myapp\" , data_dir : \"~/.local/share/myapp\" , cache_dir : \"~/.cache/myapp\" , } } ; let User = { id : null , name : \"\" , email : \"\" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ++++++++++++                                                                                                                                              +\n\nerror: struct literal body without path\n --> /tmp/.tmpOG1PlP/main.rs:1:839\n  |\n1 | ...r : \"~/.cache/myapp\" , } ; let User = { id : null , name : \"\" , email : \"\" , created : null , } ; { init_app () ; load_config () ; run...\n  |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\nhelp: you might have forgotten to add the struct literal inside the block\n  |\n1 | use std :: collections :: HashMap ; fn create_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , email : T) -> T { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! (\"User: {} ({})\" , user . name , user . email) ; println ! (\"{}\" , \"Member since: \" + user . created) } } fn main () { let APP = { name : \"MyApp\" , version : \"1.0.0\" , config_dir : \"~/.config/myapp\" , data_dir : \"~/.local/share/myapp\" , cache_dir : \"~/.cache/myapp\" , } ; let User = { SomeStruct { id : null , name : \"\" , email : \"\" , created : null , } } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ++++++++++++                                                           +\n\nerror[E0425]: cannot find value `User` in this scope\n --> /tmp/.tmpOG1PlP/main.rs:1:227\n  |\n1 | ...Clone > (name : T , email : T) -> T { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . ema...\n  |                                                         ^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpOG1PlP/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn create_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpOG1PlP/main.rs:1:212\n  |\n1 | ... { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } ...\n  |       ^^                                                                                                                                                                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn create_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , email : T) -> T { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! (\"User: {} ({})\" , user . name , user . email) ; println ! (\"{}\" , \"Member since: \" + user . created) } } fn main () { let APP = { name : \"MyApp\" , version : \"1.0.0\" , config_dir : \"~/.config/myapp\" , data_dir : \"~/.local/share/myapp\" , cache_dir : \"~/.cache/myapp\" , } ; let User = { id : null , name : \"\" , email : \"\" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n1 + use std :: collections :: HashMap ; fn create_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , email : T) -> T { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } fn display_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! (\"User: {} ({})\" , user . name , user . email) ; println ! (\"{}\" , \"Member since: \" + user . created) } } fn main () { let APP = { name : \"MyApp\" , version : \"1.0.0\" , config_dir : \"~/.config/myapp\" , data_dir : \"~/.local/share/myapp\" , cache_dir : \"~/.cache/myapp\" , } ; let User = { id : null , name : \"\" , email : \"\" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |\n\nerror[E0425]: cannot find function `generate_uuid` in this scope\n --> /tmp/.tmpOG1PlP/main.rs:1:258\n  |\n1 | ...{ { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = curren...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `current_datetime` in this scope\n --> /tmp/.tmpOG1PlP/main.rs:1:338\n  |\n1 | ...name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user < T : std :: ops :: Add < Out...\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0609]: no field `name` on type `T`\n --> /tmp/.tmpOG1PlP/main.rs:1:582\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! (\"User: {} ({})\" , user . name , ...\n  |       - type parameter 'T' declared here                                                                                                                                                      ^^^^ unknown field\n\nerror[E0609]: no field `email` on type `T`\n --> /tmp/.tmpOG1PlP/main.rs:1:596\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! (\"User: {} ({})\" , user . name , user . email) ;...\n  |       - type parameter 'T' declared here                                                                                                                                                                    ^^^^^ unknown field\n\nerror[E0609]: no field `created` on type `T`\n --> /tmp/.tmpOG1PlP/main.rs:1:649\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! (\"User: {} ({})\" , user . name , user . email) ; println ! (\"{}\" , \"Member since: \" + user . created) }...\n  |       - type parameter 'T' declared here                                                                                                                                                                                                                         ^^^^^^^ unknown field\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpOG1PlP/main.rs:1:623\n  |\n1 | ...er . email) ; println ! (\"{}\" , \"Member since: \" + user . created) } } fn main () { let APP = { name : \"MyApp\" , version : \"1.0.0\" , c...\n  |                              --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                              |\n  |                              required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpOG1PlP/main.rs:1:605\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! (\"User: {} ({})\" , user . name , user . email) ; println ! (\"{}\" , \"Member since: \" + user . created) } ...\n  |       - expected this type parameter                                                                                                                                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `init_app` in this scope\n --> /tmp/.tmpOG1PlP/main.rs:1:901\n  |\n1 | ... , name : \"\" , email : \"\" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `load_config` in this scope\n --> /tmp/.tmpOG1PlP/main.rs:1:915\n  |\n1 | ...mail : \"\" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `run_event_loop` in this scope\n --> /tmp/.tmpOG1PlP/main.rs:1:932\n  |\n1 | ...d : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `cleanup` in this scope\n --> /tmp/.tmpOG1PlP/main.rs:1:952\n  |\n1 | ...init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |                                                       ^^^^^^^ not found in this scope\n\nerror: aborting due to 14 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0425, E0609.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 3,
          "line_number": 389,
          "code": "// Status: ✅ WORKING\n\n// Global application state\nlet STATE = {\n    \"users\": [],\n    \"current_user\": null,\n    \"settings\": {},\n    \"cache\": {},\n    \"dirty\": false\n}\n\nfun update_state(key, value) {\n    STATE[key] = value\n    STATE.dirty = true\n    trigger_save()\n}\n\nfun save_state() {\n    if STATE.dirty {\n        let state_file = join_path(APP.data_dir, \"state.json\")\n        write_file(state_file, to_json(STATE))\n        STATE.dirty = false\n    }\n}\n\nfun load_state() {\n    let state_file = join_path(APP.data_dir, \"state.json\")\n    if file_exists(state_file) {\n        STATE = parse_json(read_file(state_file))\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: struct literal body without path\n --> /tmp/.tmpMiWUoV/main.rs:1:659\n  |\n1 | ...main () { let STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }\n  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\nhelp: you might have forgotten to add the struct literal inside the block\n  |\n1 | use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { SomeStruct { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ++++++++++++                                                                                           +\n\nerror[E0425]: cannot find value `STATE` in this scope\n --> /tmp/.tmpMiWUoV/main.rs:1:214\n  |\n1 | ...t :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () ...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `STATE` in this scope\n --> /tmp/.tmpMiWUoV/main.rs:1:236\n  |\n1 | ...key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty {...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `STATE` in this scope\n --> /tmp/.tmpMiWUoV/main.rs:1:303\n  |\n1 | ... true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\") ; {...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP` in this scope\n --> /tmp/.tmpMiWUoV/main.rs:1:351\n  |\n1 | ...{ if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\") ; { write_file (state_file , to_json (STATE)) ; ST...\n  |                                                         ^^^ not found in this scope\n\nerror[E0425]: cannot find value `STATE` in this scope\n --> /tmp/.tmpMiWUoV/main.rs:1:420\n  |\n1 | ...\"state.json\") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file ...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `STATE` in this scope\n --> /tmp/.tmpMiWUoV/main.rs:1:430\n  |\n1 | ...n\") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_pat...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP` in this scope\n --> /tmp/.tmpMiWUoV/main.rs:1:515\n  |\n1 | ...} fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\") ; if file_exists (state_file) { { STATE = parse_js...\n  |                                                         ^^^ not found in this scope\n\nerror[E0425]: cannot find value `STATE` in this scope\n --> /tmp/.tmpMiWUoV/main.rs:1:580\n  |\n1 | ...r , \"state.json\") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { u...\n  |                                                        ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpMiWUoV/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fm...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpMiWUoV/main.rs:1:298\n  |\n1 | ... { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } ...\n  |       ^^                                                                                                                                                               ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }\n1 + use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpMiWUoV/main.rs:1:319\n  |\n1 | ... { { { let state_file = join_path (APP . data_dir , \"state.json\") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } ...\n  |       ^^                                                                                                                                      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }\n1 + use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { let state_file = join_path (APP . data_dir , \"state.json\") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpMiWUoV/main.rs:1:483\n  |\n1 | ... { { { let state_file = join_path (APP . data_dir , \"state.json\") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } ...\n  |       ^^                                                                                                                                                ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }\n1 + use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { let state_file = join_path (APP . data_dir , \"state.json\") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } fn main () { let STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpMiWUoV/main.rs:1:578\n  |\n1 | ...ate.json\") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { users : ...\n  |                                               ^^                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }\n1 + use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\") ; if file_exists (state_file) { STATE = parse_json (read_file (state_file)) } } } } fn main () { let STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }\n  |\n\nerror[E0425]: cannot find function `trigger_save` in this scope\n --> /tmp/.tmpMiWUoV/main.rs:1:259\n  |\n1 | ...{ { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpMiWUoV/main.rs:1:340\n  |\n1 | ...te () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\") ; { write_file (state_file , to_json (STAT...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_json` in this scope\n --> /tmp/.tmpMiWUoV/main.rs:1:411\n  |\n1 | ...a_dir , \"state.json\") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let sta...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmpMiWUoV/main.rs:1:386\n  |\n1 | ... data_dir , \"state.json\") ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let...\n  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `state_file`\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpMiWUoV/main.rs:1:504\n  |\n1 | ...} } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\") ; if file_exists (state_file) { { STATE = ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpMiWUoV/main.rs:1:551\n  |\n1 | ...= join_path (APP . data_dir , \"state.json\") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmpMiWUoV/main.rs:1:600\n  |\n1 | ... file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { users : vec ! [] , curr...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `parse_json` in this scope\n --> /tmp/.tmpMiWUoV/main.rs:1:588\n  |\n1 | ....json\") ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { users : vec...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 17 previous errors; 5 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 4,
          "line_number": 432,
          "code": "// Status: ✅ WORKING\n\nfun safe_operation(operation_fn, fallback_value) {\n    try {\n        return operation_fn()\n    } catch error {\n        log_error(error)\n        return fallback_value\n    }\n}\n\nfun with_retry(operation_fn, max_attempts = 3) {\n    for attempt in range(max_attempts) {\n        try {\n            return operation_fn()\n        } catch error {\n            if attempt == max_attempts - 1 {\n                println(\"❌ Failed after \" + max_attempts.to_s() + \" attempts: \" + error.to_s())\n                throw error\n            }\n            \n            let wait_time = 2 ** attempt  // Exponential backoff\n            println(f\"⚠️  Attempt {attempt + 1} failed, retrying in {wait_time}s...\")\n            sleep(wait_time * 1000)\n        }\n    }\n}",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0423]: expected value, found macro `try`\n --> /tmp/.tmpP7p4i2/main.rs:1:234\n  |\n1 | ...+ Clone > (operation_fn : T , fallback_value : T) -> T { { try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; re...\n  |                                                               ^^^ not a value\n\nerror[E0425]: cannot find value `catch` in this scope\n --> /tmp/.tmpP7p4i2/main.rs:1:269\n  |\n1 | ...ue : T) -> T { { try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < ...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpP7p4i2/main.rs:1:277\n  |\n1 | ...-> T { { try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std ...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpP7p4i2/main.rs:1:298\n  |\n1 | ...rn operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Outpu...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `range` in this scope\n --> /tmp/.tmpP7p4i2/main.rs:1:541\n  |\n1 | ..._fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { try ; { return operation_fn () } ; catch ; error ; { if a...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::slice::range;\n  |\n\nerror[E0423]: expected value, found macro `try`\n --> /tmp/.tmpP7p4i2/main.rs:1:566\n  |\n1 | ...mpts : T) -> T { { for attempt in range (max_attempts) { { try ; { return operation_fn () } ; catch ; error ; { if attempt == max_atte...\n  |                                                               ^^^ not a value\n\nerror[E0425]: cannot find value `catch` in this scope\n --> /tmp/.tmpP7p4i2/main.rs:1:601\n  |\n1 | ...ax_attempts) { { try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{}\" , \"❌ Failed...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpP7p4i2/main.rs:1:609\n  |\n1 | ...pts) { { try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{}\" , \"❌ Failed after \"...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpP7p4i2/main.rs:1:736\n  |\n1 | ... after \" + max_attempts . to_s () + \" attempts: \" + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; ...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpP7p4i2/main.rs:1:764\n  |\n1 | ..._s () + \" attempts: \" + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! (\"⚠\\u{fe0f}  Att...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `sleep` in this scope\n --> /tmp/.tmpP7p4i2/main.rs:1:914\n  |\n1 | ...retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::thread::sleep;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpP7p4i2/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn safe_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpP7p4i2/main.rs:1:524\n  |\n1 | ... { { for attempt in range (max_attempts) { { try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{}\" , \"❌ Failed after \" + max_attempts . to_s () + \" attempts: \" + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! (\"⚠\\u{fe0f}  Attempt {} failed, retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } f...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn safe_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , fallback_value : T) -> T { { try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{}\" , \"❌ Failed after \" + max_attempts . to_s () + \" attempts: \" + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! (\"⚠\\u{fe0f}  Attempt {} failed, retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn safe_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , fallback_value : T) -> T { { try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { for attempt in range (max_attempts) { { try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{}\" , \"❌ Failed after \" + max_attempts . to_s () + \" attempts: \" + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! (\"⚠\\u{fe0f}  Attempt {} failed, retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } fn main () { }\n  |\n\nerror[E0618]: expected function, found `T`\n --> /tmp/.tmpP7p4i2/main.rs:1:249\n  |\n1 | ...+ Clone > (operation_fn : T , fallback_value : T) -> T { { try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; re...\n  |               ------------                                                   ^^^^^^^^^^^^---\n  |               |                                                              |\n  |               `operation_fn` has type `T`                                    call expression requires function\n\nwarning: unreachable statement\n --> /tmp/.tmpP7p4i2/main.rs:1:269\n  |\n1 | ...ck_value : T) -> T { { try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_re...\n  |                                   ----------------------     ^^^^^^^ unreachable statement\n  |                                   |\n  |                                   any code following this expression is unreachable\n  |\n  = note: `#[warn(unreachable_code)]` on by default\n\nerror[E0425]: cannot find function `log_error` in this scope\n --> /tmp/.tmpP7p4i2/main.rs:1:287\n  |\n1 | ... ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Ad...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0618]: expected function, found `T`\n --> /tmp/.tmpP7p4i2/main.rs:1:581\n  |\n1 | ...one > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { try ; { return operation_fn () } ; catch ...\n  |           ------------                                                                                         ^^^^^^^^^^^^---\n  |           |                                                                                                    |\n  |           `operation_fn` has type `T`                                                                          call expression requires function\n\nwarning: unreachable statement\n --> /tmp/.tmpP7p4i2/main.rs:1:601\n  |\n1 | ...nge (max_attempts) { { try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{}\" , \"❌ ...\n  |                                   ----------------------     ^^^^^^^ unreachable statement\n  |                                   |\n  |                                   any code following this expression is unreachable\n\nerror[E0369]: cannot subtract `i32` from `T`\n --> /tmp/.tmpP7p4i2/main.rs:1:646\n  |\n1 | ...rn operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{}\" , \"❌ Failed after \" + max_attempts . to_...\n  |                                                           ------------ ^ ---- i32\n  |                                                           |\n  |                                                           T\n  |\nhelp: consider further restricting type parameter `T` with trait `Sub`\n  |\n1 | use std :: collections :: HashMap ; fn safe_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , fallback_value : T) -> T { { try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Sub<i32> > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{}\" , \"❌ Failed after \" + max_attempts . to_s () + \" attempts: \" + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! (\"⚠\\u{fe0f}  Attempt {} failed, retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ++++++++++++++++++++\n\nerror[E0599]: no method named `to_s` found for type parameter `T` in the current scope\n --> /tmp/.tmpP7p4i2/main.rs:1:710\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{}\" , \"❌ Failed after \" + max_attempts . to_s () ...\n  |       - method `to_s` not found for this type parameter                                                                                                                                                                                                                                                                                                                       ^^^^ method not found in `T`\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmpP7p4i2/main.rs:1:718\n  |\n1 | ...empts - 1i32 { { println ! (\"{}\" , \"❌ Failed after \" + max_attempts . to_s () + \" attempts: \" + error . to_s ()) ; panic ! (error) } } ...\n  |                                       ------------------------------------------- ^ ------------- &str\n  |                                       |\n  |                                       str\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpP7p4i2/main.rs:1:894\n  |\n1 | ...Attempt {} failed, retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }\n  |                                                       ^^^^ expected `u32`, found `i32`\n\nerror[E0277]: cannot add `i32` to `u32`\n --> /tmp/.tmpP7p4i2/main.rs:1:892\n  |\n1 | ...Attempt {} failed, retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }\n  |                                                     ^ no implementation for `u32 + i32`\n  |\n  = help: the trait `Add<i32>` is not implemented for `u32`\n  = help: the following other types implement trait `Add<Rhs>`:\n            `&u32` implements `Add<u32>`\n            `&u32` implements `Add`\n            `u32` implements `Add<&u32>`\n            `u32` implements `Add`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpP7p4i2/main.rs:1:526\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{}\" , \"❌ Failed after \" + max_attempts . to_s () + \" attempts: \" + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! (\"⚠\\u{fe0f}  Attempt {} failed, retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } }...\n  |       -                                                                                                                                                                        -     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |       |                                                                                                                                                                        |\n  |       expected this type parameter                                                                                                                                             expected `T` because of return type\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: the caller chooses a type for `T` which can be different from `()`\n  = note: `for` loops evaluate to unit type `()`\nhelp: consider returning a value here\n  |\n1 | use std :: collections :: HashMap ; fn safe_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , fallback_value : T) -> T { { try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{}\" , \"❌ Failed after \" + max_attempts . to_s () + \" attempts: \" + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! (\"⚠\\u{fe0f}  Attempt {} failed, retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } /* `T` value */ } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         +++++++++++++++\n\nerror: aborting due to 20 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0369, E0423, E0425, E0599, E0618.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_s()"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 5,
          "line_number": 471,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected In, found Comma\n// Simple password manager with encryption\nlet MASTER_KEY = null\nlet PASSWORDS_FILE = \"~/.passwords.enc\"\n\nfun encrypt(text, key) {\n    // Simple XOR encryption (use real encryption in production!)\n    let encrypted = []\n    for i, char in text.chars().enumerate() {\n        let key_char = key[i % key.len()]\n        encrypted.push(char.code() ^ key_char.code())\n    }\n    return base64_encode(encrypted)\n}\n\nfun decrypt(encrypted, key) {\n    let bytes = base64_decode(encrypted)\n    let decrypted = []\n    for i, byte in bytes.enumerate() {\n        let key_char = key[i % key.len()]\n        decrypted.push(char_from_code(byte ^ key_char.code()))\n    }\n    return decrypted.join(\"\")\n}\n\nfun add_password(site, username, password) {\n    let passwords = load_passwords()\n    passwords[site] = {\n        \"username\": username,\n        \"password\": encrypt(password, MASTER_KEY),\n        \"created\": current_datetime()\n    }\n    save_passwords(passwords)\n}\n\nfun get_password(site) {\n    let passwords = load_passwords()\n    if passwords.has_key(site) {\n        let entry = passwords[site]\n        let password = decrypt(entry.password, MASTER_KEY)\n        copy_to_clipboard(password)\n        println(\"✅ Password copied to clipboard!\")\n        \n        // Clear clipboard after 30 seconds\n        spawn_after(30000, || clear_clipboard())\n    } else {\n        println(\"❌ No password found for \" + site)\n    }\n}",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: struct literal body without path\n --> /tmp/.tmpZyH2kw/main.rs:1:1132\n  |\n1 | ...swords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_password...\n  |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\nhelp: you might have forgotten to add the struct literal inside the block\n  |\n1 | use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { SomeStruct { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , \"❌ No password found for \" + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ++++++++++++                                                                                                        +\n\nerror[E0425]: cannot find value `MASTER_KEY` in this scope\n --> /tmp/.tmpZyH2kw/main.rs:1:1588\n  |\n1 | ...e] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboa...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `null` in this scope\n --> /tmp/.tmpZyH2kw/main.rs:1:1838\n  |\n1 | ...or \" + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n  |                                                         ^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::ptr::null;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpZyH2kw/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpZyH2kw/main.rs:1:206\n  |\n1 | ... { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } ...\n  |       ^^                                                                                                                                                                                                                                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , \"❌ No password found for \" + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , \"❌ No password found for \" + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpZyH2kw/main.rs:1:290\n  |\n1 | ... enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base...\n  |                    ^^                                                                                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , \"❌ No password found for \" + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , \"❌ No password found for \" + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpZyH2kw/main.rs:1:612\n  |\n1 | ... { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , \"❌ No password found for \" + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , \"❌ No password found for \" + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpZyH2kw/main.rs:1:726\n  |\n1 | ...merate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return d...\n  |                ^^                                                                                                         ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , \"❌ No password found for \" + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , \"❌ No password found for \" + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpZyH2kw/main.rs:1:1071\n  |\n1 | ... { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } ...\n  |       ^^                                                                                                                                                                                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , \"❌ No password found for \" + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , \"❌ No password found for \" + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpZyH2kw/main.rs:1:1436\n  |\n1 | ... { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , \"❌ No password found for \" + site) } } } } } fn...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , \"❌ No password found for \" + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , \"❌ No password found for \" + site) } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpZyH2kw/main.rs:1:1508\n  |\n1 | ... { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } e...\n  |       ^^                                                                                                                                                                                                                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , \"❌ No password found for \" + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } else { { println ! (\"{}\" , \"❌ No password found for \" + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpZyH2kw/main.rs:1:1743\n  |\n1 | ... || clear_clipboard ()) } } } } else { { println ! (\"{}\" , \"❌ No password found for \" + site) } } } } } fn main () { let MASTER_KEY = n...\n  |                                           ^^                                                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , \"❌ No password found for \" + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { println ! (\"{}\" , \"❌ No password found for \" + site) } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n  |\n\nerror[E0599]: no method named `chars` found for type parameter `T` in the current scope\n --> /tmp/.tmpZyH2kw/main.rs:1:264\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars ()...\n  |       - method `chars` not found for this type parameter                                                                                                                                                                    ^^^^^ method not found in `T`\n\nerror[E0599]: no method named `len` found for type parameter `T` in the current scope\n --> /tmp/.tmpZyH2kw/main.rs:1:324\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()...\n  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                  ^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , \"❌ No password found for \" + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n  |                                                                                                                                                                                +++++++++++++++++++\n\nerror[E0608]: cannot index into a value of type `T`\n --> /tmp/.tmpZyH2kw/main.rs:1:313\n  |\n1 | ...n text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) ...\n  |                                                              ^^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function `base64_encode` in this scope\n --> /tmp/.tmpZyH2kw/main.rs:1:404\n  |\n1 | ... . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + ...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `base64_decode` in this scope\n --> /tmp/.tmpZyH2kw/main.rs:1:628\n  |\n1 | ...encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enu...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `len` found for type parameter `T` in the current scope\n --> /tmp/.tmpZyH2kw/main.rs:1:760\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()...\n  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                                                     ^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , \"❌ No password found for \" + site) } } } } } fn main () { let MASTER_KEY = null ; let PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 +++++++++++++++++++\n\nerror[E0608]: cannot index into a value of type `T`\n --> /tmp/.tmpZyH2kw/main.rs:1:749\n  |\n1 | ... , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . cod...\n  |                                                              ^^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function `char_from_code` in this scope\n --> /tmp/.tmpZyH2kw/main.rs:1:788\n  |\n1 | ...ar = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } }...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `load_passwords` in this scope\n --> /tmp/.tmpZyH2kw/main.rs:1:1091\n  |\n1 | ... : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (p...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `save_passwords` in this scope\n --> /tmp/.tmpZyH2kw/main.rs:1:1237\n  |\n1 | ...STER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = ...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `load_passwords` in this scope\n --> /tmp/.tmpZyH2kw/main.rs:1:1456\n  |\n1 | ... } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords ()...\n  |       ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- similarly named function `add_password` defined here                                                                                                                                                                                                                                                                                                                                               ^^^^^^^^^^^^^^ help: a function with a similar name exists: `add_password`\n\nerror[E0425]: cannot find function `copy_to_clipboard` in this scope\n --> /tmp/.tmpZyH2kw/main.rs:1:1602\n  |\n1 | ...d = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_afte...\n  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `clear_clipboard` in this scope\n --> /tmp/.tmpZyH2kw/main.rs:1:1708\n  |\n1 | ...d to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , \"❌ No password found for \" + site...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `spawn_after` in this scope\n --> /tmp/.tmpZyH2kw/main.rs:1:1681\n  |\n1 | ... println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , \"❌ No...\n  |                                                      ^^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `T` to `&str`\n --> /tmp/.tmpZyH2kw/main.rs:1:1790\n  |\n1 | ...clipboard ()) } } } } else { { println ! (\"{}\" , \"❌ No password found for \" + site) } } } } } fn main () { let MASTER_KEY = null ; let ...\n  |                                                     --------------------------- ^ ---- T\n  |                                                     |\n  |                                                     &str\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpZyH2kw/main.rs:1:1745\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , \"❌ No password found for \" + site) } } ...\n  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 19 previous errors; 9 warnings emitted\n\nSome errors have detailed explanations: E0308, E0369, E0425, E0599, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: chars()"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 6,
          "line_number": 530,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected In, found Comma\n// Personal finance tracker\nlet TRANSACTIONS_FILE = \"~/.budget/transactions.csv\"\nlet CATEGORIES = [\"Food\", \"Transport\", \"Bills\", \"Entertainment\", \"Other\"]\n\nfun add_transaction(amount, category, description) {\n    let transaction = {\n        \"date\": current_date(),\n        \"amount\": amount,\n        \"category\": category,\n        \"description\": description\n    }\n    \n    append_csv(TRANSACTIONS_FILE, transaction)\n    \n    // Check budget alerts\n    let monthly_spent = get_monthly_total(category)\n    let budget_limit = get_budget_limit(category)\n    \n    if monthly_spent > budget_limit {\n        send_notification(f\"⚠️ Over budget for {category}!\")\n        println(\"Warning: \" + category + \" spending at $\" + monthly_spent.to_s() + \"/$\" + budget_limit.to_s())\n    }\n}\n\nfun generate_report(month) {\n    let transactions = load_transactions(month)\n    let by_category = group_by(transactions, \"category\")\n    \n    println(\"\\n📊 Budget Report for \" + month)\n    println(\"=\"*40)\n    \n    let total = 0\n    for category, items in by_category.items() {\n        let category_total = items.map(|t| t.amount).sum()\n        total += category_total\n        \n        let bar = \"█\" * (category_total / 50).to_i()\n        println(category + \" $\" + category_total.to_s() + \" \" + bar)\n    }\n    \n    println(\"=\"*40)\n    println(\"Total:          $\" + total.to_s())\n    \n    // Save report\n    let report_file = f\"budget_report_{month}.pdf\"\n    generate_pdf(report_file, report_data)\n    println(\"\\n📄 Report saved to \" + report_file)\n}",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: struct literal body without path\n --> /tmp/.tmpQDAxvC/main.rs:1:261\n  |\n1 | ... let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TR...\n  |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\nhelp: you might have forgotten to add the struct literal inside the block\n  |\n1 | use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { SomeStruct { date : current_date () , amount : amount , category : category , description : description , } } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{}\" , \"Warning: \" + category + \" spending at $\" + monthly_spent . to_s () + \"/$\" + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , \"category\") ; println ! (\"{}\" , \"\\n📊 Budget Report for \" + month) ; println ! (\"{}\" , \"=\" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , category + \" $\" + category_total . to_s () + \" \" + bar) } } } } ; println ! (\"{}\" , \"=\" * 40i32) ; println ! (\"{}\" , \"Total:          $\" + total . to_s ()) ; let report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{}\" , \"\\n📄 Report saved to \" + report_file) } } } } fn main () { let TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" ; let CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n  |                                                                                                                                                                                                                                                                     ++++++++++++                                                                                                  +\n\nerror[E0425]: cannot find value `TRANSACTIONS_FILE` in this scope\n --> /tmp/.tmpQDAxvC/main.rs:1:374\n  |\n1 | ...description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; le...\n  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `report_data` in this scope\n --> /tmp/.tmpQDAxvC/main.rs:1:1638\n  |\n1 | ...t_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{}\" , \"\\n📄 Report saved to \" + report_file) } } } } fn main...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpQDAxvC/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std ::...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpQDAxvC/main.rs:1:239\n  |\n1 | ... { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{}\" , \"Warning: \" + category + \" spending at $\" + monthly_spent . to_s () + \"/$\" + budget_limit . to_s ()) } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{}\" , \"Warning: \" + category + \" spending at $\" + monthly_spent . to_s () + \"/$\" + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , \"category\") ; println ! (\"{}\" , \"\\n📊 Budget Report for \" + month) ; println ! (\"{}\" , \"=\" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , category + \" $\" + category_total . to_s () + \" \" + bar) } } } } ; println ! (\"{}\" , \"=\" * 40i32) ; println ! (\"{}\" , \"Total:          $\" + total . to_s ()) ; let report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{}\" , \"\\n📄 Report saved to \" + report_file) } } } } fn main () { let TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" ; let CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n1 + use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{}\" , \"Warning: \" + category + \" spending at $\" + monthly_spent . to_s () + \"/$\" + budget_limit . to_s ()) } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , \"category\") ; println ! (\"{}\" , \"\\n📊 Budget Report for \" + month) ; println ! (\"{}\" , \"=\" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , category + \" $\" + category_total . to_s () + \" \" + bar) } } } } ; println ! (\"{}\" , \"=\" * 40i32) ; println ! (\"{}\" , \"Total:          $\" + total . to_s ()) ; let report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{}\" , \"\\n📄 Report saved to \" + report_file) } } } } fn main () { let TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" ; let CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpQDAxvC/main.rs:1:920\n  |\n1 | ... { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , \"category\") ; println ! (\"{}\" , \"\\n📊 Budget Report for \" + month) ; println ! (\"{}\" , \"=\" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , category + \" $\" + category_total . to_s () + \" \" + bar) } } } } ; println ! (\"{}\" , \"=\" * 40i32) ; println ! (\"{}\" , \"Total:          $\" + total . to_s ()) ; let report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{}\" , \"\\n📄 Report saved to \" + report_file) } } } } fn...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{}\" , \"Warning: \" + category + \" spending at $\" + monthly_spent . to_s () + \"/$\" + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , \"category\") ; println ! (\"{}\" , \"\\n📊 Budget Report for \" + month) ; println ! (\"{}\" , \"=\" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , category + \" $\" + category_total . to_s () + \" \" + bar) } } } } ; println ! (\"{}\" , \"=\" * 40i32) ; println ! (\"{}\" , \"Total:          $\" + total . to_s ()) ; let report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{}\" , \"\\n📄 Report saved to \" + report_file) } } } } fn main () { let TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" ; let CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n1 + use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{}\" , \"Warning: \" + category + \" spending at $\" + monthly_spent . to_s () + \"/$\" + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , \"category\") ; println ! (\"{}\" , \"\\n📊 Budget Report for \" + month) ; println ! (\"{}\" , \"=\" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , category + \" $\" + category_total . to_s () + \" \" + bar) } } } } ; println ! (\"{}\" , \"=\" * 40i32) ; println ! (\"{}\" , \"Total:          $\" + total . to_s ()) ; let report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{}\" , \"\\n📄 Report saved to \" + report_file) } } } fn main () { let TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" ; let CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpQDAxvC/main.rs:1:1187\n  |\n1 | ... { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , category + \" $\" + category_total . to_s () + \" \" + bar) } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{}\" , \"Warning: \" + category + \" spending at $\" + monthly_spent . to_s () + \"/$\" + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , \"category\") ; println ! (\"{}\" , \"\\n📊 Budget Report for \" + month) ; println ! (\"{}\" , \"=\" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , category + \" $\" + category_total . to_s () + \" \" + bar) } } } } ; println ! (\"{}\" , \"=\" * 40i32) ; println ! (\"{}\" , \"Total:          $\" + total . to_s ()) ; let report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{}\" , \"\\n📄 Report saved to \" + report_file) } } } } fn main () { let TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" ; let CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n1 + use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{}\" , \"Warning: \" + category + \" spending at $\" + monthly_spent . to_s () + \"/$\" + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , \"category\") ; println ! (\"{}\" , \"\\n📊 Budget Report for \" + month) ; println ! (\"{}\" , \"=\" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . items () { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , category + \" $\" + category_total . to_s () + \" \" + bar) } } } ; println ! (\"{}\" , \"=\" * 40i32) ; println ! (\"{}\" , \"Total:          $\" + total . to_s ()) ; let report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{}\" , \"\\n📄 Report saved to \" + report_file) } } } } fn main () { let TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" ; let CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n  |\n\nerror[E0425]: cannot find function `append_csv` in this scope\n --> /tmp/.tmpQDAxvC/main.rs:1:362\n  |\n1 | ...ry : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `get_monthly_total` in this scope\n --> /tmp/.tmpQDAxvC/main.rs:1:429\n  |\n1 | ...ONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if month...\n  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `get_budget_limit` in this scope\n --> /tmp/.tmpQDAxvC/main.rs:1:479\n  |\n1 | ..._monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (fo...\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `send_notification` in this scope\n --> /tmp/.tmpQDAxvC/main.rs:1:545\n  |\n1 | ...tegory) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"...\n  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `T` to `&str`\n --> /tmp/.tmpQDAxvC/main.rs:1:651\n  |\n1 | ... Over budget for {}!\" , category)) ; println ! (\"{}\" , \"Warning: \" + category + \" spending at $\" + monthly_spent . to_s () + \"/$\" + bu...\n  |                                                           ----------- ^ -------- T\n  |                                                           |\n  |                                                           &str\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpQDAxvC/main.rs:1:664\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{}\" , \"Warning: \" + category + \" spending at $\" + ...\n  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^^^^^^^^^^^^^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpQDAxvC/main.rs:1:709\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{}\" , \"Warning: \" + category + \" spending at $\" + monthly_spent . to_s () + \"/$\" + ...\n  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpQDAxvC/main.rs:1:621\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{}\" , \"Warning: \" + category + \" spending at $\" + monthly_spent . to_s () + \"/$\" + budget_limit . to_s ()) } ...\n  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `load_transactions` in this scope\n --> /tmp/.tmpQDAxvC/main.rs:1:943\n  |\n1 | ... ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{}\" , \"Warning: \" + category + \" spending at $\" + monthly_spent . to_s () + \"/$\" + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (m...\n  |       ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- similarly named function `add_transaction` defined here                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^^^^^^^^^^^^^^^^^ help: a function with a similar name exists: `add_transaction`\n\nerror[E0425]: cannot find function `group_by` in this scope\n --> /tmp/.tmpQDAxvC/main.rs:1:991\n  |\n1 | ... = load_transactions (month) ; { let by_category = group_by (transactions , \"category\") ; println ! (\"{}\" , \"\\n📊 Budget Report for \" + ...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `T` to `&str`\n --> /tmp/.tmpQDAxvC/main.rs:1:1073\n  |\n1 | ...y (transactions , \"category\") ; println ! (\"{}\" , \"\\n📊 Budget Report for \" + month) ; println ! (\"{}\" , \"=\" * 40i32) ; let total = 0i32...\n  |                                                      ------------------------- ^ ----- T\n  |                                                      |\n  |                                                      &str\n\nerror[E0369]: cannot multiply `&str` by `i32`\n --> /tmp/.tmpQDAxvC/main.rs:1:1106\n  |\n1 | ...}\" , \"\\n📊 Budget Report for \" + month) ; println ! (\"{}\" , \"=\" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . it...\n  |                                                                --- ^ ----- i32\n  |                                                                |\n  |                                                                &str\n\nerror[E0599]: no method named `to_i` found for type `i32` in the current scope\n --> /tmp/.tmpQDAxvC/main.rs:1:1362\n  |\n1 | ...ry_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , category + \" $\" + category_total . to_s () + \" \" + bar...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpQDAxvC/main.rs:1:1325\n  |\n1 | ... . sum () ; { total += category_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , category + \" $\" + categor...\n  |                                                ^^^ doesn't have a size known at compile-time\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: all local variables must have a statically known size\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpQDAxvC/main.rs:1:1435\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , \"category\") ; println ! (\"{}\" , \"\\n📊 Budget Report for \" + month) ; println ! (\"{}\" , \"=\" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , category + \" $\" + category_total . to_s () + \" \" + b...\n  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpQDAxvC/main.rs:1:1441\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , \"category\") ; println ! (\"{}\" , \"\\n📊 Budget Report for \" + month) ; println ! (\"{}\" , \"=\" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , category + \" $\" + category_total . to_s () + \" \" + bar) } ...\n  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^^^ expected type parameter `T`, found `str`\n  |\n  = note: expected type parameter `T`\n                       found type `str`\n\nerror[E0369]: cannot multiply `&str` by `i32`\n --> /tmp/.tmpQDAxvC/main.rs:1:1478\n  |\n1 | ...y_total . to_s () + \" \" + bar) } } } } ; println ! (\"{}\" , \"=\" * 40i32) ; println ! (\"{}\" , \"Total:          $\" + total . to_s ()) ; l...\n  |                                                               --- ^ ----- i32\n  |                                                               |\n  |                                                               &str\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpQDAxvC/main.rs:1:1537\n  |\n1 | ...) ; println ! (\"{}\" , \"Total:          $\" + total . to_s ()) ; let report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpQDAxvC/main.rs:1:1507\n  |\n1 | ... * 40i32) ; println ! (\"{}\" , \"Total:          $\" + total . to_s ()) ; let report_file = format ! (\"budget_report_{}.pdf\" , month) ; g...\n  |                            --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                            |\n  |                            required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `generate_pdf` in this scope\n --> /tmp/.tmpQDAxvC/main.rs:1:1610\n  |\n1 | ...le = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{}\" , \"\\n📄 Report saved to \" + ...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `String` to `&str`\n --> /tmp/.tmpQDAxvC/main.rs:1:1694\n  |\n1 | ...ata) ; println ! (\"{}\" , \"\\n📄 Report saved to \" + report_file) } } } } fn main () { let TRANSACTIONS_FILE = \"~/.budget/transactions.csv...\n  |                             ----------------------- ^ ----------- String\n  |                             |                       |\n  |                             |                       `+` cannot be used to concatenate a `&str` with a `String`\n  |                             &str\n  |\nhelp: create an owned `String` on the left and add a borrow on the right\n  |\n1 | use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; let budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{}\" , \"Warning: \" + category + \" spending at $\" + monthly_spent . to_s () + \"/$\" + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , \"category\") ; println ! (\"{}\" , \"\\n📊 Budget Report for \" + month) ; println ! (\"{}\" , \"=\" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , category + \" $\" + category_total . to_s () + \" \" + bar) } } } } ; println ! (\"{}\" , \"=\" * 40i32) ; println ! (\"{}\" , \"Total:          $\" + total . to_s ()) ; let report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{}\" , \"\\n📄 Report saved to \".to_owned() + &report_file) } } } } fn main () { let TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" ; let CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               +++++++++++   +\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpQDAxvC/main.rs:1:1653\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , \"category\") ; println ! (\"{}\" , \"\\n📊 Budget Report for \" + month) ; println ! (\"{}\" , \"=\" * 40i32) ; let total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , category + \" $\" + category_total . to_s () + \" \" + bar) } } } } ; println ! (\"{}\" , \"=\" * 40i32) ; println ! (\"{}\" , \"Total:          $\" + total . to_s ()) ; let report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{}\" , \"\\n📄 Report saved to \" + report_file) } } ...\n  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: unused variable: `TRANSACTIONS_FILE`\n --> /tmp/.tmpQDAxvC/main.rs:1:1734\n  |\n1 | ... fn main () { let TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" ; let CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Enterta...\n  |                      ^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_TRANSACTIONS_FILE`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `CATEGORIES`\n --> /tmp/.tmpQDAxvC/main.rs:1:1789\n  |\n1 | .../transactions.csv\" ; let CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n  |                             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_CATEGORIES`\n\nerror: aborting due to 25 previous errors; 6 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0369, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_i()"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 7,
          "line_number": 589,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected RightParen, found Identifier(\"commit\")\n// Development project scaffolding tool\nlet TEMPLATES = {\n    \"python\": {\n        \"files\": [\"main.py\", \"requirements.txt\", \"README.md\", \".gitignore\"],\n        \"folders\": [\"src\", \"tests\", \"docs\"]\n    },\n    \"javascript\": {\n        \"files\": [\"index.js\", \"package.json\", \"README.md\", \".gitignore\"],\n        \"folders\": [\"src\", \"test\", \"public\"]\n    },\n    \"ruchy\": {\n        \"files\": [\"main.ruchy\", \"Cargo.toml\", \"README.md\", \".gitignore\"],\n        \"folders\": [\"src\", \"tests\", \"docs\"]\n    }\n}\n\nfun create_project(name, language) {\n    let project_dir = name\n    \n    if dir_exists(project_dir) {\n        println(f\"❌ Directory {project_dir} already exists\")\n        return\n    }\n    \n    create_dir(project_dir)\n    println(\"📁 Created project: \" + name)\n    \n    let template = TEMPLATES[language]\n    \n    // Create folder structure\n    for folder in template.folders {\n        create_dir(join_path(project_dir, folder))\n        println(f\"  📂 {folder}/\")\n    }\n    \n    // Create files from templates\n    for file in template.files {\n        let template_content = get_template_content(language, file)\n        let content = template_content\n            .replace(\"{{PROJECT_NAME}}\", name)\n            .replace(\"{{DATE}}\", current_date())\n            .replace(\"{{AUTHOR}}\", get_git_user())\n        \n        write_file(join_path(project_dir, file), content)\n        println(\"  📄 \" + file)\n    }\n    \n    // Initialize git\n    run_command(\"git init\", project_dir)\n    run_command(\"git add .\", project_dir)\n    run_command('git commit -m \"Initial commit\"', project_dir)\n    \n    println(f\"\\n✅ Project {name} created successfully!\")\n    println(f\"Next steps:\")\n    println(\"  cd \" + project_dir)\n    println(\"  \" + get_run_command(language))\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 8,
          "line_number": 659,
          "code": "// Status: ✅ WORKING\n\n// test_app.ruchy - Application test suite\n\nfun test_user_creation() {\n    let user = create_user(\"Alice\", \"alice@example.com\")\n    \n    assert(user.name == \"Alice\", \"Name should be set\")\n    assert(user.email == \"alice@example.com\", \"Email should be set\")\n    assert(user.id != null, \"ID should be generated\")\n    \n    println(\"✅ test_user_creation passed\")\n}\n\nfun test_data_persistence() {\n    let test_data = {\"test\": \"value\"}\n    let test_file = \"test_data.json\"\n    \n    // Save data\n    save_json(test_file, test_data)\n    assert(file_exists(test_file), \"File should be created\")\n    \n    // Load data\n    let loaded = load_json(test_file)\n    assert(loaded.test == \"value\", \"Data should persist\")\n    \n    // Cleanup\n    remove_file(test_file)\n    \n    println(\"✅ test_data_persistence passed\")\n}\n\nfun run_all_tests() {\n    println(\"🧪 Running application tests...\")\n    \n    test_user_creation()\n    test_data_persistence()\n    test_error_handling()\n    test_performance()\n    \n    println(\"\\n✅ All tests passed!\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: struct literal body without path\n --> /tmp/.tmpQ9Cbkb/main.rs:1:411\n  |\n1 | ... } } } fn test_data_persistence () { { { let test_data = { test : \"value\" , } ; { let test_file = \"test_data.json\" ; save_json (test_f...\n  |                                                             ^^^^^^^^^^^^^^^^^^^^\n  |\nhelp: you might have forgotten to add the struct literal inside the block\n  |\n1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" , \"alice@example.com\") ; { assert (user . name == \"Alice\" , \"Name should be set\") ; assert (user . email == \"alice@example.com\" , \"Email should be set\") ; assert (user . id != null , \"ID should be generated\") ; println ! (\"✅ test_user_creation passed\") } } } } fn test_data_persistence () { { { let test_data = { SomeStruct { test : \"value\" , } } ; { let test_file = \"test_data.json\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should be created\") ; let loaded = load_json (test_file) ; assert (loaded . test == \"value\" , \"Data should persist\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\") } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                            ++++++++++++                      +\n\nerror[E0425]: cannot find value `null` in this scope\n --> /tmp/.tmpQ9Cbkb/main.rs:1:276\n  |\n1 | ...com\" , \"Email should be set\") ; assert (user . id != null , \"ID should be generated\") ; println ! (\"✅ test_user_creation passed\") } } }...\n  |                                                         ^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::ptr::null;\n  |\n\nerror[E0425]: cannot find function `remove_file` in this scope\n --> /tmp/.tmpQ9Cbkb/main.rs:1:666\n  |\n1 | ...ded . test == \"value\" , \"Data should persist\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } } fn run_...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::remove_file;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpQ9Cbkb/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" , \"alice@example.com\") ; { assert (use...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpQ9Cbkb/main.rs:1:64\n  |\n1 | ... { { { let user = create_user (\"Alice\" , \"alice@example.com\") ; { assert (user . name == \"Alice\" , \"Name should be set\") ; assert (user . email == \"alice@example.com\" , \"Email should be set\") ; assert (user . id != null , \"ID should be generated\") ; println ! (\"✅ test_user_creation passed\") } } } } f...\n  |       ^^                                                                                                                                                                                                                                                                                                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" , \"alice@example.com\") ; { assert (user . name == \"Alice\" , \"Name should be set\") ; assert (user . email == \"alice@example.com\" , \"Email should be set\") ; assert (user . id != null , \"ID should be generated\") ; println ! (\"✅ test_user_creation passed\") } } } } fn test_data_persistence () { { { let test_data = { test : \"value\" , } ; { let test_file = \"test_data.json\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should be created\") ; let loaded = load_json (test_file) ; assert (loaded . test == \"value\" , \"Data should persist\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\") } } fn main () { }\n1 + use std :: collections :: HashMap ; fn test_user_creation () { { let user = create_user (\"Alice\" , \"alice@example.com\") ; { assert (user . name == \"Alice\" , \"Name should be set\") ; assert (user . email == \"alice@example.com\" , \"Email should be set\") ; assert (user . id != null , \"ID should be generated\") ; println ! (\"✅ test_user_creation passed\") } } } fn test_data_persistence () { { { let test_data = { test : \"value\" , } ; { let test_file = \"test_data.json\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should be created\") ; let loaded = load_json (test_file) ; assert (loaded . test == \"value\" , \"Data should persist\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\") } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpQ9Cbkb/main.rs:1:391\n  |\n1 | ... { { { let test_data = { test : \"value\" , } ; { let test_file = \"test_data.json\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should be created\") ; let loaded = load_json (test_file) ; assert (loaded . test == \"value\" , \"Data should persist\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } } f...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                            ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" , \"alice@example.com\") ; { assert (user . name == \"Alice\" , \"Name should be set\") ; assert (user . email == \"alice@example.com\" , \"Email should be set\") ; assert (user . id != null , \"ID should be generated\") ; println ! (\"✅ test_user_creation passed\") } } } } fn test_data_persistence () { { { let test_data = { test : \"value\" , } ; { let test_file = \"test_data.json\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should be created\") ; let loaded = load_json (test_file) ; assert (loaded . test == \"value\" , \"Data should persist\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\") } } fn main () { }\n1 + use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" , \"alice@example.com\") ; { assert (user . name == \"Alice\" , \"Name should be set\") ; assert (user . email == \"alice@example.com\" , \"Email should be set\") ; assert (user . id != null , \"ID should be generated\") ; println ! (\"✅ test_user_creation passed\") } } } } fn test_data_persistence () { { let test_data = { test : \"value\" , } ; { let test_file = \"test_data.json\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should be created\") ; let loaded = load_json (test_file) ; assert (loaded . test == \"value\" , \"Data should persist\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\") } } fn main () { }\n  |\n\nerror[E0425]: cannot find function `create_user` in this scope\n --> /tmp/.tmpQ9Cbkb/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" , \"alice@example.com\") ; { assert (use...\n  |                                                                               ^^^^^^^^^^^ not found in this scope\n\nerror[E0423]: expected function, found macro `assert`\n --> /tmp/.tmpQ9Cbkb/main.rs:1:127\n  |\n1 | ... user = create_user (\"Alice\" , \"alice@example.com\") ; { assert (user . name == \"Alice\" , \"Name should be set\") ; assert (user . email ...\n  |                                                            ^^^^^^ not a function\n  |\nhelp: use `!` to invoke the macro\n  |\n1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" , \"alice@example.com\") ; { assert! (user . name == \"Alice\" , \"Name should be set\") ; assert (user . email == \"alice@example.com\" , \"Email should be set\") ; assert (user . id != null , \"ID should be generated\") ; println ! (\"✅ test_user_creation passed\") } } } } fn test_data_persistence () { { { let test_data = { test : \"value\" , } ; { let test_file = \"test_data.json\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should be created\") ; let loaded = load_json (test_file) ; assert (loaded . test == \"value\" , \"Data should persist\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\") } } fn main () { }\n  |                                                                                                                                     +\n\nerror[E0423]: expected function, found macro `assert`\n --> /tmp/.tmpQ9Cbkb/main.rs:1:184\n  |\n1 | ...ssert (user . name == \"Alice\" , \"Name should be set\") ; assert (user . email == \"alice@example.com\" , \"Email should be set\") ; assert ...\n  |                                                            ^^^^^^ not a function\n  |\nhelp: use `!` to invoke the macro\n  |\n1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" , \"alice@example.com\") ; { assert (user . name == \"Alice\" , \"Name should be set\") ; assert! (user . email == \"alice@example.com\" , \"Email should be set\") ; assert (user . id != null , \"ID should be generated\") ; println ! (\"✅ test_user_creation passed\") } } } } fn test_data_persistence () { { { let test_data = { test : \"value\" , } ; { let test_file = \"test_data.json\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should be created\") ; let loaded = load_json (test_file) ; assert (loaded . test == \"value\" , \"Data should persist\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\") } } fn main () { }\n  |                                                                                                                                                                                              +\n\nerror[E0423]: expected function, found macro `assert`\n --> /tmp/.tmpQ9Cbkb/main.rs:1:255\n  |\n1 | ...email == \"alice@example.com\" , \"Email should be set\") ; assert (user . id != null , \"ID should be generated\") ; println ! (\"✅ test_user...\n  |                                                            ^^^^^^ not a function\n  |\nhelp: use `!` to invoke the macro\n  |\n1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" , \"alice@example.com\") ; { assert (user . name == \"Alice\" , \"Name should be set\") ; assert (user . email == \"alice@example.com\" , \"Email should be set\") ; assert! (user . id != null , \"ID should be generated\") ; println ! (\"✅ test_user_creation passed\") } } } } fn test_data_persistence () { { { let test_data = { test : \"value\" , } ; { let test_file = \"test_data.json\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should be created\") ; let loaded = load_json (test_file) ; assert (loaded . test == \"value\" , \"Data should persist\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\") } } fn main () { }\n  |                                                                                                                                                                                                                                                                     +\n\nerror[E0425]: cannot find function `save_json` in this scope\n --> /tmp/.tmpQ9Cbkb/main.rs:1:471\n  |\n1 | ...value\" , } ; { let test_file = \"test_data.json\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should b...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpQ9Cbkb/main.rs:1:515\n  |\n1 | ...n\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should be created\") ; let loaded = load_json (test_fi...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0423]: expected function, found macro `assert`\n --> /tmp/.tmpQ9Cbkb/main.rs:1:507\n  |\n1 | ... \"test_data.json\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should be created\") ; let loaded = loa...\n  |                                                            ^^^^^^ not a function\n  |\nhelp: use `!` to invoke the macro\n  |\n1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" , \"alice@example.com\") ; { assert (user . name == \"Alice\" , \"Name should be set\") ; assert (user . email == \"alice@example.com\" , \"Email should be set\") ; assert (user . id != null , \"ID should be generated\") ; println ! (\"✅ test_user_creation passed\") } } } } fn test_data_persistence () { { { let test_data = { test : \"value\" , } ; { let test_file = \"test_data.json\" ; save_json (test_file , test_data) ; assert! (file_exists (test_file) , \"File should be created\") ; let loaded = load_json (test_file) ; assert (loaded . test == \"value\" , \"Data should persist\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\") } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  +\n\nerror[E0425]: cannot find function `load_json` in this scope\n --> /tmp/.tmpQ9Cbkb/main.rs:1:582\n  |\n1 | ..._file) , \"File should be created\") ; let loaded = load_json (test_file) ; assert (loaded . test == \"value\" , \"Data should persist\") ; ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0423]: expected function, found macro `assert`\n --> /tmp/.tmpQ9Cbkb/main.rs:1:606\n  |\n1 | ...uld be created\") ; let loaded = load_json (test_file) ; assert (loaded . test == \"value\" , \"Data should persist\") ; remove_file (test_...\n  |                                                            ^^^^^^ not a function\n  |\nhelp: use `!` to invoke the macro\n  |\n1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" , \"alice@example.com\") ; { assert (user . name == \"Alice\" , \"Name should be set\") ; assert (user . email == \"alice@example.com\" , \"Email should be set\") ; assert (user . id != null , \"ID should be generated\") ; println ! (\"✅ test_user_creation passed\") } } } } fn test_data_persistence () { { { let test_data = { test : \"value\" , } ; { let test_file = \"test_data.json\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should be created\") ; let loaded = load_json (test_file) ; assert! (loaded . test == \"value\" , \"Data should persist\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\") } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     +\n\nerror[E0425]: cannot find function `test_error_handling` in this scope\n --> /tmp/.tmpQ9Cbkb/main.rs:1:867\n  |\n1 | ...ser_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\") } } fn ...\n  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `test_performance` in this scope\n --> /tmp/.tmpQ9Cbkb/main.rs:1:892\n  |\n1 | ...data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\") } } fn main () { }\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 14 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0423, E0425.\nFor more information about an error, try `rustc --explain E0423`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 9,
          "line_number": 713,
          "code": "// Status: ✅ WORKING\n\n// build.ruchy - Build and package script\n\nfun build_release() {\n    println(\"🔨 Building release version...\")\n    \n    // Run tests first\n    run_tests()\n    \n    // Create release directory\n    let release_dir = \"release_\" + VERSION\n    create_dir_all(release_dir)\n    \n    // Copy application files\n    copy_file(\"main.ruchy\", join_path(release_dir, APP_NAME))\n    copy_dir(\"resources\", join_path(release_dir, \"resources\"))\n    \n    // Generate documentation\n    generate_docs(join_path(release_dir, \"docs\"))\n    \n    // Create installer script\n    let installer = f\"#!/bin/bash\necho 'Installing {APP_NAME} v{VERSION}'\nmkdir -p ~/.local/bin\ncp {APP_NAME} ~/.local/bin/\nchmod +x ~/.local/bin/{APP_NAME}\necho 'Installation complete! Run {APP_NAME} to start.'\n\"\n    write_file(join_path(release_dir, \"install.sh\"), installer)\n    \n    // Package as archive\n    create_archive(f\"{APP_NAME}-{VERSION}.tar.gz\", release_dir)\n    \n    println(f\"✅ Release built: {APP_NAME}-{VERSION}.tar.gz\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `VERSION` in this scope\n --> /tmp/.tmp8O452A/main.rs:1:155\n  |\n1 | ... ; run_tests () ; { let release_dir = \"release_\" + VERSION ; { create_dir_all (release_dir) ; copy_file (\"main.ruchy\" , join_path (rel...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `create_dir_all` in this scope\n --> /tmp/.tmp8O452A/main.rs:1:167\n  |\n1 | ... ; { let release_dir = \"release_\" + VERSION ; { create_dir_all (release_dir) ; copy_file (\"main.ruchy\" , join_path (release_dir , APP_...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::create_dir_all;\n  |\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmp8O452A/main.rs:1:249\n  |\n1 | ...copy_file (\"main.ruchy\" , join_path (release_dir , APP_NAME)) ; copy_dir (\"resources\" , join_path (release_dir , \"resources\")) ; gener...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmp8O452A/main.rs:1:566\n  |\n1 | ...cho 'Installation complete! Run {} to start.'\\n\" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (relea...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `VERSION` in this scope\n --> /tmp/.tmp8O452A/main.rs:1:577\n  |\n1 | ...lation complete! Run {} to start.'\\n\" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , \"i...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmp8O452A/main.rs:1:587\n  |\n1 | ...plete! Run {} to start.'\\n\" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , \"install.sh\"...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmp8O452A/main.rs:1:598\n  |\n1 | ...{} to start.'\\n\" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , \"install.sh\") , install...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmp8O452A/main.rs:1:609\n  |\n1 | ....'\\n\" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , \"install.sh\") , installer) ; creat...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmp8O452A/main.rs:1:730\n  |\n1 | ...ller) ; create_archive (format ! (\"{}-{}.tar.gz\" , APP_NAME , VERSION) , release_dir) ; println ! (\"✅ Release built: {}-{}.tar.gz\" , AP...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `VERSION` in this scope\n --> /tmp/.tmp8O452A/main.rs:1:741\n  |\n1 | ...ate_archive (format ! (\"{}-{}.tar.gz\" , APP_NAME , VERSION) , release_dir) ; println ! (\"✅ Release built: {}-{}.tar.gz\" , APP_NAME , VE...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmp8O452A/main.rs:1:812\n  |\n1 | ...ir) ; println ! (\"✅ Release built: {}-{}.tar.gz\" , APP_NAME , VERSION) } } } } fn main () { }\n  |                                                        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `VERSION` in this scope\n --> /tmp/.tmp8O452A/main.rs:1:823\n  |\n1 | ...ln ! (\"✅ Release built: {}-{}.tar.gz\" , APP_NAME , VERSION) } } } } fn main () { }\n  |                                                        ^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp8O452A/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn build_release () { { println ! (\"🔨 Building release version...\") ; run_tests () ; { let release_dir...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `run_tests` in this scope\n --> /tmp/.tmp8O452A/main.rs:1:107\n  |\n1 | ...{ { println ! (\"🔨 Building release version...\") ; run_tests () ; { let release_dir = \"release_\" + VERSION ; { create_dir_all (release_d...\n  |                                                       ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmp8O452A/main.rs:1:224\n  |\n1 | ...dir_all (release_dir) ; copy_file (\"main.ruchy\" , join_path (release_dir , APP_NAME)) ; copy_dir (\"resources\" , join_path (release_dir...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `copy_file` in this scope\n --> /tmp/.tmp8O452A/main.rs:1:198\n  |\n1 | ...se_\" + VERSION ; { create_dir_all (release_dir) ; copy_file (\"main.ruchy\" , join_path (release_dir , APP_NAME)) ; copy_dir (\"resources...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmp8O452A/main.rs:1:286\n  |\n1 | ...elease_dir , APP_NAME)) ; copy_dir (\"resources\" , join_path (release_dir , \"resources\")) ; generate_docs (join_path (release_dir , \"do...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `copy_dir` in this scope\n --> /tmp/.tmp8O452A/main.rs:1:262\n  |\n1 | ...ain.ruchy\" , join_path (release_dir , APP_NAME)) ; copy_dir (\"resources\" , join_path (release_dir , \"resources\")) ; generate_docs (joi...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmp8O452A/main.rs:1:342\n  |\n1 | ...ath (release_dir , \"resources\")) ; generate_docs (join_path (release_dir , \"docs\")) ; let installer = format ! (\"#!/bin/bash\\necho 'In...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `generate_docs` in this scope\n --> /tmp/.tmp8O452A/main.rs:1:327\n  |\n1 | ...ces\" , join_path (release_dir , \"resources\")) ; generate_docs (join_path (release_dir , \"docs\")) ; let installer = format ! (\"#!/bin/b...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmp8O452A/main.rs:1:128\n  |\n1 | ...ase version...\") ; run_tests () ; { let release_dir = \"release_\" + VERSION ; { create_dir_all (release_dir) ; copy_file (\"main.ruchy\" ...\n  |                                            ^^^^^^^^^^^ doesn't have a size known at compile-time\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: all local variables must have a statically known size\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmp8O452A/main.rs:1:633\n  |\n1 | ...N , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , \"install.sh\") , installer) ; create_archive (format ! (\"{}-...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmp8O452A/main.rs:1:621\n  |\n1 | ...AME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , \"install.sh\") , installer) ; create_archive (fo...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `create_archive` in this scope\n --> /tmp/.tmp8O452A/main.rs:1:687\n  |\n1 | ...ath (release_dir , \"install.sh\") , installer) ; create_archive (format ! (\"{}-{}.tar.gz\" , APP_NAME , VERSION) , release_dir) ; printl...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 23 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch15-00-macros-metaprogramming": {
      "chapter": "ch15-00-macros-metaprogramming",
      "total_examples": 9,
      "working_examples": 0,
      "failing_examples": 9,
      "examples": [
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected '(' or '[' after macro name\n// Define a macro for JSON-like syntax\nmacro! json {\n    // Match JSON-like input\n    ({ $($key:ident : $value:expr),* }) => {\n        {\n            let mut map = HashMap::new()\n            $(\n                map.insert(stringify!($key), json!($value))\n            )*\n            Value::Object(map)\n        }\n    }\n    ([ $($element:expr),* ]) => {\n        Value::Array(vec![$(json!($element)),*])\n    }\n    ($other:expr) => {\n        Value::from($other)\n    }\n}\n\n// Use it like native syntax!\nlet user = json!({\n    name: \"Alice\",\n    age: 30,\n    emails: [\"alice@example.com\", \"alice@work.com\"],\n    active: true,\n    metadata: {\n        created: \"2024-01-01\",\n        tags: [\"premium\", \"verified\"]\n    }\n})\n\n// Macro for automatic implementation\n#[derive(Debug, Clone, Serialize)]\nstruct User {\n    name: String\n    email: String\n    age: i32\n}\n\n// The derive macro generates all the boilerplate!",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 2,
          "line_number": 88,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected '(' or '[' after macro name\n// Simple macro\nmacro! say_hello {\n    () => {\n        println(\"Hello, World!\")\n    }\n    ($name:expr) => {\n        println(f\"Hello, {$name}!\")\n    }\n}\n\nsay_hello!()           // Prints: Hello, World!\nsay_hello!(\"Alice\")    // Prints: Hello, Alice!\n\n// Macro with repetition\nmacro! vec_of_strings {\n    ($($x:expr),*) => {\n        vec![$(String::from($x)),*]\n    }\n}\n\nlet strings = vec_of_strings![\"one\", \"two\", \"three\"]\n\n// Recursive macro\nmacro! count {\n    () => { 0 }\n    ($head:expr) => { 1 }\n    ($head:expr, $($tail:expr),*) => {\n        1 + count!($($tail),*)\n    }\n}\n\nlet n = count!(a, b, c, d)  // 4\n\n// Macro generating match arms\nmacro! handle_codes {\n    ($($code:expr => $message:expr),*) => {\n        match status_code {\n            $($code => println($message)),*\n            _ => println(\"Unknown status\")\n        }\n    }\n}\n\nhandle_codes! {\n    200 => \"OK\",\n    404 => \"Not Found\",\n    500 => \"Internal Error\"\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 3,
          "line_number": 149,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected '(' or '[' after macro name\n// Derive macro for automatic implementation\n#[proc_macro_derive(Builder)]\nfun derive_builder(input: TokenStream) -> TokenStream {\n    let ast = parse(input)\n    let name = ast.name\n    let builder_name = f\"{name}Builder\"\n    \n    let fields = ast.fields.map(|f| {\n        let name = f.name\n        let ty = f.ty\n        quote! {\n            fn $name(mut self, value: $ty) -> Self {\n                self.$name = Some(value)\n                self\n            }\n        }\n    })\n    \n    quote! {\n        struct $builder_name {\n            $($fields.name: Option<$fields.ty>),*\n        }\n        \n        impl $builder_name {\n            fun new() -> Self {\n                Self {\n                    $($fields.name: None),*\n                }\n            }\n            \n            $fields\n            \n            fun build(self) -> Result<$name, String> {\n                Ok($name {\n                    $($fields.name: self.$fields.name\n                        .ok_or(\"Missing field: \" + stringify!($fields.name))?,)*\n                })\n            }\n        }\n        \n        impl $name {\n            fun builder() -> $builder_name {\n                $builder_name::new()\n            }\n        }\n    }\n}\n\n// Use the derive macro\n#[derive(Builder)]\nstruct Config {\n    host: String\n    port: u16\n    workers: usize\n}\n\n// Generated builder pattern!\nlet config = Config::builder()\n    .host(\"localhost\")\n    .port(8080)\n    .workers(4)\n    .build()?",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 4,
          "line_number": 224,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected '(' or '[' after macro name\n// Attribute macro for benchmarking\n#[proc_macro_attribute]\nfun bench(args: TokenStream, input: TokenStream) -> TokenStream {\n    let func = parse(input)\n    let name = func.name\n    \n    quote! {\n        fn $name() {\n            let start = Instant::now()\n            let result = { $func.body }\n            let duration = start.elapsed()\n            println(stringify!($name) + \" took \" + duration.to_s())\n            result\n        }\n    }\n}\n\n#[bench]\nfun expensive_operation() {\n    // Function body\n    heavy_computation()\n}\n// Automatically prints timing!\n\n// Route attribute for web framework\n#[route(GET, \"/users/:id\")]\nasync fun get_user(id: i32) -> Response {\n    let user = fetch_user(id).await?\n    Response::json(user)\n}\n\n// Test attribute with custom behavior\n#[test_case(1, 2, 3)]\n#[test_case(10, 20, 30)]\n#[test_case(-1, -2, -3)]\nfun test_addition(a: i32, b: i32, expected: i32) {\n    assert_eq!(a + b, expected)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 5,
          "line_number": 275,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected '(' or '[' after macro name\n// SQL-like macro\nmacro! sql {\n    (SELECT $($field:ident),* FROM $table:ident WHERE $($cond:tt)*) => {\n        Query::select(vec![$(stringify!($field)),*])\n            .from(stringify!($table))\n            .where(parse_condition!($($cond)*))\n    }\n}\n\nlet query = sql! {\n    SELECT name, email, age \n    FROM users \n    WHERE age > 18 AND active = true\n}\n\n// HTML templating\nmacro! html {\n    (<$tag:ident $($attr:ident = $value:expr)*> $($content:tt)* </$close:ident>) => {\n        Element::new(stringify!($tag))\n            $(.attr(stringify!($attr), $value))*\n            .children(vec![$(html!($content)),*])\n    }\n    ($text:expr) => {\n        Text::new($text)\n    }\n}\n\nlet page = html! {\n    <div class=\"container\">\n        <h1>\"Welcome\"</h1>\n        <p>\"This is \"<strong>\"Ruchy\"</strong>\" macros!\"</p>\n    </div>\n}\n\n// Regular expression literals\nmacro! regex {\n    ($pattern:expr) => {\n        {\n            static REGEX: OnceCell<Regex> = OnceCell::new()\n            REGEX.get_or_init(|| {\n                Regex::new($pattern).expect(\"Invalid regex\")\n            })\n        }\n    }\n}\n\nlet email_regex = regex!(r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 6,
          "line_number": 335,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected '(' or '[' after macro name\n// Debug print with variable names\nmacro! dbg {\n    ($($x:expr),*) => {\n        $(\n            eprintln!(\"{} = {:?}\", stringify!($x), $x)\n        )*\n    }\n}\n\nlet x = 42\nlet y = \"hello\"\ndbg!(x, y, x + 10)\n// Prints:\n// x = 42\n// y = \"hello\"\n// x + 10 = 52\n\n// Trace macro for function calls\nmacro! trace {\n    ($func:expr) => {\n        {\n            println(\"Entering \" + stringify!($func))\n            let result = $func\n            println(\"Leaving \" + stringify!($func) + \": \" + result.to_s())\n            result\n        }\n    }\n}\n\nlet result = trace!(expensive_calculation())\n\n// Assert with custom messages\nmacro! assert_eq_msg {\n    ($left:expr, $right:expr, $msg:expr) => {\n        if $left != $right {\n            panic($msg + \"\\nLeft: \" + $left.to_s() + \"\\nRight: \" + $right.to_s())\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 7,
          "line_number": 385,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected '(' or '[' after macro name\n// Generate getters and setters\nmacro! accessors {\n    ($struct_name:ident { $($field:ident : $type:ty),* }) => {\n        impl $struct_name {\n            $(\n                fn $field(&self) -> &$type {\n                    &self.$field\n                }\n                \n                fn set_$field(&mut self, value: $type) {\n                    self.$field = value\n                }\n            )*\n        }\n    }\n}\n\nstruct Person {\n    name: String\n    age: i32\n}\n\naccessors!(Person { name: String, age: i32 })\n\n// Now person.name() and person.set_name() exist!\n\n// Generate enum variants and matchers\nmacro! define_opcodes {\n    ($($name:ident = $value:expr),*) => {\n        enum Opcode {\n            $($name = $value),*\n        }\n        \n        impl Opcode {\n            fun from_byte(byte: u8) -> Option<Opcode> {\n                match byte {\n                    $($value => Some(Opcode::$name)),*\n                    _ => None\n                }\n            }\n            \n            fun to_string(&self) -> &str {\n                match self {\n                    $(Opcode::$name => stringify!($name)),*\n                }\n            }\n        }\n    }\n}\n\ndefine_opcodes! {\n    ADD = 0x01,\n    SUB = 0x02,\n    MUL = 0x03,\n    DIV = 0x04,\n    JMP = 0x10,\n    JEQ = 0x11\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 8,
          "line_number": 454,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected '(' or '[' after macro name\n// State machine DSL\nmacro! state_machine {\n    (\n        states: [$($state:ident),*]\n        transitions: [\n            $($from:ident -> $to:ident on $event:ident),*\n        ]\n        initial: $initial:ident\n    ) => {\n        enum State {\n            $($state),*\n        }\n        \n        enum Event {\n            $($event),*\n        }\n        \n        struct StateMachine {\n            state: State\n        }\n        \n        impl StateMachine {\n            fun new() -> Self {\n                Self { state: State::$initial }\n            }\n            \n            fun transition(&mut self, event: Event) {\n                self.state = match (&self.state, event) {\n                    $(\n                        (State::$from, Event::$event) => State::$to,\n                    )*\n                    _ => panic(\"Invalid transition\")\n                }\n            }\n        }\n    }\n}\n\nstate_machine! {\n    states: [Idle, Running, Paused, Stopped]\n    transitions: [\n        Idle -> Running on Start,\n        Running -> Paused on Pause,\n        Paused -> Running on Resume,\n        Running -> Stopped on Stop,\n        Paused -> Stopped on Stop\n    ]\n    initial: Idle\n}\n\n// Configuration DSL\nmacro! config {\n    {\n        $($section:ident {\n            $($key:ident : $value:expr),*\n        })*\n    } => {\n        {\n            let mut config = Config::new()\n            $(\n                let mut section = ConfigSection::new(stringify!($section))\n                $(\n                    section.set(stringify!($key), $value)\n                )*\n                config.add_section(section)\n            )*\n            config\n        }\n    }\n}\n\nlet config = config! {\n    server {\n        host: \"localhost\",\n        port: 8080,\n        workers: 4\n    }\n    database {\n        url: \"postgres://localhost/myapp\",\n        pool_size: 20\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 9,
          "line_number": 547,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected '(' or '[' after macro name\n// Hygienic macros prevent name collisions\nmacro! safe_swap {\n    ($a:expr, $b:expr) => {\n        {\n            // Generated names won't conflict\n            let __temp = $a\n            $a = $b\n            $b = __temp\n        }\n    }\n}\n\n// Best practices:\n// 1. Keep macros simple\n// 2. Provide good error messages\nmacro! validate {\n    ($expr:expr) => {\n        if !$expr {\n            compile_error!(concat!(\n                \"Validation failed: \",\n                stringify!($expr)\n            ))\n        }\n    }\n}\n\n// 3. Document macro syntax\n/// Creates a new vector with the given elements\n/// \n/// # Example\n/// ```\n/// let v = vec![1, 2, 3]\n/// ```\nmacro! vec {\n    // Implementation\n}\n\n// 4. Use macro namespaces\nmod macros {\n    macro! internal_helper {\n        // Not exported\n    }\n    \n    #[macro_export]\n    macro! public_macro {\n        // Exported\n    }\n}\n\n// 5. Test macros thoroughly\n#[test]\nfun test_macro() {\n    let result = my_macro!(input)\n    assert_eq!(result, expected)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch09-00-network-programming": {
      "chapter": "ch09-00-network-programming",
      "total_examples": 10,
      "working_examples": 0,
      "failing_examples": 10,
      "examples": [
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: ColonColon\n// File: web_server.ruchy\n// HTTP server with routing and middleware\n\nuse std::net::http;\n\nlet server = http::Server::new(\"0.0.0.0:8080\")\n\n// Middleware for logging\nserver.use(|req, res, next| {\n    let start = current_time_ms()\n    next()\n    let duration = current_time_ms() - start\n    println(req.method + \" \" + req.path + \" - \" + res.status.to_s() + \" (\" + duration.to_s() + \"ms)\")\n})\n\n// Routes\nserver.get(\"/\", |req, res| {\n    res.html(\"<h1>Welcome to Ruchy Server!</h1>\")\n})\n\nserver.get(\"/api/users\", |req, res| {\n    let users = [\n        {id: 1, name: \"Alice\", email: \"alice@example.com\"},\n        {id: 2, name: \"Bob\", email: \"bob@example.com\"}\n    ]\n    res.json(users)\n})\n\nserver.post(\"/api/users\", |req, res| {\n    let user = req.json()\n    println(\"Creating user: \" + user.name)\n    user.id = generate_id()\n    user.created = current_datetime()\n    res.status(201).json(user)\n})\n\n// Static files\nserver.static(\"/public\", \"./static\")\n\n// Start server\nprintln(f\"🚀 Server running on http://localhost:8080\")\nserver.listen()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 2,
          "line_number": 89,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: ColonColon\n// TCP Server\nlet server = net::TcpListener::bind(\"127.0.0.1:9000\")\nprintln(\"Server listening on port 9000\")\n\nloop {\n    let client = server.accept()\n    \n    // Handle each client in a separate thread\n    spawn {\n        println(\"Client connected: \" + client.remote_addr())\n        \n        loop {\n            let message = client.read_line()\n            if message.is_empty() {\n                break\n            }\n            \n            println(\"Received: \" + message)\n            client.write(\"Echo: \" + message + \"\\n\")\n        }\n        \n        println(\"Client disconnected\")\n    }\n}\n\n// TCP Client\nlet client = net::TcpStream::connect(\"127.0.0.1:9000\")\nclient.write(\"Hello, server!\\n\")\nlet response = client.read_line()\nprintln(\"Server replied: \" + response)",
          "passed": false,
          "status": "broken",
          "error": "\nthread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:\n\"net::TcpListener\" is not a valid Ident\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 3,
          "line_number": 132,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected method name or 'await' after '.'\n// Simple GET request\nlet response = http::get(\"https://api.example.com/data\")\nlet data = response.json()\nprintln(\"Got \" + data.items.len().to_s() + \" items\")\n\n// POST with JSON\nlet user = {\n    name: \"Alice\",\n    email: \"alice@example.com\"\n}\nlet response = http::post(\"https://api.example.com/users\")\n    .json(user)\n    .send()\n\n// Advanced requests\nlet response = http::request(\"https://api.example.com/data\")\n    .method(\"GET\")\n    .header(\"Authorization\", \"Bearer \" + token)\n    .header(\"User-Agent\", \"Ruchy/1.0\")\n    .query(\"page\", 1)\n    .query(\"limit\", 100)\n    .timeout(5000)\n    .send()\n\nif response.is_success() {\n    let data = response.json()\n    process_data(data)\n} else {\n    println(\"Error: \" + response.status.to_s() + \" - \" + response.text())\n}\n\n// Download file with progress\nhttp::download(\"https://example.com/big-file.zip\", \"downloads/file.zip\")\n    .on_progress(|downloaded, total| {\n        let percent = (downloaded / total) * 100\n        print(\"\\rDownloading: \" + percent.to_s() + \"%\")\n    })\n    .await()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 4,
          "line_number": 183,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: ColonColon\n// WebSocket Server\nlet ws_server = ws::Server::new(\"0.0.0.0:8081\")\n\nws_server.on_connection(|socket| {\n    println(\"WebSocket connected: \" + socket.id)\n    \n    socket.on(\"message\", |data| {\n        println(\"Received: \" + data)\n        \n        // Broadcast to all clients\n        ws_server.broadcast({\n            type: \"chat\",\n            user: socket.id,\n            message: data\n        })\n    })\n    \n    socket.on(\"close\", || {\n        println(\"WebSocket disconnected: \" + socket.id)\n    })\n})\n\nws_server.listen()\n\n// WebSocket Client\nlet ws = ws::connect(\"ws://localhost:8081\")\n\nws.on(\"open\", || {\n    println(\"Connected to server\")\n    ws.send(\"Hello, server!\")\n})\n\nws.on(\"message\", |data| {\n    println(\"Server says: \" + data)\n})\n\nws.on(\"error\", |err| {\n    println(\"WebSocket error: \" + err.to_s())\n})",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 5,
          "line_number": 235,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: ColonColon\n// File: api_server.ruchy\n// RESTful API with database\n\nuse std::net::http;\nuse std::db;\n\nlet app = http::Server::new(\"0.0.0.0:3000\")\nlet database = db::connect(\"sqlite:data.db\")\n\n// CORS middleware\napp.use(|req, res, next| {\n    res.header(\"Access-Control-Allow-Origin\", \"*\")\n    res.header(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE\")\n    next()\n})\n\n// Authentication middleware\nfun require_auth(req, res, next) {\n    let token = req.header(\"Authorization\")\n    if !token || !validate_token(token) {\n        return res.status(401).json({error: \"Unauthorized\"})\n    }\n    req.user = decode_token(token)\n    next()\n}\n\n// Routes\napp.get(\"/api/posts\", |req, res| {\n    let page = req.query(\"page\", 1)\n    let limit = req.query(\"limit\", 10)\n    \n    let posts = database.query(\"\n        SELECT * FROM posts \n        ORDER BY created_at DESC \n        LIMIT ? OFFSET ?\n    \", [limit, (page - 1) * limit])\n    \n    res.json({\n        posts: posts,\n        page: page,\n        total: database.count(\"posts\")\n    })\n})\n\napp.get(\"/api/posts/:id\", |req, res| {\n    let id = req.params.id\n    let post = database.find(\"posts\", id)\n    \n    if post {\n        res.json(post)\n    } else {\n        res.status(404).json({error: \"Post not found\"})\n    }\n})\n\napp.post(\"/api/posts\", require_auth, |req, res| {\n    let post = req.json()\n    post.author_id = req.user.id\n    post.created_at = current_datetime()\n    \n    let id = database.insert(\"posts\", post)\n    let created = database.find(\"posts\", id)\n    \n    res.status(201).json(created)\n})\n\napp.put(\"/api/posts/:id\", require_auth, |req, res| {\n    let id = req.params.id\n    let updates = req.json()\n    \n    // Check ownership\n    let post = database.find(\"posts\", id)\n    if post.author_id != req.user.id {\n        return res.status(403).json({error: \"Forbidden\"})\n    }\n    \n    updates.updated_at = current_datetime()\n    database.update(\"posts\", id, updates)\n    \n    res.json(database.find(\"posts\", id))\n})\n\napp.delete(\"/api/posts/:id\", require_auth, |req, res| {\n    let id = req.params.id\n    \n    // Check ownership\n    let post = database.find(\"posts\", id)\n    if post.author_id != req.user.id {\n        return res.status(403).json({error: \"Forbidden\"})\n    }\n    \n    database.delete(\"posts\", id)\n    res.status(204).send()\n})\n\n// Error handling\napp.use(|err, req, res, next| {\n    console.error(\"Error: \" + err.to_s())\n    res.status(500).json({\n        error: \"Internal server error\",\n        message: err.message\n    })\n})\n\nprintln(\"🚀 API server running on http://localhost:3000\")\napp.listen()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 6,
          "line_number": 352,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: ColonColon\n// File: chat_server.ruchy\n// Multi-room chat server with history\n\nuse std::net::ws;\n\nlet server = ws::Server::new(\"0.0.0.0:8080\")\nlet rooms = {}\nlet users = {}\n\nfun broadcast_to_room(room_id, message, exclude_user = null) {\n    if rooms.has_key(room_id) {\n        for user_id in rooms[room_id] {\n            if user_id != exclude_user {\n                users[user_id].socket.send(message)\n            }\n        }\n    }\n}\n\nserver.on_connection(|socket| {\n    let user = {\n        id: generate_id(),\n        socket: socket,\n        name: null,\n        room: null,\n        joined_at: current_datetime()\n    }\n    \n    users[user.id] = user\n    \n    socket.send(json({\n        type: \"welcome\",\n        user_id: user.id,\n        message: \"Welcome to chat! Send /help for commands\"\n    }))\n    \n    socket.on(\"message\", |data| {\n        let msg = parse_json(data)\n        \n        match msg.type {\n            \"join\" => {\n                user.name = msg.name\n                user.room = msg.room\n                \n                // Add user to room\n                if !rooms.has_key(msg.room) {\n                    rooms[msg.room] = []\n                }\n                rooms[msg.room].push(user.id)\n                \n                // Notify room\n                broadcast_to_room(msg.room, json({\n                    type: \"user_joined\",\n                    user: user.name,\n                    time: current_datetime()\n                }))\n                \n                // Send room history\n                let history = get_room_history(msg.room)\n                socket.send(json({\n                    type: \"history\",\n                    messages: history\n                }))\n            }\n            \n            \"message\" => {\n                let chat_msg = {\n                    type: \"message\",\n                    user: user.name,\n                    text: msg.text,\n                    time: current_datetime()\n                }\n                \n                // Save to history\n                save_message(user.room, chat_msg)\n                \n                // Broadcast to room\n                broadcast_to_room(user.room, json(chat_msg))\n            }\n            \n            \"private\" => {\n                let target = find_user_by_name(msg.to)\n                if target {\n                    target.socket.send(json({\n                        type: \"private\",\n                        from: user.name,\n                        text: msg.text,\n                        time: current_datetime()\n                    }))\n                }\n            }\n            \n            \"typing\" => {\n                broadcast_to_room(user.room, json({\n                    type: \"typing\",\n                    user: user.name\n                }), user.id)\n            }\n        }\n    })\n    \n    socket.on(\"close\", || {\n        // Remove from room\n        if user.room && rooms.has_key(user.room) {\n            rooms[user.room] = rooms[user.room].filter(|id| id != user.id)\n            \n            broadcast_to_room(user.room, json({\n                type: \"user_left\",\n                user: user.name,\n                time: current_datetime()\n            }))\n        }\n        \n        users.remove(user.id)\n    })\n})\n\nprintln(\"💬 Chat server running on ws://localhost:8080\")\nserver.listen()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 7,
          "line_number": 482,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected identifier, '*', or '{' after '::'\n// File: network_scanner.ruchy\n// Scan network for open ports and services\n\nuse std::net;\nuse std::async;\n\nprintln(\"=== Network Scanner ===\")\n\nfun scan_port(host, port, timeout = 1000) {\n    try {\n        let socket = net::TcpStream::connect_timeout(\n            host + \":\" + port.to_s(), \n            timeout\n        )\n        socket.close()\n        return true\n    } catch {\n        return false\n    }\n}\n\nfun identify_service(port) {\n    let services = {\n        21: \"FTP\",\n        22: \"SSH\",\n        23: \"Telnet\",\n        25: \"SMTP\",\n        53: \"DNS\",\n        80: \"HTTP\",\n        110: \"POP3\",\n        143: \"IMAP\",\n        443: \"HTTPS\",\n        445: \"SMB\",\n        3306: \"MySQL\",\n        5432: \"PostgreSQL\",\n        6379: \"Redis\",\n        8080: \"HTTP-Alt\",\n        8443: \"HTTPS-Alt\",\n        27017: \"MongoDB\"\n    }\n    \n    return services.get(port, \"Unknown\")\n}\n\nfun scan_host(host, ports) {\n    println(\"\\nScanning \" + host + \"...\")\n    let open_ports = []\n    \n    // Parallel port scanning\n    let tasks = []\n    for port in ports {\n        tasks.push(async {\n            if scan_port(host, port) {\n                return port\n            }\n            return null\n        })\n    }\n    \n    let results = async::wait_all(tasks)\n    \n    for port in results {\n        if port {\n            let service = identify_service(port)\n            open_ports.push({port: port, service: service})\n            println(\"  ✓ Port \" + port.to_s() + \" open - \" + service)\n        }\n    }\n    \n    return open_ports\n}\n\n// Get scan parameters\nlet target = input(\"Target host (IP or domain): \")\nlet scan_type = input(\"Scan type (quick/full/custom): \")\n\nlet ports = match scan_type {\n    \"quick\" => [21, 22, 23, 25, 80, 443, 3306, 5432, 8080]\n    \"full\" => range(1, 65535)\n    \"custom\" => {\n        let range_str = input(\"Port range (e.g., 1-1000): \")\n        let parts = range_str.split(\"-\")\n        range(parts[0].to_i(), parts[1].to_i())\n    }\n    _ => [80, 443]\n}\n\nprintln(\"\\nScanning \" + ports.len().to_s() + \" ports on \" + target + \"...\")\nlet start_time = current_time_ms()\n\nlet results = scan_host(target, ports)\n\nlet duration = (current_time_ms() - start_time) / 1000\nprintln(\"\\nScan complete in \" + duration.to_s() + \"s\")\nprintln(\"Found \" + results.len().to_s() + \" open ports\")\n\n// Generate report\nif results.len() > 0 {\n    println(\"\\n=== Open Services ===\")\n    for item in results.sort_by(|r| r.port) {\n        println(item.port.to_s() + \" - \" + item.service)\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 8,
          "line_number": 596,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected method name or 'await' after '.'\n// File: load_balancer.ruchy\n// HTTP load balancer with health checking\n\nuse std::net::http;\n\nlet backends = [\n    {url: \"http://server1:8080\", weight: 1, healthy: true},\n    {url: \"http://server2:8080\", weight: 2, healthy: true},\n    {url: \"http://server3:8080\", weight: 1, healthy: true}\n]\n\nlet current_backend = 0\n\nfun select_backend() {\n    // Weighted round-robin selection\n    let healthy_backends = backends.filter(|b| b.healthy)\n    \n    if healthy_backends.is_empty() {\n        throw \"No healthy backends available\"\n    }\n    \n    // Simple round-robin for now\n    current_backend = (current_backend + 1) % healthy_backends.len()\n    return healthy_backends[current_backend]\n}\n\nfun health_check() {\n    for backend in backends {\n        try {\n            let response = http::get(backend.url + \"/health\")\n                .timeout(2000)\n                .send()\n            \n            backend.healthy = response.status == 200\n        } catch {\n            backend.healthy = false\n        }\n        \n        let status = backend.healthy ? \"✓\" : \"✗\"\n        println(\"Health check \" + backend.url + \": \" + status)\n    }\n}\n\n// Start health check timer\nspawn {\n    loop {\n        health_check()\n        sleep(10000)  // Check every 10 seconds\n    }\n}\n\n// Create load balancer server\nlet balancer = http::Server::new(\"0.0.0.0:80\")\n\nbalancer.all(\"*\", |req, res| {\n    let backend = select_backend()\n    \n    println(\"Routing \" + req.method + \" \" + req.path + \" -> \" + backend.url)\n    \n    // Forward request\n    let backend_response = http::request(backend.url + req.path)\n        .method(req.method)\n        .headers(req.headers)\n        .body(req.body)\n        .send()\n    \n    // Return response\n    res.status(backend_response.status)\n        .headers(backend_response.headers)\n        .send(backend_response.body)\n})\n\nprintln(\"🔄 Load balancer running on port 80\")\nprintln(\"Backends: \" + backends.len().to_s())\nbalancer.listen()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 9,
          "line_number": 686,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Function parameters must be simple identifiers (destructuring patterns not supported)\n// Custom protocol over TCP\nfun send_packet(socket, type, data) {\n    let packet = {\n        version: 1,\n        type: type,\n        timestamp: current_time_ms(),\n        data: data\n    }\n    \n    let json = to_json(packet)\n    let length = json.len()\n    \n    // Send length-prefixed message\n    socket.write_u32(length)\n    socket.write(json)\n}\n\nfun receive_packet(socket) {\n    let length = socket.read_u32()\n    let json = socket.read(length)\n    return parse_json(json)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 10,
          "line_number": 719,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: ColonColon\n// Monitor network traffic\nlet monitor = net::PacketCapture::new(\"eth0\")\n\nmonitor.on_packet(|packet| {\n    if packet.protocol == \"TCP\" {\n        println(\"TCP: \" + packet.src + \":\" + packet.src_port.to_s() + \" -> \" + packet.dst + \":\" + packet.dst_port.to_s())\n    } else if packet.protocol == \"UDP\" {\n        println(\"UDP: \" + packet.src + \" -> \" + packet.dst + \" (\" + packet.size.to_s() + \" bytes)\")\n    }\n})\n\nmonitor.start()",
          "passed": false,
          "status": "broken",
          "error": "\nthread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:\n\"net::PacketCapture\" is not a valid Ident\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch07-00-error-handling-tdd": {
      "chapter": "ch07-00-error-handling-tdd",
      "total_examples": 9,
      "working_examples": 3,
      "failing_examples": 6,
      "examples": [
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 1,
          "line_number": 17,
          "code": "fun main() {\n    println(\"Before operation\");\n    if true {\n        println(\"Operation successful\");\n    }\n    println(\"After operation\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 2,
          "line_number": 38,
          "code": "fun main() {\n    let number = 5;\n    if number > 0 {\n        println(\"Valid number\");\n    } else {\n        println(\"Invalid number\");\n    }\n    \n    let zero = 0;\n    if zero == 0 {\n        println(\"Warning: Zero value detected\");\n    } else {\n        println(\"Non-zero value\");\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 3,
          "line_number": 66,
          "code": "fun main() {\n    let age = 25;\n    match age {\n        0 => println(\"Error: Age cannot be zero\"),\n        1..=17 => println(\"Minor\"),\n        18..=65 => println(\"Adult\"),\n        _ => println(\"Senior\")\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 4,
          "line_number": 106,
          "code": "if value > 0 {\n    println(\"Valid\");\n} else {\n    println(\"Invalid\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `value` in this scope\n --> /tmp/.tmpyhQOJn/main.rs:1:66\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\") } } else { { println ! (\"Invalid\") ...\n  |                                                                  ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpyhQOJn/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\") } } else { { println ! (\"Invalid\") ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpyhQOJn/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\") } } else { { println ! (\"Invalid\") ...\n  |                                                                                 ^^                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\") } } else { { println ! (\"Invalid\") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { println ! (\"Valid\") } else { { println ! (\"Invalid\") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpyhQOJn/main.rs:1:114\n  |\n1 | ... = if value > 0i32 { { println ! (\"Valid\") } } else { { println ! (\"Invalid\") } } ; if let Some (s) = (& result as & dyn std :: any ::...\n  |                                                          ^^                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\") } } else { { println ! (\"Invalid\") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\") } } else { println ! (\"Invalid\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror: aborting due to 1 previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 5,
          "line_number": 115,
          "code": "match status {\n    0 => println(\"Error\"),\n    1 => println(\"Warning\"),\n    2 => println(\"Success\"),\n    _ => println(\"Unknown\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `status` in this scope\n --> /tmp/.tmpwgIdb4/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match status { 0i32 => println ! (\"Error\") , 1i32 => println ! (\"Warning\") ...\n  |                                                                     ^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpwgIdb4/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match status { 0i32 => println ! (\"Error\") , 1i32 => println ! (\"Warning\") ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 6,
          "line_number": 125,
          "code": "match age {\n    0 => println(\"Invalid age\"),\n    1..=17 => println(\"Minor\"),\n    18..=65 => println(\"Adult\"),\n    _ => println(\"Senior\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `age` in this scope\n --> /tmp/.tmpuogksQ/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match age { 0i32 => println ! (\"Invalid age\") , 1i32 ..= 17i32 => println !...\n  |                                                                     ^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpuogksQ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match age { 0i32 => println ! (\"Invalid age\") , 1i32 ..= 17i32 => println !...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 7,
          "line_number": 149,
          "code": "if input < 0 {\n    println(\"Error: Negative input not allowed\");\n} else {\n    process_input(input);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `input` in this scope\n --> /tmp/.tmp6IV8sI/main.rs:1:66\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! (\"Error: Negative input not allowed\") } } els...\n  |                                                                  ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `input` in this scope\n --> /tmp/.tmp6IV8sI/main.rs:1:159\n  |\n1 | ...ive input not allowed\") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_re...\n  |                                                        ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp6IV8sI/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! (\"Error: Negative input not allowed\") } } els...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp6IV8sI/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! (\"Error: Negative input not allowed\") } } els...\n  |                                                                                 ^^                                               ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! (\"Error: Negative input not allowed\") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { println ! (\"Error: Negative input not allowed\") } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp6IV8sI/main.rs:1:142\n  |\n1 | ...ln ! (\"Error: Negative input not allowed\") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any ::...\n  |                                                          ^^                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! (\"Error: Negative input not allowed\") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! (\"Error: Negative input not allowed\") } } else { process_input (input) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `process_input` in this scope\n --> /tmp/.tmp6IV8sI/main.rs:1:144\n  |\n1 | ...rror: Negative input not allowed\") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . ...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 8,
          "line_number": 158,
          "code": "match score {\n    0..=59 => println(\"Fail\"),\n    60..=79 => println(\"Pass\"),\n    80..=100 => println(\"Excellent\"),\n    _ => println(\"Invalid score\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `score` in this scope\n --> /tmp/.tmpGtoXcy/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match score { 0i32 ..= 59i32 => println ! (\"Fail\") , 60i32 ..= 79i32 => pri...\n  |                                                                     ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpGtoXcy/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match score { 0i32 ..= 59i32 => println ! (\"Fail\") , 60i32 ..= 79i32 => pri...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 9,
          "line_number": 168,
          "code": "if system_ready {\n    println(\"System operational\");\n} else {\n    println(\"System not ready\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `system_ready` in this scope\n --> /tmp/.tmphkKboB/main.rs:1:66\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\") } } else { { println !...\n  |                                                                  ^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmphkKboB/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\") } } else { { println !...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmphkKboB/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\") } } else { { println !...\n  |                                                                                 ^^                                ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\") } } else { { println ! (\"System not ready\") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if system_ready { println ! (\"System operational\") } else { { println ! (\"System not ready\") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmphkKboB/main.rs:1:127\n  |\n1 | ...y { { println ! (\"System operational\") } } else { { println ! (\"System not ready\") } } ; if let Some (s) = (& result as & dyn std :: a...\n  |                                                      ^^                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\") } } else { { println ! (\"System not ready\") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\") } } else { println ! (\"System not ready\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror: aborting due to 1 previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch08-00-systems-programming": {
      "chapter": "ch08-00-systems-programming",
      "total_examples": 9,
      "working_examples": 0,
      "failing_examples": 9,
      "examples": [
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ✅ WORKING\n\n// File: system_monitor.ruchy\n// Real-time system resource monitoring\n\nuse std::system;\nuse std::process;\n\nprintln(\"=== System Monitor ===\")\n\n// Get system information\nlet cpu_count = system::cpu_count()\nlet total_memory = system::total_memory()\nlet hostname = system::hostname()\nlet os_info = system::os_info()\n\nprintln(\"Host: \" + hostname)\nprintln(\"OS: \" + os_info.name + \" \" + os_info.version)\nprintln(\"CPUs: \" + cpu_count.to_s())\nprintln(\"Memory: \" + format_size(total_memory))\nprintln(\"\")\n\n// Monitor resources in real-time\nloop {\n    let cpu_usage = system::cpu_usage()\n    let memory_info = system::memory_info()\n    let disk_io = system::disk_io_stats()\n    let network_stats = system::network_stats()\n    \n    // Clear screen and show header\n    clear_screen()\n    println(\"System Monitor - Press Ctrl+C to exit\")\n    println(\"=\" * 50)\n    \n    // CPU Usage\n    println(\"CPU: \" + cpu_usage.to_s() + \"% |\" + (\"█\" * (cpu_usage * 50).to_i()) + (\"░\" * (50 - cpu_usage * 50).to_i()) + \"|\")\n    \n    // Memory Usage\n    let mem_percent = memory_info.used / memory_info.total\n    println(\"MEM: \" + mem_percent.to_s() + \"% |\" + (\"█\" * (mem_percent * 50).to_i()) + (\"░\" * (50 - mem_percent * 50).to_i()) + \"|\")\n    println(\"     \" + format_size(memory_info.used) + \" / \" + format_size(memory_info.total))\n    \n    // Disk I/O\n    println(\"Disk Read:  \" + format_size(disk_io.read_bytes) + \"/s\")\n    println(\"Disk Write: \" + format_size(disk_io.write_bytes) + \"/s\")\n    \n    // Network\n    println(\"Net Down: \" + format_size(network_stats.download_speed) + \"/s\")\n    println(\"Net Up:   \" + format_size(network_stats.upload_speed) + \"/s\")\n    \n    // Top processes\n    println(\"\\nTop Processes by CPU:\")\n    let processes = process::list()\n        .sort_by(|p| -p.cpu_percent)\n        .take(5)\n    \n    for proc in processes {\n        println(\"  \" + proc.pid.to_s() + \" \" + proc.name + \" \" + proc.cpu_percent.to_s() + \"%\")\n    }\n    \n    sleep(1000)  // Update every second\n}",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0432]: unresolved import `std::system`\n --> /tmp/.tmpz2E49d/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monit...\n  |                                                                     ^^^^^^^^^^^^^ no `system` in the root\n\nerror[E0425]: cannot find function `list` in module `process`\n --> /tmp/.tmpz2E49d/main.rs:1:1718\n  |\n1 | ...Top Processes by CPU:\") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes...\n  |                                                         ^^^^ not found in `process`\n\nerror[E0425]: cannot find function `sleep` in this scope\n --> /tmp/.tmpz2E49d/main.rs:1:1920\n  |\n1 | ...e + \" \" + proc . cpu_percent . to_s () + \"%\") } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::thread::sleep;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpz2E49d/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monit...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpz2E49d/main.rs:1:85\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monit...\n  |                                                                                     ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpz2E49d/main.rs:1:108\n  |\n1 | ...sult = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monitor ===\") ; let cpu_count = system :: cpu_count () ; ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpz2E49d/main.rs:1:562\n  |\n1 | ... { { { let cpu_usage = system :: cpu_usage () ; { let memory_info = system :: memory_info () ; let disk_io = system :: disk_io_stats () ; let network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\") ; println ! (\"{}\" , \"=\" * 50i32) ; println ! (\"{}\" , \"CPU: \" + cpu_usage . to_s () + \"% |\" + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () + \"|\") ; let mem_percent = memory_info . used / memory_info . total ; println ! (\"{}\" , \"MEM: \" + mem_percent . to_s () + \"% |\" + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () + \"|\") ; println ! (\"{}\" , \"     \" + format_size (memory_info . used) + \" / \" + format_size (memory_info . total)) ; println ! (\"{}\" , \"Disk Read:  \" + format_size (disk_io . read_bytes) + \"/s\") ; println ! (\"{}\" , \"Disk Write: \" + format_size (disk_io . write_bytes) + \"/s\") ; println ! (\"{}\" , \"Net Down: \" + format_size (network_stats . download_speed) + \"/s\") ; println ! (\"{}\" , \"Net Up:   \" + format_size (network_stats . upload_speed) + \"/s\") ; println ! (\"\\nTop Processes by CPU:\") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! (\"{}\" , \"  \" + proc . pid . to_s () + \" \" + proc . name + \" \" + proc . cpu_percent . to_s () + \"%\") } } ; sleep (1000i32) } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monitor ===\") ; let cpu_count = system :: cpu_count () ; let total_memory = system :: total_memory () ; let hostname = system :: hostname () ; let os_info = system :: os_info () ; println ! (\"{}\" , \"Host: \" + hostname) ; println ! (\"{}\" , \"OS: \" + os_info . name + \" \" + os_info . version) ; println ! (\"{}\" , \"CPUs: \" + cpu_count . to_s ()) ; println ! (\"{}\" , \"Memory: \" + format_size (total_memory)) ; println ! (\"\") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let memory_info = system :: memory_info () ; let disk_io = system :: disk_io_stats () ; let network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\") ; println ! (\"{}\" , \"=\" * 50i32) ; println ! (\"{}\" , \"CPU: \" + cpu_usage . to_s () + \"% |\" + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () + \"|\") ; let mem_percent = memory_info . used / memory_info . total ; println ! (\"{}\" , \"MEM: \" + mem_percent . to_s () + \"% |\" + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () + \"|\") ; println ! (\"{}\" , \"     \" + format_size (memory_info . used) + \" / \" + format_size (memory_info . total)) ; println ! (\"{}\" , \"Disk Read:  \" + format_size (disk_io . read_bytes) + \"/s\") ; println ! (\"{}\" , \"Disk Write: \" + format_size (disk_io . write_bytes) + \"/s\") ; println ! (\"{}\" , \"Net Down: \" + format_size (network_stats . download_speed) + \"/s\") ; println ! (\"{}\" , \"Net Up:   \" + format_size (network_stats . upload_speed) + \"/s\") ; println ! (\"\\nTop Processes by CPU:\") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! (\"{}\" , \"  \" + proc . pid . to_s () + \" \" + proc . name + \" \" + proc . cpu_percent . to_s () + \"%\") } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monitor ===\") ; let cpu_count = system :: cpu_count () ; let total_memory = system :: total_memory () ; let hostname = system :: hostname () ; let os_info = system :: os_info () ; println ! (\"{}\" , \"Host: \" + hostname) ; println ! (\"{}\" , \"OS: \" + os_info . name + \" \" + os_info . version) ; println ! (\"{}\" , \"CPUs: \" + cpu_count . to_s ()) ; println ! (\"{}\" , \"Memory: \" + format_size (total_memory)) ; println ! (\"\") ; loop { { let cpu_usage = system :: cpu_usage () ; { let memory_info = system :: memory_info () ; let disk_io = system :: disk_io_stats () ; let network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\") ; println ! (\"{}\" , \"=\" * 50i32) ; println ! (\"{}\" , \"CPU: \" + cpu_usage . to_s () + \"% |\" + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () + \"|\") ; let mem_percent = memory_info . used / memory_info . total ; println ! (\"{}\" , \"MEM: \" + mem_percent . to_s () + \"% |\" + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () + \"|\") ; println ! (\"{}\" , \"     \" + format_size (memory_info . used) + \" / \" + format_size (memory_info . total)) ; println ! (\"{}\" , \"Disk Read:  \" + format_size (disk_io . read_bytes) + \"/s\") ; println ! (\"{}\" , \"Disk Write: \" + format_size (disk_io . write_bytes) + \"/s\") ; println ! (\"{}\" , \"Net Down: \" + format_size (network_stats . download_speed) + \"/s\") ; println ! (\"{}\" , \"Net Up:   \" + format_size (network_stats . upload_speed) + \"/s\") ; println ! (\"\\nTop Processes by CPU:\") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! (\"{}\" , \"  \" + proc . pid . to_s () + \" \" + proc . name + \" \" + proc . cpu_percent . to_s () + \"%\") } } ; sleep (1000i32) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpz2E49d/main.rs:1:1802\n  |\n1 | ...ocesses { { println ! (\"{}\" , \"  \" + proc . pid . to_s () + \" \" + proc . name + \" \" + proc . cpu_percent . to_s () + \"%\") } } ; sleep ...\n  |              ^^                                                                                                             ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monitor ===\") ; let cpu_count = system :: cpu_count () ; let total_memory = system :: total_memory () ; let hostname = system :: hostname () ; let os_info = system :: os_info () ; println ! (\"{}\" , \"Host: \" + hostname) ; println ! (\"{}\" , \"OS: \" + os_info . name + \" \" + os_info . version) ; println ! (\"{}\" , \"CPUs: \" + cpu_count . to_s ()) ; println ! (\"{}\" , \"Memory: \" + format_size (total_memory)) ; println ! (\"\") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let memory_info = system :: memory_info () ; let disk_io = system :: disk_io_stats () ; let network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\") ; println ! (\"{}\" , \"=\" * 50i32) ; println ! (\"{}\" , \"CPU: \" + cpu_usage . to_s () + \"% |\" + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () + \"|\") ; let mem_percent = memory_info . used / memory_info . total ; println ! (\"{}\" , \"MEM: \" + mem_percent . to_s () + \"% |\" + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () + \"|\") ; println ! (\"{}\" , \"     \" + format_size (memory_info . used) + \" / \" + format_size (memory_info . total)) ; println ! (\"{}\" , \"Disk Read:  \" + format_size (disk_io . read_bytes) + \"/s\") ; println ! (\"{}\" , \"Disk Write: \" + format_size (disk_io . write_bytes) + \"/s\") ; println ! (\"{}\" , \"Net Down: \" + format_size (network_stats . download_speed) + \"/s\") ; println ! (\"{}\" , \"Net Up:   \" + format_size (network_stats . upload_speed) + \"/s\") ; println ! (\"\\nTop Processes by CPU:\") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! (\"{}\" , \"  \" + proc . pid . to_s () + \" \" + proc . name + \" \" + proc . cpu_percent . to_s () + \"%\") } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monitor ===\") ; let cpu_count = system :: cpu_count () ; let total_memory = system :: total_memory () ; let hostname = system :: hostname () ; let os_info = system :: os_info () ; println ! (\"{}\" , \"Host: \" + hostname) ; println ! (\"{}\" , \"OS: \" + os_info . name + \" \" + os_info . version) ; println ! (\"{}\" , \"CPUs: \" + cpu_count . to_s ()) ; println ! (\"{}\" , \"Memory: \" + format_size (total_memory)) ; println ! (\"\") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let memory_info = system :: memory_info () ; let disk_io = system :: disk_io_stats () ; let network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\") ; println ! (\"{}\" , \"=\" * 50i32) ; println ! (\"{}\" , \"CPU: \" + cpu_usage . to_s () + \"% |\" + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () + \"|\") ; let mem_percent = memory_info . used / memory_info . total ; println ! (\"{}\" , \"MEM: \" + mem_percent . to_s () + \"% |\" + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () + \"|\") ; println ! (\"{}\" , \"     \" + format_size (memory_info . used) + \" / \" + format_size (memory_info . total)) ; println ! (\"{}\" , \"Disk Read:  \" + format_size (disk_io . read_bytes) + \"/s\") ; println ! (\"{}\" , \"Disk Write: \" + format_size (disk_io . write_bytes) + \"/s\") ; println ! (\"{}\" , \"Net Down: \" + format_size (network_stats . download_speed) + \"/s\") ; println ! (\"{}\" , \"Net Up:   \" + format_size (network_stats . upload_speed) + \"/s\") ; println ! (\"\\nTop Processes by CPU:\") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { println ! (\"{}\" , \"  \" + proc . pid . to_s () + \" \" + proc . name + \" \" + proc . cpu_percent . to_s () + \"%\") } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpz2E49d/main.rs:1:331\n  |\n1 | ...stem :: os_info () ; println ! (\"{}\" , \"Host: \" + hostname) ; println ! (\"{}\" , \"OS: \" + os_info . name + \" \" + os_info . version) ; p...\n  |                                     --    ^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                                     |\n  |                                     required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmpz2E49d/main.rs:1:396\n  |\n1 | ... (\"{}\" , \"Host: \" + hostname) ; println ! (\"{}\" , \"OS: \" + os_info . name + \" \" + os_info . version) ; println ! (\"{}\" , \"CPUs: \" + cp...\n  |                                                      ----------------------- ^ --- &str\n  |                                                      |\n  |                                                      str\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpz2E49d/main.rs:1:443\n  |\n1 | ...fo . version) ; println ! (\"{}\" , \"CPUs: \" + cpu_count . to_s ()) ; println ! (\"{}\" , \"Memory: \" + format_size (total_memory)) ; print...\n  |                                --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                                |\n  |                                required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpz2E49d/main.rs:1:508\n  |\n1 | ...ount . to_s ()) ; println ! (\"{}\" , \"Memory: \" + format_size (total_memory)) ; println ! (\"\") ; loop { { { let cpu_usage = system :: c...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpz2E49d/main.rs:1:495\n  |\n1 | ...to_s ()) ; println ! (\"{}\" , \"Memory: \" + format_size (total_memory)) ; println ! (\"\") ; loop { { { let cpu_usage = system :: cpu_usag...\n  |                           --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                           |\n  |                           required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `clear_screen` in this scope\n --> /tmp/.tmpz2E49d/main.rs:1:746\n  |\n1 | ...let network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\") ; println ! (\"{...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot multiply `&str` by `i32`\n --> /tmp/.tmpz2E49d/main.rs:1:840\n  |\n1 | ...ystem Monitor - Press Ctrl+C to exit\") ; println ! (\"{}\" , \"=\" * 50i32) ; println ! (\"{}\" , \"CPU: \" + cpu_usage . to_s () + \"% |\" + \"█...\n  |                                                               --- ^ ----- i32\n  |                                                               |\n  |                                                               &str\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmpz2E49d/main.rs:1:899\n  |\n1 | ...ln ! (\"{}\" , \"=\" * 50i32) ; println ! (\"{}\" , \"CPU: \" + cpu_usage . to_s () + \"% |\" + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 ...\n  |                                                  ----------------------------- ^ ----- &str\n  |                                                  |\n  |                                                  str\n\nerror[E0599]: no method named `to_i` found for type `i32` in the current scope\n --> /tmp/.tmpz2E49d/main.rs:1:935\n  |\n1 | ...usage . to_s () + \"% |\" + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () + \"|\") ; let mem_percent = mem...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpz2E49d/main.rs:1:907\n  |\n1 | ...\"{}\" , \"CPU: \" + cpu_usage . to_s () + \"% |\" + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () + \"|\") ; ...\n  |                                                 ^ doesn't have a size known at compile-time\n  |\n  = help: the trait `Sized` is not implemented for `str`\n\nerror[E0369]: cannot multiply `&str` by `i32`\n --> /tmp/.tmpz2E49d/main.rs:1:949\n  |\n1 | ...ge . to_s () + \"% |\" + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () + \"|\") ; let mem_percent = memory...\n  |                                                               --- ^ ----- i32\n  |                                                               |\n  |                                                               &str\n\nerror[E0599]: no method named `to_i` found for type `i32` in the current scope\n --> /tmp/.tmpz2E49d/main.rs:1:979\n  |\n1 | ...50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () + \"|\") ; let mem_percent = memory_info . used / memory_info . total ; prin...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmpz2E49d/main.rs:1:1107\n  |\n1 | ...ed / memory_info . total ; println ! (\"{}\" , \"MEM: \" + mem_percent . to_s () + \"% |\" + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i...\n  |                                                 ------------------------------- ^ ----- &str\n  |                                                 |\n  |                                                 str\n\nerror[E0599]: no method named `to_i` found for type `i32` in the current scope\n --> /tmp/.tmpz2E49d/main.rs:1:1145\n  |\n1 | ...ent . to_s () + \"% |\" + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () + \"|\") ; println ! (\"{}\" , \"...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpz2E49d/main.rs:1:1115\n  |\n1 | ...}\" , \"MEM: \" + mem_percent . to_s () + \"% |\" + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () + \"|\"...\n  |                                                 ^ doesn't have a size known at compile-time\n  |\n  = help: the trait `Sized` is not implemented for `str`\n\nerror[E0369]: cannot multiply `&str` by `i32`\n --> /tmp/.tmpz2E49d/main.rs:1:1159\n  |\n1 | ... . to_s () + \"% |\" + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () + \"|\") ; println ! (\"{}\" , \"   ...\n  |                                                               --- ^ ----- i32\n  |                                                               |\n  |                                                               &str\n\nerror[E0599]: no method named `to_i` found for type `i32` in the current scope\n --> /tmp/.tmpz2E49d/main.rs:1:1191\n  |\n1 | ...i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () + \"|\") ; println ! (\"{}\" , \"     \" + format_size (memory_info . used) + \" ...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpz2E49d/main.rs:1:1236\n  |\n1 | ...2 . to_i () + \"|\") ; println ! (\"{}\" , \"     \" + format_size (memory_info . used) + \" / \" + format_size (memory_info . total)) ; print...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmpz2E49d/main.rs:1:1269\n  |\n1 | ...2 . to_i () + \"|\") ; println ! (\"{}\" , \"     \" + format_size (memory_info . used) + \" / \" + format_size (memory_info . total)) ; print...\n  |                                           ------------------------------------------ ^ ----- &str\n  |                                           |\n  |                                           str\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpz2E49d/main.rs:1:1279\n  |\n1 | ...  \" + format_size (memory_info . used) + \" / \" + format_size (memory_info . total)) ; println ! (\"{}\" , \"Disk Read:  \" + format_size (...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpz2E49d/main.rs:1:1351\n  |\n1 | ...o . total)) ; println ! (\"{}\" , \"Disk Read:  \" + format_size (disk_io . read_bytes) + \"/s\") ; println ! (\"{}\" , \"Disk Write: \" + forma...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmpz2E49d/main.rs:1:1386\n  |\n1 | ...info . total)) ; println ! (\"{}\" , \"Disk Read:  \" + format_size (disk_io . read_bytes) + \"/s\") ; println ! (\"{}\" , \"Disk Write: \" + fo...\n  |                                       --------------------------------------------------- ^ ---- &str\n  |                                       |\n  |                                       str\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpz2E49d/main.rs:1:1431\n  |\n1 | ...es) + \"/s\") ; println ! (\"{}\" , \"Disk Write: \" + format_size (disk_io . write_bytes) + \"/s\") ; println ! (\"{}\" , \"Net Down: \" + format...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmpz2E49d/main.rs:1:1467\n  |\n1 | ...bytes) + \"/s\") ; println ! (\"{}\" , \"Disk Write: \" + format_size (disk_io . write_bytes) + \"/s\") ; println ! (\"{}\" , \"Net Down: \" + for...\n  |                                       ---------------------------------------------------- ^ ---- &str\n  |                                       |\n  |                                       str\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpz2E49d/main.rs:1:1510\n  |\n1 | ...ytes) + \"/s\") ; println ! (\"{}\" , \"Net Down: \" + format_size (network_stats . download_speed) + \"/s\") ; println ! (\"{}\" , \"Net Up:   \"...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmpz2E49d/main.rs:1:1555\n  |\n1 | ...s) + \"/s\") ; println ! (\"{}\" , \"Net Down: \" + format_size (network_stats . download_speed) + \"/s\") ; println ! (\"{}\" , \"Net Up:   \" + ...\n  |                                   ----------------------------------------------------------- ^ ---- &str\n  |                                   |\n  |                                   str\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpz2E49d/main.rs:1:1598\n  |\n1 | ...peed) + \"/s\") ; println ! (\"{}\" , \"Net Up:   \" + format_size (network_stats . upload_speed) + \"/s\") ; println ! (\"\\nTop Processes by C...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmpz2E49d/main.rs:1:1641\n  |\n1 | ...ed) + \"/s\") ; println ! (\"{}\" , \"Net Up:   \" + format_size (network_stats . upload_speed) + \"/s\") ; println ! (\"\\nTop Processes by CPU...\n  |                                    --------------------------------------------------------- ^ ---- &str\n  |                                    |\n  |                                    str\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmpz2E49d/main.rs:1:1850\n  |\n1 | ...) ; for proc in processes { { println ! (\"{}\" , \"  \" + proc . pid . to_s () + \" \" + proc . name + \" \" + proc . cpu_percent . to_s () +...\n  |                                                    --------------------------- ^ --- &str\n  |                                                    |\n  |                                                    str\n\nwarning: unreachable expression\n --> /tmp/.tmpz2E49d/main.rs:1:1948\n  |\n1 | ... ; loop { { { let cpu_usage = system :: cpu_usage () ; { let memory_info = system :: memory_info () ; let disk_io = system :: disk_io_stats () ; let network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\") ; println ! (\"{}\" , \"=\" * 50i32) ; println ! (\"{}\" , \"CPU: \" + cpu_usage . to_s () + \"% |\" + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () + \"|\") ; let mem_percent = memory_info . used / memory_info . total ; println ! (\"{}\" , \"MEM: \" + mem_percent . to_s () + \"% |\" + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () + \"|\") ; println ! (\"{}\" , \"     \" + format_size (memory_info . used) + \" / \" + format_size (memory_info . total)) ; println ! (\"{}\" , \"Disk Read:  \" + format_size (disk_io . read_bytes) + \"/s\") ; println ! (\"{}\" , \"Disk Write: \" + format_size (disk_io . write_bytes) + \"/s\") ; println ! (\"{}\" , \"Net Down: \" + format_size (network_stats . download_speed) + \"/s\") ; println ! (\"{}\" , \"Net Up:   \" + format_size (network_stats . upload_speed) + \"/s\") ; println ! (\"\\nTop Processes by CPU:\") ; let processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! (\"{}\" , \"  \" + proc . pid . to_s () + \" \" + proc . name + \" \" + proc . cpu_percent . to_s () + \"%\") } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |       --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression\n  |       |\n  |       any code following this expression is unreachable\n  |\n  = note: `#[warn(unreachable_code)]` on by default\n\nerror: aborting due to 32 previous errors; 6 warnings emitted\n\nSome errors have detailed explanations: E0277, E0369, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_i()"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 2,
          "line_number": 108,
          "code": "// Status: ✅ WORKING\n\n// Current process information\nlet pid = process::current_pid()\nlet ppid = process::parent_pid()\nlet exe_path = process::executable_path()\nlet args = process::args()\nlet env = process::environment()\n\n// List all processes\nlet all_processes = process::list()\nfor proc in all_processes {\n    println(\"PID: \" + proc.pid.to_s() + \", Name: \" + proc.name + \", CPU: \" + proc.cpu_percent.to_s() + \"%\")\n}\n\n// Find specific process\nlet chrome_procs = process::find_by_name(\"chrome\")\nlet high_cpu_procs = process::list()\n    .filter(|p| p.cpu_percent > 50)\n\n// Process control\nlet proc = process::from_pid(1234)\nproc.suspend()  // Pause process\nproc.resume()   // Resume process\nproc.terminate() // Request termination\nproc.kill()     // Force kill\n\n// Launch new process\nlet child = process::spawn(\"ls\", [\"-la\"])\nlet output = child.wait_with_output()\nprintln(output.stdout)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpyC11iO/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let pid = process :: current_pid () ; let ppid = process :: parent_pid ()...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpyC11iO/main.rs:1:327\n  |\n1 | ... { { println ! (\"{}\" , \"PID: \" + proc . pid . to_s () + \", Name: \" + proc . name + \", CPU: \" + proc . cpu_percent . to_s () + \"%\") } } ...\n  |       ^^                                                                                                                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { let pid = process :: current_pid () ; let ppid = process :: parent_pid () ; let exe_path = process :: executable_path () ; let args = process :: args () ; let env = process :: environment () ; let all_processes = process :: list () ; for proc in all_processes { { println ! (\"{}\" , \"PID: \" + proc . pid . to_s () + \", Name: \" + proc . name + \", CPU: \" + proc . cpu_percent . to_s () + \"%\") } } ; let chrome_procs = process :: find_by_name (\"chrome\") ; let high_cpu_procs = process :: list () . into_iter () . filter (| p | p . cpu_percent > 50i32) . collect () ; let proc = process :: from_pid (1234i32) ; proc . suspend () ; proc . resume () ; proc . terminate () ; proc . kill () ; let child = process :: spawn (\"ls\" , vec ! [\"-la\"]) ; let output = child . wait_with_output () ; println ! (\"{}\" , output . stdout) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { let pid = process :: current_pid () ; let ppid = process :: parent_pid () ; let exe_path = process :: executable_path () ; let args = process :: args () ; let env = process :: environment () ; let all_processes = process :: list () ; for proc in all_processes { println ! (\"{}\" , \"PID: \" + proc . pid . to_s () + \", Name: \" + proc . name + \", CPU: \" + proc . cpu_percent . to_s () + \"%\") } ; let chrome_procs = process :: find_by_name (\"chrome\") ; let high_cpu_procs = process :: list () . into_iter () . filter (| p | p . cpu_percent > 50i32) . collect () ; let proc = process :: from_pid (1234i32) ; proc . suspend () ; proc . resume () ; proc . terminate () ; proc . kill () ; let child = process :: spawn (\"ls\" , vec ! [\"-la\"]) ; let output = child . wait_with_output () ; println ! (\"{}\" , output . stdout) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpyC11iO/main.rs:1:75\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let pid = process :: current_pid () ; let ppid = process :: parent_pid ()...\n  |                                                                           ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpyC11iO/main.rs:1:114\n  |\n1 | ...ocess :: current_pid () ; let ppid = process :: parent_pid () ; let exe_path = process :: executable_path () ; let args = process :: a...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpyC11iO/main.rs:1:156\n  |\n1 | ...ss :: parent_pid () ; let exe_path = process :: executable_path () ; let args = process :: args () ; let env = process :: environment ...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpyC11iO/main.rs:1:199\n  |\n1 | ...s :: executable_path () ; let args = process :: args () ; let env = process :: environment () ; let all_processes = process :: list ()...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpyC11iO/main.rs:1:230\n  |\n1 | ...rgs = process :: args () ; let env = process :: environment () ; let all_processes = process :: list () ; for proc in all_processes { ...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpyC11iO/main.rs:1:278\n  |\n1 | ...environment () ; let all_processes = process :: list () ; for proc in all_processes { { println ! (\"{}\" , \"PID: \" + proc . pid . to_s ...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmpyC11iO/main.rs:1:378\n  |\n1 | ...roc in all_processes { { println ! (\"{}\" , \"PID: \" + proc . pid . to_s () + \", Name: \" + proc . name + \", CPU: \" + proc . cpu_percent ...\n  |                                               ------------------------------ ^ ---------- &str\n  |                                               |\n  |                                               str\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpyC11iO/main.rs:1:480\n  |\n1 | ...s () + \"%\") } } ; let chrome_procs = process :: find_by_name (\"chrome\") ; let high_cpu_procs = process :: list () . into_iter () . fil...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpyC11iO/main.rs:1:538\n  |\n1 | ...me (\"chrome\") ; let high_cpu_procs = process :: list () . into_iter () . filter (| p | p . cpu_percent > 50i32) . collect () ; let pro...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpyC11iO/main.rs:1:639\n  |\n1 | ...t > 50i32) . collect () ; let proc = process :: from_pid (1234i32) ; proc . suspend () ; proc . resume () ; proc . terminate () ; proc...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpyC11iO/main.rs:1:761\n  |\n1 | ...te () ; proc . kill () ; let child = process :: spawn (\"ls\" , vec ! [\"-la\"]) ; let output = child . wait_with_output () ; println ! (\"...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror: aborting due to 11 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0369, E0433.\nFor more information about an error, try `rustc --explain E0369`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 3,
          "line_number": 151,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected identifier after '::'\n// Register signal handlers\nsignal::on(SIGINT, || {\n    println(\"\\nGracefully shutting down...\")\n    cleanup()\n    exit(0)\n})\n\nsignal::on(SIGTERM, || {\n    save_state()\n    exit(0)\n})\n\nsignal::on(SIGUSR1, || {\n    reload_config()\n})\n\n// Send signals to other processes\nlet target_pid = 1234\nsignal::send(target_pid, SIGUSR1)\n\n// Block/unblock signals\nsignal::block([SIGPIPE])\ncritical_operation()\nsignal::unblock([SIGPIPE])",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 4,
          "line_number": 188,
          "code": "// Status: ✅ WORKING\n\n// Get memory information\nlet mem_info = system::memory_info()\nprintln(\"Total: \" + mem_info.total.to_s())\nprintln(\"Used: \" + mem_info.used.to_s())\nprintln(\"Free: \" + mem_info.free.to_s())\nprintln(\"Available: \" + mem_info.available.to_s())\nprintln(\"Swap Used: \" + mem_info.swap_used.to_s())\n\n// Monitor memory pressure\nif mem_info.available < 100_000_000 {  // Less than 100MB\n    println(\"WARNING: Low memory!\")\n    free_caches()\n}\n\n// Memory-mapped files for large data\nlet mmap = memory::map_file(\"huge_dataset.bin\", READ_ONLY)\nlet data = mmap.read_range(0, 1000000)  // Read 1MB\nmmap.close()\n\n// Shared memory between processes\nlet shared = memory::create_shared(\"my_buffer\", 1024 * 1024)\nshared.write(0, data)\n\n// In another process\nlet shared = memory::open_shared(\"my_buffer\")\nlet data = shared.read(0, 1024)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpci4At5/main.rs:1:856\n  |\n1 | ... data = shared . read (0i32 , 1024i32) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0425]: cannot find value `_000_000` in this scope\n --> /tmp/.tmpci4At5/main.rs:1:454\n  |\n1 | ...ed . to_s ()) ; if mem_info . available < 100i32 { _000_000 } ; { println ! (\"WARNING: Low memory!\") ; free_caches () } ; let mmap = m...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `READ_ONLY` in this scope\n --> /tmp/.tmpci4At5/main.rs:1:577\n  |\n1 | ...t mmap = memory :: map_file (\"huge_dataset.bin\" , READ_ONLY) ; let data = mmap . read_range (0i32 , 1000000i32) ; mmap . close () ; le...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpci4At5/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mem_info = system :: memory_info () ; println ! (\"{}\" , \"Total: \" + m...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `system`\n --> /tmp/.tmpci4At5/main.rs:1:80\n  |\n1 | ...in () { let result = { let mem_info = system :: memory_info () ; println ! (\"{}\" , \"Total: \" + mem_info . total . to_s ()) ; println !...\n  |                                          ^^^^^^ use of unresolved module or unlinked crate `system`\n  |\n  = help: you might be missing a crate named `system`\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpci4At5/main.rs:1:125\n  |\n1 | ...y_info () ; println ! (\"{}\" , \"Total: \" + mem_info . total . to_s ()) ; println ! (\"{}\" , \"Used: \" + mem_info . used . to_s ()) ; prin...\n  |                            --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                            |\n  |                            required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpci4At5/main.rs:1:185\n  |\n1 | .... to_s ()) ; println ! (\"{}\" , \"Used: \" + mem_info . used . to_s ()) ; println ! (\"{}\" , \"Free: \" + mem_info . free . to_s ()) ; print...\n  |                             --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                             |\n  |                             required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpci4At5/main.rs:1:243\n  |\n1 | .... to_s ()) ; println ! (\"{}\" , \"Free: \" + mem_info . free . to_s ()) ; println ! (\"{}\" , \"Available: \" + mem_info . available . to_s (...\n  |                             --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                             |\n  |                             required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpci4At5/main.rs:1:301\n  |\n1 | ...s ()) ; println ! (\"{}\" , \"Available: \" + mem_info . available . to_s ()) ; println ! (\"{}\" , \"Swap Used: \" + mem_info . swap_used . t...\n  |                        --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                        |\n  |                        required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpci4At5/main.rs:1:369\n  |\n1 | ...s ()) ; println ! (\"{}\" , \"Swap Used: \" + mem_info . swap_used . to_s ()) ; if mem_info . available < 100i32 { _000_000 } ; { println ...\n  |                        --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                        |\n  |                        required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `free_caches` in this scope\n --> /tmp/.tmpci4At5/main.rs:1:506\n  |\n1 | ...0_000 } ; { println ! (\"WARNING: Low memory!\") ; free_caches () } ; let mmap = memory :: map_file (\"huge_dataset.bin\" , READ_ONLY) ; l...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `memory`\n --> /tmp/.tmpci4At5/main.rs:1:536\n  |\n1 | ...ry!\") ; free_caches () } ; let mmap = memory :: map_file (\"huge_dataset.bin\" , READ_ONLY) ; let data = mmap . read_range (0i32 , 10000...\n  |                                          ^^^^^^ use of unresolved module or unlinked crate `memory`\n  |\n  = help: you might be missing a crate named `memory`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `memory`\n --> /tmp/.tmpci4At5/main.rs:1:672\n  |\n1 | ...i32) ; mmap . close () ; let shared = memory :: create_shared (\"my_buffer\" , 1024i32 * 1024i32) ; shared . write (0i32 , data) ; let s...\n  |                                          ^^^^^^ use of unresolved module or unlinked crate `memory`\n  |\n  = help: you might be missing a crate named `memory`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `memory`\n --> /tmp/.tmpci4At5/main.rs:1:776\n  |\n1 | ... . write (0i32 , data) ; let shared = memory :: open_shared (\"my_buffer\") ; let data = shared . read (0i32 , 1024i32) } ; if let Some ...\n  |                                          ^^^^^^ use of unresolved module or unlinked crate `memory`\n  |\n  = help: you might be missing a crate named `memory`\n\nerror: aborting due to 13 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0277, E0425, E0433.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 5,
          "line_number": 228,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected identifier or string key in object literal\n// File: service_manager.ruchy\n// Manage system services\n\nprintln(\"=== Service Manager ===\")\n\nlet services = [\n    {name: \"web_server\", command: \"./server\", port: 8080},\n    {name: \"worker\", command: \"./worker\", count: 4},\n    {name: \"scheduler\", command: \"./scheduler\", interval: 60}\n]\n\nlet running_services = {}\n\nfun start_service(service) {\n    println(\"Starting \" + service.name + \"...\")\n    \n    match service.name {\n        \"web_server\" => {\n            let proc = process::spawn(service.command, [\n                \"--port\", service.port.to_s()\n            ])\n            running_services[service.name] = proc\n            \n            // Wait for port to be available\n            while !network::port_is_open(\"localhost\", service.port) {\n                sleep(100)\n            }\n            println(\"✅ \" + service.name + \" listening on port \" + service.port.to_s())\n        }\n        \"worker\" => {\n            let workers = []\n            for i in range(service.count) {\n                let proc = process::spawn(service.command, [\n                    \"--id\", i.to_s()\n                ])\n                workers.push(proc)\n            }\n            running_services[service.name] = workers\n            println(\"✅ Started \" + service.count.to_s() + \" workers\")\n        }\n        \"scheduler\" => {\n            let proc = process::spawn(service.command, [\n                \"--interval\", service.interval.to_s()\n            ])\n            running_services[service.name] = proc\n            println(\"✅ Scheduler running every \" + service.interval.to_s() + \"s\")\n        }\n    }\n}\n\nfun stop_service(name) {\n    if running_services.has_key(name) {\n        println(\"Stopping \" + name + \"...\")\n        let proc = running_services[name]\n        \n        if proc.is_array() {\n            // Multiple processes (workers)\n            for p in proc {\n                p.terminate()\n                p.wait()\n            }\n        } else {\n            // Single process\n            proc.terminate()\n            proc.wait()\n        }\n        \n        running_services.remove(name)\n        println(\"✅ \" + name + \" stopped\")\n    }\n}\n\nfun service_status() {\n    println(\"\\n=== Service Status ===\")\n    for service in services {\n        let status = if running_services.has_key(service.name) {\n            \"🟢 Running\"\n        } else {\n            \"🔴 Stopped\"\n        }\n        println(service.name + \" \" + status)\n    }\n}\n\n// Handle shutdown gracefully\nsignal::on(SIGTERM, || {\n    println(\"\\nShutting down all services...\")\n    for name in running_services.keys() {\n        stop_service(name)\n    }\n    exit(0)\n})\n\n// Interactive management\nloop {\n    service_status()\n    println(\"\\nCommands: start <name>, stop <name>, restart <name>, quit\")\n    let command = input(\"> \").split(\" \")\n    \n    match command[0] {\n        \"start\" => start_service(services.find(|s| s.name == command[1]))\n        \"stop\" => stop_service(command[1])\n        \"restart\" => {\n            stop_service(command[1])\n            start_service(services.find(|s| s.name == command[1]))\n        }\n        \"quit\" => break\n        _ => println(\"Unknown command\")\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 6,
          "line_number": 349,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: Question\n// File: health_check.ruchy\n// Monitor system health and alert on issues\n\nprintln(\"=== System Health Checker ===\")\n\nlet checks = {\n    cpu_threshold: 80,      // Alert if CPU > 80%\n    memory_threshold: 90,   // Alert if memory > 90%\n    disk_threshold: 95,     // Alert if disk > 95%\n    load_threshold: 4.0,    // Alert if load average > 4\n    temp_threshold: 80      // Alert if CPU temp > 80°C\n}\n\nlet alerts = []\n\nfun check_cpu() {\n    let usage = system::cpu_usage() * 100\n    if usage > checks.cpu_threshold {\n        alerts.push({\n            level: \"WARNING\",\n            message: \"CPU usage high: \" + usage.to_s() + \"%\",\n            time: current_datetime()\n        })\n        return false\n    }\n    return true\n}\n\nfun check_memory() {\n    let mem = system::memory_info()\n    let usage = (mem.used / mem.total) * 100\n    if usage > checks.memory_threshold {\n        alerts.push({\n            level: \"CRITICAL\",\n            message: \"Memory usage critical: \" + usage.to_s() + \"%\",\n            time: current_datetime()\n        })\n        return false\n    }\n    return true\n}\n\nfun check_disk() {\n    let disks = system::disk_usage()\n    for disk in disks {\n        let usage = (disk.used / disk.total) * 100\n        if usage > checks.disk_threshold {\n            alerts.push({\n                level: \"WARNING\",\n                message: \"Disk \" + disk.mount + \" almost full: \" + usage.to_s() + \"%\",\n                time: current_datetime()\n            })\n            return false\n        }\n    }\n    return true\n}\n\nfun check_load() {\n    let load = system::load_average()\n    let cpu_count = system::cpu_count()\n    let normalized_load = load.one_minute / cpu_count\n    \n    if normalized_load > checks.load_threshold {\n        alerts.push({\n            level: \"WARNING\",\n            message: \"System load high: \" + load.one_minute.to_s() + \",\",\n            time: current_datetime()\n        })\n        return false\n    }\n    return true\n}\n\nfun check_temperature() {\n    let temps = system::temperatures()\n    for sensor in temps {\n        if sensor.current > checks.temp_threshold {\n            alerts.push({\n                level: \"CRITICAL\",\n                message: \"Temperature critical: \" + sensor.name + \" at \" + sensor.current.to_s() + \"°C\",\n                time: current_datetime()\n            })\n            return false\n        }\n    }\n    return true\n}\n\nfun run_health_checks() {\n    let all_healthy = true\n    \n    all_healthy = check_cpu() && all_healthy\n    all_healthy = check_memory() && all_healthy\n    all_healthy = check_disk() && all_healthy\n    all_healthy = check_load() && all_healthy\n    all_healthy = check_temperature() && all_healthy\n    \n    return all_healthy\n}\n\n// Main monitoring loop\nloop {\n    clear_screen()\n    println(\"System Health Check - \" + current_datetime())\n    println(\"=\" * 50)\n    \n    let healthy = run_health_checks()\n    \n    if healthy {\n        println(\"✅ All systems healthy\")\n    } else {\n        println(\"⚠️  Issues detected:\")\n        for alert in alerts.last(5) {\n            let icon = alert.level == \"CRITICAL\" ? \"🔴\" : \"🟡\"\n            println(icon + \" [\" + alert.level + \"] \" + alert.message)\n        }\n    }\n    \n    // Show current stats\n    println(\"\\nCurrent Status:\")\n    let cpu = system::cpu_usage() * 100\n    let mem = system::memory_info()\n    let mem_percent = (mem.used / mem.total) * 100\n    let load = system::load_average()\n    \n    println(\"CPU:    \" + cpu.to_s() + \"% / \" + checks.cpu_threshold.to_s() + \"%\")\n    println(\"Memory: \" + mem_percent.to_s() + \"% / \" + checks.memory_threshold.to_s() + \"%\")\n    println(\"Load:   \" + load.one_minute.to_s() + \" / \" + checks.load_threshold.to_s())\n    \n    // Send notifications for critical alerts\n    for alert in alerts {\n        if alert.level == \"CRITICAL\" {\n            system::notify(alert.message, \"System Health Alert\")\n        }\n    }\n    \n    sleep(5000)  // Check every 5 seconds\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 7,
          "line_number": 499,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected In, found Comma\n// File: process_tree.ruchy\n// Visualize process hierarchy\n\nfun build_process_tree() {\n    let processes = process::list()\n    let tree = {}\n    \n    // Build parent-child relationships\n    for proc in processes {\n        let ppid = proc.parent_pid\n        if !tree.has_key(ppid) {\n            tree[ppid] = []\n        }\n        tree[ppid].push(proc)\n    }\n    \n    return tree\n}\n\nfun print_tree(pid, tree, indent = \"\") {\n    if !tree.has_key(pid) {\n        return\n    }\n    \n    let children = tree[pid].sort_by(|p| p.pid)\n    for i, proc in children.enumerate() {\n        let is_last = (i == children.len() - 1)\n        let prefix = is_last ? \"└─\" : \"├─\"\n        let extension = is_last ? \"  \" : \"│ \"\n        \n        let memory = format_size(proc.memory_info.rss)\n        println(indent + prefix + \" [\" + proc.pid.to_s() + \"] \" + proc.name + \" (\" + memory + \", \" + proc.cpu_percent.to_s() + \"%)\")\n        \n        // Recursively print children\n        print_tree(proc.pid, tree, indent + extension)\n    }\n}\n\nprintln(\"=== Process Tree ===\")\nlet tree = build_process_tree()\n\n// Start from init (PID 1) or system idle (PID 0)\nlet root_pid = tree.has_key(0) ? 0 : 1\nprintln(\"[\" + root_pid.to_s() + \"] System Root\")\nprint_tree(root_pid, tree)\n\n// Show process statistics\nlet all_procs = process::list()\nlet total_memory = all_procs.map(|p| p.memory_info.rss).sum()\nlet total_cpu = all_procs.map(|p| p.cpu_percent).sum()\n\nprintln(\"\\nTotal Processes: \" + all_procs.len().to_s())\nprintln(\"Total Memory: \" + format_size(total_memory))\nprintln(\"Total CPU: \" + total_cpu.to_s() + \"%\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 8,
          "line_number": 568,
          "code": "// Status: ✅ WORKING\n\n// Watch for file system events\nlet watcher = fs::watch(\"/path/to/watch\", RECURSIVE)\n\nwatcher.on(\"created\", |path| {\n    println(\"File created: \" + path)\n})\n\nwatcher.on(\"modified\", |path| {\n    println(\"File modified: \" + path)\n    process_change(path)\n})\n\nwatcher.on(\"deleted\", |path| {\n    println(\"File deleted: \" + path)\n})\n\nwatcher.start()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `RECURSIVE` in this scope\n --> /tmp/.tmpIms1V1/main.rs:1:111\n  |\n1 | ...= { let watcher = fs :: watch (\"/path/to/watch\" , RECURSIVE) ; watcher . on (\"created\" , | path | { println ! (\"{}\" , \"File created: \"...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpIms1V1/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let watcher = fs :: watch (\"/path/to/watch\" , RECURSIVE) ; watcher . on (...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n --> /tmp/.tmpIms1V1/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let watcher = fs :: watch (\"/path/to/watch\" , RECURSIVE) ; watcher . on (...\n  |                                                                               ^^ use of unresolved module or unlinked crate `fs`\n  |\n  = help: you might be missing a crate named `fs`\n\nerror[E0369]: cannot add `_` to `&str`\n --> /tmp/.tmpIms1V1/main.rs:1:196\n  |\n1 | ...atcher . on (\"created\" , | path | { println ! (\"{}\" , \"File created: \" + path) }) ; watcher . on (\"modified\" , | path | { println ! (\"...\n  |                                                          ---------------- ^ ---- _\n  |                                                          |\n  |                                                          &str\n\nerror[E0369]: cannot add `_` to `&str`\n --> /tmp/.tmpIms1V1/main.rs:1:283\n  |\n1 | ...tcher . on (\"modified\" , | path | { println ! (\"{}\" , \"File modified: \" + path) ; process_change (path) }) ; watcher . on (\"deleted\" ,...\n  |                                                          ----------------- ^ ---- _\n  |                                                          |\n  |                                                          &str\n\nerror[E0425]: cannot find function `process_change` in this scope\n --> /tmp/.tmpIms1V1/main.rs:1:293\n  |\n1 | ...{ println ! (\"{}\" , \"File modified: \" + path) ; process_change (path) }) ; watcher . on (\"deleted\" , | path | { println ! (\"{}\" , \"Fil...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `_` to `&str`\n --> /tmp/.tmpIms1V1/main.rs:1:392\n  |\n1 | ...atcher . on (\"deleted\" , | path | { println ! (\"{}\" , \"File deleted: \" + path) }) ; watcher . start () } ; if let Some (s) = (& result...\n  |                                                          ---------------- ^ ---- _\n  |                                                          |\n  |                                                          &str\n\nerror: aborting due to 6 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0369, E0425, E0433.\nFor more information about an error, try `rustc --explain E0369`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 9,
          "line_number": 597,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected RightParen, found Colon\n// Automated system maintenance\nfun auto_cleanup() {\n    // Clean temp files older than 7 days\n    let temp_dir = \"/tmp\"\n    let cutoff_time = current_time() - days(7)\n    \n    for file in fs::walk(temp_dir) {\n        if fs::modified_time(file) < cutoff_time {\n            fs::remove(file)\n            println(\"Cleaned: \" + file)\n        }\n    }\n    \n    // Clear package manager cache\n    if fs::dir_size(\"/var/cache/apt\") > gb(1) {\n        run_command(\"apt-get clean\")\n    }\n    \n    // Rotate logs\n    for log in fs::glob(\"/var/log/*.log\") {\n        if fs::size(log) > mb(100) {\n            fs::rotate_log(log, keep_count: 5)\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch08-00-advanced-functions-tdd": {
      "chapter": "ch08-00-advanced-functions-tdd",
      "total_examples": 9,
      "working_examples": 5,
      "failing_examples": 4,
      "examples": [
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 1,
          "line_number": 17,
          "code": "fun double(x: i32) -> i32 {\n    return x * 2;\n}\n\nfun add_ten(x: i32) -> i32 {\n    return x + 10;\n}\n\nfun main() {\n    let x = 5;\n    let doubled = double(x);\n    let result = add_ten(doubled);\n    println(result);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 2,
          "line_number": 43,
          "code": "fun classify_number(x: i32) -> i32 {\n    if x < 0 {\n        return -1;\n    }\n    if x == 0 {\n        return 0;\n    }\n    return 1;\n}\n\nfun main() {\n    println(classify_number(-5));\n    println(classify_number(0));\n    println(classify_number(10));\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 3,
          "line_number": 72,
          "code": "fun factorial(n: i32) -> i32 {\n    if n <= 1 {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nfun main() {\n    println(factorial(1));\n    println(factorial(3));\n    println(factorial(5));\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 4,
          "line_number": 117,
          "code": "fun step_one(x: Type) -> Type { ... }\nfun step_two(x: Type) -> Type { ... }\n\n// Usage\nlet intermediate = step_one(input);\nlet result = step_two(intermediate);",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 5,
          "line_number": 127,
          "code": "fun categorize(input: Type) -> ResultType {\n    if condition1 {\n        return result1;\n    }\n    if condition2 {\n        return result2;\n    }\n    return default_result;\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `Type` in this scope\n --> /tmp/.tmpoFE4ZC/main.rs:1:60\n  |\n1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...\n  |                                                            ^^^^ not found in this scope\n\nerror[E0412]: cannot find type `ResultType` in this scope\n --> /tmp/.tmpoFE4ZC/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...\n  |                                                                     ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `condition1` in this scope\n --> /tmp/.tmpoFE4ZC/main.rs:1:87\n  |\n1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...\n  |                                                                                       ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `result1` in this scope\n --> /tmp/.tmpoFE4ZC/main.rs:1:109\n  |\n1 | ...: Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn m...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `condition2` in this scope\n --> /tmp/.tmpoFE4ZC/main.rs:1:126\n  |\n1 | ...ype { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `result2` in this scope\n --> /tmp/.tmpoFE4ZC/main.rs:1:148\n  |\n1 | ... { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `default_result` in this scope\n --> /tmp/.tmpoFE4ZC/main.rs:1:169\n  |\n1 | ...; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpoFE4ZC/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpoFE4ZC/main.rs:1:100\n  |\n1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...\n  |                                                                                                    ^^              ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n1 + use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { return result1 } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpoFE4ZC/main.rs:1:139\n  |\n1 | ... { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n  |                                                              ^^              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n1 + use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { return result2 } ; return default_result } } fn main () { }\n  |\n\nerror: aborting due to 7 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 6,
          "line_number": 140,
          "code": "fun recursive_func(n: Type) -> Type {\n    if base_condition {\n        return base_value;\n    }\n    return combine(n, recursive_func(reduce(n)));\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `Type` in this scope\n --> /tmp/.tmpGksqWs/main.rs:1:60\n  |\n1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...\n  |                                                            ^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Type` in this scope\n --> /tmp/.tmpGksqWs/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...\n  |                                                                     ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `base_condition` in this scope\n --> /tmp/.tmpGksqWs/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...\n  |                                                                                 ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `base_value` in this scope\n --> /tmp/.tmpGksqWs/main.rs:1:107\n  |\n1 | ... : Type) -> Type { { if base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpGksqWs/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpGksqWs/main.rs:1:98\n  |\n1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...\n  |                                                                                                  ^^                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { return base_value } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }\n  |\n\nerror[E0425]: cannot find function `reduce` in this scope\n --> /tmp/.tmpGksqWs/main.rs:1:160\n  |\n1 | ...ase_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }\n  |                                                        ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `combine` in this scope\n --> /tmp/.tmpGksqWs/main.rs:1:131\n  |\n1 | ... base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }\n  |                                                       ^^^^^^^ not found in this scope\n\nerror: aborting due to 6 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 7,
          "line_number": 164,
          "code": "fun validate(input: i32) -> i32 { ... }\nfun normalize(input: i32) -> i32 { ... }\nfun process(input: i32) -> i32 { ... }\n\n// Usage\nlet clean_input = validate(raw_input);\nlet normal_input = normalize(clean_input);\nlet result = process(normal_input);",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 8,
          "line_number": 176,
          "code": "fun get_grade(score: i32) -> i32 {\n    if score >= 90 {\n        return 4; // A\n    }\n    if score >= 80 {\n        return 3; // B\n    }\n    if score >= 70 {\n        return 2; // C\n    }\n    return 1; // D/F\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 9,
          "line_number": 192,
          "code": "fun countdown(n: i32) -> i32 {\n    if n <= 0 {\n        return 0;\n    }\n    println(n);\n    return countdown(n - 1);\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch13-00-error-handling": {
      "chapter": "ch13-00-error-handling",
      "total_examples": 12,
      "working_examples": 0,
      "failing_examples": 12,
      "examples": [
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected RightBrace, found Identifier(\"ParseError\")\n// Define error types\nenum AppError {\n    NetworkError(String)\n    ParseError(String)\n    NotFound(String)\n    Unauthorized\n}\n\n// Functions return Result\nfun fetch_user(id: i32) -> Result<User, AppError> {\n    // Note: In v0.11.0, the ? operator is removed. Use match for error handling:\n    let response = match http::get(\"/api/users/\" + id.to_s()) {\n        Ok(r) => r,\n        Err(e) => return Err(AppError::NetworkError(e))\n    }\n    \n    if response.status == 404 {\n        return Err(AppError::NotFound(\"User \" + id.to_s() + \" not found\"))\n    }\n    \n    if response.status == 401 {\n        return Err(AppError::Unauthorized)\n    }\n    \n    let user = match parse_json(response.body) {\n        Ok(u) => u,\n        Err(e) => return Err(AppError::ParseError(e.to_string()))\n    }\n    \n    return Ok(user)\n}\n\n// Handle errors explicitly\nmatch fetch_user(123) {\n    Ok(user) => {\n        println(\"Found user: \" + user.name)\n    }\n    Err(AppError::NotFound(msg)) => {\n        println(\"User not found: \" + msg)\n    }\n    Err(AppError::NetworkError(e)) => {\n        println(\"Network problem: \" + e.to_s())\n        retry_with_backoff()\n    }\n    Err(e) => {\n        log_error(e)\n        return_default_user()\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 2,
          "line_number": 96,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected enum name\n// Result is an enum with two variants\nenum Result<T, E> {\n    Ok(T)    // Success with value\n    Err(E)   // Error with error value\n}\n\n// Functions that can fail return Result\nfun divide(a: f64, b: f64) -> Result<f64, String> {\n    if b == 0.0 {\n        return Err(\"Division by zero\")\n    }\n    return Ok(a / b)\n}\n\n// Check and handle results\nlet result = divide(10.0, 2.0)\nif result.is_ok() {\n    println(\"Result: \" + result.unwrap().to_s())\n} else {\n    println(\"Error: \" + result.unwrap_err().to_s())\n}\n\n// Pattern matching\nmatch divide(10.0, 0.0) {\n    Ok(value) => println(\"Success: \" + value.to_s())\n    Err(error) => println(\"Failed: \" + error.to_s())\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 3,
          "line_number": 136,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected enum name\n// Option represents nullable values\nenum Option<T> {\n    Some(T)  // Value present\n    None     // Value absent\n}\n\n// Functions that might not return a value\nfun find_user(name: String) -> Option<User> {\n    let users = load_users()\n    for user in users {\n        if user.name == name {\n            return Some(user)\n        }\n    }\n    return None\n}\n\n// Safe handling of missing values\nlet user = find_user(\"Alice\")\nif let Some(u) = user {\n    println(\"Found: \" + u.email)\n} else {\n    println(\"User not found\")\n}\n\n// Chain operations safely\nlet email = find_user(\"Bob\")\n    .map(|u| u.email)\n    .unwrap_or(\"no-email@example.com\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 4,
          "line_number": 178,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected type\n// Without ? operator - verbose\nfun process_file_verbose(path: String) -> Result<String, Error> {\n    let file = match open_file(path) {\n        Ok(f) => f\n        Err(e) => return Err(e)\n    }\n    \n    let contents = match read_all(file) {\n        Ok(c) => c\n        Err(e) => return Err(e)\n    }\n    \n    let processed = match process(contents) {\n        Ok(p) => p\n        Err(e) => return Err(e)\n    }\n    \n    return Ok(processed)\n}\n\n// In v0.11.0 - use explicit error handling\nfun process_file(path: String) -> Result<String, Error> {\n    let file = match open_file(path) {\n        Ok(f) => f,\n        Err(e) => return Err(e)\n    }\n    let contents = match read_all(file) {\n        Ok(c) => c,\n        Err(e) => return Err(e)\n    }\n    let processed = match process(contents) {\n        Ok(p) => p,\n        Err(e) => return Err(e)\n    }\n    return Ok(processed)\n}\n\n// Chain multiple operations with explicit handling\nfun complex_operation() -> Result<Data, Error> {\n    let data = match fetch_data() {\n        Ok(d) => d,\n        Err(e) => return Err(e)\n    }\n    let validated = match data.validate() {\n        Ok(v) => v,\n        Err(e) => return Err(e)\n    }\n    let transformed = match validated.transform() {\n        Ok(t) => t,\n        Err(e) => return Err(e)\n    }\n    let optimized = match transformed.optimize() {\n        Ok(o) => o,\n        Err(e) => return Err(e)\n    }\n    \n    return Ok(optimized)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 5,
          "line_number": 249,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected RightBrace, found LeftBrace\n// Detailed error enum\nenum DatabaseError {\n    ConnectionFailed { host: String, port: i32 }\n    QueryFailed { query: String, error: String }\n    Timeout { duration: i32 }\n    InvalidCredentials\n}\n\nimpl Display for DatabaseError {\n    fun fmt(self, f: Formatter) -> Result {\n        match self {\n            ConnectionFailed{host, port} => \n                write(f, \"Failed to connect to \" + host + \":\" + port.to_s())\n            QueryFailed{query, error} => \n                write(f, \"Query failed: \" + query + \"\\nError: \" + error)\n            Timeout{duration} => \n                write(f, \"Operation timed out after \" + duration.to_s() + \"ms\")\n            InvalidCredentials => \n                write(f, \"Invalid database credentials\")\n        }\n    }\n}\n\n// Error with context\nstruct Error {\n    kind: ErrorKind\n    message: String\n    source: Option<Box<Error>>\n    backtrace: Backtrace\n}\n\nimpl Error {\n    fun new(kind: ErrorKind, message: String) -> Error {\n        return Error{\n            kind,\n            message,\n            source: None,\n            backtrace: Backtrace::capture()\n        }\n    }\n    \n    fun with_source(mut self, source: Error) -> Error {\n        self.source = Some(Box::new(source))\n        return self\n    }\n    \n    fun chain(self) -> Vec<String> {\n        let mut messages = vec![self.message]\n        let mut current = self.source\n        \n        while let Some(error) = current {\n            messages.push(error.message)\n            current = error.source\n        }\n        \n        return messages\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 6,
          "line_number": 322,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected type\nfun validate_user(user: User) -> Result<User, ValidationError> {\n    // Early return on validation failures\n    if user.name.is_empty() {\n        return Err(ValidationError::EmptyName)\n    }\n    \n    if !is_valid_email(user.email) {\n        return Err(ValidationError::InvalidEmail(user.email))\n    }\n    \n    if user.age < 0 || user.age > 150 {\n        return Err(ValidationError::InvalidAge(user.age))\n    }\n    \n    // All validations passed\n    return Ok(user)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 7,
          "line_number": 352,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected RightParen, found LeftParen\n// Retry with exponential backoff\nfun fetch_with_retry<T>(\n    operation: Fn() -> Result<T, Error>,\n    max_attempts: i32\n) -> Result<T, Error> {\n    let mut attempt = 0\n    let mut delay = 1000  // Start with 1 second\n    \n    loop {\n        match operation() {\n            Ok(result) => return Ok(result)\n            Err(e) if attempt >= max_attempts => {\n                return Err(e)\n            }\n            Err(e) => {\n                println(\"Attempt \" + (attempt + 1).to_s() + \" failed: \" + e.to_s())\n                sleep(delay)\n                delay *= 2  // Exponential backoff\n                attempt += 1\n            }\n        }\n    }\n}\n\n// Fallback strategies\nfun get_config() -> Config {\n    load_config_file()\n        .or_else(|| load_env_config())\n        .or_else(|| fetch_remote_config())\n        .unwrap_or_else(|| Config::default())\n}\n\n// Circuit breaker pattern\nstruct CircuitBreaker {\n    failure_count: i32\n    last_failure: Option<Instant>\n    state: State\n}\n\nimpl CircuitBreaker {\n    fn call<T>(mut self, f: Fn() -> Result<T, Error>) -> Result<T, Error> {\n        match self.state {\n            State::Open => {\n                if self.should_attempt() {\n                    self.state = State::HalfOpen\n                } else {\n                    return Err(Error::CircuitOpen)\n                }\n            }\n            _ => {}\n        }\n        \n        match f() {\n            Ok(result) => {\n                self.reset()\n                Ok(result)\n            }\n            Err(e) => {\n                self.record_failure()\n                Err(e)\n            }\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 8,
          "line_number": 429,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected type\n// Trait for adding context\ntrait Context<T> {\n    fun context(self, msg: String) -> Result<T, Error>\n    fun with_context<F>(self, f: F) -> Result<T, Error>\n        where F: FnOnce() -> String\n}\n\nimpl<T, E: Into<Error>> Context<T> for Result<T, E> {\n    fun context(self, msg: String) -> Result<T, Error> {\n        self.map_err(|e| {\n            Error::new(e.into())\n                .with_message(msg)\n        })\n    }\n    \n    fun with_context<F>(self, f: F) -> Result<T, Error>\n        where F: FnOnce() -> String\n    {\n        self.map_err(|e| {\n            Error::new(e.into())\n                .with_message(f())\n        })\n    }\n}\n\n// Use context for better errors\nfun process_order(order_id: i32) -> Result<Order, Error> {\n    let order = fetch_order(order_id)\n        .context(\"Failed to fetch order \" + order_id)??\n    \n    let validated = validate_order(order)\n        .context(\"Order validation failed\")?\n    \n    let processed = process_payment(validated)\n        .with_context(|| \"Payment processing failed for $\" + validated.total.to_s())??\n    \n    return Ok(processed)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 9,
          "line_number": 480,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected RightBrace, found Identifier(\"code\")\n// Structured API errors\nstruct ApiError {\n    status: i32\n    code: String\n    message: String\n    details: Option<Map<String, Any>>\n}\n\nimpl ApiError {\n    fun bad_request(message: String) -> ApiError {\n        ApiError{\n            status: 400,\n            code: \"BAD_REQUEST\",\n            message,\n            details: None\n        }\n    }\n    \n    fun unauthorized() -> ApiError {\n        ApiError{\n            status: 401,\n            code: \"UNAUTHORIZED\",\n            message: \"Authentication required\",\n            details: None\n        }\n    }\n    \n    fun internal_error(error: Error) -> ApiError {\n        // Log full error internally\n        log::error(\"Internal error: \" + error.chain().join(\" -> \"))\n        \n        // Return sanitized error to client\n        ApiError{\n            status: 500,\n            code: \"INTERNAL_ERROR\",\n            message: \"An internal error occurred\",\n            details: None\n        }\n    }\n}\n\n// Convert to HTTP response\nimpl IntoResponse for ApiError {\n    fun into_response(self) -> Response {\n        Response::builder()\n            .status(self.status)\n            .json(self)\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 10,
          "line_number": 540,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: Type\n// Composable validators\ntype Validator<T> = Fn(T) -> Result<T, ValidationError>\n\nfun validate_pipeline<T>(\n    value: T,\n    validators: Vec<Validator<T>>\n) -> Result<T, Vec<ValidationError>> {\n    let mut errors = Vec::new()\n    let mut current = value\n    \n    for validator in validators {\n        match validator(current) {\n            Ok(validated) => current = validated\n            Err(e) => errors.push(e)\n        }\n    }\n    \n    if errors.is_empty() {\n        Ok(current)\n    } else {\n        Err(errors)\n    }\n}\n\n// Use validation pipeline\nlet user_validators = vec![\n    validate_required_fields,\n    validate_email_format,\n    validate_age_range,\n    validate_unique_username\n]\n\nmatch validate_pipeline(user, user_validators) {\n    Ok(valid_user) => save_user(valid_user)\n    Err(errors) => {\n        for error in errors {\n            println(\"Validation error: \" + error.to_s())\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 11,
          "line_number": 591,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected type\n// Async Result type\nasync fun fetch_data(url: String) -> Result<Data, Error> {\n    let response = http::get(url).await?\n    let parsed = parse_response(response).await?\n    return Ok(parsed)\n}\n\n// Try multiple sources\nasync fun get_data_with_fallback() -> Result<Data, Error> {\n    // Try primary source\n    if let Ok(data) = fetch_data(PRIMARY_URL).await {\n        return Ok(data)\n    }\n    \n    // Try backup source\n    if let Ok(data) = fetch_data(BACKUP_URL).await {\n        return Ok(data)\n    }\n    \n    // Try cache\n    if let Some(cached) = get_cached_data().await {\n        log::warn(\"Using stale cached data\")\n        return Ok(cached)\n    }\n    \n    return Err(Error::NoDataAvailable)\n}\n\n// Parallel error handling\nasync fun fetch_all(urls: Vec<String>) -> Vec<Result<Data, Error>> {\n    let futures = urls.map(|url| fetch_data(url))\n    return join_all(futures).await\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 12,
          "line_number": 635,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: Underscore\n#[test]\nfun test_error_handling() {\n    // Test expected errors\n    let result = divide(10.0, 0.0)\n    assert!(result.is_err())\n    assert_eq!(result.unwrap_err(), \"Division by zero\")\n    \n    // Test error propagation\n    let result = process_invalid_file()\n    assert!(matches!(result, Err(FileError::NotFound(_))))\n    \n    // Test recovery\n    let config = get_config_with_fallback()\n    assert!(config.is_valid())  // Should always succeed\n}\n\n#[test]\n#[should_panic(expected = \"assertion failed\")]\nfun test_panic_condition() {\n    unsafe_operation()\n}\n\n// Property-based testing for error conditions\n#[property_test]\nfun never_panics(input: RandomInput) {\n    let _ = safe_process(input)  // Should never panic\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch03-01-testing-functions": {
      "chapter": "ch03-01-testing-functions",
      "total_examples": 12,
      "working_examples": 0,
      "failing_examples": 12,
      "examples": [
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ✅ WORKING\n// Your function\nfun add(a, b) {\n    a + b\n}\n\n// Your test\n#[test]\nfun test_add() {\n    assert_eq!(add(2, 3), 5)\n    assert_eq!(add(0, 0), 0)\n    assert_eq!(add(-1, 1), 0)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 2,
          "line_number": 65,
          "code": "// Status: ✅ WORKING\n#[test]\nfun test_function_name() {\n    // Test code here\n    assert_eq!(actual, expected)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 3,
          "line_number": 92,
          "code": "// Status: ✅ WORKING\n// tests/calculator_test.ruchy\n\nuse super::*;  // Import functions from main module\n\n#[test]\nfun test_addition() {\n    assert_eq!(add(2, 3), 5)\n}\n\n#[test]  \nfun test_subtraction() {\n    assert_eq!(subtract(10, 4), 6)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 4,
          "line_number": 119,
          "code": "// Status: ✅ WORKING\n// calculator.ruchy\nfun multiply(a, b) {\n    a * b\n}\n\nfun divide(a, b) {\n    if b == 0 {\n        0  // Simple handling for now\n    } else {\n        a / b\n    }\n}\n\nfun is_even(n) {\n    n % 2 == 0\n}\n\n// tests/calculator_test.ruchy  \n#[test]\nfun test_multiply() {\n    assert_eq!(multiply(3, 4), 12)\n    assert_eq!(multiply(0, 5), 0)\n    assert_eq!(multiply(-2, 3), -6)\n}\n\n#[test]\nfun test_divide() {\n    assert_eq!(divide(10, 2), 5)\n    assert_eq!(divide(7, 3), 2)  // Integer division\n    assert_eq!(divide(5, 0), 0)  // Division by zero handled\n}\n\n#[test]\nfun test_is_even() {\n    assert!(is_even(4))        // 4 is even\n    assert!(!is_even(3))       // 3 is not even  \n    assert!(is_even(0))        // 0 is even\n    assert!(!is_even(-1))      // -1 is not even\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 5,
          "line_number": 170,
          "code": "// Status: ✅ WORKING\nfun find_max(numbers) {\n    if numbers.len() == 0 {\n        -999999  // Sentinel value for empty\n    } else {\n        let mut max_val = numbers[0]\n        let mut i = 1\n        while i < numbers.len() {\n            if numbers[i] > max_val {\n                max_val = numbers[i]\n            }\n            i = i + 1\n        }\n        max_val\n    }\n}\n\n#[test]\nfun test_find_max() {\n    // Normal cases\n    assert_eq!(find_max([1, 5, 3, 9, 2]), 9)\n    assert_eq!(find_max([10]), 10)\n    \n    // Edge cases\n    assert_eq!(find_max([]), -999999)        // Empty list\n    assert_eq!(find_max([-5, -1, -10]), -1)  // All negative\n    assert_eq!(find_max([5, 5, 5]), 5)       // All same\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 6,
          "line_number": 207,
          "code": "// Status: ✅ WORKING\nfun clean_username(raw_username) {\n    // Simple cleaning - replace spaces with underscores\n    raw_username.replace(\" \", \"_\")\n}\n\nfun count_vowels(text) {\n    let vowels = \"aeiouAEIOU\"\n    let mut count = 0\n    let mut i = 0\n    while i < text.len() {\n        if vowels.contains(text[i]) {\n            count = count + 1\n        }\n        i = i + 1\n    }\n    count\n}\n\n#[test]\nfun test_clean_username() {\n    assert_eq!(clean_username(\"Alice Johnson\"), \"Alice_Johnson\")\n    assert_eq!(clean_username(\"JOHN\"), \"JOHN\")\n    assert_eq!(clean_username(\"\"), \"\")\n}\n\n#[test]\nfun test_count_vowels() {\n    assert_eq!(count_vowels(\"hello\"), 2)      // e, o\n    assert_eq!(count_vowels(\"HELLO\"), 2)      // Case insensitive\n    assert_eq!(count_vowels(\"xyz\"), 0)        // No vowels\n    assert_eq!(count_vowels(\"aeiou\"), 5)      // All vowels\n    assert_eq!(count_vowels(\"\"), 0)           // Empty string\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 7,
          "line_number": 250,
          "code": "// Status: ✅ WORKING\nfun calculate_grade(score) {\n    if score >= 90 { \"A\" }\n    else if score >= 80 { \"B\" } \n    else if score >= 70 { \"C\" }\n    else if score >= 60 { \"D\" }\n    else { \"F\" }\n}\n\nfun can_vote(age, is_citizen) {\n    age >= 18 && is_citizen\n}\n\n#[test]\nfun test_calculate_grade() {\n    // Boundary testing\n    assert_eq!(calculate_grade(95), \"A\")\n    assert_eq!(calculate_grade(90), \"A\")  // Exactly 90\n    assert_eq!(calculate_grade(89), \"B\")  // Just below A\n    assert_eq!(calculate_grade(80), \"B\")  // Exactly 80\n    assert_eq!(calculate_grade(79), \"C\")  // Just below B\n    assert_eq!(calculate_grade(59), \"F\")  // Failing grade\n    assert_eq!(calculate_grade(0), \"F\")   // Very low\n}\n\n#[test]\nfun test_can_vote() {\n    // All combinations\n    assert!(can_vote(18, true))      // Minimum age, citizen\n    assert!(can_vote(25, true))      // Adult citizen\n    assert!(!can_vote(17, true))     // Too young\n    assert!(!can_vote(25, false))    // Not citizen\n    assert!(!can_vote(17, false))    // Too young AND not citizen\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 8,
          "line_number": 299,
          "code": "// Status: ✅ WORKING\n\n// Step 1: Write the test first\n#[test]\nfun test_fahrenheit_to_celsius() {\n    assert_eq!(fahrenheit_to_celsius(32), 0)    // Freezing point\n    assert_eq!(fahrenheit_to_celsius(212), 100) // Boiling point\n    assert_eq!(fahrenheit_to_celsius(98.6), 37) // Body temperature\n}\n\n// Step 2: Write minimal code to pass\nfun fahrenheit_to_celsius(fahrenheit) {\n    return (fahrenheit - 32) * 5 / 9\n}\n\n// Step 3: Run tests, refactor if needed\n// All tests pass! Code is ready to use.",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 9,
          "line_number": 327,
          "code": "// Status: ✅ WORKING\n\n// ❌ Only testing happy path\n#[test]\nfun test_divide_bad() {\n    assert_eq!(divide(10, 2), 5)  // What about divide by zero?\n}\n\n// ✅ Testing edge cases\n#[test]\nfun test_divide_good() {\n    assert_eq!(divide(10, 2), 5)      // Normal case\n    assert_eq!(divide(0, 5), 0)       // Zero dividend\n    // Should handle divide by zero gracefully\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 10,
          "line_number": 351,
          "code": "// Status: ✅ WORKING\n\n// ❌ This test will always pass\n#[test]\nfun test_useless() {\n    let result = add(2, 3)\n    assert!(result > 0)  // Too vague!\n}\n\n// ✅ This test verifies exact behavior\n#[test]  \nfun test_useful() {\n    assert_eq!(add(2, 3), 5)  // Exact expectation\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 11,
          "line_number": 374,
          "code": "// Status: ✅ WORKING\n\n// ❌ Unclear what this tests\n#[test]\nfun test1() {\n    assert_eq!(is_valid(\"abc\"), false)\n}\n\n// ✅ Clear, descriptive name\n#[test]\nfun test_password_too_short() {\n    assert_eq!(is_valid_password(\"abc\"), false)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 12,
          "line_number": 434,
          "code": "// Status: ✅ WORKING\n\n// 1. Write failing tests first\n#[test]\nfun test_is_strong_password() {\n    assert!(is_strong_password(\"MyPass123!\"))      // Valid\n    assert!(!is_strong_password(\"weak\"))           // Too short\n    assert!(!is_strong_password(\"NoNumbers!\"))     // No digits\n    assert!(!is_strong_password(\"nonumbers123\"))   // No special chars\n}\n\n// 2. Write minimal code to pass\nfun is_strong_password(password) {\n    if password.len() < 8 { return false }\n    \n    let has_digit = password.chars().any(|c| c.is_digit())\n    let has_special = password.chars().any(|c| \"!@#$%^&*\".contains(c))\n    \n    return has_digit && has_special\n}\n\n// 3. Run tests - they should all pass now!\n\n// 4. Add more edge case tests\n#[test]\nfun test_password_edge_cases() {\n    assert!(!is_strong_password(\"\"))              // Empty\n    assert!(!is_strong_password(\"12345678\"))      // Only digits\n    assert!(!is_strong_password(\"!!!!!!!!\"))      // Only special\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch16-00-testing-quality": {
      "chapter": "ch16-00-testing-quality",
      "total_examples": 11,
      "working_examples": 0,
      "failing_examples": 11,
      "examples": [
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected method name or 'await' after '.'\n// Unit test with multiple assertions\n#[test]\nfun test_user_validation() {\n    // Arrange\n    let valid_user = User {\n        name: \"Alice\",\n        email: \"alice@example.com\",\n        age: 25\n    }\n    \n    // Act\n    let result = validate_user(valid_user)\n    \n    // Assert\n    assert!(result.is_ok())\n    assert_eq!(result.unwrap().name, \"Alice\")\n}\n\n// Property-based testing\n#[proptest]\nfun test_serialization_roundtrip(user: User) {\n    let serialized = user.serialize()\n    let deserialized = User::deserialize(serialized)\n    assert_eq!(user, deserialized)\n}\n\n// Integration test\n#[integration_test]\nasync fun test_api_workflow() {\n    // Start test server\n    let server = TestServer::new()\n    \n    // Create user\n    let response = server.post(\"/users\")\n        .json(new_user)\n        .send()\n        .await\n    \n    assert_eq!(response.status(), 201)\n    let user: User = response.json().await\n    \n    // Verify user exists\n    let get_response = server.get(\"/users/\" + user.id.to_s())\n        .send()\n        .await\n    \n    assert_eq!(get_response.status(), 200)\n}\n\n// Benchmark\n#[bench]\nfun bench_data_processing(b: &mut Bencher) {\n    let data = generate_test_data(10000)\n    b.iter(|| {\n        process_data(data.clone())\n    })\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 2,
          "line_number": 104,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: RightParen\n// Basic test\n#[test]\nfun test_addition() {\n    assert_eq!(2 + 2, 4)\n}\n\n// Test with setup\n#[test]\nfun test_calculator() {\n    // Arrange\n    let calc = Calculator::new()\n    \n    // Act\n    let result = calc.add(5, 3)\n    \n    // Assert\n    assert_eq!(result, 8)\n}\n\n// Test expected failures\n#[test]\n#[should_panic(expected = \"Division by zero\")]\nfun test_divide_by_zero() {\n    divide(10, 0)\n}\n\n// Async tests\n#[async_test]\nasync fun test_async_operation() {\n    let result = fetch_data().await\n    assert!(result.is_ok())\n}\n\n// Parameterized tests\n#[test_case(0, 0, 0)]\n#[test_case(1, 1, 2)]\n#[test_case(-1, 1, 0)]\n#[test_case(100, 200, 300)]\nfun test_add_parameterized(a: i32, b: i32, expected: i32) {\n    assert_eq!(add(a, b), expected)\n}\n\n// Test groups\nmod calculator_tests {\n    use super::*\n    \n    #[test]\n    fun test_add() { /* ... */ }\n    \n    #[test]\n    fun test_subtract() { /* ... */ }\n    \n    #[test]\n    fun test_multiply() { /* ... */ }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 3,
          "line_number": 172,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected RightBrace, found Identifier(\"test_data\")\n// Fixture trait\ntrait TestFixture {\n    fun setup() -> Self\n    fun teardown(self)\n}\n\n// Database fixture\nstruct DatabaseFixture {\n    db: Database\n    test_data: Vec<User>\n}\n\nimpl TestFixture for DatabaseFixture {\n    fun setup() -> Self {\n        let db = Database::connect(\":memory:\")\n        db.migrate()\n        \n        let test_data = vec![\n            User::new(\"Alice\", \"alice@example.com\"),\n            User::new(\"Bob\", \"bob@example.com\")\n        ]\n        \n        for user in &test_data {\n            db.insert(user)\n        }\n        \n        DatabaseFixture { db, test_data }\n    }\n    \n    fun teardown(self) {\n        self.db.drop_all_tables()\n        self.db.disconnect()\n    }\n}\n\n// Use fixture in tests\n#[test]\nfun test_user_query() {\n    let fixture = DatabaseFixture::setup()\n    \n    let users = fixture.db.query(\"SELECT * FROM users\")\n    assert_eq!(users.len(), 2)\n    \n    fixture.teardown()\n}\n\n// Fixture macro for automatic cleanup\n#[with_fixture(DatabaseFixture)]\nfun test_with_auto_cleanup(fixture: DatabaseFixture) {\n    // Fixture automatically cleaned up after test\n    let user = fixture.db.find_user(\"Alice\")\n    assert!(user.is_some())\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 4,
          "line_number": 238,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected type\n// Mock trait\ntrait EmailService {\n    fun send_email(to: String, subject: String, body: String) -> Result<(), Error>\n}\n\n// Mock implementation\n#[mockable]\nstruct MockEmailService {\n    sent_emails: RefCell<Vec<Email>>\n}\n\nimpl EmailService for MockEmailService {\n    fun send_email(to: String, subject: String, body: String) -> Result<(), Error> {\n        self.sent_emails.borrow_mut().push(Email { to, subject, body })\n        Ok(())\n    }\n}\n\n// Test with mock\n#[test]\nfun test_user_registration() {\n    let email_service = MockEmailService::new()\n    let user_service = UserService::new(email_service)\n    \n    user_service.register_user(\"alice@example.com\")\n    \n    // Verify email was sent\n    assert_eq!(email_service.sent_emails.borrow().len(), 1)\n    assert_eq!(email_service.sent_emails.borrow()[0].subject, \"Welcome!\")\n}\n\n// Spy to verify behavior\n#[test]\nfun test_with_spy() {\n    let spy = Spy::new(RealService::new())\n    \n    spy.method_call()\n    \n    assert!(spy.was_called(\"method_call\"))\n    assert_eq!(spy.call_count(\"method_call\"), 1)\n    assert_eq!(spy.last_args(\"method_call\"), expected_args)\n}\n\n// Stub for predetermined responses\n#[test]\nfun test_with_stub() {\n    let stub = Stub::new()\n        .with_response(\"get_user\", User::test_user())\n        .with_error(\"network_call\", NetworkError)\n    \n    let result = service_using_stub.process()\n    assert_eq!(result, expected)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 5,
          "line_number": 304,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected field name\nuse proptest::prelude::*\n\n// Generate arbitrary test data\n#[derive(Arbitrary)]\nstruct TestUser {\n    #[proptest(regex = \"[a-z]{3,10}\")]\n    name: String\n    \n    #[proptest(range = 0..150)]\n    age: u8\n    \n    #[proptest(strategy = \"email_strategy()\")]\n    email: String\n}\n\n// Property test\n#[proptest]\nfun test_user_serialization(user: TestUser) {\n    // Property: serialization round-trip preserves data\n    let json = to_json(user)\n    let restored: TestUser = from_json(json)\n    prop_assert_eq!(user, restored)\n}\n\n// Custom strategies\nfun email_strategy() -> impl Strategy<Value = String> {\n    \"[a-z]{3,10}@[a-z]{3,10}\\\\.(com|org|net)\"\n        .prop_map(|s| s.to_string())\n}\n\n// Shrinking for minimal failing case\n#[proptest]\nfun test_no_panic(input: Vec<u8>) {\n    // Proptest will find minimal input that causes panic\n    process_bytes(input)  // Should never panic\n}\n\n// Stateful property testing\n#[proptest]\nfun test_database_consistency(operations: Vec<DbOperation>) {\n    let db = Database::new()\n    \n    for op in operations {\n        op.apply(&db)\n    }\n    \n    // Properties that should always hold\n    prop_assert!(db.is_consistent())\n    prop_assert_eq!(db.total_balance(), INITIAL_BALANCE)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 6,
          "line_number": 367,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected method name or 'await' after '.'\n// Integration test in tests/ directory\n#[integration_test]\nasync fun test_full_api_flow() {\n    // Start services\n    let db = TestDatabase::new()\n    let cache = TestCache::new()\n    let server = TestServer::with_services(db, cache)\n    \n    // Register user\n    let register_response = server\n        .post(\"/api/register\")\n        .json(json!({\n            \"email\": \"test@example.com\",\n            \"password\": \"secure123\"\n        }))\n        .send()\n        .await\n    \n    assert_eq!(register_response.status(), 201)\n    let user: User = register_response.json().await\n    \n    // Login\n    let login_response = server\n        .post(\"/api/login\")\n        .json(json!({\n            \"email\": \"test@example.com\",\n            \"password\": \"secure123\"\n        }))\n        .send()\n        .await\n    \n    assert_eq!(login_response.status(), 200)\n    let token = login_response.header(\"Authorization\")\n    \n    // Use authenticated endpoint\n    let profile_response = server\n        .get(\"/api/profile\")\n        .header(\"Authorization\", token)\n        .send()\n        .await\n    \n    assert_eq!(profile_response.status(), 200)\n    let profile: Profile = profile_response.json().await\n    assert_eq!(profile.email, \"test@example.com\")\n}\n\n// Database integration test\n#[test]\nfun test_database_transactions() {\n    let db = Database::connect(TEST_DATABASE_URL)\n    \n    db.transaction(|tx| {\n        tx.insert_user(user1)?\n        tx.insert_user(user2)?\n        \n        // Verify within transaction\n        let count = tx.count_users()?\n        assert_eq!(count, 2)\n        \n        // Rollback for test isolation\n        Err(TestRollback)\n    })\n    \n    // Verify rollback worked\n    assert_eq!(db.count_users(), 0)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 7,
          "line_number": 446,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected type\n// Benchmarks\n#[bench]\nfun bench_sorting_algorithms(b: &mut Bencher) {\n    let data = generate_random_vec(10000)\n    \n    b.iter(|| {\n        let mut copy = data.clone()\n        copy.sort()\n    })\n}\n\n// Comparative benchmarks\n#[bench_group]\nmod sorting_benchmarks {\n    #[bench]\n    fun quick_sort(b: &mut Bencher) {\n        let data = generate_data()\n        b.iter(|| quick_sort(data.clone()))\n    }\n    \n    #[bench]\n    fun merge_sort(b: &mut Bencher) {\n        let data = generate_data()\n        b.iter(|| merge_sort(data.clone()))\n    }\n    \n    #[bench]\n    fun heap_sort(b: &mut Bencher) {\n        let data = generate_data()\n        b.iter(|| heap_sort(data.clone()))\n    }\n}\n\n// Load testing\n#[load_test]\nasync fun test_api_under_load() {\n    let config = LoadTestConfig {\n        concurrent_users: 1000,\n        requests_per_user: 100,\n        ramp_up_time: Duration::from_secs(10)\n    }\n    \n    let results = load_test(config, |client| async {\n        client.get(\"/api/endpoint\").send().await\n    }).await\n    \n    assert!(results.median_response_time < Duration::from_millis(100))\n    assert!(results.p99_response_time < Duration::from_millis(500))\n    assert!(results.error_rate < 0.01)\n}\n\n// Profiling in tests\n#[test]\n#[profile]\nfun test_with_profiling() {\n    let profiler = CpuProfiler::start()\n    \n    expensive_operation()\n    \n    let report = profiler.report()\n    assert!(report.total_time < Duration::from_secs(1))\n    \n    // Generate flame graph\n    report.save_flamegraph(\"profile.svg\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 8,
          "line_number": 524,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: EqualEqual\n// Run tests with coverage\n$ ruchy test --coverage\n\n// Coverage report\n================================\nFile            Lines  Covered  %\nsrc/lib.rs      245    238     97.1%\nsrc/parser.rs   512    487     95.1%\nsrc/executor.rs 380    360     94.7%\n================================\nTotal           1137   1085    95.4%\n\n// Coverage annotations\n#[test]\nfun test_all_branches() {\n    // Tool shows which branches are not covered\n    if condition {      // ✓ true branch covered\n        do_something()\n    } else {           // ✗ false branch not covered\n        do_other()\n    }\n}\n\n// Exclude from coverage\n#[cfg(not(tarpaulin_include))]\nfun debug_function() {\n    // Not included in coverage metrics\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 9,
          "line_number": 563,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: Colon\n// Mutation testing finds gaps in tests\n$ ruchy mutate\n\n// Mutations that survived (tests didn't catch)\nsrc/calculator.rs:15\n- Original: x + y\n+ Mutation: x - y\nStatus: SURVIVED ❌\n\n// Add test to catch mutation\n#[test]\nfun test_addition_not_subtraction() {\n    assert_ne!(add(5, 3), subtract(5, 3))\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 10,
          "line_number": 588,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected type\n// Fuzz testing for security\n#[fuzz_test]\nfun fuzz_parser(data: &[u8]) {\n    // Fuzzer generates random inputs\n    if let Ok(s) = std::str::from_utf8(data) {\n        // Should never panic or crash\n        let _ = parse_input(s)\n    }\n}\n\n// Run fuzzer\n$ ruchy fuzz parser_fuzz\n=== Fuzzing parser_fuzz ===\nIterations: 1000000\nCrashes found: 0\nHangs found: 0\nCoverage: 95%\n\n// Targeted fuzzing\n#[fuzz_target]\nfun fuzz_api_endpoint(input: FuzzInput) {\n    let request = Request::from_fuzz(input)\n    let response = handle_request(request)\n    \n    // Properties that should hold\n    assert!(response.status() < 600)\n    assert!(response.body().len() < 10_000_000)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 11,
          "line_number": 661,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected identifier after 'for'\n// quality.ruchy - Quality gate script\nfun main() {\n    let mut passed = true\n    \n    // Test coverage gate\n    let coverage = run_coverage_analysis()\n    if coverage.percentage < 80.0 {\n        println(\"❌ Coverage too low: \" + coverage.percentage.to_s() + \"%\")\n        passed = false\n    }\n    \n    // Performance gate\n    let benchmarks = run_benchmarks()\n    for (name, result) in benchmarks {\n        if result.regression > 0.1 {  // 10% regression\n            println(\"❌ Performance regression in \" + name + \": \" + (result.regression * 100).to_s() + \"%\")\n            passed = false\n        }\n    }\n    \n    // Complexity gate\n    let complexity = analyze_complexity()\n    if complexity.max_cyclomatic > 10 {\n        println(\"❌ Complexity too high: \" + complexity.max_cyclomatic.to_s())\n        passed = false\n    }\n    \n    // Security gate\n    let vulnerabilities = security_scan()\n    if !vulnerabilities.is_empty() {\n        println(\"❌ Security vulnerabilities found: \" + vulnerabilities.len().to_s())\n        passed = false\n    }\n    \n    if !passed {\n        exit(1)\n    }\n    \n    println(\"✅ All quality gates passed!\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch14-00-concurrency": {
      "chapter": "ch14-00-concurrency",
      "total_examples": 13,
      "working_examples": 0,
      "failing_examples": 13,
      "examples": [
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected identifier, '*', or '{' after '::'\nuse std::sync;\nuse std::async;\n\n// Parallel processing with channels\nfun process_files(files: Vec<String>) -> Vec<Result> {\n    let (sender, receiver) = channel()\n    \n    // Spawn worker for each file\n    for file in files {\n        let tx = sender.clone()\n        spawn {\n            let result = process_file(file)\n            tx.send((file, result))\n        }\n    }\n    \n    // Collect results\n    let results = Vec::new()\n    for _ in files.len() {\n        let (file, result) = receiver.recv()\n        results.push(result)\n    }\n    \n    return results\n}\n\n// Async/await for I/O\nasync fun fetch_all_data(urls: Vec<String>) -> Vec<Data> {\n    let futures = urls.map(|url| async {\n        let response = http::get(url).await?\n        parse_response(response)\n    })\n    \n    return join_all(futures).await\n}\n\n// Thread pool for CPU-bound work\nlet pool = ThreadPool::new(num_cpus())\nlet results = pool.parallel_map(items, |item| {\n    expensive_computation(item)\n})",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 2,
          "line_number": 88,
          "code": "// Status: ✅ WORKING\n\n// Spawn a thread\nlet handle = spawn {\n    println(\"Running in parallel!\")\n    compute_result()\n}\n\n// Wait for thread to complete\nlet result = handle.join()\n\n// Spawn with move semantics\nlet data = vec![1, 2, 3]\nlet handle = spawn move {\n    let sum = data.sum()  // data moved into thread\n    println(\"Sum: \" + sum.to_s())\n}\n\n// Thread builder for configuration\nlet handle = Thread::builder()\n    .name(\"worker\")\n    .stack_size(4 * 1024 * 1024)\n    .spawn(|| {\n        heavy_computation()\n    })",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `async`, `|`, or `||`, found `;`\n --> /tmp/.tmpmIz5nz/main.rs:1:245\n  |\n1 | ...i32 , 2i32 , 3i32] ; let handle = spawn ; move ; { { let sum = data . sum () ; println ! (\"{}\" , \"Sum: \" + sum . to_s ()) } } ; let ha...\n  |                                                   ^ expected one of `async`, `|`, or `||`\n\nerror[E0425]: cannot find value `spawn` in this scope\n --> /tmp/.tmpmIz5nz/main.rs:1:78\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let handle = spawn ; { println ! (\"Running in parallel!\") ; compute_resul...\n  |                                                                              ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::thread::spawn;\n  |\n\nerror[E0425]: cannot find value `spawn` in this scope\n --> /tmp/.tmpmIz5nz/main.rs:1:232\n  |\n1 | ...et data = vec ! [1i32 , 2i32 , 3i32] ; let handle = spawn ; move ; { { let sum = data . sum () ; println ! (\"{}\" , \"Sum: \" + sum . to_...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::thread::spawn;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpmIz5nz/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let handle = spawn ; { println ! (\"Running in parallel!\") ; compute_resul...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `compute_result` in this scope\n --> /tmp/.tmpmIz5nz/main.rs:1:125\n  |\n1 | ... spawn ; { println ! (\"Running in parallel!\") ; compute_result () } ; let result = handle . join () ; let data = vec ! [1i32 , 2i32 , ...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 3,
          "line_number": 125,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected identifier after 'let' or 'let mut'\n// Create a channel\nlet (sender, receiver) = channel()\n\n// Multiple producers\nfor i in range(10) {\n    let tx = sender.clone()\n    spawn move {\n        let result = process(i)\n        tx.send(result)\n    }\n}\n\n// Single consumer\nspawn move {\n    while let Ok(result) = receiver.recv() {\n        println(\"Got: \" + result.to_s())\n    }\n}\n\n// Bounded channels for backpressure\nlet (tx, rx) = sync_channel(100)  // Buffer size 100\n\n// Select from multiple channels\nloop {\n    select! {\n        msg = rx1.recv() => {\n            process_message(msg)\n        }\n        data = rx2.recv() => {\n            process_data(data)\n        }\n        _ = timeout(1000) => {\n            println(\"Timeout!\")\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 4,
          "line_number": 174,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected identifier after 'for'\n// Mutex for mutual exclusion\nlet counter = Arc::new(Mutex::new(0))\n\nlet handles = Vec::new()\nfor _ in range(10) {\n    let counter = counter.clone()\n    handles.push(spawn move {\n        let mut num = counter.lock()\n        *num += 1\n    })\n}\n\nfor handle in handles {\n    handle.join()\n}\n\nprintln(\"Result: \" + (*counter.lock()).to_s())\n\n// RwLock for multiple readers\nlet data = Arc::new(RwLock::new(HashMap::new()))\n\n// Multiple readers\nlet data_clone = data.clone()\nspawn move {\n    let map = data_clone.read()  // Shared read access\n    println(\"Value: \" + map.get(\"key\").to_s())\n}\n\n// Single writer\nlet data_clone = data.clone()\nspawn move {\n    let mut map = data_clone.write()  // Exclusive write access\n    map.insert(\"key\", \"value\")\n}\n\n// Atomic operations for lock-free programming\nlet counter = Arc::new(AtomicI32::new(0))\ncounter.fetch_add(1, Ordering::SeqCst)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 5,
          "line_number": 225,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected type\n// Async function\nasync fun fetch_user(id: i32) -> Result<User, Error> {\n    let response = http::get(\"/api/users/\" + id.to_s()).await?\n    let user = parse_json(response.body).await?\n    return Ok(user)\n}\n\n// Await multiple futures\nasync fun fetch_all_users(ids: Vec<i32>) -> Vec<User> {\n    let futures = ids.map(|id| fetch_user(id))\n    let results = join_all(futures).await\n    \n    return results\n        .filter_map(|r| r.ok())\n        .collect()\n}\n\n// Select first to complete\nasync fun fetch_with_timeout(url: String) -> Result<Data, Error> {\n    select! {\n        result = fetch_data(url) => result,\n        _ = sleep(5000) => Err(Error::Timeout)\n    }\n}\n\n// Async streams\nasync fun process_stream(stream: AsyncStream<Item>) {\n    while let Some(item) = stream.next().await {\n        process_item(item).await\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 6,
          "line_number": 271,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected RightBrace, found Identifier(\"sender\")\nstruct ThreadPool {\n    workers: Vec<Worker>\n    sender: Sender<Job>\n}\n\nimpl ThreadPool {\n    fun new(size: usize) -> ThreadPool {\n        let (sender, receiver) = channel()\n        let receiver = Arc::new(Mutex::new(receiver))\n        \n        let workers = Vec::with_capacity(size)\n        for id in range(size) {\n            workers.push(Worker::new(id, receiver.clone()))\n        }\n        \n        ThreadPool { workers, sender }\n    }\n    \n    fn execute<F>(&self, f: F)\n    where F: FnOnce() + Send + 'static\n    {\n        self.sender.send(Box::new(f))\n    }\n    \n    fn parallel_map<T, R, F>(&self, items: Vec<T>, f: F) -> Vec<R>\n    where\n        F: Fn(T) -> R + Send + Clone + 'static,\n        T: Send + 'static,\n        R: Send + 'static\n    {\n        let (tx, rx) = channel()\n        \n        for item in items {\n            let tx = tx.clone()\n            let f = f.clone()\n            self.execute(move || {\n                let result = f(item)\n                tx.send(result)\n            })\n        }\n        \n        let results = Vec::new()\n        for _ in items.len() {\n            results.push(rx.recv())\n        }\n        \n        return results\n    }\n}\n\n// Use thread pool\nlet pool = ThreadPool::new(4)\n\nfor i in range(100) {\n    pool.execute(move || {\n        println(\"Task \" + i.to_s() + \" on thread \" + current_thread_id().to_s())\n        heavy_work()\n    })\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 7,
          "line_number": 343,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected identifier after 'let' or 'let mut'\nfun producer_consumer_pipeline<T>() {\n    let (tx, rx) = channel()\n    \n    // Multiple producers\n    for i in range(4) {\n        let tx = tx.clone()\n        spawn move {\n            loop {\n                let work = generate_work(i)\n                if tx.send(work).is_err() {\n                    break  // Channel closed\n                }\n            }\n        }\n    }\n    \n    // Multiple consumers  \n    for i in range(2) {\n        let rx = rx.clone()\n        spawn move {\n            while let Ok(work) = rx.recv() {\n                process_work(work)\n            }\n        }\n    }\n}\n\n// With bounded queue for backpressure\nfun bounded_pipeline() {\n    let (tx, rx) = sync_channel(100)  // Max 100 items\n    \n    spawn move {\n        for item in generate_items() {\n            tx.send(item)  // Blocks if queue full\n        }\n    }\n    \n    spawn move {\n        while let Ok(item) = rx.recv() {\n            slow_process(item)\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 8,
          "line_number": 399,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected Greater, found Colon\nfun parallel_merge_sort<T: Ord + Send>(mut items: Vec<T>) -> Vec<T> {\n    if items.len() <= 1 {\n        return items\n    }\n    \n    let mid = items.len() / 2\n    let right = items.split_off(mid)\n    \n    // Fork: sort halves in parallel\n    let (left_sorted, right_sorted) = join(\n        || parallel_merge_sort(items),\n        || parallel_merge_sort(right)\n    )\n    \n    // Join: merge sorted halves\n    return merge(left_sorted, right_sorted)\n}\n\n// Parallel reduce\nfun parallel_sum(numbers: Vec<i32>) -> i32 {\n    if numbers.len() <= 1000 {\n        return numbers.sum()  // Sequential for small inputs\n    }\n    \n    let chunk_size = numbers.len() / num_cpus()\n    let chunks = numbers.chunks(chunk_size)\n    \n    let sums = chunks\n        .parallel_map(|chunk| chunk.sum())\n        .collect()\n    \n    return sums.sum()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 9,
          "line_number": 445,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected 'fun' or 'fn' keyword\n// Actor trait\ntrait Actor {\n    type Message\n    \n    fun handle(&mut self, msg: Self::Message)\n}\n\n// Example actor\nstruct CounterActor {\n    count: i32\n}\n\nenum CounterMessage {\n    Increment\n    Decrement\n    Get(Sender<i32>)\n}\n\nimpl Actor for CounterActor {\n    type Message = CounterMessage\n    \n    fun handle(&mut self, msg: CounterMessage) {\n        match msg {\n            Increment => self.count += 1\n            Decrement => self.count -= 1\n            Get(reply) => reply.send(self.count)\n        }\n    }\n}\n\n// Actor system\nstruct ActorSystem {\n    actors: HashMap<String, Box<dyn Actor>>\n}\n\nimpl ActorSystem {\n    fn spawn<A: Actor>(&mut self, name: String, actor: A) -> ActorRef<A> {\n        let (tx, rx) = channel()\n        \n        spawn move {\n            let mut actor = actor\n            while let Ok(msg) = rx.recv() {\n                actor.handle(msg)\n            }\n        }\n        \n        ActorRef { name, sender: tx }\n    }\n}\n\n// Use actors\nlet system = ActorSystem::new()\nlet counter = system.spawn(\"counter\", CounterActor { count: 0 })\n\ncounter.send(Increment)\ncounter.send(Increment)\n\nlet (tx, rx) = channel()\ncounter.send(Get(tx))\nlet count = rx.recv()\nprintln(\"Count: \" + count.to_s())  // 2",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 10,
          "line_number": 521,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected identifier after 'let' or 'let mut'\nasync fun web_server() {\n    let listener = TcpListener::bind(\"0.0.0.0:8080\").await\n    \n    loop {\n        let (socket, addr) = listener.accept().await\n        \n        // Handle each connection concurrently\n        spawn async {\n            handle_connection(socket, addr).await\n        }\n    }\n}\n\nasync fun handle_connection(socket: TcpStream, addr: SocketAddr) {\n    let (reader, writer) = socket.split()\n    \n    let request = read_http_request(reader).await\n    let response = route_request(request).await\n    \n    write_http_response(writer, response).await\n}\n\n// Connection pool for database\nlet db_pool = ConnectionPool::new(20)\n\nasync fun handle_request(req: Request) -> Response {\n    let conn = db_pool.get().await\n    \n    let data = conn.query(\"SELECT * FROM users\").await\n    \n    db_pool.return(conn)\n    \n    Response::json(data)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 11,
          "line_number": 568,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected type\nfun process_dataset(data: Vec<Record>) -> Vec<Result> {\n    // Partition data for parallel processing\n    let chunk_size = data.len() / num_cpus()\n    let chunks = data.chunks(chunk_size)\n    \n    // Process chunks in parallel\n    let handles = chunks.map(|chunk| {\n        spawn move {\n            chunk.iter()\n                .map(|record| process_record(record))\n                .collect()\n        }\n    })\n    \n    // Collect results\n    let mut results = Vec::new()\n    for handle in handles {\n        results.extend(handle.join())\n    }\n    \n    return results\n}\n\n// Pipeline with stages\nfun parallel_pipeline(input: Stream<Data>) -> Stream<Output> {\n    input\n        .parallel_map(stage1, workers: 4)\n        .parallel_filter(stage2, workers: 2)\n        .parallel_flat_map(stage3, workers: 4)\n        .collect()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 12,
          "line_number": 612,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected RightParen, found Identifier(\"move\")\n#[test]\nfun test_concurrent_access() {\n    let shared = Arc::new(Mutex::new(Vec::new()))\n    let handles = Vec::new()\n    \n    // Spawn concurrent writers\n    for i in range(100) {\n        let shared = shared.clone()\n        handles.push(spawn move {\n            let mut vec = shared.lock()\n            vec.push(i)\n        })\n    }\n    \n    // Wait for completion\n    for handle in handles {\n        handle.join()\n    }\n    \n    // Verify all writes succeeded\n    let vec = shared.lock()\n    assert_eq!(vec.len(), 100)\n}\n\n#[test]\nasync fun test_async_operations() {\n    let results = join_all(vec![\n        async_operation(1),\n        async_operation(2),\n        async_operation(3)\n    ]).await\n    \n    assert!(results.all(|r| r.is_ok()))\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 13,
          "line_number": 657,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected '|' after lambda parameters\n// 1. Choose the right abstraction\n// Threads: OS parallelism, CPU-bound work\n// Async: I/O-bound work, many concurrent tasks\n// Channels: Decoupled communication\n// Shared state: When necessary, with proper synchronization\n\n// 2. Avoid contention\nlet shards = (0..16).map(|_| Mutex::new(HashMap::new()))\nfun get_shard(key: &str) -> &Mutex<HashMap> {\n    let hash = hash(key)\n    return &shards[hash % 16]\n}\n\n// 3. Use work stealing\nlet queue = WorkStealingQueue::new()\n// Threads steal work from other threads when idle\n\n// 4. Batch operations\ninstead_of {\n    for item in items {\n        channel.send(item)  // Many small sends\n    }\n}\n\ndo {\n    channel.send(items)  // One batch send\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch04-00-command-line-tools": {
      "chapter": "ch04-00-command-line-tools",
      "total_examples": 14,
      "working_examples": 1,
      "failing_examples": 13,
      "examples": [
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ✅ WORKING\n\n// File: word_counter.ruchy\n// Simple word counter tool\n\n// Get filename from user\nprintln(\"Word Counter Tool\")\nprint(\"Enter filename: \")\nlet filename = input()\n\n// Read and process file\nlet content = read_file(filename)\nlet words = content.split_whitespace()\nlet word_count = words.len()\nlet char_count = content.len()\nlet line_count = content.lines().len()\n\n// Display results\nprintln(\"\\nFile Analysis: \" + filename)\nprintln(\"Characters: \" + char_count.to_s())\nprintln(\"Words: \" + word_count.to_s())  \nprintln(\"Lines: \" + line_count.to_s())",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpQQnc73/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"Word Counter Tool\") ; print ! (\"Enter filename: \") ; let file...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmpQQnc73/main.rs:1:145\n  |\n1 | ...l\") ; print ! (\"Enter filename: \") ; let filename = input () ; let content = read_file (filename) ; let words = content . split_whites...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmpQQnc73/main.rs:1:170\n  |\n1 | ...ame: \") ; let filename = input () ; let content = read_file (filename) ; let words = content . split_whitespace () ; let word_count = ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpQQnc73/main.rs:1:372\n  |\n1 | ...s () . len () ; println ! (\"{}\" , \"\\nFile Analysis: \" + filename) ; println ! (\"{}\" , \"Characters: \" + char_count . to_s ()) ; println...\n  |                                --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                                |\n  |                                required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpQQnc73/main.rs:1:424\n  |\n1 | ...filename) ; println ! (\"{}\" , \"Characters: \" + char_count . to_s ()) ; println ! (\"{}\" , \"Words: \" + word_count . to_s ()) ; println !...\n  |                            --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                            |\n  |                            required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpQQnc73/main.rs:1:483\n  |\n1 | ...t . to_s ()) ; println ! (\"{}\" , \"Words: \" + word_count . to_s ()) ; println ! (\"{}\" , \"Lines: \" + line_count . to_s ()) } ; if let So...\n  |                               --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                               |\n  |                               required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpQQnc73/main.rs:1:537\n  |\n1 | ...t . to_s ()) ; println ! (\"{}\" , \"Lines: \" + line_count . to_s ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downc...\n  |                               --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                               |\n  |                               required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 6 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 2,
          "line_number": 79,
          "code": "// Status: ✅ WORKING\n\nlet name = input(\"What's your name? \")\nlet age = input(\"How old are you? \").to_i()\nlet is_student = input(\"Are you a student? (y/n) \") == \"y\"",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpBZqwmj/main.rs:1:217\n  |\n1 | ...t (\"Are you a student? (y/n) \") == \"y\" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpBZqwmj/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let name = input (\"What's your name? \") ; let age = input (\"How old are y...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmpBZqwmj/main.rs:1:76\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let name = input (\"What's your name? \") ; let age = input (\"How old are y...\n  |                                                                            ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmpBZqwmj/main.rs:1:117\n  |\n1 | ...let name = input (\"What's your name? \") ; let age = input (\"How old are you? \") . to_i () ; let is_student = input (\"Are you a student...\n  |                                                        ^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 3,
          "line_number": 95,
          "code": "// Status: ✅ WORKING\n\n// Reading files\nlet content = read_file(\"data.txt\")\nlet lines = read_lines(\"data.txt\")\n\n// Writing files\nwrite_file(\"output.txt\", \"Hello, World!\")\nappend_file(\"log.txt\", \"New entry: \" + timestamp())\n\n// File information\nlet exists = file_exists(\"config.txt\")\nlet size = file_size(\"data.txt\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpeY8K1n/main.rs:1:321\n  |\n1 | ...\") ; let size = file_size (\"data.txt\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpeY8K1n/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let content = read_file (\"data.txt\") ; let lines = read_lines (\"data.txt\"...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmpeY8K1n/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let content = read_file (\"data.txt\") ; let lines = read_lines (\"data.txt\"...\n  |                                                                               ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `read_lines` in this scope\n --> /tmp/.tmpeY8K1n/main.rs:1:116\n  |\n1 | ...et content = read_file (\"data.txt\") ; let lines = read_lines (\"data.txt\") ; write_file (\"output.txt\" , \"Hello, World!\") ; append_file ...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmpeY8K1n/main.rs:1:142\n  |\n1 | ...ata.txt\") ; let lines = read_lines (\"data.txt\") ; write_file (\"output.txt\" , \"Hello, World!\") ; append_file (\"log.txt\" , \"New entry: \"...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `timestamp` in this scope\n --> /tmp/.tmpeY8K1n/main.rs:1:229\n  |\n1 | ...rld!\") ; append_file (\"log.txt\" , \"New entry: \" + timestamp ()) ; let exists = file_exists (\"config.txt\") ; let size = file_size (\"dat...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `append_file` in this scope\n --> /tmp/.tmpeY8K1n/main.rs:1:188\n  |\n1 | ... ; write_file (\"output.txt\" , \"Hello, World!\") ; append_file (\"log.txt\" , \"New entry: \" + timestamp ()) ; let exists = file_exists (\"c...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpeY8K1n/main.rs:1:258\n  |\n1 | ...\" , \"New entry: \" + timestamp ()) ; let exists = file_exists (\"config.txt\") ; let size = file_size (\"data.txt\") } ; if let Some (s) = ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 7 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 4,
          "line_number": 119,
          "code": "// Status: ✅ WORKING\n\n// Usage: ruchy run script.ruchy file1.txt file2.txt\nlet args = command_args()\nlet program_name = args[0]\nlet first_file = args[1]\nlet second_file = args[2]\n\nprintln(\"Processing: \" + first_file + \" and \" + second_file)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp45YpVx/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let args = command_args () ; let program_name = args [0i32] ; let first_f...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `command_args` in this scope\n --> /tmp/.tmp45YpVx/main.rs:1:76\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let args = command_args () ; let program_name = args [0i32] ; let first_f...\n  |                                                                            ^^^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmp45YpVx/main.rs:1:236\n  |\n1 | ...second_file = args [2i32] ; println ! (\"{}\" , \"Processing: \" + first_file + \" and \" + second_file) } ; if let Some (s) = (& result as ...\n  |                                                  --------------------------- ^ ------- &str\n  |                                                  |\n  |                                                  str\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0369, E0425.\nFor more information about an error, try `rustc --explain E0369`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 5,
          "line_number": 140,
          "code": "// Status: ✅ WORKING\n\n// File: text_processor.ruchy\n// Processes text files with various operations\n\nprintln(\"=== Text Processor ===\")\nlet filename = input(\"Enter filename: \")\n\nif !file_exists(filename) {\n    println(\"Error: File '\" + filename + \"' not found!\")\n    exit(1)\n}\n\nlet content = read_file(filename)\nlet lines = content.lines()\n\nprintln(\"\\nChoose operation:\")\nprintln(\"1. Count lines\")\nprintln(\"2. Find and replace\")\nprintln(\"3. Convert to uppercase\") \nprintln(\"4. Remove empty lines\")\n\nlet choice = input(\"Enter choice (1-4): \").to_i()\n\nmatch choice {\n    1 => {\n        println(\"Total lines: \" + lines.len().to_s())\n    }\n    2 => {\n        let find = input(\"Find: \")\n        let replace = input(\"Replace with: \")\n        let new_content = content.replace(find, replace)\n        let output_file = filename.replace(\".txt\", \"_modified.txt\")\n        write_file(output_file, new_content)\n        println(\"Saved to: \" + output_file)\n    }\n    3 => {\n        let upper_content = content.to_uppercase()\n        let output_file = filename.replace(\".txt\", \"_upper.txt\")\n        write_file(output_file, upper_content)\n        println(\"Saved to: \" + output_file)\n    }\n    4 => {\n        let clean_lines = lines.filter(|line| !line.trim().is_empty())\n        let clean_content = clean_lines.join(\"\\n\")\n        let output_file = filename.replace(\".txt\", \"_clean.txt\")\n        write_file(output_file, clean_content)\n        println(\"Saved to: \" + output_file)\n    }\n    _ => {\n        println(\"Invalid choice!\")\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find function `exit` in this scope\n --> /tmp/.tmpR6A0ay/main.rs:1:245\n  |\n1 | ...{}\" , \"Error: File '\" + filename + \"' not found!\") ; exit (1i32) } } ; let content = read_file (filename) ; let lines = content . line...\n  |                                                         ^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::process::exit;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpR6A0ay/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Text Processor ===\") ; let filename = input (\"Enter filen...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmpR6A0ay/main.rs:1:119\n  |\n1 | ...intln ! (\"=== Text Processor ===\") ; let filename = input (\"Enter filename: \") ; if ! file_exists (filename) { { println ! (\"{}\" , \"Er...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpR6A0ay/main.rs:1:153\n  |\n1 | ...let filename = input (\"Enter filename: \") ; if ! file_exists (filename) { { println ! (\"{}\" , \"Error: File '\" + filename + \"' not foun...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmpR6A0ay/main.rs:1:225\n  |\n1 | ...le_exists (filename) { { println ! (\"{}\" , \"Error: File '\" + filename + \"' not found!\") ; exit (1i32) } } ; let content = read_file (f...\n  |                                               -------------------------- ^ -------------- &str\n  |                                               |\n  |                                               str\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmpR6A0ay/main.rs:1:277\n  |\n1 | ...\"' not found!\") ; exit (1i32) } } ; let content = read_file (filename) ; let lines = content . lines () ; println ! (\"\\nChoose operati...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmpR6A0ay/main.rs:1:527\n  |\n1 | ... println ! (\"4. Remove empty lines\") ; let choice = input (\"Enter choice (1-4): \") . to_i () ; match choice { 1i32 => { println ! (\"{}...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpR6A0ay/main.rs:1:613\n  |\n1 | ...1i32 => { println ! (\"{}\" , \"Total lines: \" + lines . len () . to_s ()) } , 2i32 => { { let find = input (\"Find: \") ; { let replace = ...\n  |                          --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                          |\n  |                          required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmpR6A0ay/main.rs:1:684\n  |\n1 | ...ines . len () . to_s ()) } , 2i32 => { { let find = input (\"Find: \") ; { let replace = input (\"Replace with: \") ; let new_content = co...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmpR6A0ay/main.rs:1:719\n  |\n1 | ...> { { let find = input (\"Find: \") ; { let replace = input (\"Replace with: \") ; let new_content = content . replace (find , replace) ; ...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmpR6A0ay/main.rs:1:867\n  |\n1 | ...= filename . replace (\".txt\" , \"_modified.txt\") ; write_file (output_file , new_content) ; println ! (\"{}\" , \"Saved to: \" + output_fil...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpR6A0ay/main.rs:1:926\n  |\n1 | ... , new_content) ; println ! (\"{}\" , \"Saved to: \" + output_file) } } } , 3i32 => { { let upper_content = content . to_uppercase () ; { ...\n  |                                  --    ^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                                  |\n  |                                  required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmpR6A0ay/main.rs:1:1087\n  |\n1 | ...le = filename . replace (\".txt\" , \"_upper.txt\") ; write_file (output_file , upper_content) ; println ! (\"{}\" , \"Saved to: \" + output_f...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpR6A0ay/main.rs:1:1148\n  |\n1 | ... upper_content) ; println ! (\"{}\" , \"Saved to: \" + output_file) } } } , 4i32 => { { let clean_lines = lines . into_iter () . filter (|...\n  |                                  --    ^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                                  |\n  |                                  required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmpR6A0ay/main.rs:1:1414\n  |\n1 | ...le = filename . replace (\".txt\" , \"_clean.txt\") ; write_file (output_file , clean_content) ; println ! (\"{}\" , \"Saved to: \" + output_f...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpR6A0ay/main.rs:1:1475\n  |\n1 | ... clean_content) ; println ! (\"{}\" , \"Saved to: \" + output_file) } } } , _ => { println ! (\"Invalid choice!\") } , } } ; if let Some (s)...\n  |                                  --    ^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                                  |\n  |                                  required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 15 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0277, E0369, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 6,
          "line_number": 203,
          "code": "// Status: ✅ WORKING\n\n// File: log_analyzer.ruchy\n// Analyzes server log files\n\nprintln(\"=== Log Analyzer ===\")\nlet log_file = input(\"Enter log file path: \")\n\nlet lines = read_lines(log_file)\nlet total_requests = lines.len()\n\n// Count different status codes\nlet success_count = 0\nlet error_count = 0\nlet not_found_count = 0\n\nfor line in lines {\n    if line.contains(\" 200 \") {\n        success_count += 1\n    } else if line.contains(\" 404 \") {\n        not_found_count += 1\n    } else if line.contains(\" 500 \") {\n        error_count += 1\n    }\n}\n\n// Calculate percentages\nlet success_percent = (success_count * 100) / total_requests\nlet error_percent = (error_count * 100) / total_requests\nlet not_found_percent = (not_found_count * 100) / total_requests\n\nprintln(\"\\n=== Analysis Results ===\")\nprintln(\"Total Requests: \" + total_requests.to_s())\nprintln(\"Success (200): \" + success_count.to_s() + \" (\" + success_percent.to_s() + \"%)\")\nprintln(\"Not Found (404): \" + not_found_count.to_s() + \" (\" + not_found_percent.to_s() + \"%)\")\nprintln(\"Server Error (500): \" + error_count.to_s() + \" (\" + error_percent.to_s() + \"%)\")\n\n// Find busiest hour\nlet hour_counts = {}\nfor line in lines {\n    let timestamp = extract_hour(line)  // Custom function\n    hour_counts[timestamp] = hour_counts.get(timestamp, 0) + 1\n}\n\nlet busiest_hour = hour_counts.max_by_value().key\nprintln(\"Busiest Hour: \" + busiest_hour.to_s() + \":00\")",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpw83YeB/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\") ; let log_file = input (\"Enter log fil...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpw83YeB/main.rs:1:326\n  |\n1 | ... { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ...\n  |       ^^                                                                                                                                                                                                  ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\") ; let log_file = input (\"Enter log file path: \") ; let lines = read_lines (log_file) ; let total_requests = lines . len () ; let success_count = 0i32 ; let error_count = 0i32 ; let not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; let error_percent = error_count * 100i32 / total_requests ; let not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{}\" , \"Total Requests: \" + total_requests . to_s ()) ; println ! (\"{}\" , \"Success (200): \" + success_count . to_s () + \" (\" + success_percent . to_s () + \"%)\") ; println ! (\"{}\" , \"Not Found (404): \" + not_found_count . to_s () + \" (\" + not_found_percent . to_s () + \"%)\") ; println ! (\"{}\" , \"Server Error (500): \" + error_count . to_s () + \" (\" + error_percent . to_s () + \"%)\") ; let hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{}\" , \"Busiest Hour: \" + busiest_hour . to_s () + \":00\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\") ; let log_file = input (\"Enter log file path: \") ; let lines = read_lines (log_file) ; let total_requests = lines . len () ; let success_count = 0i32 ; let error_count = 0i32 ; let not_found_count = 0i32 ; for line in lines { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } ; let success_percent = success_count * 100i32 / total_requests ; let error_percent = error_count * 100i32 / total_requests ; let not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{}\" , \"Total Requests: \" + total_requests . to_s ()) ; println ! (\"{}\" , \"Success (200): \" + success_count . to_s () + \" (\" + success_percent . to_s () + \"%)\") ; println ! (\"{}\" , \"Not Found (404): \" + not_found_count . to_s () + \" (\" + not_found_percent . to_s () + \"%)\") ; println ! (\"{}\" , \"Server Error (500): \" + error_count . to_s () + \" (\" + error_percent . to_s () + \"%)\") ; let hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{}\" , \"Busiest Hour: \" + busiest_hour . to_s () + \":00\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpw83YeB/main.rs:1:359\n  |\n1 | ... for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_co...\n  |                                                          ^^                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\") ; let log_file = input (\"Enter log file path: \") ; let lines = read_lines (log_file) ; let total_requests = lines . len () ; let success_count = 0i32 ; let error_count = 0i32 ; let not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; let error_percent = error_count * 100i32 / total_requests ; let not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{}\" , \"Total Requests: \" + total_requests . to_s ()) ; println ! (\"{}\" , \"Success (200): \" + success_count . to_s () + \" (\" + success_percent . to_s () + \"%)\") ; println ! (\"{}\" , \"Not Found (404): \" + not_found_count . to_s () + \" (\" + not_found_percent . to_s () + \"%)\") ; println ! (\"{}\" , \"Server Error (500): \" + error_count . to_s () + \" (\" + error_percent . to_s () + \"%)\") ; let hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{}\" , \"Busiest Hour: \" + busiest_hour . to_s () + \":00\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\") ; let log_file = input (\"Enter log file path: \") ; let lines = read_lines (log_file) ; let total_requests = lines . len () ; let success_count = 0i32 ; let error_count = 0i32 ; let not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { success_count += 1i32 } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; let error_percent = error_count * 100i32 / total_requests ; let not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{}\" , \"Total Requests: \" + total_requests . to_s ()) ; println ! (\"{}\" , \"Success (200): \" + success_count . to_s () + \" (\" + success_percent . to_s () + \"%)\") ; println ! (\"{}\" , \"Not Found (404): \" + not_found_count . to_s () + \" (\" + not_found_percent . to_s () + \"%)\") ; println ! (\"{}\" , \"Server Error (500): \" + error_count . to_s () + \" (\" + error_percent . to_s () + \"%)\") ; let hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{}\" , \"Busiest Hour: \" + busiest_hour . to_s () + \":00\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpw83YeB/main.rs:1:425\n  |\n1 | ...nt += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count...\n  |                                                         ^^                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\") ; let log_file = input (\"Enter log file path: \") ; let lines = read_lines (log_file) ; let total_requests = lines . len () ; let success_count = 0i32 ; let error_count = 0i32 ; let not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; let error_percent = error_count * 100i32 / total_requests ; let not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{}\" , \"Total Requests: \" + total_requests . to_s ()) ; println ! (\"{}\" , \"Success (200): \" + success_count . to_s () + \" (\" + success_percent . to_s () + \"%)\") ; println ! (\"{}\" , \"Not Found (404): \" + not_found_count . to_s () + \" (\" + not_found_percent . to_s () + \"%)\") ; println ! (\"{}\" , \"Server Error (500): \" + error_count . to_s () + \" (\" + error_percent . to_s () + \"%)\") ; let hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{}\" , \"Busiest Hour: \" + busiest_hour . to_s () + \":00\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\") ; let log_file = input (\"Enter log file path: \") ; let lines = read_lines (log_file) ; let total_requests = lines . len () ; let success_count = 0i32 ; let error_count = 0i32 ; let not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { not_found_count += 1i32 } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; let error_percent = error_count * 100i32 / total_requests ; let not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{}\" , \"Total Requests: \" + total_requests . to_s ()) ; println ! (\"{}\" , \"Success (200): \" + success_count . to_s () + \" (\" + success_percent . to_s () + \"%)\") ; println ! (\"{}\" , \"Not Found (404): \" + not_found_count . to_s () + \" (\" + not_found_percent . to_s () + \"%)\") ; println ! (\"{}\" , \"Server Error (500): \" + error_count . to_s () + \" (\" + error_percent . to_s () + \"%)\") ; let hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{}\" , \"Busiest Hour: \" + busiest_hour . to_s () + \":00\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpw83YeB/main.rs:1:493\n  |\n1 | ...ount += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i3...\n  |                                                           ^^                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\") ; let log_file = input (\"Enter log file path: \") ; let lines = read_lines (log_file) ; let total_requests = lines . len () ; let success_count = 0i32 ; let error_count = 0i32 ; let not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; let error_percent = error_count * 100i32 / total_requests ; let not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{}\" , \"Total Requests: \" + total_requests . to_s ()) ; println ! (\"{}\" , \"Success (200): \" + success_count . to_s () + \" (\" + success_percent . to_s () + \"%)\") ; println ! (\"{}\" , \"Not Found (404): \" + not_found_count . to_s () + \" (\" + not_found_percent . to_s () + \"%)\") ; println ! (\"{}\" , \"Server Error (500): \" + error_count . to_s () + \" (\" + error_percent . to_s () + \"%)\") ; let hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{}\" , \"Busiest Hour: \" + busiest_hour . to_s () + \":00\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\") ; let log_file = input (\"Enter log file path: \") ; let lines = read_lines (log_file) ; let total_requests = lines . len () ; let success_count = 0i32 ; let error_count = 0i32 ; let not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { error_count += 1i32 } } } } } ; let success_percent = success_count * 100i32 / total_requests ; let error_percent = error_count * 100i32 / total_requests ; let not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{}\" , \"Total Requests: \" + total_requests . to_s ()) ; println ! (\"{}\" , \"Success (200): \" + success_count . to_s () + \" (\" + success_percent . to_s () + \"%)\") ; println ! (\"{}\" , \"Not Found (404): \" + not_found_count . to_s () + \" (\" + not_found_percent . to_s () + \"%)\") ; println ! (\"{}\" , \"Server Error (500): \" + error_count . to_s () + \" (\" + error_percent . to_s () + \"%)\") ; let hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{}\" , \"Busiest Hour: \" + busiest_hour . to_s () + \":00\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpw83YeB/main.rs:1:1202\n  |\n1 | ... lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let b...\n  |             ^^                                                                                                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\") ; let log_file = input (\"Enter log file path: \") ; let lines = read_lines (log_file) ; let total_requests = lines . len () ; let success_count = 0i32 ; let error_count = 0i32 ; let not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; let error_percent = error_count * 100i32 / total_requests ; let not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{}\" , \"Total Requests: \" + total_requests . to_s ()) ; println ! (\"{}\" , \"Success (200): \" + success_count . to_s () + \" (\" + success_percent . to_s () + \"%)\") ; println ! (\"{}\" , \"Not Found (404): \" + not_found_count . to_s () + \" (\" + not_found_percent . to_s () + \"%)\") ; println ! (\"{}\" , \"Server Error (500): \" + error_count . to_s () + \" (\" + error_percent . to_s () + \"%)\") ; let hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{}\" , \"Busiest Hour: \" + busiest_hour . to_s () + \":00\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\") ; let log_file = input (\"Enter log file path: \") ; let lines = read_lines (log_file) ; let total_requests = lines . len () ; let success_count = 0i32 ; let error_count = 0i32 ; let not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; let error_percent = error_count * 100i32 / total_requests ; let not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{}\" , \"Total Requests: \" + total_requests . to_s ()) ; println ! (\"{}\" , \"Success (200): \" + success_count . to_s () + \" (\" + success_percent . to_s () + \"%)\") ; println ! (\"{}\" , \"Not Found (404): \" + not_found_count . to_s () + \" (\" + not_found_percent . to_s () + \"%)\") ; println ! (\"{}\" , \"Server Error (500): \" + error_count . to_s () + \" (\" + error_percent . to_s () + \"%)\") ; let hour_counts = () ; for line in lines { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } ; let busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{}\" , \"Busiest Hour: \" + busiest_hour . to_s () + \":00\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmpw83YeB/main.rs:1:117\n  |\n1 | ...println ! (\"=== Log Analyzer ===\") ; let log_file = input (\"Enter log file path: \") ; let lines = read_lines (log_file) ; let total_re...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `read_lines` in this scope\n --> /tmp/.tmpw83YeB/main.rs:1:163\n  |\n1 | ...e = input (\"Enter log file path: \") ; let lines = read_lines (log_file) ; let total_requests = lines . len () ; let success_count = 0i...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpw83YeB/main.rs:1:782\n  |\n1 | ...===\") ; println ! (\"{}\" , \"Total Requests: \" + total_requests . to_s ()) ; println ! (\"{}\" , \"Success (200): \" + success_count . to_s ...\n  |                        --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                        |\n  |                        required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpw83YeB/main.rs:1:885\n  |\n1 | ...intln ! (\"{}\" , \"Success (200): \" + success_count . to_s () + \" (\" + success_percent . to_s () + \"%)\") ; println ! (\"{}\" , \"Not Found ...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmpw83YeB/main.rs:1:893\n  |\n1 | ...equests . to_s ()) ; println ! (\"{}\" , \"Success (200): \" + success_count . to_s () + \" (\" + success_percent . to_s () + \"%)\") ; printl...\n  |                                           ------------------------------------------- ^ ---- &str\n  |                                           |\n  |                                           str\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpw83YeB/main.rs:1:920\n  |\n1 | ... success_count . to_s () + \" (\" + success_percent . to_s () + \"%)\") ; println ! (\"{}\" , \"Not Found (404): \" + not_found_count . to_s (...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpw83YeB/main.rs:1:996\n  |\n1 | ...n ! (\"{}\" , \"Not Found (404): \" + not_found_count . to_s () + \" (\" + not_found_percent . to_s () + \"%)\") ; println ! (\"{}\" , \"Server E...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmpw83YeB/main.rs:1:1004\n  |\n1 | ... to_s () + \"%)\") ; println ! (\"{}\" , \"Not Found (404): \" + not_found_count . to_s () + \" (\" + not_found_percent . to_s () + \"%)\") ; pr...\n  |                                         ----------------------------------------------- ^ ---- &str\n  |                                         |\n  |                                         str\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpw83YeB/main.rs:1:1033\n  |\n1 | ..._found_count . to_s () + \" (\" + not_found_percent . to_s () + \"%)\") ; println ! (\"{}\" , \"Server Error (500): \" + error_count . to_s ()...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpw83YeB/main.rs:1:1108\n  |\n1 | ...ln ! (\"{}\" , \"Server Error (500): \" + error_count . to_s () + \" (\" + error_percent . to_s () + \"%)\") ; let hour_counts = () ; for line...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmpw83YeB/main.rs:1:1116\n  |\n1 | .... to_s () + \"%)\") ; println ! (\"{}\" , \"Server Error (500): \" + error_count . to_s () + \" (\" + error_percent . to_s () + \"%)\") ; let ho...\n  |                                          ---------------------------------------------- ^ ---- &str\n  |                                          |\n  |                                          str\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpw83YeB/main.rs:1:1141\n  |\n1 | ... \" + error_count . to_s () + \" (\" + error_percent . to_s () + \"%)\") ; let hour_counts = () ; for line in lines { { { let timestamp = e...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0425]: cannot find function `extract_hour` in this scope\n --> /tmp/.tmpw83YeB/main.rs:1:1222\n  |\n1 | ...s = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) ...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `get` found for unit type `()` in the current scope\n    --> /tmp/.tmpw83YeB/main.rs:1:1284\n     |\n1    | ... = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let busiest_hour = hour_counts ...\n     |                                                                     ^^^\n     |\nhelp: there is a method `ge` with a similar name, but with different arguments\n    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1438:5\n     |\n1438 |     fn ge(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `max_by_value` found for unit type `()` in the current scope\n --> /tmp/.tmpw83YeB/main.rs:1:1355\n  |\n1 | ...+ 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{}\" , \"Busiest Hour: \" + busiest_hour . to_s () + ...\n  |                                                    ^^^^^^^^^^^^ method not found in `()`\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmpw83YeB/main.rs:1:1439\n  |\n1 | ...x_by_value () . key ; println ! (\"{}\" , \"Busiest Hour: \" + busiest_hour . to_s () + \":00\") } ; if let Some (s) = (& result as & dyn st...\n  |                                            ----------------------------------------- ^ ----- &str\n  |                                            |\n  |                                            str\n\nerror: aborting due to 16 previous errors; 6 warnings emitted\n\nSome errors have detailed explanations: E0277, E0369, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_s()"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 7,
          "line_number": 259,
          "code": "// Status: ✅ WORKING\n\n// File: batch_renamer.ruchy  \n// Renames multiple files with patterns\n\nprintln(\"=== Batch File Renamer ===\")\nlet directory = input(\"Enter directory path: \")\nlet pattern = input(\"Enter pattern to find: \")\nlet replacement = input(\"Enter replacement: \")\n\nlet files = list_files(directory)\nlet renamed_count = 0\n\nfor file in files {\n    if file.contains(pattern) {\n        let new_name = file.replace(pattern, replacement)\n        let old_path = join_path(directory, file)\n        let new_path = join_path(directory, new_name)\n        \n        if rename_file(old_path, new_path) {\n            println(\"Renamed: \" + file + \" -> \" + new_name)\n            renamed_count += 1\n        } else {\n            println(\"Failed to rename: \" + file)\n        }\n    }\n}\n\nprintln(\"\\nRenamed \" + renamed_count.to_s() + \" files\")",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp0z08Oj/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Batch File Renamer ===\") ; let directory = input (\"Enter ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp0z08Oj/main.rs:1:343\n  |\n1 | ... { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; let new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{}\" , \"Renamed: \" + file + \" -> \" + new_name) ; renamed_count += 1i32 } } else { { println ! (\"{}\" , \"Failed to rename: \" + file) } } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                               ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Batch File Renamer ===\") ; let directory = input (\"Enter directory path: \") ; let pattern = input (\"Enter pattern to find: \") ; let replacement = input (\"Enter replacement: \") ; let files = list_files (directory) ; let renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; let new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{}\" , \"Renamed: \" + file + \" -> \" + new_name) ; renamed_count += 1i32 } } else { { println ! (\"{}\" , \"Failed to rename: \" + file) } } } } } } } } ; println ! (\"{}\" , \"\\nRenamed \" + renamed_count . to_s () + \" files\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Batch File Renamer ===\") ; let directory = input (\"Enter directory path: \") ; let pattern = input (\"Enter pattern to find: \") ; let replacement = input (\"Enter replacement: \") ; let files = list_files (directory) ; let renamed_count = 0i32 ; for file in files { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; let new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{}\" , \"Renamed: \" + file + \" -> \" + new_name) ; renamed_count += 1i32 } } else { { println ! (\"{}\" , \"Failed to rename: \" + file) } } } } } } } ; println ! (\"{}\" , \"\\nRenamed \" + renamed_count . to_s () + \" files\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp0z08Oj/main.rs:1:376\n  |\n1 | ... { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; let new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{}\" , \"Renamed: \" + file + \" -> \" + new_name) ; renamed_count += 1i32 } } else { { println ! (\"{}\" , \"Failed to rename: \" + file) } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                          ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Batch File Renamer ===\") ; let directory = input (\"Enter directory path: \") ; let pattern = input (\"Enter pattern to find: \") ; let replacement = input (\"Enter replacement: \") ; let files = list_files (directory) ; let renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; let new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{}\" , \"Renamed: \" + file + \" -> \" + new_name) ; renamed_count += 1i32 } } else { { println ! (\"{}\" , \"Failed to rename: \" + file) } } } } } } } } ; println ! (\"{}\" , \"\\nRenamed \" + renamed_count . to_s () + \" files\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Batch File Renamer ===\") ; let directory = input (\"Enter directory path: \") ; let pattern = input (\"Enter pattern to find: \") ; let replacement = input (\"Enter replacement: \") ; let files = list_files (directory) ; let renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; let new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{}\" , \"Renamed: \" + file + \" -> \" + new_name) ; renamed_count += 1i32 } } else { { println ! (\"{}\" , \"Failed to rename: \" + file) } } } } } } } ; println ! (\"{}\" , \"\\nRenamed \" + renamed_count . to_s () + \" files\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp0z08Oj/main.rs:1:668\n  |\n1 | ..._name) ; renamed_count += 1i32 } } else { { println ! (\"{}\" , \"Failed to rename: \" + file) } } } } } } } } ; println ! (\"{}\" , \"\\nRena...\n  |                                              ^^                                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Batch File Renamer ===\") ; let directory = input (\"Enter directory path: \") ; let pattern = input (\"Enter pattern to find: \") ; let replacement = input (\"Enter replacement: \") ; let files = list_files (directory) ; let renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; let new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{}\" , \"Renamed: \" + file + \" -> \" + new_name) ; renamed_count += 1i32 } } else { { println ! (\"{}\" , \"Failed to rename: \" + file) } } } } } } } } ; println ! (\"{}\" , \"\\nRenamed \" + renamed_count . to_s () + \" files\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Batch File Renamer ===\") ; let directory = input (\"Enter directory path: \") ; let pattern = input (\"Enter pattern to find: \") ; let replacement = input (\"Enter replacement: \") ; let files = list_files (directory) ; let renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; let new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{}\" , \"Renamed: \" + file + \" -> \" + new_name) ; renamed_count += 1i32 } } else { println ! (\"{}\" , \"Failed to rename: \" + file) } } } } } } } ; println ! (\"{}\" , \"\\nRenamed \" + renamed_count . to_s () + \" files\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmp0z08Oj/main.rs:1:124\n  |\n1 | ... ! (\"=== Batch File Renamer ===\") ; let directory = input (\"Enter directory path: \") ; let pattern = input (\"Enter pattern to find: \")...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmp0z08Oj/main.rs:1:173\n  |\n1 | ... = input (\"Enter directory path: \") ; let pattern = input (\"Enter pattern to find: \") ; let replacement = input (\"Enter replacement: \"...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmp0z08Oj/main.rs:1:227\n  |\n1 | ...put (\"Enter pattern to find: \") ; let replacement = input (\"Enter replacement: \") ; let files = list_files (directory) ; let renamed_c...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `list_files` in this scope\n --> /tmp/.tmp0z08Oj/main.rs:1:271\n  |\n1 | ...ent = input (\"Enter replacement: \") ; let files = list_files (directory) ; let renamed_count = 0i32 ; for file in files { { if file . ...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmp0z08Oj/main.rs:1:453\n  |\n1 | ...eplace (pattern , replacement) ; { let old_path = join_path (directory , file) ; let new_path = join_path (directory , new_name) ; if ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmp0z08Oj/main.rs:1:499\n  |\n1 | ...ctory , file) ; let new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{}\" , \"Renamed:...\n  |                                   ^^^^^^^^^ help: a local variable with a similar name exists: `old_path`\n\nerror[E0425]: cannot find function `rename_file` in this scope\n --> /tmp/.tmp0z08Oj/main.rs:1:537\n  |\n1 | ...new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{}\" , \"Renamed: \" + file + \" -> \" +...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmp0z08Oj/main.rs:1:612\n  |\n1 | ...e_file (old_path , new_path) { { println ! (\"{}\" , \"Renamed: \" + file + \" -> \" + new_name) ; renamed_count += 1i32 } } else { { printl...\n  |                                                       ------------------ ^ ------ &str\n  |                                                       |\n  |                                                       str\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmp0z08Oj/main.rs:1:688\n  |\n1 | ...i32 } } else { { println ! (\"{}\" , \"Failed to rename: \" + file) } } } } } } } } ; println ! (\"{}\" , \"\\nRenamed \" + renamed_count . to_...\n  |                                 --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                                 |\n  |                                 required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmp0z08Oj/main.rs:1:784\n  |\n1 | ... ; println ! (\"{}\" , \"\\nRenamed \" + renamed_count . to_s () + \" files\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . ...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmp0z08Oj/main.rs:1:792\n  |\n1 | ...le) } } } } } } } } ; println ! (\"{}\" , \"\\nRenamed \" + renamed_count . to_s () + \" files\") } ; if let Some (s) = (& result as & dyn st...\n  |                                            -------------------------------------- ^ -------- &str\n  |                                            |\n  |                                            str\n\nerror: aborting due to 11 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0277, E0369, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_s()"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 8,
          "line_number": 300,
          "code": "// Status: ✅ WORKING\n\n// Robust file processor with error handling\n\nfun process_file(filename) {\n    // Check if file exists\n    if !file_exists(filename) {\n        println(\"❌ Error: File '\" + filename + \"' does not exist\")\n        return false\n    }\n    \n    // Check if file is readable\n    if !file_readable(filename) {\n        println(\"❌ Error: Cannot read file '\" + filename + \"' (permission denied?)\")\n        return false\n    }\n    \n    // Try to read file\n    let content = try {\n        read_file(filename)\n    } catch error {\n        println(\"❌ Error reading file: \" + error.to_s())\n        return false\n    }\n    \n    // Process content\n    let word_count = content.split_whitespace().len()\n    println(\"✅ File processed: \" + word_count.to_s() + \" words\")\n    return true\n}\n\n// Main program\nlet filename = input(\"Enter filename: \")\nif process_file(filename) {\n    println(\"Processing completed successfully!\")\n} else {\n    println(\"Processing failed!\")\n    exit(1)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0423]: expected value, found macro `try`\n --> /tmp/.tmpUs6yzO/main.rs:1:487\n  |\n1 | ...permission denied?)\") ; return false } } ; { let content = try ; { { read_file (filename) } ; catch ; error ; { println ! (\"{}\" , \"❌ Er...\n  |                                                               ^^^ not a value\n\nerror[E0425]: cannot find value `catch` in this scope\n --> /tmp/.tmpUs6yzO/main.rs:1:522\n  |\n1 | ... { let content = try ; { { read_file (filename) } ; catch ; error ; { println ! (\"{}\" , \"❌ Error reading file: \" + error . to_s ()) ; r...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpUs6yzO/main.rs:1:530\n  |\n1 | ...ontent = try ; { { read_file (filename) } ; catch ; error ; { println ! (\"{}\" , \"❌ Error reading file: \" + error . to_s ()) ; return fa...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpUs6yzO/main.rs:1:585\n  |\n1 | ...or ; { println ! (\"{}\" , \"❌ Error reading file: \" + error . to_s ()) ; return false } ; let word_count = content . split_whitespace () ...\n  |                                                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `exit` in this scope\n --> /tmp/.tmpUs6yzO/main.rs:1:960\n  |\n1 | ...y!\") } } else { { println ! (\"Processing failed!\") ; exit (1i32) } } ; }\n  |                                                         ^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::process::exit;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpUs6yzO/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn process_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fm...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpUs6yzO/main.rs:1:861\n  |\n1 | ...ename: \") ; if process_file (filename) { { println ! (\"Processing completed successfully!\") } } else { { println ! (\"Processing failed...\n  |                                             ^^                                                ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (filename : T) -> T { { if ! file_exists (filename) { { println ! (\"{}\" , \"❌ Error: File '\" + filename + \"' does not exist\") ; return false } } ; if ! file_readable (filename) { { println ! (\"{}\" , \"❌ Error: Cannot read file '\" + filename + \"' (permission denied?)\") ; return false } } ; { let content = try ; { { read_file (filename) } ; catch ; error ; { println ! (\"{}\" , \"❌ Error reading file: \" + error . to_s ()) ; return false } ; let word_count = content . split_whitespace () . len () ; println ! (\"{}\" , \"✅ File processed: \" + word_count . to_s () + \" words\") ; return true } } } } fn main () { let filename = input (\"Enter filename: \") ; if process_file (filename) { { println ! (\"Processing completed successfully!\") } } else { { println ! (\"Processing failed!\") ; exit (1i32) } } ; }\n1 + use std :: collections :: HashMap ; fn process_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (filename : T) -> T { { if ! file_exists (filename) { { println ! (\"{}\" , \"❌ Error: File '\" + filename + \"' does not exist\") ; return false } } ; if ! file_readable (filename) { { println ! (\"{}\" , \"❌ Error: Cannot read file '\" + filename + \"' (permission denied?)\") ; return false } } ; { let content = try ; { { read_file (filename) } ; catch ; error ; { println ! (\"{}\" , \"❌ Error reading file: \" + error . to_s ()) ; return false } ; let word_count = content . split_whitespace () . len () ; println ! (\"{}\" , \"✅ File processed: \" + word_count . to_s () + \" words\") ; return true } } } } fn main () { let filename = input (\"Enter filename: \") ; if process_file (filename) { println ! (\"Processing completed successfully!\") } else { { println ! (\"Processing failed!\") ; exit (1i32) } } ; }\n  |\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpUs6yzO/main.rs:1:212\n  |\n1 | ... :: Debug + Clone > (filename : T) -> T { { if ! file_exists (filename) { { println ! (\"{}\" , \"❌ Error: File '\" + filename + \"' does no...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `T` to `&str`\n --> /tmp/.tmpUs6yzO/main.rs:1:275\n  |\n1 | ...{ if ! file_exists (filename) { { println ! (\"{}\" , \"❌ Error: File '\" + filename + \"' does not exist\") ; return false } } ; if ! file_r...\n  |                                                        ------------------ ^ -------- T\n  |                                                        |\n  |                                                        &str\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpUs6yzO/main.rs:1:288\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (filename : T) -> T { { if ! file_exists (filename) { { println ! (\"{}\" , \"❌ Error: File '\" + filename + \"' does not exist\") ; ...\n  |       - expected this type parameter                                                                                                                                                                                                            ^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpUs6yzO/main.rs:1:317\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (filename : T) -> T { { if ! file_exists (filename) { { println ! (\"{}\" , \"❌ Error: File '\" + filename + \"' does not exist\") ; return false } }...\n  |       - expected this type parameter                                                                                                                    - expected `T` because of return type                                                                                ^^^^^ expected type parameter `T`, found `bool`\n  |\n  = note: expected type parameter `T`\n                       found type `bool`\n  = note: the caller chooses a type for `T` which can be different from `bool`\n\nerror[E0425]: cannot find function `file_readable` in this scope\n --> /tmp/.tmpUs6yzO/main.rs:1:334\n  |\n1 | ...+ \"' does not exist\") ; return false } } ; if ! file_readable (filename) { { println ! (\"{}\" , \"❌ Error: Cannot read file '\" + filename...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `T` to `&str`\n --> /tmp/.tmpUs6yzO/main.rs:1:411\n  |\n1 | ...ile_readable (filename) { { println ! (\"{}\" , \"❌ Error: Cannot read file '\" + filename + \"' (permission denied?)\") ; return false } } ;...\n  |                                                  ------------------------------ ^ -------- T\n  |                                                  |\n  |                                                  &str\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpUs6yzO/main.rs:1:424\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (filename : T) -> T { { if ! file_exists (filename) { { println ! (\"{}\" , \"❌ Error: File '\" + filename + \"' does not exist\") ; return false } } ; if ! file_readable (filename) { { println ! (\"{}\" , \"❌ Error: Cannot read file '\" + filename + \"' (permission denied?)\") ; r...\n  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmpUs6yzO/main.rs:1:497\n  |\n1 | ...\") ; return false } } ; { let content = try ; { { read_file (filename) } ; catch ; error ; { println ! (\"{}\" , \"❌ Error reading file: \"...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpUs6yzO/main.rs:1:558\n  |\n1 | ...error ; { println ! (\"{}\" , \"❌ Error reading file: \" + error . to_s ()) ; return false } ; let word_count = content . split_whitespace ...\n  |                          --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                          |\n  |                          required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: unreachable statement\n --> /tmp/.tmpUs6yzO/main.rs:1:621\n  |\n1 | ...error . to_s ()) ; return false } ; let word_count = content . split_whitespace () . len () ; println ! (\"{}\" , \"✅ File processed: \" + ...\n  |                       ------------     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable statement\n  |                       |\n  |                       any code following this expression is unreachable\n  |\n  = note: `#[warn(unreachable_code)]` on by default\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmpUs6yzO/main.rs:1:741\n  |\n1 | ...pace () . len () ; println ! (\"{}\" , \"✅ File processed: \" + word_count . to_s () + \" words\") ; return true } } } } fn main () { let fil...\n  |                                         -------------------------------------------- ^ -------- &str\n  |                                         |\n  |                                         str\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmpUs6yzO/main.rs:1:803\n  |\n1 | ...) ; return true } } } } fn main () { let filename = input (\"Enter filename: \") ; if process_file (filename) { { println ! (\"Processing...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0277]: cannot add `bool` to `bool`\n --> /tmp/.tmpUs6yzO/main.rs:1:849\n  |\n1 | ...ame = input (\"Enter filename: \") ; if process_file (filename) { { println ! (\"Processing completed successfully!\") } } else { { printl...\n  |                                          ------------  ^^^^^^^^ no implementation for `bool + bool`\n  |                                          |\n  |                                          required by a bound introduced by this call\n  |\n  = help: the trait `Add` is not implemented for `bool`\nnote: required by a bound in `process_file`\n --> /tmp/.tmpUs6yzO/main.rs:1:59\n  |\n1 | use std :: collections :: HashMap ; fn process_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fm...\n  |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `process_file`\n\nerror[E0277]: cannot multiply `bool` by `bool`\n --> /tmp/.tmpUs6yzO/main.rs:1:849\n  |\n1 | ...ame = input (\"Enter filename: \") ; if process_file (filename) { { println ! (\"Processing completed successfully!\") } } else { { printl...\n  |                                          ------------  ^^^^^^^^ no implementation for `bool * bool`\n  |                                          |\n  |                                          required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `bool`\nnote: required by a bound in `process_file`\n --> /tmp/.tmpUs6yzO/main.rs:1:94\n  |\n1 | ...: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (filename : T) ...\n  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `process_file`\n\nerror: aborting due to 18 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0369, E0423, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 9,
          "line_number": 351,
          "code": "// Status: ✅ WORKING\n\n// Good CLI tool practices\n\nfun show_help() {\n    println(\"File Statistics Tool v1.0\")\n    println(\"\")\n    println(\"Usage:\")\n    println(\"  ruchy run file_stats.ruchy <filename>\")\n    println(\"\")\n    println(\"Examples:\")\n    println(\"  ruchy run file_stats.ruchy document.txt\")\n    println(\"  ruchy run file_stats.ruchy data/*.csv\")\n    println(\"\")\n    println(\"Options:\")\n    println(\"  --help     Show this help message\")\n    println(\"  --verbose  Show detailed output\")\n}\n\nfun process_with_progress(files) {\n    let total = files.len()\n    let mut i = 0\n    \n    while i < total {\n        let file = files[i]\n        let progress = ((i + 1) * 100) / total\n        print(\"\\rProcessing... [\" + progress.to_s() + \"%] \" + file)\n        \n        // Do the actual work\n        process_file(file)\n        \n        // Small delay to show progress\n        sleep(100)  // 100ms\n        i = i + 1\n    }\n    \n    println(\"\\n✅ All files processed!\")\n}",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find function `sleep` in this scope\n --> /tmp/.tmp5XQ85C/main.rs:1:913\n  |\n1 | ...s . to_s () + \"%] \" + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\") } } ...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::thread::sleep;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp5XQ85C/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\") ; println ! (\"\") ; println ! (\"Usage:\") ;...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5XQ85C/main.rs:1:672\n  |\n1 | ... { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let progress = i + 1i32 * 100i32 / total ; print ! (\"{}\" , \"\\rProcessing... [\" + progress . to_s () + \"%] \" + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\") } } } } f...\n  |       ^^                                                                                                                                                                                                                                                                                                                                  ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\") ; println ! (\"\") ; println ! (\"Usage:\") ; println ! (\"  ruchy run file_stats.ruchy <filename>\") ; println ! (\"\") ; println ! (\"Examples:\") ; println ! (\"  ruchy run file_stats.ruchy document.txt\") ; println ! (\"  ruchy run file_stats.ruchy data/*.csv\") ; println ! (\"\") ; println ! (\"Options:\") ; println ! (\"  --help     Show this help message\") ; println ! (\"  --verbose  Show detailed output\") } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let progress = i + 1i32 * 100i32 / total ; print ! (\"{}\" , \"\\rProcessing... [\" + progress . to_s () + \"%] \" + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\") } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\") ; println ! (\"\") ; println ! (\"Usage:\") ; println ! (\"  ruchy run file_stats.ruchy <filename>\") ; println ! (\"\") ; println ! (\"Examples:\") ; println ! (\"  ruchy run file_stats.ruchy document.txt\") ; println ! (\"  ruchy run file_stats.ruchy data/*.csv\") ; println ! (\"\") ; println ! (\"Options:\") ; println ! (\"  --help     Show this help message\") ; println ! (\"  --verbose  Show detailed output\") } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let progress = i + 1i32 * 100i32 / total ; print ! (\"{}\" , \"\\rProcessing... [\" + progress . to_s () + \"%] \" + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\") } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5XQ85C/main.rs:1:744\n  |\n1 | ... { { { let file = files [i] ; { let progress = i + 1i32 * 100i32 / total ; print ! (\"{}\" , \"\\rProcessing... [\" + progress . to_s () + \"%] \" + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ...\n  |       ^^                                                                                                                                                                                                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\") ; println ! (\"\") ; println ! (\"Usage:\") ; println ! (\"  ruchy run file_stats.ruchy <filename>\") ; println ! (\"\") ; println ! (\"Examples:\") ; println ! (\"  ruchy run file_stats.ruchy document.txt\") ; println ! (\"  ruchy run file_stats.ruchy data/*.csv\") ; println ! (\"\") ; println ! (\"Options:\") ; println ! (\"  --help     Show this help message\") ; println ! (\"  --verbose  Show detailed output\") } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let progress = i + 1i32 * 100i32 / total ; print ! (\"{}\" , \"\\rProcessing... [\" + progress . to_s () + \"%] \" + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\") } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\") ; println ! (\"\") ; println ! (\"Usage:\") ; println ! (\"  ruchy run file_stats.ruchy <filename>\") ; println ! (\"\") ; println ! (\"Examples:\") ; println ! (\"  ruchy run file_stats.ruchy document.txt\") ; println ! (\"  ruchy run file_stats.ruchy data/*.csv\") ; println ! (\"\") ; println ! (\"Options:\") ; println ! (\"  --help     Show this help message\") ; println ! (\"  --verbose  Show detailed output\") } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { let file = files [i] ; { let progress = i + 1i32 * 100i32 / total ; print ! (\"{}\" , \"\\rProcessing... [\" + progress . to_s () + \"%] \" + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } ; println ! (\"\\n✅ All files processed!\") } } } } fn main () { }\n  |\n\nerror[E0599]: no method named `len` found for type parameter `T` in the current scope\n --> /tmp/.tmp5XQ85C/main.rs:1:696\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len ()...\n  |       - method `len` not found for this type parameter                                                                                                                           ^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\") ; println ! (\"\") ; println ! (\"Usage:\") ; println ! (\"  ruchy run file_stats.ruchy <filename>\") ; println ! (\"\") ; println ! (\"Examples:\") ; println ! (\"  ruchy run file_stats.ruchy document.txt\") ; println ! (\"  ruchy run file_stats.ruchy data/*.csv\") ; println ! (\"\") ; println ! (\"Options:\") ; println ! (\"  --help     Show this help message\") ; println ! (\"  --verbose  Show detailed output\") } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let progress = i + 1i32 * 100i32 / total ; print ! (\"{}\" , \"\\rProcessing... [\" + progress . to_s () + \"%] \" + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\") } } } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           +++++++++++++++++++\n\nerror[E0608]: cannot index into a value of type `T`\n --> /tmp/.tmp5XQ85C/main.rs:1:765\n  |\n1 | ...() ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let progress = i + 1i32 * 100i32 / total ; print ! (\"{}\" , \"\\...\n  |                                                                     ^^^\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmp5XQ85C/main.rs:1:865\n  |\n1 | ... ; print ! (\"{}\" , \"\\rProcessing... [\" + progress . to_s () + \"%] \" + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } ...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmp5XQ85C/main.rs:1:873\n  |\n1 | ...1i32 * 100i32 / total ; print ! (\"{}\" , \"\\rProcessing... [\" + progress . to_s () + \"%] \" + file) ; process_file (file) ; sleep (100i32...\n  |                                            ---------------------------------------- ^ ----- &str\n  |                                            |\n  |                                            str\n\nerror[E0425]: cannot find function `process_file` in this scope\n --> /tmp/.tmp5XQ85C/main.rs:1:891\n  |\n1 | ...ing... [\" + progress . to_s () + \"%] \" + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All file...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp5XQ85C/main.rs:1:953\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let progress = i + 1i32 * 100i32 / total ; print ! (\"{}\" , \"\\rProcessing... [\" + progress . to_s () + \"%] \" + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\") } }...\n  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 7 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0369, E0425, E0599, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: len()"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 10,
          "line_number": 404,
          "code": "// Status: ✅ WORKING\n// Example: Manual line counting implementation\n\nfun main() {\n    // Sample file content for demonstration\n    let content = \"line 1\\nline 2\\nline 3\";\n    \n    // Manual line counting implementation\n    let mut lines = 1;\n    let mut i = 0;\n    while i < content.len() {\n        if content[i] == '\\n' {\n            lines = lines + 1;\n        }\n        i = i + 1;\n    }\n    \n    println(\"File has\", lines, \"lines\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpfWDLDd/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let content = \"line 1\\nline 2\\nline 3\" ; { let mut lines = 1i32 ; let mut i = 0i32 ;...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpfWDLDd/main.rs:1:50\n  |\n1 | ... { { { let content = \"line 1\\nline 2\\nline 3\" ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"{} {} {}\" , \"File has\" , lines , \"lines\") } } } }\n  |       ^^                                                                                                                                                                                                                                                        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let content = \"line 1\\nline 2\\nline 3\" ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"{} {} {}\" , \"File has\" , lines , \"lines\") } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let content = \"line 1\\nline 2\\nline 3\" ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"{} {} {}\" , \"File has\" , lines , \"lines\") } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpfWDLDd/main.rs:1:195\n  |\n1 | ...hile i < content . len () { { if content [i] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"{} {} {}\" , \"File h...\n  |                                                           ^^                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let content = \"line 1\\nline 2\\nline 3\" ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"{} {} {}\" , \"File has\" , lines , \"lines\") } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let content = \"line 1\\nline 2\\nline 3\" ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i] == '\\n' { lines = lines + 1i32 } ; i = i + 1i32 } } ; println ! (\"{} {} {}\" , \"File has\" , lines , \"lines\") } } } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpfWDLDd/main.rs:1:149\n  |\n1 | ...t lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 ...\n  |                                              -   ^^^^^^^^^^^^^^^^ expected `i32`, found `usize`\n  |                                              |\n  |                                              expected because this is `i32`\n  |\nhelp: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let content = \"line 1\\nline 2\\nline 3\" ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len ().try_into().unwrap() { { if content [i] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"{} {} {}\" , \"File has\" , lines , \"lines\") } } } }\n  |                                                                                                                                                                     ++++++++++++++++++++\n\nerror[E0277]: the type `str` cannot be indexed by `i32`\n --> /tmp/.tmpfWDLDd/main.rs:1:182\n  |\n1 | ...32 ; while i < content . len () { { if content [i] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"{} {} {}\" , \"...\n  |                                                    ^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `i32`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `str` to implement `Index<i32>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 11,
          "line_number": 504,
          "code": "// Status: ✅ WORKING\n\n// task_manager.ruchy - A simple but useful task management tool\n\nlet TASK_FILE = \"tasks.txt\"\n\nfun show_menu() {\n    println(\"\\n=== Task Manager ===\")\n    println(\"1. List tasks\")\n    println(\"2. Add task\")\n    println(\"3. Complete task\")\n    println(\"4. Delete task\")\n    println(\"5. Quit\")\n}\n\nfun load_tasks() {\n    if file_exists(TASK_FILE) {\n        return read_lines(TASK_FILE)\n    }\n    return []\n}\n\nfun save_tasks(tasks) {\n    let content = tasks.join(\"\\n\")\n    write_file(TASK_FILE, content)\n}\n\nfun list_tasks(tasks) {\n    if tasks.is_empty() {\n        println(\"\\n📝 No tasks yet!\")\n        return\n    }\n    \n    println(\"\\n📋 Your Tasks (\" + tasks.len().to_s() + \" items):\")\n    let mut i = 0\n    while i < tasks.len() {\n        let task = tasks[i]\n        let status = if task.starts_with(\"✅\") { \"DONE\" } else { \"PENDING\" }\n        println((i + 1).to_s() + \". \" + task)\n        i = i + 1\n    }\n}\n\nfun add_task(tasks) {\n    let new_task = input(\"\\nWhat do you want to add? \")\n    tasks.push(\"📌 \" + new_task)\n    save_tasks(tasks)\n    println(\"✅ Task added!\")\n}\n\nfun complete_task(tasks) {\n    list_tasks(tasks)\n    let index = input(\"\\nWhich task to complete? (number): \").to_i() - 1\n    \n    if index >= 0 && index < tasks.len() {\n        tasks[index] = tasks[index].replace(\"📌\", \"✅\")\n        save_tasks(tasks)\n        println(\"🎉 Task completed!\")\n    } else {\n        println(\"❌ Invalid task number\")\n    }\n}\n\n// Main program loop\nlet tasks = load_tasks()\n\nloop {\n    show_menu()\n    let choice = input(\"\\nChoose option: \")\n    \n    match choice {\n        \"1\" => list_tasks(tasks)\n        \"2\" => add_task(tasks)\n        \"3\" => complete_task(tasks)\n        \"4\" => {\n            list_tasks(tasks)\n            let index = input(\"Which task to delete? (number): \").to_i() - 1\n            if index >= 0 && index < tasks.len() {\n                tasks.remove(index)\n                save_tasks(tasks)\n                println(\"🗑️  Task deleted!\")\n            }\n        }\n        \"5\" => {\n            println(\"👋 Goodbye!\")\n            break\n        }\n        _ => println(\"❌ Invalid choice\")\n    }\n}",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `TASK_FILE` in this scope\n --> /tmp/.tmp1iRFru/main.rs:1:281\n  |\n1 | .... Quit\") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `TASK_FILE` in this scope\n --> /tmp/.tmp1iRFru/main.rs:1:315\n  |\n1 | ...if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `TASK_FILE` in this scope\n --> /tmp/.tmp1iRFru/main.rs:1:567\n  |\n1 | ...{ let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + st...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp1iRFru/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp1iRFru/main.rs:1:294\n  |\n1 | ...fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std ::...\n  |                                                      ^^                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () . to_s () + \" items):\") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌 \" + new_task) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () { { if file_exists (TASK_FILE) { return read_lines (TASK_FILE) } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () . to_s () + \" items):\") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌 \" + new_task) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp1iRFru/main.rs:1:515\n  |\n1 | ...+ Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std ::...\n  |                                 ^^                                                                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () . to_s () + \" items):\") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌 \" + new_task) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () . to_s () + \" items):\") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌 \" + new_task) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp1iRFru/main.rs:1:959\n  |\n1 | ... { { { let task = tasks [i] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } }...\n  |       ^^                                                                                                                                                                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () . to_s () + \" items):\") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌 \" + new_task) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () . to_s () + \" items):\") ; let mut i = 0i32 ; while i < tasks . len () { { let task = tasks [i] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌 \" + new_task) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp1iRFru/main.rs:1:1031\n  |\n1 | ...sk = tasks [i] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s (...\n  |                                                                   ^^      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () . to_s () + \" items):\") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌 \" + new_task) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () . to_s () + \" items):\") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with (\"✅\") { \"DONE\" } else { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌 \" + new_task) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp1iRFru/main.rs:1:1051\n  |\n1 | ... status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i =...\n  |                                                                 ^^         ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () . to_s () + \" items):\") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌 \" + new_task) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () . to_s () + \" items):\") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { \"PENDING\" } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌 \" + new_task) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp1iRFru/main.rs:1:1309\n  |\n1 | ... { { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌 \" + new_task) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn...\n  |       ^^                                                                                                                                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () . to_s () + \" items):\") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌 \" + new_task) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () . to_s () + \" items):\") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌 \" + new_task) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp1iRFru/main.rs:1:1894\n  |\n1 | ...) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" ...\n  |                                                    ^^                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () . to_s () + \" items):\") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌 \" + new_task) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () . to_s () + \" items):\") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌 \" + new_task) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { println ! (\"❌ Invalid task number\") } } } } fn main () { let TASK_FILE = \"tasks.txt\" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmp1iRFru/main.rs:1:268\n  |\n1 | ...rintln ! (\"5. Quit\") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } f...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `read_lines` in this scope\n --> /tmp/.tmp1iRFru/main.rs:1:303\n  |\n1 | ...asks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: A...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `join` found for type parameter `T` in the current scope\n --> /tmp/.tmp1iRFru/main.rs:1:541\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"...\n  |       - method `join` not found for this type parameter                                                                                                                            ^^^^ method not found in `T`\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmp1iRFru/main.rs:1:555\n  |\n1 | ...T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Outpu...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `is_empty` found for type parameter `T` in the current scope\n --> /tmp/.tmp1iRFru/main.rs:1:770\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty ()...\n  |       - method `is_empty` not found for this type parameter                                                                                                           ^^^^^^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following traits define an item `is_empty`, perhaps you need to restrict type parameter `T` with one of them:\n  |\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () . to_s () + \" items):\") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌 \" + new_task) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                +++++++++++++++++++\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + RangeBounds</* T */> > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () . to_s () + \" items):\") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌 \" + new_task) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ++++++++++++++++++++++\n\nerror[E0069]: `return;` in a function whose return type is not `()`\n --> /tmp/.tmp1iRFru/main.rs:1:820\n  |\n1 | ... > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" +...\n  |                      - expected `T` because of this return type                          ^^^^^^ return type is not `()`\n  |\nhelp: give the `return` a value of the expected type\n  |\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return /* value */ } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () . to_s () + \" items):\") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌 \" + new_task) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            +++++++++++\n\nerror[E0599]: no method named `len` found for type parameter `T` in the current scope\n --> /tmp/.tmp1iRFru/main.rs:1:880\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () ....\n  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                ^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () . to_s () + \" items):\") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌 \" + new_task) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                +++++++++++++++++++\n\nerror[E0369]: cannot add `&str` to `str`\n --> /tmp/.tmp1iRFru/main.rs:1:897\n  |\n1 | ...) ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () . to_s () + \" items):\") ; let mut i = 0i32 ; while i < tasks . l...\n  |                                       ---------------------------------------------- ^ ---------- &str\n  |                                       |\n  |                                       str\n\nerror[E0599]: no method named `len` found for type parameter `T` in the current scope\n --> /tmp/.tmp1iRFru/main.rs:1:950\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () . to_s () + \" items):\") ; let mut i = 0i32 ; while i < tasks . len () {...\n  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                                                                                      ^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () . to_s () + \" items):\") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌 \" + new_task) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                +++++++++++++++++++\n\nerror[E0608]: cannot index into a value of type `T`\n --> /tmp/.tmp1iRFru/main.rs:1:980\n  |\n1 | ...t mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else {...\n  |                                                                     ^^^\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmp1iRFru/main.rs:1:1098\n  |\n1 | ...se { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: ...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0277]: cannot add `&str` to `i32`\n --> /tmp/.tmp1iRFru/main.rs:1:1106\n  |\n1 | ...DING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Outpu...\n  |                                                     ^ no implementation for `i32 + &str`\n  |\n  = help: the trait `Add<&str>` is not implemented for `i32`\n  = help: the following other types implement trait `Add<Rhs>`:\n            `&i32` implements `Add<i32>`\n            `&i32` implements `Add`\n            `i32` implements `Add<&i32>`\n            `i32` implements `Add`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp1iRFru/main.rs:1:932\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () . to_s () + \" items):\") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } } } f...\n  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                                                                                                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: the caller chooses a type for `T` which can be different from `()`\n  = note: `while` loops evaluate to unit type `()`\nhelp: consider returning a value here\n  |\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () . to_s () + \" items):\") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } /* `T` value */ } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌 \" + new_task) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           +++++++++++++++\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmp1iRFru/main.rs:1:1328\n  |\n1 | ...bug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌 \" + new_task) ; save_tas...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0599]: no method named `push` found for type parameter `T` in the current scope\n --> /tmp/.tmp1iRFru/main.rs:1:1378\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌...\n  |       - method `push` not found for this type parameter                                                                                                                                                                       ^^^^ method not found in `T`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp1iRFru/main.rs:1:1424\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌 \" + new_task) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } ...\n  |       - expected this type parameter                                                                                                                                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmp1iRFru/main.rs:1:1663\n  |\n1 | ...ks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0599]: no method named `len` found for type parameter `T` in the current scope\n --> /tmp/.tmp1iRFru/main.rs:1:1765\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len ()...\n  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                              ^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{}\" , \"\\n📋 Your Tasks (\" + tasks . len () . to_s () + \" items):\") ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , i + 1i32 . to_s () + \". \" + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \") ; { tasks . push (\"📌 \" + new_task) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" ; let tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp1iRFru/main.rs:1:1851\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } e...\n  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp1iRFru/main.rs:1:1896\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } ...\n  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmp1iRFru/main.rs:1:2052\n  |\n1 | ...d_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => ad...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0277]: cannot add `()` to `()`\n --> /tmp/.tmp1iRFru/main.rs:1:2116\n  |\n1 | ...oose option: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_ta...\n  |                                            ----------  ^^^^^ no implementation for `() + ()`\n  |                                            |\n  |                                            required by a bound introduced by this call\n  |\n  = help: the trait `Add` is not implemented for `()`\nnote: required by a bound in `list_tasks`\n --> /tmp/.tmp1iRFru/main.rs:1:614\n  |\n1 | ...ent) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fm...\n  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`\n\nerror[E0277]: cannot multiply `()` by `()`\n --> /tmp/.tmp1iRFru/main.rs:1:2116\n  |\n1 | ...oose option: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_ta...\n  |                                            ----------  ^^^^^ no implementation for `() * ()`\n  |                                            |\n  |                                            required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `()`\nnote: required by a bound in `list_tasks`\n --> /tmp/.tmp1iRFru/main.rs:1:649\n  |\n1 | ...:: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) ->...\n  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`\n\nerror[E0277]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmp1iRFru/main.rs:1:2116\n  |\n1 | ...: \") ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks)...\n  |                                 ----------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`\n  |                                 |\n  |                                 required by a bound introduced by this call\n  |\nnote: required by a bound in `list_tasks`\n --> /tmp/.tmp1iRFru/main.rs:1:684\n  |\n1 | ...+ std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty ()...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`\n\nerror[E0277]: cannot add `()` to `()`\n --> /tmp/.tmp1iRFru/main.rs:1:2142\n  |\n1 | ...ice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index =...\n  |                                             --------  ^^^^^ no implementation for `() + ()`\n  |                                             |\n  |                                             required by a bound introduced by this call\n  |\n  = help: the trait `Add` is not implemented for `()`\nnote: required by a bound in `add_task`\n --> /tmp/.tmp1iRFru/main.rs:1:1166\n  |\n1 | ...2 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: f...\n  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `add_task`\n\nerror[E0277]: cannot multiply `()` by `()`\n --> /tmp/.tmp1iRFru/main.rs:1:2142\n  |\n1 | ...ice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index =...\n  |                                             --------  ^^^^^ no implementation for `() * ()`\n  |                                             |\n  |                                             required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `()`\nnote: required by a bound in `add_task`\n --> /tmp/.tmp1iRFru/main.rs:1:1201\n  |\n1 | ... :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -...\n  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `add_task`\n\nerror[E0277]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmp1iRFru/main.rs:1:2142\n  |\n1 | ...> list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Wh...\n  |                                  --------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`\n  |                                  |\n  |                                  required by a bound introduced by this call\n  |\nnote: required by a bound in `add_task`\n --> /tmp/.tmp1iRFru/main.rs:1:1236\n  |\n1 | ... + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = inpu...\n  |                                          ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `add_task`\n\nerror[E0277]: cannot add `()` to `()`\n --> /tmp/.tmp1iRFru/main.rs:1:2173\n  |\n1 | ...s) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete...\n  |                                          -------------  ^^^^^ no implementation for `() + ()`\n  |                                          |\n  |                                          required by a bound introduced by this call\n  |\n  = help: the trait `Add` is not implemented for `()`\nnote: required by a bound in `complete_task`\n --> /tmp/.tmp1iRFru/main.rs:1:1483\n  |\n1 | ... } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt...\n  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `complete_task`\n\nerror[E0277]: cannot multiply `()` by `()`\n --> /tmp/.tmp1iRFru/main.rs:1:2173\n  |\n1 | ...s) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete...\n  |                                          -------------  ^^^^^ no implementation for `() * ()`\n  |                                          |\n  |                                          required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `()`\nnote: required by a bound in `complete_task`\n --> /tmp/.tmp1iRFru/main.rs:1:1518\n  |\n1 | ...: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> ...\n  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `complete_task`\n\nerror[E0277]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmp1iRFru/main.rs:1:2173\n  |\n1 | ...> add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number)...\n  |                                -------------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`\n  |                                |\n  |                                required by a bound introduced by this call\n  |\nnote: required by a bound in `complete_task`\n --> /tmp/.tmp1iRFru/main.rs:1:1553\n  |\n1 | ...std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { l...\n  |                                       ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `complete_task`\n\nerror[E0277]: cannot add `()` to `()`\n --> /tmp/.tmp1iRFru/main.rs:1:2203\n  |\n1 | ...\"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32...\n  |                                            ----------  ^^^^^ no implementation for `() + ()`\n  |                                            |\n  |                                            required by a bound introduced by this call\n  |\n  = help: the trait `Add` is not implemented for `()`\nnote: required by a bound in `list_tasks`\n --> /tmp/.tmp1iRFru/main.rs:1:614\n  |\n1 | ...ent) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fm...\n  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`\n\nerror[E0277]: cannot multiply `()` by `()`\n --> /tmp/.tmp1iRFru/main.rs:1:2203\n  |\n1 | ...\"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32...\n  |                                            ----------  ^^^^^ no implementation for `() * ()`\n  |                                            |\n  |                                            required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `()`\nnote: required by a bound in `list_tasks`\n --> /tmp/.tmp1iRFru/main.rs:1:649\n  |\n1 | ...:: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) ->...\n  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`\n\nerror[E0277]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmp1iRFru/main.rs:1:2203\n  |\n1 | ...lete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32 ; if index...\n  |                                 ----------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`\n  |                                 |\n  |                                 required by a bound introduced by this call\n  |\nnote: required by a bound in `list_tasks`\n --> /tmp/.tmp1iRFru/main.rs:1:684\n  |\n1 | ...+ std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty ()...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmp1iRFru/main.rs:1:2226\n  |\n1 | ...asks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \") . to_i () - 1i32 ; if index >= 0i32 && ...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0599]: no method named `len` found for unit type `()` in the current scope\n    --> /tmp/.tmp1iRFru/main.rs:1:2324\n     |\n1    | ...mber): \") . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"...\n     |                                                                     ^^^\n     |\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1402:5\n     |\n1402 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `remove` found for unit type `()` in the current scope\n --> /tmp/.tmp1iRFru/main.rs:1:2343\n  |\n1 | ...ndex >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } ...\n  |                                                       ^^^^^^ method not found in `()`\n\nerror[E0277]: cannot add `()` to `()`\n --> /tmp/.tmp1iRFru/main.rs:1:2372\n  |\n1 | ...s . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Go...\n  |                                            ----------  ^^^^^ no implementation for `() + ()`\n  |                                            |\n  |                                            required by a bound introduced by this call\n  |\n  = help: the trait `Add` is not implemented for `()`\nnote: required by a bound in `save_tasks`\n --> /tmp/.tmp1iRFru/main.rs:1:372\n  |\n1 | ...c ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fm...\n  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `save_tasks`\n\nerror[E0277]: cannot multiply `()` by `()`\n --> /tmp/.tmp1iRFru/main.rs:1:2372\n  |\n1 | ...s . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Go...\n  |                                            ----------  ^^^^^ no implementation for `() * ()`\n  |                                            |\n  |                                            required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `()`\nnote: required by a bound in `save_tasks`\n --> /tmp/.tmp1iRFru/main.rs:1:407\n  |\n1 | ...:: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) ->...\n  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `save_tasks`\n\nerror[E0277]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmp1iRFru/main.rs:1:2372\n  |\n1 | ...{ { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; ...\n  |                                 ----------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`\n  |                                 |\n  |                                 required by a bound introduced by this call\n  |\nnote: required by a bound in `save_tasks`\n --> /tmp/.tmp1iRFru/main.rs:1:442\n  |\n1 | ...+ std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `save_tasks`\n\nerror: aborting due to 42 previous errors; 8 warnings emitted\n\nSome errors have detailed explanations: E0069, E0277, E0308, E0369, E0425, E0599, E0608.\nFor more information about an error, try `rustc --explain E0069`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: join()"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 12,
          "line_number": 622,
          "code": "// Status: ✅ WORKING\n// ❌ This demonstrates what NOT to do - no error handling\n\nfun main() {\n    // Example of code that would fail without proper error checking\n    println(\"Example: Unsafe file operations\");\n    println(\"This pattern would crash if file doesn't exist:\");\n    println(\"// let content = read_file(\\\"missing.txt\\\");\");\n    \n    // Better approach would include error checking\n    println(\"Always check if operations can fail before using them\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 13,
          "line_number": 642,
          "code": "// Status: ✅ WORKING\n\n// ❌ Confusing and unhelpful\nprintln(\"Enter thing:\")\nlet thing = input()\n// What thing? What format?",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmp2LJbuX/main.rs:1:115\n  |\n1 | ...\"Enter thing:\") ; let thing = input () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp2LJbuX/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"Enter thing:\") ; let thing = input () } ; if let Some (s) = (...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 14,
          "line_number": 657,
          "code": "// Status: ✅ WORKING\n\n// ❌ Only works on your computer\nlet data = read_file(\"/Users/noah/Desktop/data.txt\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected expression, found `let` statement\n --> /tmp/.tmpXyviY1/main.rs:1:63\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let data = read_file (\"/Users/noah/Desktop/data.txt\") ; if let Some (s) = (...\n  |                                                               ^^^\n  |\n  = note: only supported directly in conditions of `if` and `while` expressions\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpXyviY1/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let data = read_file (\"/Users/noah/Desktop/data.txt\") ; if let Some (s) = (...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmpXyviY1/main.rs:1:74\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let data = read_file (\"/Users/noah/Desktop/data.txt\") ; if let Some (s) = (...\n  |                                                                          ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch12-00-traits-generics": {
      "chapter": "ch12-00-traits-generics",
      "total_examples": 11,
      "working_examples": 0,
      "failing_examples": 11,
      "examples": [
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected Greater, found Colon\n// Define behavior with traits\ntrait Serializable {\n    fun serialize(self) -> String\n    fun deserialize(String) -> Self\n}\n\n// Generic function works with any Serializable type\nfun save_to_file<T: Serializable>(item: T, path: String) {\n    let serialized = item.serialize()\n    write_file(path, serialized)\n}\n\nfun load_from_file<T: Serializable>(path: String) -> T {\n    let content = read_file(path)\n    return T::deserialize(content)\n}\n\n// Implement trait for your types\nstruct User {\n    name: String\n    email: String\n    age: i32\n}\n\nimpl Serializable for User {\n    fun serialize(self) -> String {\n        return to_json(self)\n    }\n    \n    fun deserialize(data: String) -> User {\n        return parse_json(data)\n    }\n}\n\n// Now it just works!\nlet user = User{name: \"Alice\", email: \"alice@example.com\", age: 30}\nsave_to_file(user, \"user.json\")  // Generic function, specific type\nlet loaded: User = load_from_file(\"user.json\")  // Type safe!",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 2,
          "line_number": 85,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected 'fun' or 'fn' keyword\n// Simple trait\ntrait Drawable {\n    fun draw(self)\n}\n\n// Trait with multiple methods\ntrait Container {\n    fun len(self) -> i32\n    fun is_empty(self) -> bool {\n        return self.len() == 0  // Default implementation\n    }\n    fun clear(mut self)\n}\n\n// Traits with associated types\ntrait Iterator {\n    type Item\n    \n    fun next(mut self) -> Option<Item>\n    \n    fun collect(mut self) -> Vec<Item> {\n        let result = Vec::new()\n        while let Some(item) = self.next() {\n            result.push(item)\n        }\n        return result\n    }\n}\n\n// Traits with constraints\ntrait Comparable: Eq {\n    fun compare(self, other: Self) -> Ordering\n}\n\n// Trait inheritance\ntrait Animal {\n    fun speak(self)\n}\n\ntrait Dog: Animal {\n    fun wag_tail(self)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 3,
          "line_number": 140,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected RightBrace, found Identifier(\"y\")\nstruct Point {\n    x: f64\n    y: f64\n}\n\nimpl Drawable for Point {\n    fun draw(self) {\n        println(\"Point at (\" + self.x.to_s() + \", \" + self.y.to_s() + \")\")\n    }\n}\n\nstruct Circle {\n    center: Point\n    radius: f64\n}\n\nimpl Drawable for Circle {\n    fun draw(self) {\n        println(\"Circle at (\" + self.center.x.to_s() + \", \" + self.center.y.to_s() + \") with radius \" + self.radius.to_s())\n    }\n}\n\n// Now both types can be drawn\nlet p = Point{x: 10, y: 20}\nlet c = Circle{center: p, radius: 5}\n\np.draw()  // Trait method\nc.draw()  // Same interface, different implementation\n\n// Implement traits for existing types\nimpl Drawable for String {\n    fun draw(self) {\n        println(\"Text: \" + self)\n    }\n}\n\n\"Hello\".draw()  // Extension methods!",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 4,
          "line_number": 190,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected type\n// Simple generic function\nfun swap<T>(a: mut T, b: mut T) {\n    let temp = a\n    a = b\n    b = temp\n}\n\n// Multiple type parameters\nfun pair<K, V>(key: K, value: V) -> (K, V) {\n    return (key, value)\n}\n\n// Trait bounds\nfun print_all<T: Display>(items: Vec<T>) {\n    for item in items {\n        println(item)  // Works because T implements Display\n    }\n}\n\n// Multiple bounds\nfun process<T: Clone + Debug + Send>(item: T) {\n    let copy = item.clone()\n    debug(copy)\n    send_to_thread(item)\n}\n\n// Where clauses for complex bounds\nfun complex_function<T, U>(x: T, y: U) -> Vec<T>\nwhere\n    T: Clone + From<U>,\n    U: Display + Into<String>\n{\n    let converted: T = T::from(y)\n    return vec![x.clone(), converted]\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 5,
          "line_number": 238,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected RightBrace, found Identifier(\"second\")\n// Generic struct\nstruct Pair<T> {\n    first: T\n    second: T\n}\n\nimpl<T> Pair<T> {\n    fun new(first: T, second: T) -> Pair<T> {\n        return Pair{first, second}\n    }\n    \n    fun swap(mut self) {\n        let temp = self.first\n        self.first = self.second\n        self.second = temp\n    }\n}\n\n// Generic enum\nenum Option<T> {\n    Some(T)\n    None\n}\n\nenum Result<T, E> {\n    Ok(T)\n    Err(E)\n}\n\n// Generic with constraints\nstruct SortedVec<T: Ord> {\n    items: Vec<T>\n}\n\nimpl<T: Ord> SortedVec<T> {\n    fun insert(mut self, item: T) {\n        let pos = self.items.binary_search(item)\n        self.items.insert(pos, item)\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 6,
          "line_number": 291,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected Greater, found Colon\n// Custom collection with traits\nstruct Cache<K: Hash + Eq, V> {\n    map: HashMap<K, V>\n    max_size: usize\n    access_order: Vec<K>\n}\n\nimpl<K: Hash + Eq + Clone, V: Clone> Cache<K, V> {\n    fun new(max_size: usize) -> Cache<K, V> {\n        return Cache{\n            map: HashMap::new(),\n            max_size,\n            access_order: Vec::new()\n        }\n    }\n    \n    fun get(mut self, key: K) -> Option<V> {\n        if let Some(value) = self.map.get(key) {\n            // Update access order\n            self.access_order.retain(|k| k != key)\n            self.access_order.push(key.clone())\n            return Some(value.clone())\n        }\n        return None\n    }\n    \n    fun put(mut self, key: K, value: V) {\n        if self.map.len() >= self.max_size && !self.map.contains_key(key) {\n            // Evict least recently used\n            let lru = self.access_order.remove(0)\n            self.map.remove(lru)\n        }\n        \n        self.map.insert(key.clone(), value)\n        self.access_order.push(key)\n    }\n}\n\n// Use with any hashable types\nlet cache: Cache<String, User> = Cache::new(100)\ncache.put(\"alice\", alice_user)\n\nlet cache2: Cache<i32, Vec<String>> = Cache::new(50)\ncache2.put(1, vec![\"data\"])",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 7,
          "line_number": 348,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected type\n// Trait for plugins\ntrait Plugin {\n    fun name(self) -> String\n    fun execute(self, context: Context) -> Result<(), Error>\n}\n\nstruct LogPlugin {\n    level: String\n}\n\nimpl Plugin for LogPlugin {\n    fun name(self) -> String {\n        return \"Logger\"\n    }\n    \n    fun execute(self, context: Context) -> Result<(), Error> {\n        log(self.level, context.message)\n        return Ok(())\n    }\n}\n\n// Store different plugin types\nlet plugins: Vec<Box<dyn Plugin>> = vec![\n    Box::new(LogPlugin{level: \"INFO\"}),\n    Box::new(MetricsPlugin{...}),\n    Box::new(CachePlugin{...})\n]\n\n// Execute all plugins\nfor plugin in plugins {\n    plugin.execute(context)?\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 8,
          "line_number": 391,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected LeftBrace, found Less\n// Generic builder\nstruct Builder<T> {\n    value: T\n}\n\nimpl<T> Builder<T> {\n    fun new(initial: T) -> Builder<T> {\n        return Builder{value: initial}\n    }\n    \n    fun with<F>(mut self, f: F) -> Builder<T>\n    where F: FnOnce(mut T) -> T\n    {\n        self.value = f(self.value)\n        return self\n    }\n    \n    fun build(self) -> T {\n        return self.value\n    }\n}\n\n// Use with any type\nlet config = Builder::new(Config::default())\n    .with(|c| { c.port = 8080; c })\n    .with(|c| { c.host = \"localhost\"; c })\n    .with(|c| { c.workers = 4; c })\n    .build()\n\nlet user = Builder::new(User::new())\n    .with(|u| { u.name = \"Alice\"; u })\n    .with(|u| { u.role = Role::Admin; u })\n    .build()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 9,
          "line_number": 435,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected 'fun' or 'fn' keyword\n// Associated types pattern\ntrait Graph {\n    type Node\n    type Edge\n    \n    fun nodes(self) -> Vec<Node>\n    fun edges(self) -> Vec<Edge>\n    fun neighbors(self, node: Node) -> Vec<Node>\n}\n\nstruct SocialNetwork {\n    users: Vec<User>\n    connections: Vec<Friendship>\n}\n\nimpl Graph for SocialNetwork {\n    type Node = User\n    type Edge = Friendship\n    \n    fun nodes(self) -> Vec<User> {\n        return self.users\n    }\n    \n    fun edges(self) -> Vec<Friendship> {\n        return self.connections\n    }\n    \n    fun neighbors(self, user: User) -> Vec<User> {\n        self.connections\n            .filter(|f| f.from == user.id || f.to == user.id)\n            .map(|f| self.get_user(f.other_id(user.id)))\n            .collect()\n    }\n}\n\n// Phantom types for compile-time guarantees\nstruct Id<T> {\n    value: String\n    _phantom: PhantomData<T>\n}\n\nimpl<T> Id<T> {\n    fun new(value: String) -> Id<T> {\n        return Id{value, _phantom: PhantomData}\n    }\n}\n\n// Type-safe IDs\nlet user_id: Id<User> = Id::new(\"user_123\")\nlet post_id: Id<Post> = Id::new(\"post_456\")\n\n// Won't compile - type safety!\n// let wrong = user_id == post_id",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 10,
          "line_number": 501,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected Greater, found Colon\n// Generics are monomorphized - no runtime cost\nfun generic_add<T: Add>(a: T, b: T) -> T {\n    return a + b  // Compiles to specific add instruction\n}\n\n// This generates two functions at compile time:\nlet int_result = generic_add(5, 10)      // Generates add_i32\nlet float_result = generic_add(5.0, 10.0) // Generates add_f64\n\n// Trait bounds are checked at compile time\nfun process<T: Send + Sync>(item: T) {\n    // Can safely send to another thread\n    spawn(|| {\n        use_item(item)\n    })\n}\n\n// Inline hints for performance\n#[inline]\nfun hot_path<T: Copy>(x: T) -> T {\n    return x  // Will be inlined\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 11,
          "line_number": 534,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected Greater, found Colon\n// Static dispatch (faster)\nfun static_dispatch<T: Display>(item: T) {\n    println(item)  // Direct call, no indirection\n}\n\n// Dynamic dispatch (flexible)\nfun dynamic_dispatch(item: Box<dyn Display>) {\n    println(item)  // Virtual call through vtable\n}\n\n// Choose based on needs:\n// - Static: Known types, performance critical\n// - Dynamic: Plugin systems, heterogeneous collections",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch03-00-functions-tdd": {
      "chapter": "ch03-00-functions-tdd",
      "total_examples": 9,
      "working_examples": 8,
      "failing_examples": 1,
      "examples": [
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 1,
          "line_number": 17,
          "code": "fun greet() {\n    println(\"Hello from function!\");\n}\n\nfun main() {\n    greet();\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 2,
          "line_number": 36,
          "code": "fun add(a, b) {\n    a + b\n}\n\nfun main() {\n    let result = add(5, 3);\n    println(result);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 3,
          "line_number": 56,
          "code": "fun multiply(x: i32, y: i32) -> i32 {\n    x * y\n}\n\nfun main() {\n    let product = multiply(6, 7);\n    println(product);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 4,
          "line_number": 76,
          "code": "fun square(n: i32) -> i32 {\n    n * n\n}\n\nfun sum_of_squares(a: i32, b: i32) -> i32 {\n    square(a) + square(b)\n}\n\nfun main() {\n    let result = sum_of_squares(3, 4);\n    println(result);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 5,
          "line_number": 100,
          "code": "fun function_name(parameters) -> return_type {\n    // function body\n    return_expression\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `return_type` in this scope\n --> /tmp/.tmp4WSaK8/main.rs:1:204\n  |\n1 | ...td :: fmt :: Debug + Clone > (parameters : T) -> return_type { { return_expression } } fn main () { }\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `return_expression` in this scope\n --> /tmp/.tmp4WSaK8/main.rs:1:220\n  |\n1 | ...+ Clone > (parameters : T) -> return_type { { return_expression } } fn main () { }\n  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp4WSaK8/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn function_name < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: f...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4WSaK8/main.rs:1:218\n  |\n1 | ...mt :: Debug + Clone > (parameters : T) -> return_type { { return_expression } } fn main () { }\n  |                                                            ^^                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn function_name < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (parameters : T) -> return_type { { return_expression } } fn main () { }\n1 + use std :: collections :: HashMap ; fn function_name < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (parameters : T) -> return_type { return_expression } fn main () { }\n  |\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 6,
          "line_number": 135,
          "code": "fun calculate(x: i32, y: i32) -> i32 {\n    x * 2 + y * 3\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 7,
          "line_number": 161,
          "code": "fun calculate(input: i32) -> i32 {\n    input * 2\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 8,
          "line_number": 168,
          "code": "fun combine(a: i32, b: i32, c: i32) -> i32 {\n    a + b + c\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 9,
          "line_number": 175,
          "code": "fun helper(x: i32) -> i32 {\n    x * x\n}\n\nfun main_calculation(n: i32) -> i32 {\n    helper(n) + helper(n + 1)\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch11-00-file-operations-tdd": {
      "chapter": "ch11-00-file-operations-tdd",
      "total_examples": 10,
      "working_examples": 6,
      "failing_examples": 4,
      "examples": [
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 1,
          "line_number": 17,
          "code": "fun read_config() -> i32 {\n    // Simulate reading a config value\n    return 42;\n}\n\nfun write_status(value: i32) -> bool {\n    // Simulate writing status\n    if value > 0 {\n        return true;\n    }\n    return false;\n}\n\nfun main() {\n    let config = read_config();\n    println(\"Config value:\");\n    println(config);\n    \n    let success = write_status(config);\n    println(\"Write success:\");\n    println(success);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 2,
          "line_number": 54,
          "code": "fun save_game_state(level: i32, score: i32) {\n    println(\"Saving game state...\");\n    println(\"Level:\");\n    println(level);\n    println(\"Score:\");\n    println(score);\n    println(\"State saved successfully\");\n}\n\nfun load_game_state() {\n    println(\"Loading game state...\");\n    println(\"Level: 5\");\n    println(\"Score: 1000\");\n    println(\"State loaded successfully\");\n}\n\nfun main() {\n    save_game_state(5, 1000);\n    println(\"---\");\n    load_game_state();\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 3,
          "line_number": 97,
          "code": "fun get_default_config() -> i32 {\n    return 100;\n}\n\nfun validate_config(value: i32) -> bool {\n    if value > 0 && value <= 1000 {\n        return true;\n    }\n    return false;\n}\n\nfun apply_config(value: i32) {\n    println(\"Applying configuration...\");\n    println(\"Config value:\");\n    println(value);\n    if validate_config(value) {\n        println(\"Configuration applied successfully\");\n    } else {\n        println(\"Invalid configuration\");\n    }\n}\n\nfun main() {\n    let config = get_default_config();\n    apply_config(config);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 4,
          "line_number": 157,
          "code": "fun read_data() -> DataType {\n    // Return simulated data\n    return default_value;\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `DataType` in this scope\n --> /tmp/.tmpyKewlP/main.rs:1:56\n  |\n1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }\n  |                                                        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `default_value` in this scope\n --> /tmp/.tmpyKewlP/main.rs:1:76\n  |\n1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }\n  |                                                                            ^^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpyKewlP/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpyKewlP/main.rs:1:67\n  |\n1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }\n  |                                                                   ^^                    ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }\n1 + use std :: collections :: HashMap ; fn read_data () -> DataType { return default_value } fn main () { }\n  |\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 5,
          "line_number": 165,
          "code": "fun write_data(value: DataType) -> bool {\n    // Validate and \"write\"\n    if valid(value) {\n        return true;\n    }\n    return false;\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `DataType` in this scope\n --> /tmp/.tmp3wOSxc/main.rs:1:60\n  |\n1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...\n  |                                                            ^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp3wOSxc/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp3wOSxc/main.rs:1:101\n  |\n1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...\n  |                                                                                                     ^^           ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } fn main () { }\n1 + use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { return true } ; return false } } fn main () { }\n  |\n\nerror[E0425]: cannot find function `valid` in this scope\n --> /tmp/.tmp3wOSxc/main.rs:1:85\n  |\n1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...\n  |                                                                                     ^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 6,
          "line_number": 176,
          "code": "fun load_config() -> ConfigType {\n    return default_config;\n}\n\nfun save_config(config: ConfigType) -> bool {\n    return validate(config);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `ConfigType` in this scope\n --> /tmp/.tmpEqJ3AU/main.rs:1:58\n  |\n1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...\n  |                                                          ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `default_config` in this scope\n --> /tmp/.tmpEqJ3AU/main.rs:1:80\n  |\n1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...\n  |                                                                                ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `ConfigType` in this scope\n --> /tmp/.tmpEqJ3AU/main.rs:1:124\n  |\n1 | ...eturn default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpEqJ3AU/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpEqJ3AU/main.rs:1:71\n  |\n1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...\n  |                                                                       ^^                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn load_config () -> ConfigType { return default_config } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpEqJ3AU/main.rs:1:146\n  |\n1 | ...g } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }\n  |                                                         ^^                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { return validate (config) } fn main () { }\n  |\n\nerror[E0425]: cannot find function `validate` in this scope\n --> /tmp/.tmpEqJ3AU/main.rs:1:155\n  |\n1 | ...ve_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 7,
          "line_number": 201,
          "code": "fun load_settings() -> i32 {\n    return 50; // Default volume\n}\n\nfun save_settings(volume: i32) -> bool {\n    return volume >= 0 && volume <= 100;\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 8,
          "line_number": 212,
          "code": "fun save_progress(level: i32, score: i32) {\n    println(\"Saving progress...\");\n    println(level);\n    println(score);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 9,
          "line_number": 221,
          "code": "fun get_cached_value(key: i32) -> i32 {\n    // Simulate cache lookup\n    if key == 1 {\n        return 100;\n    }\n    return 0;\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 10,
          "line_number": 232,
          "code": "fun log_event(message: &str, severity: i32) {\n    println(\"LOG:\");\n    println(message);\n    println(\"Severity:\");\n    println(severity);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch05-00-control-flow-tdd": {
      "chapter": "ch05-00-control-flow-tdd",
      "total_examples": 14,
      "working_examples": 7,
      "failing_examples": 7,
      "examples": [
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 1,
          "line_number": 17,
          "code": "fun main() {\n    let x = 10;\n    if x > 5 {\n        println(\"x is greater than 5\");\n    } else {\n        println(\"x is not greater than 5\");\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 2,
          "line_number": 37,
          "code": "fun main() {\n    let score = 85;\n    if score >= 80 {\n        println(\"Great job!\");\n    }\n    println(\"Score processed\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 3,
          "line_number": 57,
          "code": "fun main() {\n    let grade = 75;\n    if grade >= 90 {\n        println(\"A grade\");\n    } else if grade >= 80 {\n        println(\"B grade\");\n    } else if grade >= 70 {\n        println(\"C grade\");\n    } else {\n        println(\"Below C\");\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 4,
          "line_number": 81,
          "code": "fun main() {\n    let mut i = 0;\n    while i < 3 {\n        println(i);\n        i = i + 1;\n    }\n    println(\"Done\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 5,
          "line_number": 104,
          "code": "fun main() {\n    for i in 0..3 {\n        println(i);\n    }\n    println(\"For loop done\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 6,
          "line_number": 125,
          "code": "fun main() {\n    let number = 2;\n    match number {\n        1 => println(\"One\"),\n        2 => println(\"Two\"),\n        3 => println(\"Three\"),\n        _ => println(\"Other\")\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 7,
          "line_number": 146,
          "code": "fun main() {\n    let mut i = 0;\n    while i < 10 {\n        i = i + 1;\n        if i == 3 {\n            continue;\n        }\n        if i == 6 {\n            break;\n        }\n        println(i);\n    }\n    println(\"Loop ended\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 8,
          "line_number": 200,
          "code": "if condition {\n    // true branch\n} else if other_condition {\n    // else if branch\n} else {\n    // false branch\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `condition` in this scope\n --> /tmp/.tmpIVWJ2u/main.rs:1:66\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if condition { () } else { if other_condition { () } else { () } } ; if let...\n  |                                                                  ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `other_condition` in this scope\n --> /tmp/.tmpIVWJ2u/main.rs:1:93\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if condition { () } else { if other_condition { () } else { () } } ; if let...\n  |                                                                                             ^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpIVWJ2u/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if condition { () } else { if other_condition { () } else { () } } ; if let...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 9,
          "line_number": 211,
          "code": "// While loop\nwhile condition {\n    // loop body\n}\n\n// For loop with range\nfor variable in start..end {\n    // loop body\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `condition` in this scope\n --> /tmp/.tmpgpJ8UD/main.rs:1:71\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start .. end { () } } ; if let S...\n  |                                                                       ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `start` in this scope\n --> /tmp/.tmpgpJ8UD/main.rs:1:106\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start .. end { () } } ; if let S...\n  |                                                                                                          ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `end` in this scope\n --> /tmp/.tmpgpJ8UD/main.rs:1:115\n  |\n1 | ... { while condition { () } ; for variable in start .. end { () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast...\n  |                                                         ^^^ not found in this scope\n  |\nhelp: you might have meant to write `.` instead of `..`\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start .. end { () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start.end { () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpgpJ8UD/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start .. end { () } } ; if let S...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 10,
          "line_number": 224,
          "code": "match value {\n    pattern1 => action1,\n    pattern2 => action2,\n    _ => default_action\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `value` in this scope\n --> /tmp/.tmpbTK7Uv/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match value { pattern1 => action1 , pattern2 => action2 , _ => default_acti...\n  |                                                                     ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `action1` in this scope\n --> /tmp/.tmpbTK7Uv/main.rs:1:89\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match value { pattern1 => action1 , pattern2 => action2 , _ => default_acti...\n  |                                                                                         ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `action2` in this scope\n --> /tmp/.tmpbTK7Uv/main.rs:1:111\n  |\n1 | ... = match value { pattern1 => action1 , pattern2 => action2 , _ => default_action , } ; if let Some (s) = (& result as & dyn std :: any...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `default_action` in this scope\n --> /tmp/.tmpbTK7Uv/main.rs:1:126\n  |\n1 | ...attern1 => action1 , pattern2 => action2 , _ => default_action , } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcas...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpbTK7Uv/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match value { pattern1 => action1 , pattern2 => action2 , _ => default_acti...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 11,
          "line_number": 247,
          "code": "if user_input > threshold {\n    process_high_value();\n} else {\n    process_normal_value();\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `user_input` in this scope\n --> /tmp/.tmpBuYkdQ/main.rs:1:66\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...\n  |                                                                  ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `threshold` in this scope\n --> /tmp/.tmpBuYkdQ/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...\n  |                                                                               ^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpBuYkdQ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpBuYkdQ/main.rs:1:91\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...\n  |                                                                                           ^^                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { process_high_value () } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpBuYkdQ/main.rs:1:126\n  |\n1 | ...put > threshold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :...\n  |                                                         ^^                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { process_normal_value () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `process_high_value` in this scope\n --> /tmp/.tmpBuYkdQ/main.rs:1:93\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...\n  |                                                                                             ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `process_normal_value` in this scope\n --> /tmp/.tmpBuYkdQ/main.rs:1:128\n  |\n1 | ...shold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . d...\n  |                                                 ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 12,
          "line_number": 256,
          "code": "let mut count = 0;\nwhile count < 10 {\n    do_something();\n    count = count + 1;\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpCV9v7a/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; while count < 10i32 { { do_something () ; count = ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `do_something` in this scope\n --> /tmp/.tmpCV9v7a/main.rs:1:112\n  |\n1 | ...{ let mut count = 0i32 ; while count < 10i32 { { do_something () ; count = count + 1i32 } } } ; if let Some (s) = (& result as & dyn s...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 13,
          "line_number": 265,
          "code": "for i in 1..5 {\n    println(\"Processing item \" + i);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp03Yetm/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 5i32 { { println ! (\"{}\" , \"Processing item \" + i) } } ; i...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp03Yetm/main.rs:1:87\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 5i32 { { println ! (\"{}\" , \"Processing item \" + i) } } ; i...\n  |                                                                                       ^^                                         ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 5i32 { { println ! (\"{}\" , \"Processing item \" + i) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 5i32 { println ! (\"{}\" , \"Processing item \" + i) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0369]: cannot add `i32` to `&str`\n --> /tmp/.tmp03Yetm/main.rs:1:126\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 5i32 { { println ! (\"{}\" , \"Processing item \" + i) } } ; i...\n  |                                                                                                           ------------------ ^ - i32\n  |                                                                                                           |\n  |                                                                                                           &str\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0369`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 14,
          "line_number": 272,
          "code": "match status_code {\n    200 => println(\"Success\"),\n    404 => println(\"Not Found\"),\n    500 => println(\"Server Error\"),\n    _ => println(\"Unknown Status\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `status_code` in this scope\n --> /tmp/.tmpkqyw6i/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match status_code { 200i32 => println ! (\"Success\") , 404i32 => println ! (...\n  |                                                                     ^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpkqyw6i/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match status_code { 200i32 => println ! (\"Success\") , 404i32 => println ! (...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "appendix-c-troubleshooting": {
      "chapter": "appendix-c-troubleshooting",
      "total_examples": 20,
      "working_examples": 1,
      "failing_examples": 19,
      "examples": [
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 1,
          "line_number": 25,
          "code": "// Status: ✅ WORKING\n\n// ❌ Error\nlet x = 42\nlet y = 24\n\n// ✅ Fixed\nlet x = 42;\nlet y = 24;\n\n// Note: Semicolons needed for statements, not expressions",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpaNvyTQ/main.rs:1:127\n  |\n1 | ... 24i32 ; let x = 42i32 ; let y = 24i32 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpaNvyTQ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let x = 42i32 ; let y = 24i32 ; let x = 42i32 ; let y = 24i32 } ; if let ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 2,
          "line_number": 45,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected end of input\n// ❌ Error\nif condition {\n    do_something()\n// Missing closing brace\n\n// ✅ Fixed  \nif condition {\n    do_something()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 3,
          "line_number": 64,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected identifier after 'let' or 'let mut'\n// ❌ Error\nlet 123invalid = \"nope\"\nlet my-var = \"no hyphens\"\nlet fn = \"keyword\"\n\n// ✅ Fixed\nlet invalid_123 = \"ok\"\nlet my_var = \"underscores ok\"\nlet function_name = \"not keyword\"",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 4,
          "line_number": 85,
          "code": "// Status: ✅ WORKING\n\n// ❌ Error\nlet x: i32 = \"string\"\n\n\n\n// ✅ Fixed\nlet x: i32 = 42\n// or\nlet x = \"string\"  // Let compiler infer type",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmp0bei6t/main.rs:1:117\n  |\n1 | ...ng\" ; let x = 42i32 ; let x = \"string\" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp0bei6t/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let x = \"string\" ; let x = 42i32 ; let x = \"string\" } ; if let Some (s) =...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 5,
          "line_number": 105,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: Star\n// ❌ Error\nlet s = String::from(\"hello\")\nlet r = &s\nlet moved = *r  // Cannot move out of borrowed content\n\n// ✅ Fixed\nlet s = String::from(\"hello\")\nlet r = &s\nlet copied = r.clone()  // Clone instead of move",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 6,
          "line_number": 124,
          "code": "// Status: ✅ WORKING\n\n// ❌ Error\nlet s = String::from(\"hello\")\ntakes_ownership(s)\nprintln(s)  \n\n// ✅ Fixed - Option 1: Clone\nlet s = String::from(\"hello\")\ntakes_ownership(s.clone())\nprintln(s)  // s still valid\n\n// ✅ Fixed - Option 2: Borrow\nlet s = String::from(\"hello\")\nborrows_value(&s)\nprintln(s)  // s still valid",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpEEcO4M/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let s = String :: from (\"hello\") ; takes_ownership (s) ; println ! (\"{}\" ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `takes_ownership` in this scope\n --> /tmp/.tmpEEcO4M/main.rs:1:100\n  |\n1 | ... result = { let s = String :: from (\"hello\") ; takes_ownership (s) ; println ! (\"{}\" , s) ; let s = String :: from (\"hello\") ; takes_o...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `takes_ownership` in this scope\n --> /tmp/.tmpEEcO4M/main.rs:1:180\n  |\n1 | ...\"{}\" , s) ; let s = String :: from (\"hello\") ; takes_ownership (s . clone ()) ; println ! (\"{}\" , s) ; let s = String :: from (\"hello\"...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `borrows_value` in this scope\n --> /tmp/.tmpEEcO4M/main.rs:1:271\n  |\n1 | ...(\"{}\" , s) ; let s = String :: from (\"hello\") ; borrows_value (& s) ; println ! (\"{}\" , s) } ; if let Some (s) = (& result as & dyn st...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 7,
          "line_number": 151,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected type\n// ❌ Error\nfun dangle() -> &String {\n    let s = String::from(\"hello\")\n    &s  // s goes out of scope\n}\n\n// ✅ Fixed - Return owned value\nfun not_dangle() -> String {\n    let s = String::from(\"hello\")\n    s  // Move ownership\n}\n\n// ✅ Fixed - Use static lifetime\nfun static_str() -> &'static str {\n    \"hello\"  // String literals have static lifetime\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 8,
          "line_number": 177,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: Mut\n// ❌ Error\nlet mut s = String::from(\"hello\")\nlet r1 = &mut s\nlet r2 = &mut s  // Error: Parse error: Unexpected token: Mut\nprintln(r1)\nprintln(r2)\n\n// ✅ Fixed - Use references sequentially\nlet mut s = String::from(\"hello\")\n{\n    let r1 = &mut s\n    // r1 scope ends here\n}\nlet r2 = &mut s  // Now ok",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 9,
          "line_number": 205,
          "code": "// Status: ✅ WORKING\n\n// ❌ Runtime panic\nlet v = vec![1, 2, 3]\nlet item = v[5]  // Panic: index out of bounds\n\n// ✅ Safe access\nlet v = vec![1, 2, 3]\nmatch v.get(5) {\n    Some(item) => println(\"Item: {}\", item),\n    None => println(\"Index out of bounds\"),\n}\n\n// ✅ Or use safe indexing\nif let Some(item) = v.get(5) {\n    println(\"Item: {}\", item)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpgD7TnA/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let v = vec ! [1i32 , 2i32 , 3i32] ; let item = v [5i32] ; let v = vec ! ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpgD7TnA/main.rs:1:340\n  |\n1 | ... if let Some (item) = v . get (5i32) { { println ! (\"{} {}\" , format ! (\"Item: {{}}\") , item) } } } ; if let Some (s) = (& result as &...\n  |                                           ^^                                                    ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { let v = vec ! [1i32 , 2i32 , 3i32] ; let item = v [5i32] ; let v = vec ! [1i32 , 2i32 , 3i32] ; match v . get (5i32) { Some (item) => println ! (\"{} {}\" , format ! (\"Item: {{}}\") , item) , None => println ! (\"Index out of bounds\") , } ; if let Some (item) = v . get (5i32) { { println ! (\"{} {}\" , format ! (\"Item: {{}}\") , item) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { let v = vec ! [1i32 , 2i32 , 3i32] ; let item = v [5i32] ; let v = vec ! [1i32 , 2i32 , 3i32] ; match v . get (5i32) { Some (item) => println ! (\"{} {}\" , format ! (\"Item: {{}}\") , item) , None => println ! (\"Index out of bounds\") , } ; if let Some (item) = v . get (5i32) { println ! (\"{} {}\" , format ! (\"Item: {{}}\") , item) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0277]: the type `[i32]` cannot be indexed by `i32`\n --> /tmp/.tmpgD7TnA/main.rs:1:116\n  |\n1 | ...[1i32 , 2i32 , 3i32] ; let item = v [5i32] ; let v = vec ! [1i32 , 2i32 , 3i32] ; match v . get (5i32) { Some (item) => println ! (\"{}...\n  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `Vec<i32>` to implement `Index<i32>`\n\nerror[E0277]: the type `[i32]` cannot be indexed by `i32`\n   --> /tmp/.tmpgD7TnA/main.rs:1:176\n    |\n1   | ...! [1i32 , 2i32 , 3i32] ; match v . get (5i32) { Some (item) => println ! (\"{} {}\" , format ! (\"Item: {{}}\") , item) , None => println ...\n    |                                       ---  ^^^^ slice indices are of type `usize` or ranges of `usize`\n    |                                       |\n    |                                       required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`\n    = help: the following other types implement trait `SliceIndex<T>`:\n              `usize` implements `SliceIndex<ByteStr>`\n              `usize` implements `SliceIndex<[T]>`\nnote: required by a bound in `core::slice::<impl [T]>::get`\n   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:573:12\n    |\n571 |     pub fn get<I>(&self, index: I) -> Option<&I::Output>\n    |            --- required by a bound in this associated function\n572 |     where\n573 |         I: SliceIndex<Self>,\n    |            ^^^^^^^^^^^^^^^^ required by this bound in `core::slice::<impl [T]>::get`\n\nerror[E0277]: the type `[i32]` cannot be indexed by `i32`\n   --> /tmp/.tmpgD7TnA/main.rs:1:332\n    |\n1   | ...s\") , } ; if let Some (item) = v . get (5i32) { { println ! (\"{} {}\" , format ! (\"Item: {{}}\") , item) } } } ; if let Some (s) = (& re...\n    |                                       ---  ^^^^ slice indices are of type `usize` or ranges of `usize`\n    |                                       |\n    |                                       required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`\n    = help: the following other types implement trait `SliceIndex<T>`:\n              `usize` implements `SliceIndex<ByteStr>`\n              `usize` implements `SliceIndex<[T]>`\nnote: required by a bound in `core::slice::<impl [T]>::get`\n   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:573:12\n    |\n571 |     pub fn get<I>(&self, index: I) -> Option<&I::Output>\n    |            --- required by a bound in this associated function\n572 |     where\n573 |         I: SliceIndex<Self>,\n    |            ^^^^^^^^^^^^^^^^ required by this bound in `core::slice::<impl [T]>::get`\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 10,
          "line_number": 231,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected type\n// ❌ Runtime panic\nlet maybe_value: Option<i32> = None\nlet value = maybe_value.unwrap()  // Panic: called unwrap on None\n\n// ✅ Safe handling\nlet maybe_value: Option<i32> = None\nmatch maybe_value {\n    Some(value) => println(\"Value: {}\", value),\n    None => println(\"No value\"),\n}\n\n// ✅ Or provide default\nlet value = maybe_value.unwrap_or(0)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 11,
          "line_number": 254,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected type\n// ❌ Runtime panic\nfun divide(a: i32, b: i32) -> i32 {\n    a / b  // Panic if b is 0\n}\n\n// ✅ Safe division\nfun safe_divide(a: i32, b: i32) -> Option<i32> {\n    if b != 0 {\n        Some(a / b)\n    } else {\n        None\n    }\n}\n\n// ✅ Or return Result\nfun divide_result(a: i32, b: i32) -> Result<i32, String> {\n    if b != 0 {\n        Ok(a / b)\n    } else {\n        Err(\"Division by zero\".to_string())\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 12,
          "line_number": 288,
          "code": "// Status: ✅ WORKING\n\n// ❌ Infinite recursion causes stack overflow\nfun infinite_recursion(n: i32) -> i32 {\n    infinite_recursion(n + 1)  // No base case\n}\n\n// ✅ Proper recursion with base case\nfun factorial(n: i32) -> i32 {\n    if n <= 1 {\n        1  // Base case\n    } else {\n        n * factorial(n - 1)\n    }\n}\n\n// ✅ Or use iteration\nfun factorial_iterative(n: i32) -> i32 {\n    let mut result = 1\n    for i in 1..=n {\n        result *= i\n    }\n    result\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 13,
          "line_number": 321,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected RightBracket, found Semicolon\n// ❌ May cause stack overflow\nfun large_array() {\n    let big_array: [i32; 1_000_000] = [0; 1_000_000]  // 4MB on stack\n}\n\n// ✅ Use heap allocation\nfun large_vector() {\n    let big_vector: Vec<i32> = vec![0; 1_000_000]  // Allocated on heap\n}\n\n// ✅ Or use Box for single large items\nfun boxed_array() {\n    let big_array: Box<[i32; 1_000_000]> = Box::new([0; 1_000_000])\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 14,
          "line_number": 347,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected type\n// ❌ Inefficient - unnecessary clones\nfun process_strings(strings: Vec<String>) -> Vec<String> {\n    strings.iter()\n        .map(|s| s.clone().to_uppercase())  // Unnecessary clone\n        .collect()\n}\n\n// ✅ More efficient - work with references\nfun process_strings_efficient(strings: &[String]) -> Vec<String> {\n    strings.iter()\n        .map(|s| s.to_uppercase())  // to_uppercase() works on &str\n        .collect()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 15,
          "line_number": 370,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected type\n// ❌ Inefficient - creates many temporary strings\nfun concat_inefficient(strings: &[&str]) -> String {\n    let mut result = String::new()\n    for s in strings {\n        result = result + s  // Creates new string each time\n    }\n    result\n}\n\n// ✅ Efficient - reuses buffer\nfun concat_efficient(strings: &[&str]) -> String {\n    let mut result = String::new()\n    for s in strings {\n        result.push_str(s)  // Appends to existing string\n    }\n    result\n}\n\n// ✅ Even better - pre-allocate capacity\nfun concat_with_capacity(strings: &[&str]) -> String {\n    let total_len: usize = strings.iter().map(|s| s.len()).sum()\n    let mut result = String::with_capacity(total_len)\n    for s in strings {\n        result.push_str(s)\n    }\n    result\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 16,
          "line_number": 407,
          "code": "// Status: ✅ WORKING\n\n// ❌ Wrong collection for use case\nuse std::collections::VecDeque\n\nlet mut list = Vec::new()\n// Frequent insertions at beginning - O(n) for each insert\nfor i in 0..1000 {\n    list.insert(0, i)\n}\n\n// ✅ Better collection choice\nlet mut deque = VecDeque::new()\n// Efficient insertion at front - O(1)\nfor i in 0..1000 {\n    deque.push_front(i)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpz2hW6t/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpz2hW6t/main.rs:1:102\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for...\n  |                                                                                                      ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpz2hW6t/main.rs:1:162\n  |\n1 | ...ut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i...\n  |                                                         ^^                        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { list . insert (0i32 , i) } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpz2hW6t/main.rs:1:259\n  |\n1 | ...que = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any...\n  |                                                          ^^                      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { deque . push_front (i) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0308]: mismatched types\n    --> /tmp/.tmpz2hW6t/main.rs:1:179\n     |\n1    | ...ew () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { ...\n     |                                                ------  ^^^^ expected `usize`, found `i32`\n     |                                                |\n     |                                                arguments to this method are incorrect\n     |\nnote: method defined here\n    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2034:12\n     |\n2034 |     pub fn insert(&mut self, index: usize, element: T) {\n     |            ^^^^^^\nhelp: change the type of the numeric literal from `i32` to `usize`\n     |\n1    - use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1    + use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0usize , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n     |\n\nerror: aborting due to 1 previous error; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 17,
          "line_number": 448,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: Question\n// ❌ Error: no method named `json` found for type `Response`\nlet response = reqwest::get(url).await?\nlet data = response.json().await?  // Feature not enabled\n\n// ✅ Enable required features in Cargo.toml\n// [dependencies]\n// reqwest = { version = \"0.11\", features = [\"json\"] }",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpgxxWSG/main.rs:1:153\n  |\n1 | ...et data = response . json () . await ? } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0425]: cannot find value `url` in this scope\n --> /tmp/.tmpgxxWSG/main.rs:1:96\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let response = reqwest :: get (url) . await ? ; let data = response . jso...\n  |                                                                                                ^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpgxxWSG/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let response = reqwest :: get (url) . await ? ; let data = response . jso...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`\n --> /tmp/.tmpgxxWSG/main.rs:1:80\n  |\n1 | ...n () { let result = { let response = reqwest :: get (url) . await ? ; let data = response . json () . await ? } ; if let Some (s) = (&...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `reqwest`\n  |\n  = help: you might be missing a crate named `reqwest`\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 18,
          "line_number": 568,
          "code": "// Status: ✅ WORKING\n\n// Simple debug prints\nprintln!(\"Debug: x = {}\", x)\nprintln!(\"Debug: {:?}\", complex_struct)  // Debug formatting\nprintln!(\"Debug: {:#?}\", nested_struct)  // Pretty debug formatting\n\n// Conditional debug prints\n#[cfg(debug_assertions)]\nprintln!(\"This only prints in debug builds\")\n\n// Debug macro\ndebug!(\"Variable state: x={}, y={}\", x, y)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 19,
          "line_number": 605,
          "code": "// Status: ✅ WORKING\n\nuse log::{debug, info, warn, error}\n\nfun main() {\n    env_logger::init()\n    \n    debug!(\"This is a debug message\")\n    info!(\"This is info\")\n    warn!(\"This is a warning\")\n    error!(\"This is an error\")\n}\n\n// Control log level with environment variable\n// RUST_LOG=debug cargo run",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 20,
          "line_number": 629,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: Hash\n#[cfg(test)]\nmod tests {\n    use super::*\n    \n    #[test]\n    fun test_with_debug_output() {\n        let result = my_function(42)\n        \n        // Print for debugging (use -- --nocapture to see output)\n        println!(\"Result: {:?}\", result)\n        \n        assert_eq!(result, expected)\n    }\n    \n    // Run with: cargo test -- --nocapture\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch05-00-data-processing": {
      "chapter": "ch05-00-data-processing",
      "total_examples": 10,
      "working_examples": 0,
      "failing_examples": 10,
      "examples": [
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: RightBracket\n// File: sales_analyzer.ruchy\n// Analyzes sales data from CSV file\n\nprintln(\"=== Sales Data Analyzer ===\")\n\n// Read CSV data (simplified - in practice you'd use CSV parser)\nlet sales_data = [\n    [\"Date\", \"Product\", \"Amount\", \"Region\"],\n    [\"2024-01-15\", \"Laptop\", \"1299\", \"North\"],\n    [\"2024-01-16\", \"Mouse\", \"25\", \"South\"], \n    [\"2024-01-17\", \"Keyboard\", \"79\", \"North\"],\n    [\"2024-01-18\", \"Laptop\", \"1299\", \"East\"],\n    [\"2024-01-19\", \"Monitor\", \"399\", \"West\"]\n]\n\n// Process data\nlet total_sales = 0\nlet product_counts = {}\nlet region_sales = {}\n\nfor row in sales_data[1..] {  // Skip header\n    let product = row[1]\n    let amount = row[2].to_f()\n    let region = row[3]\n    \n    // Calculate totals\n    total_sales += amount\n    \n    // Count products\n    product_counts[product] = product_counts.get(product, 0) + 1\n    \n    // Sum by region\n    region_sales[region] = region_sales.get(region, 0) + amount\n}\n\n// Display results\nprintln(\"Total Sales: $\" + total_sales.to_s())\nprintln(\"Average Sale: $\" + (total_sales / (sales_data.len() - 1)).to_s())\n\nprintln(\"\\nTop Products:\")\nfor product, count in product_counts.items() {\n    println(\"  \" + product + \": \" + count.to_s() + \" sales\")\n}\n\nprintln(\"\\nSales by Region:\")\nfor region, amount in region_sales.items() {\n    println(\"  \" + region + \": $\" + amount.to_s())\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 2,
          "line_number": 113,
          "code": "// Status: ✅ WORKING\n\n// Arrays for sequences\nlet sales_amounts = [1299, 25, 79, 1299, 399]\nlet monthly_revenue = [45000, 52000, 48000, 61000]\n\n// Dictionaries for key-value mapping  \nlet customer_orders = {\n    \"alice@email.com\": 5,\n    \"bob@email.com\": 2,\n    \"carol@email.com\": 8\n}\n\n// Arrays of dictionaries for structured records\nlet transactions = [\n    {\"id\": 1001, \"amount\": 1299, \"customer\": \"alice@email.com\"},\n    {\"id\": 1002, \"amount\": 25, \"customer\": \"bob@email.com\"},\n    {\"id\": 1003, \"amount\": 79, \"customer\": \"alice@email.com\"}\n]",
          "passed": false,
          "status": "broken",
          "error": "\nthread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:\n\"alice@email.com\" is not a valid Ident\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 3,
          "line_number": 143,
          "code": "// Status: ✅ WORKING\n\n// Sum and averages\nlet total = numbers.sum()\nlet average = numbers.sum() / numbers.len()\nlet maximum = numbers.max()\nlet minimum = numbers.min()\n\n// Grouping and counting\nfun group_by_field(records, field) {\n    let groups = {}\n    for record in records {\n        let key = record[field]\n        if !groups.has_key(key) {\n            groups[key] = []\n        }\n        groups[key].push(record)\n    }\n    return groups\n}\n\n// Filtering and transformation\nlet high_value = transactions.filter(|t| t.amount > 100)\nlet customer_ids = transactions.map(|t| t.customer)\nlet amounts_only = transactions.map(|t| t.amount)",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `numbers` in this scope\n --> /tmp/.tmp2oebNH/main.rs:1:447\n  |\n1 | ...} ; return groups } } } } fn main () { let total = numbers . sum () ; let average = numbers . sum () / numbers . len () ; let maximum ...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `numbers` in this scope\n --> /tmp/.tmp2oebNH/main.rs:1:480\n  |\n1 | ... () { let total = numbers . sum () ; let average = numbers . sum () / numbers . len () ; let maximum = numbers . max () ; let minimum ...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `numbers` in this scope\n --> /tmp/.tmp2oebNH/main.rs:1:499\n  |\n1 | ...umbers . sum () ; let average = numbers . sum () / numbers . len () ; let maximum = numbers . max () ; let minimum = numbers . min () ...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `numbers` in this scope\n --> /tmp/.tmp2oebNH/main.rs:1:532\n  |\n1 | ...umbers . sum () / numbers . len () ; let maximum = numbers . max () ; let minimum = numbers . min () ; let high_value = transactions ....\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `numbers` in this scope\n --> /tmp/.tmp2oebNH/main.rs:1:565\n  |\n1 | ...) ; let maximum = numbers . max () ; let minimum = numbers . min () ; let high_value = transactions . into_iter () . filter (| t | t ....\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `transactions` in this scope\n --> /tmp/.tmp2oebNH/main.rs:1:601\n  |\n1 | ...et minimum = numbers . min () ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let c...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `transactions` in this scope\n --> /tmp/.tmp2oebNH/main.rs:1:700\n  |\n1 | ...ount > 100i32) . collect () ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let ...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `transactions` in this scope\n --> /tmp/.tmp2oebNH/main.rs:1:800\n  |\n1 | ... collect :: < Vec < _ >> () ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp2oebNH/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp2oebNH/main.rs:1:218\n  |\n1 | ... { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } } } } ...\n  |       ^^                                                                                                                                                                                                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } } } } fn main () { let total = numbers . sum () ; let average = numbers . sum () / numbers . len () ; let maximum = numbers . max () ; let minimum = numbers . min () ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }\n1 + use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } } } fn main () { let total = numbers . sum () ; let average = numbers . sum () / numbers . len () ; let maximum = numbers . max () ; let minimum = numbers . min () ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp2oebNH/main.rs:1:266\n  |\n1 | ... { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ...\n  |       ^^                                                                                                                             ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } } } } fn main () { let total = numbers . sum () ; let average = numbers . sum () / numbers . len () ; let maximum = numbers . max () ; let minimum = numbers . min () ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }\n1 + use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } ; return groups } } } } fn main () { let total = numbers . sum () ; let average = numbers . sum () / numbers . len () ; let maximum = numbers . max () ; let minimum = numbers . min () ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp2oebNH/main.rs:1:329\n  |\n1 | ...y = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return gro...\n  |                                                         ^^                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } } } } fn main () { let total = numbers . sum () ; let average = numbers . sum () / numbers . len () ; let maximum = numbers . max () ; let minimum = numbers . min () ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }\n1 + use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { groups [key] = vec ! [] } ; groups [key] . push (record) } } } } ; return groups } } } } fn main () { let total = numbers . sum () ; let average = numbers . sum () / numbers . len () ; let maximum = numbers . max () ; let minimum = numbers . min () ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }\n  |\n\nerror[E0277]: `T` is not an iterator\n --> /tmp/.tmp2oebNH/main.rs:1:256\n  |\n1 | ...d : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups ...\n  |                                                        ^^^^^^^ `T` is not an iterator\n  |\n  = note: required for `T` to implement `IntoIterator`\nhelp: consider further restricting type parameter `T` with trait `Iterator`\n  |\n1 | use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } } } } fn main () { let total = numbers . sum () ; let average = numbers . sum () / numbers . len () ; let maximum = numbers . max () ; let minimum = numbers . min () ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }\n  |                                                                                                                                                                                       +++++++++++++++++++++\n\nerror[E0599]: no method named `has_key` found for unit type `()` in the current scope\n --> /tmp/.tmp2oebNH/main.rs:1:313\n  |\n1 | ...s { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } ...\n  |                                                       ^^^^^^^ method not found in `()`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp2oebNH/main.rs:1:407\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } ...\n  |       - expected this type parameter                                                                                                                               - expected `T` because of return type                                                                                                                                                            ^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: the caller chooses a type for `T` which can be different from `()`\n\nerror: aborting due to 11 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: has_key()"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 4,
          "line_number": 179,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: RightBracket\n// CSV-like processing (simplified)\nfun parse_csv_line(line) {\n    return line.split(\",\").map(|field| field.trim())\n}\n\nfun load_csv(filename) {\n    let lines = read_lines(filename)\n    let header = parse_csv_line(lines[0])\n    let data = []\n    \n    for line in lines[1..] {\n        let fields = parse_csv_line(line)\n        let record = {}\n        for i, field in fields.enumerate() {\n            record[header[i]] = field\n        }\n        data.push(record)\n    }\n    \n    return data\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 5,
          "line_number": 213,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: DotDot\n// File: customer_analytics.ruchy\n// Analyzes customer purchase patterns\n\nprintln(\"=== Customer Analytics Tool ===\")\n\n// Sample customer data (in practice, load from file)\nlet customers = [\n    {\"name\": \"Alice\", \"email\": \"alice@email.com\", \"orders\": 5, \"total_spent\": 2500, \"signup_date\": \"2023-06-15\"},\n    {\"name\": \"Bob\", \"email\": \"bob@email.com\", \"orders\": 2, \"total_spent\": 150, \"signup_date\": \"2024-01-20\"},\n    {\"name\": \"Carol\", \"email\": \"carol@email.com\", \"orders\": 8, \"total_spent\": 4200, \"signup_date\": \"2023-03-10\"},\n    {\"name\": \"David\", \"email\": \"david@email.com\", \"orders\": 1, \"total_spent\": 75, \"signup_date\": \"2024-02-01\"}\n]\n\n// Calculate key metrics\nlet total_customers = customers.len()\nlet total_revenue = customers.map(|c| c.total_spent).sum()\nlet average_order_value = total_revenue / customers.map(|c| c.orders).sum()\nlet average_customer_value = total_revenue / total_customers\n\nprintln(\"Customer Base: \" + total_customers.to_s() + \" customers\")\nprintln(\"Total Revenue: $\" + total_revenue.to_s())\nprintln(\"Average Order Value: $\" + average_order_value.to_s())\nprintln(\"Average Customer Value: $\" + average_customer_value.to_s())\n\n// Segment customers\nlet vip_customers = customers.filter(|c| c.total_spent > 1000)\nlet new_customers = customers.filter(|c| c.signup_date.starts_with(\"2024\"))\nlet frequent_buyers = customers.filter(|c| c.orders > 5)\n\nprintln(f\"\\nCustomer Segments:\")\nprintln(\"VIP Customers (>$1000): \" + vip_customers.len().to_s())\nprintln(\"New Customers (2024): \" + new_customers.len().to_s())\nprintln(\"Frequent Buyers (>5 orders): \" + frequent_buyers.len().to_s())\n\n// Top customers by spending\nlet top_spenders = customers.sort_by(|c| -c.total_spent)[..3]\nprintln(f\"\\nTop Spenders:\")\nfor i, customer in top_spenders.enumerate() {\n    println(\"  \" + (i+1).to_s() + \". \" + customer.name + \": $\" + customer.total_spent.to_s() + \" (\" + customer.orders.to_s() + \" orders)\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 6,
          "line_number": 264,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: RightBracket\n// File: advanced_log_analyzer.ruchy\n// Comprehensive log file analysis\n\nprintln(\"=== Advanced Log Analyzer ===\")\n\n// Sample log entries (in practice, read from file)\nlet log_entries = [\n    \"2024-08-19 10:15:32 INFO User login: alice@email.com\",\n    \"2024-08-19 10:16:45 ERROR Database connection failed\", \n    \"2024-08-19 10:17:12 INFO User login: bob@email.com\",\n    \"2024-08-19 10:18:33 WARN Slow query detected: 2.5s\",\n    \"2024-08-19 10:19:44 ERROR 404 Not Found: /api/users/999\",\n    \"2024-08-19 10:20:15 INFO User logout: alice@email.com\"\n]\n\n// Parse log entries\nfun parse_log_entry(entry) {\n    let parts = entry.split(\" \")\n    return {\n        \"date\": parts[0],\n        \"time\": parts[1], \n        \"level\": parts[2],\n        \"message\": parts[3..].join(\" \")\n    }\n}\n\nlet parsed_logs = log_entries.map(parse_log_entry)\n\n// Analyze by level\nlet level_counts = {}\nfor log in parsed_logs {\n    let level = log.level\n    level_counts[level] = level_counts.get(level, 0) + 1\n}\n\nprintln(\"Log Level Summary:\")\nfor level, count in level_counts.items() {\n    let emoji = match level {\n        \"INFO\" => \"ℹ️\",\n        \"WARN\" => \"⚠️\", \n        \"ERROR\" => \"❌\",\n        _ => \"📝\"\n    }\n    println(\"  \" + emoji + \" \" + level + \": \" + count.to_s() + \" entries\")\n}\n\n// Find errors and warnings\nlet issues = parsed_logs.filter(|log| log.level == \"ERROR\" || log.level == \"WARN\")\nprintln(\"\\nIssues Found (\" + issues.len().to_s() + \"):\")\nfor issue in issues {\n    println(\"  \" + issue.time + \" \" + issue.level + \": \" + issue.message)\n}\n\n// Extract user activity\nlet user_actions = parsed_logs.filter(|log| log.message.contains(\"User\"))\nprintln(\"\\nUser Activity (\" + user_actions.len().to_s() + \" actions):\")\nfor action in user_actions {\n    println(\"  \" + action.time + \": \" + action.message)\n}\n\n// Time-based analysis\nlet hours = parsed_logs.map(|log| log.time.split(\":\")[0])\nlet hour_counts = {}\nfor hour in hours {\n    hour_counts[hour] = hour_counts.get(hour, 0) + 1\n}\n\nlet busiest_hour = hour_counts.max_by_value()\nprintln(\"\\nBusiest Hour: \" + busiest_hour.key + \":xx (\" + busiest_hour.value.to_s() + \" entries)\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 7,
          "line_number": 344,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected method name or 'await' after '.'\n// File: finance_processor.ruchy\n// Processes financial transactions and generates reports\n\nprintln(\"=== Financial Data Processor ===\")\n\n// Transaction data structure\nlet transactions = [\n    {\"date\": \"2024-01-15\", \"type\": \"income\", \"category\": \"salary\", \"amount\": 5000, \"description\": \"Monthly salary\"},\n    {\"date\": \"2024-01-16\", \"type\": \"expense\", \"category\": \"rent\", \"amount\": 1200, \"description\": \"Apartment rent\"},\n    {\"date\": \"2024-01-17\", \"type\": \"expense\", \"category\": \"groceries\", \"amount\": 85, \"description\": \"Weekly shopping\"},\n    {\"date\": \"2024-01-18\", \"type\": \"expense\", \"category\": \"utilities\", \"amount\": 150, \"description\": \"Electricity bill\"},\n    {\"date\": \"2024-01-20\", \"type\": \"income\", \"category\": \"freelance\", \"amount\": 800, \"description\": \"Web design project\"}\n]\n\n// Calculate totals\nlet total_income = transactions.filter(|t| t.type == \"income\").map(|t| t.amount).sum()\nlet total_expenses = transactions.filter(|t| t.type == \"expense\").map(|t| t.amount).sum()\nlet net_income = total_income - total_expenses\n\nprintln(f\"Financial Summary:\")\nprintln(\"Total Income: $\" + total_income.to_s())\nprintln(\"Total Expenses: $\" + total_expenses.to_s())\nprintln(\"Net Income: $\" + net_income.to_s())\nprintln(\"Savings Rate: \" + (net_income * 100 / total_income).to_s() + \"%\")\n\n// Expense breakdown by category\nlet expense_categories = {}\nfor transaction in transactions.filter(|t| t.type == \"expense\") {\n    let category = transaction.category\n    expense_categories[category] = expense_categories.get(category, 0) + transaction.amount\n}\n\nprintln(f\"\\nExpense Breakdown:\")\nfor category, amount in expense_categories.items() {\n    let percentage = (amount * 100) / total_expenses\n    println(\"  \" + category.capitalize() + \": $\" + amount.to_s() + \" (\" + percentage.to_s() + \"%)\")\n}\n\n// Budget analysis\nlet budget_limits = {\n    \"rent\": 1500,\n    \"groceries\": 400, \n    \"utilities\": 200,\n    \"entertainment\": 300\n}\n\nprintln(f\"\\nBudget Analysis:\")\nfor category, limit in budget_limits.items() {\n    let spent = expense_categories.get(category, 0)\n    let remaining = limit - spent\n    let status = if remaining >= 0 { \"✅ Under budget\" } else { \"❌ Over budget\" }\n    println(\"  \" + category.capitalize() + \": $\" + spent.to_s() + \"/$\" + limit.to_s() + \" - \" + status)\n}\n\n// Monthly trend (if we had multiple months of data)\nprintln(\"\\nTransaction History (\" + transactions.len().to_s() + \" transactions):\")\nfor transaction in transactions.sort_by(|t| t.date) {\n    let emoji = if transaction.type == \"income\" { \"💰\" } else { \"💸\" }\n    println(\"  \" + transaction.date + \" \" + emoji + \" $\" + transaction.amount.to_s() + \" - \" + transaction.description)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 8,
          "line_number": 417,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Expected In, found Comma\n// Simple bar chart function\nfun draw_bar_chart(data, title) {\n    println(\"\\n\" + title)\n    println(\"=\" * title.len())\n    \n    let max_value = data.values().max()\n    let max_bar_width = 50\n    \n    for key, value in data.items() {\n        let bar_width = (value * max_bar_width) / max_value\n        let bar = \"█\" * bar_width.to_i()\n        println(key + \" │\" + bar + \" \" + value.to_s())\n    }\n}\n\n// Usage example\nlet monthly_sales = {\n    \"January\": 45000,\n    \"February\": 52000,\n    \"March\": 48000,\n    \"April\": 61000,\n    \"May\": 58000\n}\n\ndraw_bar_chart(monthly_sales, \"Monthly Sales Report\")",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: struct literal body without path\n --> /tmp/.tmpsY675f/main.rs:1:613\n  |\n1 | ...monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart...\n  |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\nhelp: you might have forgotten to add the struct literal inside the block\n  |\n1 | use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! (\"{}\" , \"\\n\" + title) ; println ! (\"{}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let bar = \"█\" * bar_width . to_i () ; println ! (\"{}\" , key + \" │\" + bar + \" \" + value . to_s ()) } } } } } } } } fn main () { let monthly_sales = { SomeStruct { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } } ; draw_bar_chart (monthly_sales , \"Monthly Sales Report\") ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ++++++++++++                                                                                                       +\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpsY675f/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpsY675f/main.rs:1:408\n  |\n1 | ... { { { let bar_width = value * max_bar_width / max_value ; { let bar = \"█\" * bar_width . to_i () ; println ! (\"{}\" , key + \" │\" + bar + \" \" + value . to_s ()) } } } } ...\n  |       ^^                                                                                                                                                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! (\"{}\" , \"\\n\" + title) ; println ! (\"{}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let bar = \"█\" * bar_width . to_i () ; println ! (\"{}\" , key + \" │\" + bar + \" \" + value . to_s ()) } } } } } } } } fn main () { let monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart (monthly_sales , \"Monthly Sales Report\") ; }\n1 + use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! (\"{}\" , \"\\n\" + title) ; println ! (\"{}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; for (key , value) in data . items () { { let bar_width = value * max_bar_width / max_value ; { let bar = \"█\" * bar_width . to_i () ; println ! (\"{}\" , key + \" │\" + bar + \" \" + value . to_s ()) } } } } } } } fn main () { let monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart (monthly_sales , \"Monthly Sales Report\") ; }\n  |\n\nerror[E0369]: cannot add `T` to `&str`\n --> /tmp/.tmpsY675f/main.rs:1:240\n  |\n1 | ...+ Clone > (data : T , title : T) -> T { { println ! (\"{}\" , \"\\n\" + title) ; println ! (\"{}\" , \"=\" * title . len ()) ; { let max_value ...\n  |                                                                ---- ^ ----- T\n  |                                                                |\n  |                                                                &str\n\nerror[E0599]: no method named `len` found for type parameter `T` in the current scope\n --> /tmp/.tmpsY675f/main.rs:1:283\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! (\"{}\" , \"\\n\" + title) ; println ! (\"{}\" , \"=\" * title . len ()...\n  |       - method `len` not found for this type parameter                                                                                                                                                                                  ^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (data : T , title : T) -> T { { println ! (\"{}\" , \"\\n\" + title) ; println ! (\"{}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let bar = \"█\" * bar_width . to_i () ; println ! (\"{}\" , key + \" │\" + bar + \" \" + value . to_s ()) } } } } } } } } fn main () { let monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart (monthly_sales , \"Monthly Sales Report\") ; }\n  |                                                                                                                                                                                       +++++++++++++++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpsY675f/main.rs:1:269\n  |\n1 | ...}\" , \"\\n\" + title) ; println ! (\"{}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i...\n  |                                     --    ^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                                     |\n  |                                     required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `values` found for type parameter `T` in the current scope\n --> /tmp/.tmpsY675f/main.rs:1:318\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! (\"{}\" , \"\\n\" + title) ; println ! (\"{}\" , \"=\" * title . len ()) ; { let max_value = data . values ()...\n  |       - method `values` not found for this type parameter                                                                                                                                                                                                                  ^^^^^^ method not found in `T`\n\nerror[E0599]: no method named `items` found for type parameter `T` in the current scope\n --> /tmp/.tmpsY675f/main.rs:1:397\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! (\"{}\" , \"\\n\" + title) ; println ! (\"{}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; for (key , value) in data . items ()...\n  |       - method `items` not found for this type parameter                                                                                                                                                                                                                                                                                                  ^^^^^ method not found in `T`\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpsY675f/main.rs:1:470\n  |\n1 | ...= value * max_bar_width / max_value ; { let bar = \"█\" * bar_width . to_i () ; println ! (\"{}\" , key + \" │\" + bar + \" \" + value . to_s ...\n  |                                                ^^^ doesn't have a size known at compile-time\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: all local variables must have a statically known size\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpsY675f/main.rs:1:533\n  |\n1 | ...dth . to_i () ; println ! (\"{}\" , key + \" │\" + bar + \" \" + value . to_s ()) } } } } } } } } fn main () { let monthly_sales = { January...\n  |                                                 ^ doesn't have a size known at compile-time\n  |\n  = help: the trait `Sized` is not implemented for `str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpsY675f/main.rs:1:369\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! (\"{}\" , \"\\n\" + title) ; println ! (\"{}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let bar = \"█\" * bar_width . to_i () ; println ! (\"{}\" , key + \" │\" + bar + \" \" + value . to_s ()) } } } } } ...\n  |       - expected this type parameter                                                                                                                            - expected `T` because of return type                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: the caller chooses a type for `T` which can be different from `()`\n  = note: `for` loops evaluate to unit type `()`\nhelp: consider returning a value here\n  |\n1 | use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! (\"{}\" , \"\\n\" + title) ; println ! (\"{}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let bar = \"█\" * bar_width . to_i () ; println ! (\"{}\" , key + \" │\" + bar + \" \" + value . to_s ()) } } } } /* `T` value */ } } } } fn main () { let monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart (monthly_sales , \"Monthly Sales Report\") ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            +++++++++++++++\n\nerror: aborting due to 9 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0369, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: len()"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 9,
          "line_number": 470,
          "code": "// Status: ✅ WORKING\n\nlet sales_data = load_csv(\"sales.csv\")\nlet total = sales_data.map(|row| row.amount.to_f()).sum()\nlet average = total / sales_data.len()\nprintln(\"Average sale: $\" + average.to_s())",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp2kT5a5/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let sales_data = load_csv (\"sales.csv\") ; let total = sales_data . iter (...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `load_csv` in this scope\n --> /tmp/.tmp2kT5a5/main.rs:1:82\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let sales_data = load_csv (\"sales.csv\") ; let total = sales_data . iter (...\n  |                                                                                  ^^^^^^^^ not found in this scope\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmp2kT5a5/main.rs:1:281\n  |\n1 | ... . len () ; println ! (\"{}\" , \"Average sale: $\" + average . to_s ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . dow...\n  |                            --    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                            |\n  |                            required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 10,
          "line_number": 564,
          "code": "// Status: ❌ BROKEN\n// Error: Parse error: Unexpected token: RightBracket\n// expense_tracker.ruchy - Track and analyze personal expenses\n\nlet EXPENSES_FILE = \"expenses.csv\"\n\nfun save_expense(date, category, amount, description) {\n    let entry = date + \",\" + category + \",\" + amount.to_s() + \",\" + description + \"\\n\"\n    append_file(EXPENSES_FILE, entry)\n}\n\nfun load_expenses() {\n    if !file_exists(EXPENSES_FILE) {\n        // Create header if file doesn't exist\n        write_file(EXPENSES_FILE, \"Date,Category,Amount,Description\\n\")\n        return []\n    }\n    \n    let lines = read_lines(EXPENSES_FILE)[1..]  // Skip header\n    let expenses = []\n    \n    for line in lines {\n        let parts = line.split(\",\")\n        expenses.push({\n            \"date\": parts[0],\n            \"category\": parts[1], \n            \"amount\": parts[2].to_f(),\n            \"description\": parts[3]\n        })\n    }\n    \n    return expenses\n}\n\nfun analyze_expenses(expenses) {\n    let total = expenses.map(|e| e.amount).sum()\n    let average = total / expenses.len()\n    \n    // Category breakdown\n    let categories = {}\n    for expense in expenses {\n        categories[expense.category] = categories.get(expense.category, 0) + expense.amount\n    }\n    \n    println(\"\\n💰 Expense Analysis (\" + expenses.len().to_s() + \" transactions)\")\n    println(\"Total Spent: $\" + total.to_s())\n    println(\"Average Transaction: $\" + average.to_s())\n    \n    println(f\"\\n📊 Spending by Category:\")\n    for category, amount in categories.items().sort_by(|item| -item.value) {\n        let percentage = (amount * 100) / total\n        println(\"  \" + category + \": $\" + amount.to_s() + \" (\" + percentage.to_s() + \"%)\")\n    }\n    \n    // Recent transactions\n    let recent = expenses.sort_by(|e| -e.date)[..5]  // Last 5\n    println(f\"\\n🕒 Recent Transactions:\")\n    for expense in recent {\n        println(\"  \" + expense.date + \" $\" + expense.amount.to_s() + \" \" + expense.category + \" \" + expense.description)\n    }\n}\n\nfun main_menu() {\n    println(\"\\n=== Personal Expense Tracker ===\")\n    println(\"1. Add expense\")\n    println(\"2. View analysis\") \n    println(\"3. Export data\")\n    println(\"4. Quit\")\n    \n    let choice = input(\"\\nChoose option: \")\n    \n    match choice {\n        \"1\" => {\n            let date = input(\"Date (YYYY-MM-DD): \")\n            let category = input(\"Category: \")\n            let amount = input(\"Amount: $\").to_f()\n            let description = input(\"Description: \")\n            \n            save_expense(date, category, amount, description)\n            println(\"✅ Expense added!\")\n        }\n        \"2\" => {\n            let expenses = load_expenses()\n            if expenses.is_empty() {\n                println(\"📝 No expenses recorded yet\")\n            } else {\n                analyze_expenses(expenses)\n            }\n        }\n        \"3\" => {\n            println(\"📁 Data exported to: \" + EXPENSES_FILE)\n            println(\"Open in spreadsheet application for advanced analysis\")\n        }\n        \"4\" => {\n            println(\"💸 Happy budgeting!\")\n            return false\n        }\n        _ => {\n            println(\"❌ Invalid choice\")\n        }\n    }\n    \n    return true\n}\n\n// Main program loop\nwhile main_menu() {\n    // Continue until user quits\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch01-02-hello-world": {
      "chapter": "ch01-02-hello-world",
      "total_examples": 8,
      "working_examples": 7,
      "failing_examples": 1,
      "examples": [
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ✅ WORKING\nfun main() {\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 2,
          "line_number": 84,
          "code": "// Status: ✅ WORKING\nfun main() {\n    println(\"Hello\", \"World\", \"from\", \"Ruchy\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 3,
          "line_number": 102,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let name = \"Alice\";\n    println(\"Hello,\", name);\n    \n    // String concatenation (interpolation coming in future versions)\n    println(\"Hello, \" + name + \"!\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpa8Lxrt/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let name = \"Alice\" ; { println ! (\"{} {}\" , \"Hello,\" , name) ; println ! (\"{}\" , \"He...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpa8Lxrt/main.rs:1:50\n  |\n1 | ...main () { { { let name = \"Alice\" ; { println ! (\"{} {}\" , \"Hello,\" , name) ; println ! (\"{}\" , \"Hello, \" + name + \"!\") } } } }\n  |              ^^                                                                                                              ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let name = \"Alice\" ; { println ! (\"{} {}\" , \"Hello,\" , name) ; println ! (\"{}\" , \"Hello, \" + name + \"!\") } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let name = \"Alice\" ; { println ! (\"{} {}\" , \"Hello,\" , name) ; println ! (\"{}\" , \"Hello, \" + name + \"!\") } } }\n  |\n\nerror[E0369]: cannot add `&str` to `&str`\n --> /tmp/.tmpa8Lxrt/main.rs:1:145\n  |\n1 | ...ello,\" , name) ; println ! (\"{}\" , \"Hello, \" + name + \"!\") } } } }\n  |                                       --------- ^ ---- &str\n  |                                       |         |\n  |                                       |         `+` cannot be used to concatenate two `&str` strings\n  |                                       &str\n  |\n  = note: string concatenation requires an owned `String` on the left\nhelp: create an owned `String` from a string reference\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let name = \"Alice\" ; { println ! (\"{} {}\" , \"Hello,\" , name) ; println ! (\"{}\" , \"Hello, \".to_owned() + name + \"!\") } } } }\n  |                                                                                                                                                +++++++++++\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0369`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 4,
          "line_number": 125,
          "code": "// Status: ✅ WORKING\nfun main() {\n    println(\"The answer is\", 42);\n    println(\"Pi is approximately\", 3.14159);\n    println(\"Is Ruchy awesome?\", true);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 5,
          "line_number": 148,
          "code": "// Status: ✅ WORKING\n// ❌ This won't work - intentional error example\n// println(Hello, World!);\n//\n\n// Always use quotes for literal text.\n\nfun main() {\n    // ✅ Correct way:\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 6,
          "line_number": 166,
          "code": "// Status: ✅ WORKING\n// ❌ Quotes don't match - intentional error example\n// println(\"Hello, World!');\n//\n\n// Use either \"...\" or '...' but be consistent.\n\nfun main() {\n    // ✅ Correct way:\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 7,
          "line_number": 184,
          "code": "// Status: ✅ WORKING\n// ❌ Wrong capitalization - intentional error example\n// PrintLn(\"Hello, World!\");\n//\n\n\nfun main() {\n    // ✅ Correct way:\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 8,
          "line_number": 208,
          "code": "// Status: ✅ WORKING\nfun main() {\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch02-00-variables-types": {
      "chapter": "ch02-00-variables-types",
      "total_examples": 9,
      "working_examples": 4,
      "failing_examples": 5,
      "examples": [
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let name = \"Alice\"\n    let age = 25\n    let is_learning = true\n\n    println(\"Hi\", name, \", you're\", age, \"years old!\")\n    println(\"Currently learning Ruchy:\", is_learning)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 2,
          "line_number": 84,
          "code": "// Status: ✅ WORKING\nfun main() {\n    // Text data\n    let first_name = \"John\"\n    let last_name = \"Doe\"\n    let full_name = first_name + \" \" + last_name\n\n    // Numeric data\n    let score = 95\n    let percentage = 95.5\n    let temperature = -10\n\n    // Boolean (true/false) data\n    let is_student = true\n    let has_graduated = false\n    let is_enrolled = !has_graduated\n\n    println(\"Student:\", full_name)\n    println(\"Score:\", score, \"(\", percentage, \"%)\")\n    println(\"Temperature:\", temperature, \"°C\")\n    println(\"Status: student=\", is_student, \", graduated=\", has_graduated)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpvW3SyP/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let first_name = \"John\" ; { let last_name = \"Doe\" ; let full_name = first_name + \" \"...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpvW3SyP/main.rs:1:50\n  |\n1 | ... { { { let first_name = \"John\" ; { let last_name = \"Doe\" ; let full_name = first_name + \" \" + last_name ; let score = 95i32 ; let percentage = 95.5f64 ; let temperature = - 10i32 ; let is_student = true ; let has_graduated = false ; let is_enrolled = ! has_graduated ; println ! (\"{} {}\" , \"Student:\" , full_name) ; println ! (\"{} {} {} {} {}\" , \"Score:\" , score , \"(\" , percentage , \"%)\") ; println ! (\"{} {} {}\" , \"Temperature:\" , temperature , \"°C\") ; println ! (\"{} {} {} {}\" , \"Status: student=\" , is_student , \", graduated=\" , has_graduated) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let first_name = \"John\" ; { let last_name = \"Doe\" ; let full_name = first_name + \" \" + last_name ; let score = 95i32 ; let percentage = 95.5f64 ; let temperature = - 10i32 ; let is_student = true ; let has_graduated = false ; let is_enrolled = ! has_graduated ; println ! (\"{} {}\" , \"Student:\" , full_name) ; println ! (\"{} {} {} {} {}\" , \"Score:\" , score , \"(\" , percentage , \"%)\") ; println ! (\"{} {} {}\" , \"Temperature:\" , temperature , \"°C\") ; println ! (\"{} {} {} {}\" , \"Status: student=\" , is_student , \", graduated=\" , has_graduated) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let first_name = \"John\" ; { let last_name = \"Doe\" ; let full_name = first_name + \" \" + last_name ; let score = 95i32 ; let percentage = 95.5f64 ; let temperature = - 10i32 ; let is_student = true ; let has_graduated = false ; let is_enrolled = ! has_graduated ; println ! (\"{} {}\" , \"Student:\" , full_name) ; println ! (\"{} {} {} {} {}\" , \"Score:\" , score , \"(\" , percentage , \"%)\") ; println ! (\"{} {} {}\" , \"Temperature:\" , temperature , \"°C\") ; println ! (\"{} {} {} {}\" , \"Status: student=\" , is_student , \", graduated=\" , has_graduated) } } }\n  |\n\nerror[E0369]: cannot add `&str` to `&str`\n --> /tmp/.tmpvW3SyP/main.rs:1:133\n  |\n1 | ...st_name = \"Doe\" ; let full_name = first_name + \" \" + last_name ; let score = 95i32 ; let percentage = 95.5f64 ; let temperature = - 10...\n  |                                      ---------- ^ --- &str\n  |                                      |          |\n  |                                      |          `+` cannot be used to concatenate two `&str` strings\n  |                                      &str\n  |\n  = note: string concatenation requires an owned `String` on the left\nhelp: create an owned `String` from a string reference\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let first_name = \"John\" ; { let last_name = \"Doe\" ; let full_name = first_name.to_owned() + \" \" + last_name ; let score = 95i32 ; let percentage = 95.5f64 ; let temperature = - 10i32 ; let is_student = true ; let has_graduated = false ; let is_enrolled = ! has_graduated ; println ! (\"{} {}\" , \"Student:\" , full_name) ; println ! (\"{} {} {} {} {}\" , \"Score:\" , score , \"(\" , percentage , \"%)\") ; println ! (\"{} {} {}\" , \"Temperature:\" , temperature , \"°C\") ; println ! (\"{} {} {} {}\" , \"Status: student=\" , is_student , \", graduated=\" , has_graduated) } } } }\n  |                                                                                                                                    +++++++++++\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0369`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 3,
          "line_number": 115,
          "code": "// Status: ✅ WORKING\nfun main() {\n    // Store user information\n    let username = \"programmer2024\"\n    let mut login_count = 1\n    let mut is_premium = false\n\n    // Use variables in calculations\n    let welcome_bonus = 100\n    let total_points = welcome_bonus + (login_count * 10)\n\n    // Update information (use mut for mutable variables)\n    login_count = login_count + 1\n    is_premium = total_points > 150\n\n    println(\"Welcome back,\", username, \"!\")\n    println(\"Logins:\", login_count, \", Points:\", total_points)\n    println(\"Premium status:\", is_premium)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 4,
          "line_number": 143,
          "code": "// Status: ✅ WORKING\nfun main() {\n    // Store multiple values\n    let favorite_languages = [\"Python\", \"Rust\", \"Ruchy\"]\n    let daily_temperatures = [22.5, 25.0, 23.8, 26.2]\n    let task_completed = [true, false, true, true]\n\n    // Access items by index (starting from 0)\n    println(\"First language:\", favorite_languages[0])\n    println(\"Today's temp:\", daily_temperatures[0], \"°C\")\n\n    // Get list length\n    println(\"I know\", favorite_languages.len(), \"languages\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpDzRoEs/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let favorite_languages = vec ! [\"Python\" , \"Rust\" , \"Ruchy\"] ; { let daily_temperatu...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpDzRoEs/main.rs:1:50\n  |\n1 | ... { { { let favorite_languages = vec ! [\"Python\" , \"Rust\" , \"Ruchy\"] ; { let daily_temperatures = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let task_completed = vec ! [true , false , true , true] ; println ! (\"{} {}\" , \"First language:\" , favorite_languages [0i32]) ; println ! (\"{} {} {}\" , \"Today's temp:\" , daily_temperatures [0i32] , \"°C\") ; println ! (\"{} {} {}\" , \"I know\" , favorite_languages . len () , \"languages\") } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                         ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let favorite_languages = vec ! [\"Python\" , \"Rust\" , \"Ruchy\"] ; { let daily_temperatures = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let task_completed = vec ! [true , false , true , true] ; println ! (\"{} {}\" , \"First language:\" , favorite_languages [0i32]) ; println ! (\"{} {} {}\" , \"Today's temp:\" , daily_temperatures [0i32] , \"°C\") ; println ! (\"{} {} {}\" , \"I know\" , favorite_languages . len () , \"languages\") } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let favorite_languages = vec ! [\"Python\" , \"Rust\" , \"Ruchy\"] ; { let daily_temperatures = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let task_completed = vec ! [true , false , true , true] ; println ! (\"{} {}\" , \"First language:\" , favorite_languages [0i32]) ; println ! (\"{} {} {}\" , \"Today's temp:\" , daily_temperatures [0i32] , \"°C\") ; println ! (\"{} {} {}\" , \"I know\" , favorite_languages . len () , \"languages\") } } }\n  |\n\nerror[E0277]: the type `[&str]` cannot be indexed by `i32`\n --> /tmp/.tmpDzRoEs/main.rs:1:309\n  |\n1 | ...rst language:\" , favorite_languages [0i32]) ; println ! (\"{} {} {}\" , \"Today's temp:\" , daily_temperatures [0i32] , \"°C\") ; println ! ...\n  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[&str]>` is not implemented for `i32`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `Vec<&str>` to implement `Index<i32>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `i32`\n --> /tmp/.tmpDzRoEs/main.rs:1:380\n  |\n1 | ...Today's temp:\" , daily_temperatures [0i32] , \"°C\") ; println ! (\"{} {} {}\" , \"I know\" , favorite_languages . len () , \"languages\") } }...\n  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[f64]>` is not implemented for `i32`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `Vec<f64>` to implement `Index<i32>`\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 5,
          "line_number": 167,
          "code": "// Status: ✅ WORKING\n// ❌ This won't work\nfun main() {\n    user_name = \"Alice\"  \n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `user_name` in this scope\n --> /tmp/.tmpokQv3W/main.rs:1:52\n  |\n1 | use std :: collections :: HashMap ; fn main () { { user_name = \"Alice\" } }\n  |                                                    ^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpokQv3W/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { user_name = \"Alice\" } }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpokQv3W/main.rs:1:50\n  |\n1 | use std :: collections :: HashMap ; fn main () { { user_name = \"Alice\" } }\n  |                                                  ^^                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { user_name = \"Alice\" } }\n1 + use std :: collections :: HashMap ; fn main () { user_name = \"Alice\" }\n  |\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 6,
          "line_number": 180,
          "code": "// Status: ✅ WORKING\n// ❌ This might not work as expected\nfun main() {\n    let age = \"25\"  // String, not number\n    let next_year = age + 1  // Can't add number to string\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpQRJMJM/main.rs:1:98\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let age = \"25\" ; let next_year = age + 1i32 } } }\n  |                                                                                                  ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpQRJMJM/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let age = \"25\" ; let next_year = age + 1i32 } } }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpQRJMJM/main.rs:1:50\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let age = \"25\" ; let next_year = age + 1i32 } } }\n  |                                                  ^^                                               ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let age = \"25\" ; let next_year = age + 1i32 } } }\n1 + use std :: collections :: HashMap ; fn main () { { let age = \"25\" ; let next_year = age + 1i32 } }\n  |\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 7,
          "line_number": 195,
          "code": "// Status: ✅ WORKING\n// ❌ These are different variables\nfun main() {\n    let userName = \"Alice\"\n    let username = \"Bob\"\n    println(userName)  // Prints \"Alice\", not \"Bob\"\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 8,
          "line_number": 218,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let name = \"Alice\"\n    let age = 25\n    println(\"Hi\", name, \", age\", age)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 9,
          "line_number": 285,
          "code": "// Status: ✅ WORKING\nfun main() {\n    // Personal profile\n    let name = \"Alex\"\n    let age = 28\n    let city = \"San Francisco\"\n    let hobby = \"rock climbing\"\n    let goal = \"master Ruchy in 30 days\"\n\n    // Data calculator  \n    let num1 = 15\n    let num2 = 25\n    let sum = num1 + num2\n    let difference = num1 - num2\n    let average = (num1 + num2) / 2\n\n    // Text manipulation\n    let first_name = \"Alex\"\n    let last_name = \"Johnson\"\n    let username = first_name + \"_\" + last_name\n    let email = username + \"@example.com\"\n\n    // Boolean logic\n    let is_adult = age >= 18\n    let lives_in_tech_city = city == \"San Francisco\"\n    let ready_for_job = is_adult && lives_in_tech_city\n\n    println(\"Profile:\", name, age, city)\n    println(\"Math:\", sum, difference, average)\n    println(\"Contact:\", username, email)\n    println(\"Status:\", is_adult, lives_in_tech_city, ready_for_job)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpCRB07h/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let name = \"Alex\" ; { let age = 28i32 ; let city = \"San Francisco\" ; let hobby = \"ro...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpCRB07h/main.rs:1:50\n  |\n1 | ... { { { let name = \"Alex\" ; { let age = 28i32 ; let city = \"San Francisco\" ; let hobby = \"rock climbing\" ; let goal = \"master Ruchy in 30 days\" ; let num1 = 15i32 ; let num2 = 25i32 ; let sum = num1 + num2 ; let difference = num1 - num2 ; let average = num1 + num2 / 2i32 ; let first_name = \"Alex\" ; let last_name = \"Johnson\" ; let username = first_name + \"_\" + last_name ; let email = username + \"@example.com\" ; let is_adult = age >= 18i32 ; let lives_in_tech_city = city == \"San Francisco\" ; let ready_for_job = is_adult && lives_in_tech_city ; println ! (\"{} {} {} {}\" , \"Profile:\" , name , age , city) ; println ! (\"{} {} {} {}\" , \"Math:\" , sum , difference , average) ; println ! (\"{} {} {}\" , \"Contact:\" , username , email) ; println ! (\"{} {} {} {}\" , \"Status:\" , is_adult , lives_in_tech_city , ready_for_job) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let name = \"Alex\" ; { let age = 28i32 ; let city = \"San Francisco\" ; let hobby = \"rock climbing\" ; let goal = \"master Ruchy in 30 days\" ; let num1 = 15i32 ; let num2 = 25i32 ; let sum = num1 + num2 ; let difference = num1 - num2 ; let average = num1 + num2 / 2i32 ; let first_name = \"Alex\" ; let last_name = \"Johnson\" ; let username = first_name + \"_\" + last_name ; let email = username + \"@example.com\" ; let is_adult = age >= 18i32 ; let lives_in_tech_city = city == \"San Francisco\" ; let ready_for_job = is_adult && lives_in_tech_city ; println ! (\"{} {} {} {}\" , \"Profile:\" , name , age , city) ; println ! (\"{} {} {} {}\" , \"Math:\" , sum , difference , average) ; println ! (\"{} {} {}\" , \"Contact:\" , username , email) ; println ! (\"{} {} {} {}\" , \"Status:\" , is_adult , lives_in_tech_city , ready_for_job) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let name = \"Alex\" ; { let age = 28i32 ; let city = \"San Francisco\" ; let hobby = \"rock climbing\" ; let goal = \"master Ruchy in 30 days\" ; let num1 = 15i32 ; let num2 = 25i32 ; let sum = num1 + num2 ; let difference = num1 - num2 ; let average = num1 + num2 / 2i32 ; let first_name = \"Alex\" ; let last_name = \"Johnson\" ; let username = first_name + \"_\" + last_name ; let email = username + \"@example.com\" ; let is_adult = age >= 18i32 ; let lives_in_tech_city = city == \"San Francisco\" ; let ready_for_job = is_adult && lives_in_tech_city ; println ! (\"{} {} {} {}\" , \"Profile:\" , name , age , city) ; println ! (\"{} {} {} {}\" , \"Math:\" , sum , difference , average) ; println ! (\"{} {} {}\" , \"Contact:\" , username , email) ; println ! (\"{} {} {} {}\" , \"Status:\" , is_adult , lives_in_tech_city , ready_for_job) } } }\n  |\n\nerror[E0369]: cannot add `&str` to `&str`\n --> /tmp/.tmpCRB07h/main.rs:1:400\n  |\n1 | ...name = \"Johnson\" ; let username = first_name + \"_\" + last_name ; let email = username + \"@example.com\" ; let is_adult = age >= 18i32 ;...\n  |                                      ---------- ^ --- &str\n  |                                      |          |\n  |                                      |          `+` cannot be used to concatenate two `&str` strings\n  |                                      &str\n  |\n  = note: string concatenation requires an owned `String` on the left\nhelp: create an owned `String` from a string reference\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let name = \"Alex\" ; { let age = 28i32 ; let city = \"San Francisco\" ; let hobby = \"rock climbing\" ; let goal = \"master Ruchy in 30 days\" ; let num1 = 15i32 ; let num2 = 25i32 ; let sum = num1 + num2 ; let difference = num1 - num2 ; let average = num1 + num2 / 2i32 ; let first_name = \"Alex\" ; let last_name = \"Johnson\" ; let username = first_name.to_owned() + \"_\" + last_name ; let email = username + \"@example.com\" ; let is_adult = age >= 18i32 ; let lives_in_tech_city = city == \"San Francisco\" ; let ready_for_job = is_adult && lives_in_tech_city ; println ! (\"{} {} {} {}\" , \"Profile:\" , name , age , city) ; println ! (\"{} {} {} {}\" , \"Math:\" , sum , difference , average) ; println ! (\"{} {} {}\" , \"Contact:\" , username , email) ; println ! (\"{} {} {} {}\" , \"Status:\" , is_adult , lives_in_tech_city , ready_for_job) } } } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                               +++++++++++\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0369`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch06-00-data-structures-tdd": {
      "chapter": "ch06-00-data-structures-tdd",
      "total_examples": 8,
      "working_examples": 3,
      "failing_examples": 5,
      "examples": [
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 1,
          "line_number": 17,
          "code": "fun main() {\n    let greeting = \"Hello\";\n    let name = \"World\";\n    println(greeting);\n    println(name);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 2,
          "line_number": 36,
          "code": "fun main() {\n    let first = \"Hello\";\n    let second = \"Beautiful\";\n    let third = \"World\";\n    println(first);\n    println(second);\n    println(third);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 3,
          "line_number": 58,
          "code": "fun main() {\n    let number = 42;\n    let text = \"Answer\";\n    println(text);\n    println(number);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 4,
          "line_number": 95,
          "code": "let message = \"Hello World\";\nlet name = \"Alice\";\nlet greeting = \"Welcome\";",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpADqRiW/main.rs:1:141\n  |\n1 | ...e = \"Alice\" ; let greeting = \"Welcome\" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpADqRiW/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let message = \"Hello World\" ; let name = \"Alice\" ; let greeting = \"Welcom...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 5,
          "line_number": 102,
          "code": "let text = \"Count\";\nlet number = 100;\nlet flag = true;",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpJqYynS/main.rs:1:124\n  |\n1 | ... let number = 100i32 ; let flag = true } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpJqYynS/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let text = \"Count\" ; let number = 100i32 ; let flag = true } ; if let Som...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 6,
          "line_number": 123,
          "code": "let first_name = \"John\";\nlet last_name = \"Doe\";\nlet title = \"Mr.\";",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpE4uZqZ/main.rs:1:133\n  |\n1 | ... last_name = \"Doe\" ; let title = \"Mr.\" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpE4uZqZ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let first_name = \"John\" ; let last_name = \"Doe\" ; let title = \"Mr.\" } ; i...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 7,
          "line_number": 130,
          "code": "let label = \"Temperature\";\nlet value = 72;\nlet unit = \"Fahrenheit\";",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpEX0EoG/main.rs:1:137\n  |\n1 | ...alue = 72i32 ; let unit = \"Fahrenheit\" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpEX0EoG/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let label = \"Temperature\" ; let value = 72i32 ; let unit = \"Fahrenheit\" }...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 8,
          "line_number": 137,
          "code": "let app_name = \"MyApp\";\nlet version = \"1.0\";\nlet debug = true;",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpBXNZmM/main.rs:1:129\n  |\n1 | ...let version = \"1.0\" ; let debug = true } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpBXNZmM/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let app_name = \"MyApp\" ; let version = \"1.0\" ; let debug = true } ; if le...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch03-00-functions": {
      "chapter": "ch03-00-functions",
      "total_examples": 12,
      "working_examples": 2,
      "failing_examples": 10,
      "examples": [
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ✅ WORKING\nfun main() {\n    // Organize calculations\n    let name = \"Alice\"  \n    let a = 15\n    let b = 27\n\n    // Reusable greeting logic\n    let greeting = \"Hello, \" + name + \"! Welcome to Ruchy!\"\n\n    // Reusable calculation logic  \n    let sum = a + b\n    let result_message = a + \" + \" + b + \" = \" + sum\n\n    println(greeting)\n    println(result_message)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpM9M3vP/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let name = \"Alice\" ; { let a = 15i32 ; let b = 27i32 ; let greeting = \"Hello, \" + na...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpM9M3vP/main.rs:1:50\n  |\n1 | ... { { { let name = \"Alice\" ; { let a = 15i32 ; let b = 27i32 ; let greeting = \"Hello, \" + name + \"! Welcome to Ruchy!\" ; let sum = a + b ; let result_message = a + \" + \" + b + \" = \" + sum ; println ! (\"{}\" , greeting) ; println ! (\"{}\" , result_message) } } } }\n  |       ^^                                                                                                                                                                                                                                                           ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let name = \"Alice\" ; { let a = 15i32 ; let b = 27i32 ; let greeting = \"Hello, \" + name + \"! Welcome to Ruchy!\" ; let sum = a + b ; let result_message = a + \" + \" + b + \" = \" + sum ; println ! (\"{}\" , greeting) ; println ! (\"{}\" , result_message) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let name = \"Alice\" ; { let a = 15i32 ; let b = 27i32 ; let greeting = \"Hello, \" + name + \"! Welcome to Ruchy!\" ; let sum = a + b ; let result_message = a + \" + \" + b + \" = \" + sum ; println ! (\"{}\" , greeting) ; println ! (\"{}\" , result_message) } } }\n  |\n\nerror[E0369]: cannot add `&str` to `&str`\n --> /tmp/.tmpM9M3vP/main.rs:1:134\n  |\n1 | ...2 ; let b = 27i32 ; let greeting = \"Hello, \" + name + \"! Welcome to Ruchy!\" ; let sum = a + b ; let result_message = a + \" + \" + b + \"...\n  |                                       --------- ^ ---- &str\n  |                                       |         |\n  |                                       |         `+` cannot be used to concatenate two `&str` strings\n  |                                       &str\n  |\n  = note: string concatenation requires an owned `String` on the left\nhelp: create an owned `String` from a string reference\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let name = \"Alice\" ; { let a = 15i32 ; let b = 27i32 ; let greeting = \"Hello, \".to_owned() + name + \"! Welcome to Ruchy!\" ; let sum = a + b ; let result_message = a + \" + \" + b + \" = \" + sum ; println ! (\"{}\" , greeting) ; println ! (\"{}\" , result_message) } } } }\n  |                                                                                                                                     +++++++++++\n\nerror[E0277]: cannot add `&str` to `i32`\n --> /tmp/.tmpM9M3vP/main.rs:1:208\n  |\n1 | ...chy!\" ; let sum = a + b ; let result_message = a + \" + \" + b + \" = \" + sum ; println ! (\"{}\" , greeting) ; println ! (\"{}\" , result_me...\n  |                                                     ^ no implementation for `i32 + &str`\n  |\n  = help: the trait `Add<&str>` is not implemented for `i32`\n  = help: the following other types implement trait `Add<Rhs>`:\n            `&i32` implements `Add<i32>`\n            `&i32` implements `Add`\n            `i32` implements `Add<&i32>`\n            `i32` implements `Add`\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 2,
          "line_number": 67,
          "code": "// Status: ✅ WORKING\nfun main() {\n    // Store inputs\n    let input1 = 10\n    let input2 = 20\n\n    // Organize calculations  \n    let sum = input1 + input2\n    let product = input1 * input2\n    let average = sum / 2\n\n    // Organize output\n    let result = \"Sum: \" + sum + \", Product: \" + product + \", Average: \" + average\n    println(result)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpR74UQk/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let input1 = 10i32 ; { let input2 = 20i32 ; let sum = input1 + input2 ; let product ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpR74UQk/main.rs:1:50\n  |\n1 | ... { { { let input1 = 10i32 ; { let input2 = 20i32 ; let sum = input1 + input2 ; let product = input1 * input2 ; let average = sum / 2i32 ; let result = \"Sum: \" + sum + \", Product: \" + product + \", Average: \" + average ; println ! (\"{}\" , result) } } } }\n  |       ^^                                                                                                                                                                                                                                                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let input1 = 10i32 ; { let input2 = 20i32 ; let sum = input1 + input2 ; let product = input1 * input2 ; let average = sum / 2i32 ; let result = \"Sum: \" + sum + \", Product: \" + product + \", Average: \" + average ; println ! (\"{}\" , result) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let input1 = 10i32 ; { let input2 = 20i32 ; let sum = input1 + input2 ; let product = input1 * input2 ; let average = sum / 2i32 ; let result = \"Sum: \" + sum + \", Product: \" + product + \", Average: \" + average ; println ! (\"{}\" , result) } } }\n  |\n\nerror[E0369]: cannot add `i32` to `&str`\n --> /tmp/.tmpR74UQk/main.rs:1:206\n  |\n1 | ...input1 * input2 ; let average = sum / 2i32 ; let result = \"Sum: \" + sum + \", Product: \" + product + \", Average: \" + average ; println ...\n  |                                                              ------- ^ --- i32\n  |                                                              |\n  |                                                              &str\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0369`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 3,
          "line_number": 92,
          "code": "// Status: ✅ WORKING\nfun main() {\n    // Template: greeting with name\n    let user_name = \"Alice\"\n    let greeting_template = \"Hello, \" + user_name + \"! Welcome!\"\n\n    // Template: calculation display\n    let num1 = 15\n    let num2 = 27  \n    let operation = \"addition\"\n    let calc_result = num1 + num2\n    let calc_display = operation + \": \" + num1 + \" + \" + num2 + \" = \" + calc_result\n    \n    println(greeting_template)\n    println(calc_display)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp79Eyag/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let user_name = \"Alice\" ; { let greeting_template = \"Hello, \" + user_name + \"! Welco...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp79Eyag/main.rs:1:50\n  |\n1 | ... { { { let user_name = \"Alice\" ; { let greeting_template = \"Hello, \" + user_name + \"! Welcome!\" ; let num1 = 15i32 ; let num2 = 27i32 ; let operation = \"addition\" ; let calc_result = num1 + num2 ; let calc_display = operation + \": \" + num1 + \" + \" + num2 + \" = \" + calc_result ; println ! (\"{}\" , greeting_template) ; println ! (\"{}\" , calc_display) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                            ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let user_name = \"Alice\" ; { let greeting_template = \"Hello, \" + user_name + \"! Welcome!\" ; let num1 = 15i32 ; let num2 = 27i32 ; let operation = \"addition\" ; let calc_result = num1 + num2 ; let calc_display = operation + \": \" + num1 + \" + \" + num2 + \" = \" + calc_result ; println ! (\"{}\" , greeting_template) ; println ! (\"{}\" , calc_display) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let user_name = \"Alice\" ; { let greeting_template = \"Hello, \" + user_name + \"! Welcome!\" ; let num1 = 15i32 ; let num2 = 27i32 ; let operation = \"addition\" ; let calc_result = num1 + num2 ; let calc_display = operation + \": \" + num1 + \" + \" + num2 + \" = \" + calc_result ; println ! (\"{}\" , greeting_template) ; println ! (\"{}\" , calc_display) } } }\n  |\n\nerror[E0369]: cannot add `&str` to `&str`\n --> /tmp/.tmp79Eyag/main.rs:1:116\n  |\n1 | ...Alice\" ; { let greeting_template = \"Hello, \" + user_name + \"! Welcome!\" ; let num1 = 15i32 ; let num2 = 27i32 ; let operation = \"addit...\n  |                                       --------- ^ --------- &str\n  |                                       |         |\n  |                                       |         `+` cannot be used to concatenate two `&str` strings\n  |                                       &str\n  |\n  = note: string concatenation requires an owned `String` on the left\nhelp: create an owned `String` from a string reference\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let user_name = \"Alice\" ; { let greeting_template = \"Hello, \".to_owned() + user_name + \"! Welcome!\" ; let num1 = 15i32 ; let num2 = 27i32 ; let operation = \"addition\" ; let calc_result = num1 + num2 ; let calc_display = operation + \": \" + num1 + \" + \" + num2 + \" = \" + calc_result ; println ! (\"{}\" , greeting_template) ; println ! (\"{}\" , calc_display) } } } }\n  |                                                                                                                   +++++++++++\n\nerror[E0369]: cannot add `&str` to `&str`\n --> /tmp/.tmp79Eyag/main.rs:1:273\n  |\n1 | ...= num1 + num2 ; let calc_display = operation + \": \" + num1 + \" + \" + num2 + \" = \" + calc_result ; println ! (\"{}\" , greeting_template)...\n  |                                       --------- ^ ---- &str\n  |                                       |         |\n  |                                       |         `+` cannot be used to concatenate two `&str` strings\n  |                                       &str\n  |\n  = note: string concatenation requires an owned `String` on the left\nhelp: create an owned `String` from a string reference\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let user_name = \"Alice\" ; { let greeting_template = \"Hello, \" + user_name + \"! Welcome!\" ; let num1 = 15i32 ; let num2 = 27i32 ; let operation = \"addition\" ; let calc_result = num1 + num2 ; let calc_display = operation.to_owned() + \": \" + num1 + \" + \" + num2 + \" = \" + calc_result ; println ! (\"{}\" , greeting_template) ; println ! (\"{}\" , calc_display) } } } }\n  |                                                                                                                                                                                                                                                                                +++++++++++\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0369`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 4,
          "line_number": 118,
          "code": "// Status: ✅ WORKING\nfun main() {\n    // Input section\n    let temperature_f = 68\n    let user_location = \"San Francisco\"\n\n    // Processing section  \n    let temperature_c = (temperature_f - 32) * 5 / 9\n    let is_comfortable = temperature_c > 18 && temperature_c < 25\n\n    // Output section\n    let weather_report = \"Weather in \" + user_location + \": \" + temperature_f + \"°F (\" + temperature_c + \"°C)\"\n    let comfort_message = if is_comfortable { \"Perfect weather!\" } else { \"Dress accordingly\" }\n\n    println(weather_report)\n    println(comfort_message)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpzBm6Oz/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let user_location = \"San Francisco\" ; let temperature_...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpzBm6Oz/main.rs:1:50\n  |\n1 | ... { { { let temperature_f = 68i32 ; { let user_location = \"San Francisco\" ; let temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let weather_report = \"Weather in \" + user_location + \": \" + temperature_f + \"°F (\" + temperature_c + \"°C)\" ; let comfort_message = if is_comfortable { { \"Perfect weather!\" } } else { { \"Dress accordingly\" } } ; println ! (\"{}\" , weather_report) ; println ! (\"{}\" , comfort_message) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let user_location = \"San Francisco\" ; let temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let weather_report = \"Weather in \" + user_location + \": \" + temperature_f + \"°F (\" + temperature_c + \"°C)\" ; let comfort_message = if is_comfortable { { \"Perfect weather!\" } } else { { \"Dress accordingly\" } } ; println ! (\"{}\" , weather_report) ; println ! (\"{}\" , comfort_message) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let temperature_f = 68i32 ; { let user_location = \"San Francisco\" ; let temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let weather_report = \"Weather in \" + user_location + \": \" + temperature_f + \"°F (\" + temperature_c + \"°C)\" ; let comfort_message = if is_comfortable { { \"Perfect weather!\" } } else { { \"Dress accordingly\" } } ; println ! (\"{}\" , weather_report) ; println ! (\"{}\" , comfort_message) } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpzBm6Oz/main.rs:1:401\n  |\n1 | ...e_c + \"°C)\" ; let comfort_message = if is_comfortable { { \"Perfect weather!\" } } else { { \"Dress accordingly\" } } ; println ! (\"{}\" , ...\n  |                                                            ^^                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let user_location = \"San Francisco\" ; let temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let weather_report = \"Weather in \" + user_location + \": \" + temperature_f + \"°F (\" + temperature_c + \"°C)\" ; let comfort_message = if is_comfortable { { \"Perfect weather!\" } } else { { \"Dress accordingly\" } } ; println ! (\"{}\" , weather_report) ; println ! (\"{}\" , comfort_message) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let user_location = \"San Francisco\" ; let temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let weather_report = \"Weather in \" + user_location + \": \" + temperature_f + \"°F (\" + temperature_c + \"°C)\" ; let comfort_message = if is_comfortable { \"Perfect weather!\" } else { { \"Dress accordingly\" } } ; println ! (\"{}\" , weather_report) ; println ! (\"{}\" , comfort_message) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpzBm6Oz/main.rs:1:433\n  |\n1 | ... = if is_comfortable { { \"Perfect weather!\" } } else { { \"Dress accordingly\" } } ; println ! (\"{}\" , weather_report) ; println ! (\"{}\"...\n  |                                                           ^^                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let user_location = \"San Francisco\" ; let temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let weather_report = \"Weather in \" + user_location + \": \" + temperature_f + \"°F (\" + temperature_c + \"°C)\" ; let comfort_message = if is_comfortable { { \"Perfect weather!\" } } else { { \"Dress accordingly\" } } ; println ! (\"{}\" , weather_report) ; println ! (\"{}\" , comfort_message) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let user_location = \"San Francisco\" ; let temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let weather_report = \"Weather in \" + user_location + \": \" + temperature_f + \"°F (\" + temperature_c + \"°C)\" ; let comfort_message = if is_comfortable { { \"Perfect weather!\" } } else { \"Dress accordingly\" } ; println ! (\"{}\" , weather_report) ; println ! (\"{}\" , comfort_message) } } } }\n  |\n\nerror[E0369]: cannot add `&str` to `&str`\n --> /tmp/.tmpzBm6Oz/main.rs:1:285\n  |\n1 | ...c < 25i32 ; let weather_report = \"Weather in \" + user_location + \": \" + temperature_f + \"°F (\" + temperature_c + \"°C)\" ; let comfort_m...\n  |                                     ------------- ^ ------------- &str\n  |                                     |             |\n  |                                     |             `+` cannot be used to concatenate two `&str` strings\n  |                                     &str\n  |\n  = note: string concatenation requires an owned `String` on the left\nhelp: create an owned `String` from a string reference\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let user_location = \"San Francisco\" ; let temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let weather_report = \"Weather in \".to_owned() + user_location + \": \" + temperature_f + \"°F (\" + temperature_c + \"°C)\" ; let comfort_message = if is_comfortable { { \"Perfect weather!\" } } else { { \"Dress accordingly\" } } ; println ! (\"{}\" , weather_report) ; println ! (\"{}\" , comfort_message) } } } }\n  |                                                                                                                                                                                                                                                                                            +++++++++++\n\nerror: aborting due to 1 previous error; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0369`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 5,
          "line_number": 146,
          "code": "// Status: ✅ WORKING\n// Mathematical operations\nfun square(x) {\n    x * x\n}\n\nfun circle_area(radius) {\n    let pi = 3.14159\n    pi * square(radius)\n}\n\n// Text processing\nfun make_username(first_name, last_name) {\n    first_name + \"_\" + last_name\n}\n\nfun shout(message) {\n    message + \"!!!\"\n}\n\nfun main() {\n    // Use them together\n    let area = circle_area(5)\n    let username = make_username(\"Alice\", \"Johnson\") \n    let excited = shout(\"I love functions\")\n\n    println(\"Circle area:\", area)\n    println(\"Username:\", username)\n    println(excited)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpqlpzcZ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: D...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpqlpzcZ/main.rs:1:192\n  |\n1 | ...fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std ...\n  |                                                                  ^^     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + \"_\" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + \"!!!\" } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" , \"Johnson\") ; let excited = shout (\"I love functions\") ; println ! (\"{} {}\" , \"Circle area:\" , area) ; println ! (\"{} {}\" , \"Username:\" , username) ; println ! (\"{}\" , excited) } } } }\n1 + use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { x * x } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + \"_\" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + \"!!!\" } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" , \"Johnson\") ; let excited = shout (\"I love functions\") ; println ! (\"{} {}\" , \"Circle area:\" , area) ; println ! (\"{} {}\" , \"Username:\" , username) ; println ! (\"{}\" , excited) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpqlpzcZ/main.rs:1:369\n  |\n1 | ...mt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Ad...\n  |                                              ^^                                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + \"_\" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + \"!!!\" } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" , \"Johnson\") ; let excited = shout (\"I love functions\") ; println ! (\"{} {}\" , \"Circle area:\" , area) ; println ! (\"{} {}\" , \"Username:\" , username) ; println ! (\"{}\" , excited) } } } }\n1 + use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { let pi = 3.14159f64 ; pi * square (radius) } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + \"_\" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + \"!!!\" } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" , \"Johnson\") ; let excited = shout (\"I love functions\") ; println ! (\"{} {}\" , \"Circle area:\" , area) ; println ! (\"{} {}\" , \"Username:\" , username) ; println ! (\"{}\" , excited) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpqlpzcZ/main.rs:1:609\n  |\n1 | ... + Clone > (first_name : T , last_name : T) -> T { { first_name + \"_\" + last_name } } fn shout < T : std :: ops :: Add < Output = T > ...\n  |                                                       ^^                            ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + \"_\" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + \"!!!\" } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" , \"Johnson\") ; let excited = shout (\"I love functions\") ; println ! (\"{} {}\" , \"Circle area:\" , area) ; println ! (\"{} {}\" , \"Username:\" , username) ; println ! (\"{}\" , excited) } } } }\n1 + use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { first_name + \"_\" + last_name } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + \"!!!\" } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" , \"Johnson\") ; let excited = shout (\"I love functions\") ; println ! (\"{} {}\" , \"Circle area:\" , area) ; println ! (\"{} {}\" , \"Username:\" , username) ; println ! (\"{}\" , excited) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpqlpzcZ/main.rs:1:804\n  |\n1 | ...lay + std :: fmt :: Debug + Clone > (message : T) -> T { { message + \"!!!\" } } fn main () { { { let area = circle_area (5i32) ; { let ...\n  |                                                             ^^               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + \"_\" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + \"!!!\" } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" , \"Johnson\") ; let excited = shout (\"I love functions\") ; println ! (\"{} {}\" , \"Circle area:\" , area) ; println ! (\"{} {}\" , \"Username:\" , username) ; println ! (\"{}\" , excited) } } } }\n1 + use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + \"_\" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { message + \"!!!\" } fn main () { { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" , \"Johnson\") ; let excited = shout (\"I love functions\") ; println ! (\"{} {}\" , \"Circle area:\" , area) ; println ! (\"{} {}\" , \"Username:\" , username) ; println ! (\"{}\" , excited) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpqlpzcZ/main.rs:1:839\n  |\n1 | ... { { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" , \"Johnson\") ; let excited = shout (\"I love functions\") ; println ! (\"{} {}\" , \"Circle area:\" , area) ; println ! (\"{} {}\" , \"Username:\" , username) ; println ! (\"{}\" , excited) } } } }\n  |       ^^                                                                                                                                                                                                                                                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + \"_\" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + \"!!!\" } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" , \"Johnson\") ; let excited = shout (\"I love functions\") ; println ! (\"{} {}\" , \"Circle area:\" , area) ; println ! (\"{} {}\" , \"Username:\" , username) ; println ! (\"{}\" , excited) } } } }\n1 + use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + \"_\" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + \"!!!\" } } fn main () { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" , \"Johnson\") ; let excited = shout (\"I love functions\") ; println ! (\"{} {}\" , \"Circle area:\" , area) ; println ! (\"{} {}\" , \"Username:\" , username) ; println ! (\"{}\" , excited) } } }\n  |\n\nerror[E0277]: cannot multiply `f64` by `T`\n --> /tmp/.tmpqlpzcZ/main.rs:1:398\n  |\n1 | ... (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + st...\n  |                                                      ^ no implementation for `f64 * T`\n  |\n  = help: the trait `Mul<T>` is not implemented for `f64`\nhelp: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n  |\n1 | use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T where f64: Mul<T> { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + \"_\" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + \"!!!\" } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" , \"Johnson\") ; let excited = shout (\"I love functions\") ; println ! (\"{} {}\" , \"Circle area:\" , area) ; println ! (\"{} {}\" , \"Username:\" , username) ; println ! (\"{}\" , excited) } } } }\n  |                                                                                                                                                                                                                                                                                                                                                                               +++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpqlpzcZ/main.rs:1:624\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + \"_\" + ...\n  |       -                                                                                                                                                                         ----------   ^^^ expected type parameter `T`, found `&str`\n  |       |                                                                                                                                                                         |\n  |       expected this type parameter                                                                                                                                              expected because this is `T`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpqlpzcZ/main.rs:1:816\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + \"!!!\" } ...\n  |       -                                                                                                                                                      -------   ^^^^^ expected type parameter `T`, found `&str`\n  |       |                                                                                                                                                      |\n  |       expected this type parameter                                                                                                                           expected because this is `T`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n\nerror[E0277]: cannot add `&str` to `&str`\n --> /tmp/.tmpqlpzcZ/main.rs:1:892\n  |\n1 | ...a = circle_area (5i32) ; { let username = make_username (\"Alice\" , \"Johnson\") ; let excited = shout (\"I love functions\") ; println ! (...\n  |                                              ^^^^^^^^^^^^^ no implementation for `&str + &str`\n  |\n  = help: the trait `Add<&str>` is not implemented for `&str`\n          but it is implemented for `String`\n  = help: for that trait implementation, expected `String`, found `&str`\nnote: required by a bound in `make_username`\n --> /tmp/.tmpqlpzcZ/main.rs:1:445\n  |\n1 | ... } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt...\n  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `make_username`\n\nerror[E0277]: cannot multiply `&str` by `&str`\n --> /tmp/.tmpqlpzcZ/main.rs:1:892\n  |\n1 | ...a = circle_area (5i32) ; { let username = make_username (\"Alice\" , \"Johnson\") ; let excited = shout (\"I love functions\") ; println ! (...\n  |                                              ^^^^^^^^^^^^^ no implementation for `&str * &str`\n  |\n  = help: the trait `Mul` is not implemented for `&str`\nnote: required by a bound in `make_username`\n --> /tmp/.tmpqlpzcZ/main.rs:1:480\n  |\n1 | ...: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T...\n  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `make_username`\n\nerror[E0277]: cannot add `&str` to `&str`\n --> /tmp/.tmpqlpzcZ/main.rs:1:951\n  |\n1 | ...Alice\" , \"Johnson\") ; let excited = shout (\"I love functions\") ; println ! (\"{} {}\" , \"Circle area:\" , area) ; println ! (\"{} {}\" , \"U...\n  |                                        -----  ^^^^^^^^^^^^^^^^^^ no implementation for `&str + &str`\n  |                                        |\n  |                                        required by a bound introduced by this call\n  |\n  = help: the trait `Add<&str>` is not implemented for `&str`\n          but it is implemented for `String`\n  = help: for that trait implementation, expected `String`, found `&str`\nnote: required by a bound in `shout`\n --> /tmp/.tmpqlpzcZ/main.rs:1:659\n  |\n1 | ..._\" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std ::...\n  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `shout`\n\nerror[E0277]: cannot multiply `&str` by `&str`\n --> /tmp/.tmpqlpzcZ/main.rs:1:951\n  |\n1 | ...Alice\" , \"Johnson\") ; let excited = shout (\"I love functions\") ; println ! (\"{} {}\" , \"Circle area:\" , area) ; println ! (\"{} {}\" , \"U...\n  |                                        -----  ^^^^^^^^^^^^^^^^^^ no implementation for `&str * &str`\n  |                                        |\n  |                                        required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `&str`\nnote: required by a bound in `shout`\n --> /tmp/.tmpqlpzcZ/main.rs:1:694\n  |\n1 | ...td :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : ...\n  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `shout`\n\nerror[E0382]: use of moved value: `x`\n   --> /tmp/.tmpqlpzcZ/main.rs:1:198\n    |\n1   | ...: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output...\n    |                              -               ----^\n    |                              |               |   |\n    |                              |               |   value used here after move\n    |                              |               `x` moved due to usage in operator\n    |                              move occurs because `x` has type `T`, which does not implement the `Copy` trait\n    |\nnote: calling this operator moves the left-hand side\n   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/arith.rs:333:12\n    |\n333 |     fn mul(self, rhs: Rhs) -> Self::Output;\n    |            ^^^^\nhelp: consider cloning the value if the performance cost is acceptable\n    |\n1   | use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x.clone() * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + \"_\" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + \"!!!\" } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" , \"Johnson\") ; let excited = shout (\"I love functions\") ; println ! (\"{} {}\" , \"Circle area:\" , area) ; println ! (\"{} {}\" , \"Username:\" , username) ; println ! (\"{}\" , excited) } } } }\n    |                                                                                                                                                                                                   ++++++++\nhelp: consider further restricting type parameter `T` with trait `Copy`\n    |\n1   | use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + Copy > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { first_name + \"_\" + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { message + \"!!!\" } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" , \"Johnson\") ; let excited = shout (\"I love functions\") ; println ! (\"{} {}\" , \"Circle area:\" , area) ; println ! (\"{} {}\" , \"Username:\" , username) ; println ! (\"{}\" , excited) } } } }\n    |                                                                                                                                                                               ++++++\n\nerror: aborting due to 8 previous errors; 6 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0382.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 6,
          "line_number": 185,
          "code": "// Status: ✅ WORKING\nfun is_even(number) {\n    number % 2 == 0\n}\n\nfun grade_letter(score) {\n    if score >= 90 {\n        \"A\"\n    } else if score >= 80 {\n        \"B\"\n    } else if score >= 70 {\n        \"C\"\n    } else if score >= 60 {\n        \"D\"\n    } else {\n        \"F\"\n    }\n}\n\nfun describe_number(n) {\n    let even_odd = if is_even(n) { \"even\" } else { \"odd\" }\n    let size = if n > 100 { \"large\" } else { \"small\" }\n    n + \" is a \" + size + \" \" + even_odd + \" number\"\n}\n\nfun main() {\n    // Test your functions\n    println(describe_number(42))   // \"42 is a small even number\"\n    println(describe_number(150))  // \"150 is a large even number\"\n    println(grade_letter(85))      // \"B\"\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpEZnnEq/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpEZnnEq/main.rs:1:198\n  |\n1 | ...y + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T...\n  |                                                          ^^                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { number % 2i32 == 0i32 } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpEZnnEq/main.rs:1:391\n  |\n1 | ... { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } ...\n  |       ^^                                                                                                                                                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpEZnnEq/main.rs:1:413\n  |\n1 | ...mt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32...\n  |                                                                   ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { \"A\" } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpEZnnEq/main.rs:1:450\n  |\n1 | ...T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32...\n  |                                                                   ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { \"B\" } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpEZnnEq/main.rs:1:487\n  |\n1 | ...lse { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } }...\n  |                                                                   ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { \"C\" } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpEZnnEq/main.rs:1:524\n  |\n1 | ...lse { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: op...\n  |                                                                   ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { \"D\" } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpEZnnEq/main.rs:1:541\n  |\n1 | ... 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output...\n  |                                                                   ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { \"F\" } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpEZnnEq/main.rs:1:725\n  |\n1 | ... { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } ...\n  |       ^^                                                                                                                                                                                          ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpEZnnEq/main.rs:1:761\n  |\n1 | ... + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\"...\n  |                                                                  ^^      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { \"even\" } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpEZnnEq/main.rs:1:781\n  |\n1 | ...> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small...\n  |                                                                  ^^     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { \"odd\" } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpEZnnEq/main.rs:1:824\n  |\n1 | ...\"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd...\n  |                                                                 ^^       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { \"large\" } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpEZnnEq/main.rs:1:845\n  |\n1 | ...odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } ...\n  |                                                                 ^^       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { \"small\" } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |\n\nerror[E0369]: cannot calculate the remainder of `T` divided by `i32`\n --> /tmp/.tmpEZnnEq/main.rs:1:207\n  |\n1 | ...lay + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output =...\n  |                                                              ------ ^ ---- i32\n  |                                                              |\n  |                                                              T\n  |\nhelp: consider further restricting type parameter `T` with trait `Rem`\n  |\n1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Rem<i32> > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |                                                                                                                                                                                ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpEZnnEq/main.rs:1:200\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } ...\n  |       -                                                                                                                                               -     ^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `bool`\n  |       |                                                                                                                                               |\n  |       expected this type parameter                                                                                                                    expected `T` because of return type\n  |\n  = note: expected type parameter `T`\n                       found type `bool`\n  = note: the caller chooses a type for `T` which can be different from `bool`\n\nerror[E0369]: binary operation `>=` cannot be applied to type `T`\n --> /tmp/.tmpEZnnEq/main.rs:1:402\n  |\n1 | ...y + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if sc...\n  |                                                              ----- ^^ ----- i32\n  |                                                              |\n  |                                                              T\n  |\nhelp: consider further restricting type parameter `T` with trait `PartialOrd`\n  |\n1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                  +++++++++++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpEZnnEq/main.rs:1:415\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } ...\n  |       -                                                                                                                                              -                           ^^^ expected type parameter `T`, found `&str`\n  |       |                                                                                                                                              |\n  |       expected this type parameter                                                                                                                   expected `T` because of return type\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n  = note: the caller chooses a type for `T` which can be different from `&'static str`\n\nerror[E0369]: binary operation `>=` cannot be applied to type `T`\n --> /tmp/.tmpEZnnEq/main.rs:1:439\n  |\n1 | ...ore : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if sc...\n  |                                                              ----- ^^ ----- i32\n  |                                                              |\n  |                                                              T\n  |\nhelp: consider further restricting type parameter `T` with trait `PartialOrd`\n  |\n1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                  +++++++++++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpEZnnEq/main.rs:1:452\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } ...\n  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                            ^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n  = note: the caller chooses a type for `T` which can be different from `&'static str`\n\nerror[E0369]: binary operation `>=` cannot be applied to type `T`\n --> /tmp/.tmpEZnnEq/main.rs:1:476\n  |\n1 | ... { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\"...\n  |                                                              ----- ^^ ----- i32\n  |                                                              |\n  |                                                              T\n  |\nhelp: consider further restricting type parameter `T` with trait `PartialOrd`\n  |\n1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                  +++++++++++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpEZnnEq/main.rs:1:489\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } ...\n  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                                                                 ^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n  = note: the caller chooses a type for `T` which can be different from `&'static str`\n\nerror[E0369]: binary operation `>=` cannot be applied to type `T`\n --> /tmp/.tmpEZnnEq/main.rs:1:513\n  |\n1 | ... { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T...\n  |                                                              ----- ^^ ----- i32\n  |                                                              |\n  |                                                              T\n  |\nhelp: consider further restricting type parameter `T` with trait `PartialOrd`\n  |\n1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                  +++++++++++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpEZnnEq/main.rs:1:526\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } ...\n  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                                                                                                      ^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n  = note: the caller chooses a type for `T` which can be different from `&'static str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpEZnnEq/main.rs:1:543\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } ...\n  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                                                                                                                       ^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n  = note: the caller chooses a type for `T` which can be different from `&'static str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpEZnnEq/main.rs:1:756\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) {...\n  |       -                                                                                                                                                                    -------  ^ expected `bool`, found type parameter `T`\n  |       |                                                                                                                                                                    |\n  |       found this type parameter                                                                                                                                            arguments to this function are incorrect\n  |\n  = note:        expected type `bool`\n          found type parameter `T`\nhelp: the return type of this call is `T` due to the type of the argument passed\n --> /tmp/.tmpEZnnEq/main.rs:1:747\n  |\n1 | ... : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { {...\n  |                                       ^^^^^^^^^-^\n  |                                                |\n  |                                                this argument influences the return type of `is_even`\nnote: function defined here\n --> /tmp/.tmpEZnnEq/main.rs:1:40\n  |\n1 | ...fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -...\n  |       ^^^^^^^                                                                                                                                    ----------\n\nerror[E0277]: cannot add `bool` to `bool`\n --> /tmp/.tmpEZnnEq/main.rs:1:756\n  |\n1 | ...e > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } el...\n  |                                             -------  ^ no implementation for `bool + bool`\n  |                                             |\n  |                                             required by a bound introduced by this call\n  |\n  = help: the trait `Add` is not implemented for `bool`\nnote: required by a bound in `is_even`\n --> /tmp/.tmpEZnnEq/main.rs:1:54\n  |\n1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: ...\n  |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_even`\n\nerror[E0277]: cannot multiply `bool` by `bool`\n --> /tmp/.tmpEZnnEq/main.rs:1:756\n  |\n1 | ...e > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } el...\n  |                                             -------  ^ no implementation for `bool * bool`\n  |                                             |\n  |                                             required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `bool`\nnote: required by a bound in `is_even`\n --> /tmp/.tmpEZnnEq/main.rs:1:89\n  |\n1 | ...d :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T)...\n  |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_even`\n\nerror[E0369]: binary operation `>` cannot be applied to type `T`\n --> /tmp/.tmpEZnnEq/main.rs:1:813\n  |\n1 | ...ven (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" ...\n  |                                                                - ^ ------ i32\n  |                                                                |\n  |                                                                T\n  |\nhelp: consider further restricting type parameter `T` with trait `PartialOrd`\n  |\n1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    +++++++++++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpEZnnEq/main.rs:1:865\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + ...\n  |       -                                                                                                                                                                                                                                                                                      -   ^^^^^^^^ expected type parameter `T`, found `&str`\n  |       |                                                                                                                                                                                                                                                                                      |\n  |       expected this type parameter                                                                                                                                                                                                                                                           expected because this is `T`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpEZnnEq/main.rs:1:883\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + ...\n  |       -                                                                                                                                                                                                                                                                                      -------------------   ^^^ expected type parameter `T`, found `&str`\n  |       |                                                                                                                                                                                                                                                                                      |\n  |       expected this type parameter                                                                                                                                                                                                                                                           expected because this is `T`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpEZnnEq/main.rs:1:889\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + ...\n  |       -                                                                                                                                                                                                                                                                                      -------------------------   ^^^^^^^^ expected type parameter `T`, found `&str`\n  |       |                                                                                                                                                                                                                                                                                      |\n  |       expected this type parameter                                                                                                                                                                                                                                                           expected because this is `T`\n  |\n  = note: expected type parameter `T`\n                  found reference `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpEZnnEq/main.rs:1:900\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; n + \" is a \" + size + \" \" + even_odd + \" number\" } ...\n  |       -                                                                                                                                                                                                                                                                                      ------------------------------------   ^^^^^^^^^ expected type parameter `T`, found `&str`\n  |       |                                                                                                                                                                                                                                                                                      |\n  |       expected this type parameter                                                                                                                                                                                                                                                           expected because this is `T`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n\nerror: aborting due to 19 previous errors; 13 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0369.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 7,
          "line_number": 225,
          "code": "// Status: ✅ WORKING\nfun calculate_total(prices) {\n    let mut total = 0.0\n    let mut i = 0\n    while i < prices.len() {\n        total = total + prices[i]\n        i = i + 1\n    }\n    total\n}\n\nfun find_max(numbers) {\n    let mut max_val = numbers[0]\n    let mut i = 0\n    while i < numbers.len() {\n        if numbers[i] > max_val {\n            max_val = numbers[i]\n        }\n        i = i + 1\n    }\n    max_val\n}\n\nfun count_words(text) {\n    let words = text.split(\" \")\n    words.len()\n}\n\nfun main() {\n    // Real-world usage\n    let shopping_cart = [19.99, 5.50, 12.00, 8.75]\n    let test_scores = [85, 92, 78, 96, 88]\n    let essay = \"Functions make code reusable and testable\"\n\n    println(\"Total cost: $\", calculate_total(shopping_cart))\n    println(\"Highest score:\", find_max(test_scores))\n    println(\"Word count:\", count_words(essay))\n}",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp851z3V/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std ::...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp851z3V/main.rs:1:615\n  |\n1 | ...e i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T ...\n  |                                                          ^^                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let essay = \"Functions make code reusable and testable\" ; println ! (\"{} {}\" , \"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" , count_words (essay)) } } } }\n1 + use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { max_val = numbers [i] } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let essay = \"Functions make code reusable and testable\" ; println ! (\"{} {}\" , \"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" , count_words (essay)) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp851z3V/main.rs:1:839\n  |\n1 | ...t :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = ...\n  |                                           ^^                                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let essay = \"Functions make code reusable and testable\" ; println ! (\"{} {}\" , \"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" , count_words (essay)) } } } }\n1 + use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { let words = text . split (\" \") ; words . len () } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let essay = \"Functions make code reusable and testable\" ; println ! (\"{} {}\" , \"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" , count_words (essay)) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp851z3V/main.rs:1:910\n  |\n1 | ... { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let essay = \"Functions make code reusable and testable\" ; println ! (\"{} {}\" , \"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" , count_words (essay)) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let essay = \"Functions make code reusable and testable\" ; println ! (\"{} {}\" , \"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" , count_words (essay)) } } } }\n1 + use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn main () { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let essay = \"Functions make code reusable and testable\" ; println ! (\"{} {}\" , \"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" , count_words (essay)) } } }\n  |\n\nerror[E0599]: no method named `len` found for type parameter `T` in the current scope\n --> /tmp/.tmp851z3V/main.rs:1:269\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len ()...\n  |       - method `len` not found for this type parameter                                                                                                                                                                   ^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let essay = \"Functions make code reusable and testable\" ; println ! (\"{} {}\" , \"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" , count_words (essay)) } } } }\n  |                                                                                                                                                                                        +++++++++++++++++++\n\nerror[E0608]: cannot index into a value of type `T`\n --> /tmp/.tmp851z3V/main.rs:1:303\n  |\n1 | ... i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Ad...\n  |                                                                     ^^^\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp851z3V/main.rs:1:328\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } ...\n  |       - expected this type parameter                                                                                                                  - expected `T` because of return type                                                                                         ^^^^^ expected type parameter `T`, found `f64`\n  |\n  = note: expected type parameter `T`\n                       found type `f64`\n  = note: the caller chooses a type for `T` which can be different from `f64`\n\nerror[E0608]: cannot index into a value of type `T`\n --> /tmp/.tmp851z3V/main.rs:1:529\n  |\n1 | ...ebug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers ...\n  |                                                                    ^^^^^^\n\nerror[E0599]: no method named `len` found for type parameter `T` in the current scope\n --> /tmp/.tmp851z3V/main.rs:1:577\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len ()...\n  |       - method `len` not found for this type parameter                                                                                                                                                                                 ^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let essay = \"Functions make code reusable and testable\" ; println ! (\"{} {}\" , \"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" , count_words (essay)) } } } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              +++++++++++++++++++\n\nerror[E0608]: cannot index into a value of type `T`\n --> /tmp/.tmp851z3V/main.rs:1:599\n  |\n1 | ...] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_...\n  |                                                                     ^^^\n\nerror[E0608]: cannot index into a value of type `T`\n --> /tmp/.tmp851z3V/main.rs:1:635\n  |\n1 | ...bers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ...\n  |                                                                     ^^^\n\nerror[E0599]: no method named `split` found for type parameter `T` in the current scope\n --> /tmp/.tmp851z3V/main.rs:1:862\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\"...\n  |       - method `split` not found for this type parameter                                                                                                                       ^^^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `split`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + BufRead > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let essay = \"Functions make code reusable and testable\" ; println ! (\"{} {}\" , \"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" , count_words (essay)) } } } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   +++++++++\n\nerror[E0277]: cannot add `Vec<f64>` to `Vec<f64>`\n --> /tmp/.tmp851z3V/main.rs:1:1162\n  |\n1 | ... (\"{} {}\" , \"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" , find_max (test_scores)) ; pri...\n  |                                  ---------------  ^^^^^^^^^^^^^ no implementation for `Vec<f64> + Vec<f64>`\n  |                                  |\n  |                                  required by a bound introduced by this call\n  |\n  = help: the trait `Add` is not implemented for `Vec<f64>`\nnote: required by a bound in `calculate_total`\n --> /tmp/.tmp851z3V/main.rs:1:62\n  |\n1 | ...p ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt ...\n  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `calculate_total`\n\nerror[E0277]: cannot multiply `Vec<f64>` by `Vec<f64>`\n --> /tmp/.tmp851z3V/main.rs:1:1162\n  |\n1 | ... (\"{} {}\" , \"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" , find_max (test_scores)) ; pri...\n  |                                  ---------------  ^^^^^^^^^^^^^ no implementation for `Vec<f64> * Vec<f64>`\n  |                                  |\n  |                                  required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `Vec<f64>`\nnote: required by a bound in `calculate_total`\n --> /tmp/.tmp851z3V/main.rs:1:97\n  |\n1 | ... ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> ...\n  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `calculate_total`\n\nerror[E0277]: `Vec<f64>` doesn't implement `std::fmt::Display`\n --> /tmp/.tmp851z3V/main.rs:1:1162\n  |\n1 | ..., \"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{...\n  |                        ---------------  ^^^^^^^^^^^^^ the trait `std::fmt::Display` is not implemented for `Vec<f64>`\n  |                        |\n  |                        required by a bound introduced by this call\n  |\nnote: required by a bound in `calculate_total`\n --> /tmp/.tmp851z3V/main.rs:1:132\n  |\n1 | ...td :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; l...\n  |                                      ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `calculate_total`\n\nerror[E0277]: `Vec<f64>` doesn't implement `std::fmt::Display`\n --> /tmp/.tmp851z3V/main.rs:1:1145\n  |\n1 | ...ln ! (\"{} {}\" , \"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" , find_max (test_scores)) ;...\n  |              --                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `Vec<f64>` cannot be formatted with the default formatter\n  |              |\n  |              required by this formatting parameter\n  |\n  = help: the trait `std::fmt::Display` is not implemented for `Vec<f64>`\n  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add `Vec<i32>` to `Vec<i32>`\n --> /tmp/.tmp851z3V/main.rs:1:1230\n  |\n1 | ...n ! (\"{} {}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" , count_words (essay)) } } } }\n  |                                      --------  ^^^^^^^^^^^ no implementation for `Vec<i32> + Vec<i32>`\n  |                                      |\n  |                                      required by a bound introduced by this call\n  |\n  = help: the trait `Add` is not implemented for `Vec<i32>`\nnote: required by a bound in `find_max`\n --> /tmp/.tmp851z3V/main.rs:1:356\n  |\n1 | ...} ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: f...\n  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`\n\nerror[E0277]: cannot multiply `Vec<i32>` by `Vec<i32>`\n --> /tmp/.tmp851z3V/main.rs:1:1230\n  |\n1 | ...n ! (\"{} {}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" , count_words (essay)) } } } }\n  |                                      --------  ^^^^^^^^^^^ no implementation for `Vec<i32> * Vec<i32>`\n  |                                      |\n  |                                      required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `Vec<i32>`\nnote: required by a bound in `find_max`\n --> /tmp/.tmp851z3V/main.rs:1:391\n  |\n1 | ... :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T)...\n  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`\n\nerror[E0277]: `Vec<i32>` doesn't implement `std::fmt::Display`\n --> /tmp/.tmp851z3V/main.rs:1:1230\n  |\n1 | ...}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" , count_words (essay)) } } } }\n  |                            --------  ^^^^^^^^^^^ the trait `std::fmt::Display` is not implemented for `Vec<i32>`\n  |                            |\n  |                            required by a bound introduced by this call\n  |\nnote: required by a bound in `find_max`\n --> /tmp/.tmp851z3V/main.rs:1:426\n  |\n1 | ... + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = n...\n  |                                          ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`\n\nerror[E0277]: `Vec<i32>` doesn't implement `std::fmt::Display`\n --> /tmp/.tmp851z3V/main.rs:1:1220\n  |\n1 | ...rintln ! (\"{} {}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" , count_words (essay)) } } } }\n  |                  --                       ^^^^^^^^^^^^^^^^^^^^^^ `Vec<i32>` cannot be formatted with the default formatter\n  |                  |\n  |                  required by this formatting parameter\n  |\n  = help: the trait `std::fmt::Display` is not implemented for `Vec<i32>`\n  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add `&str` to `&str`\n --> /tmp/.tmp851z3V/main.rs:1:1296\n  |\n1 | ...; println ! (\"{} {}\" , \"Word count:\" , count_words (essay)) } } } }\n  |                                           -----------  ^^^^^ no implementation for `&str + &str`\n  |                                           |\n  |                                           required by a bound introduced by this call\n  |\n  = help: the trait `Add<&str>` is not implemented for `&str`\n          but it is implemented for `String`\n  = help: for that trait implementation, expected `String`, found `&str`\nnote: required by a bound in `count_words`\n --> /tmp/.tmp851z3V/main.rs:1:697\n  |\n1 | ...x_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fm...\n  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `count_words`\n\nerror[E0277]: cannot multiply `&str` by `&str`\n --> /tmp/.tmp851z3V/main.rs:1:1296\n  |\n1 | ...; println ! (\"{} {}\" , \"Word count:\" , count_words (essay)) } } } }\n  |                                           -----------  ^^^^^ no implementation for `&str * &str`\n  |                                           |\n  |                                           required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `&str`\nnote: required by a bound in `count_words`\n --> /tmp/.tmp851z3V/main.rs:1:732\n  |\n1 | ...:: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> ...\n  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `count_words`\n\nerror: aborting due to 18 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0599, E0608.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: len()"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 8,
          "line_number": 273,
          "code": "// Status: ✅ WORKING\n// ❌ This returns nothing (unit type)\nfun bad_add(a, b) {\n    a + b;\n    // The semicolon makes this a statement, returns ()\n}\n\n// ✅ This returns the sum\nfun good_add(a, b) {\n    a + b  // No semicolon - this is an expression\n}\n\nfun main() {\n    println(good_add(2, 3))\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 9,
          "line_number": 296,
          "code": "// Status: ✅ WORKING\nfun greet(name, age) {\n    \"Hi \" + name + \", you're \" + age + \" years old\"\n}\n\nfun main() {\n    // ❌ This won't work\n    let msg = greet(\"Alice\")  // Missing age parameter\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpU0xYnk/main.rs:1:299\n  |\n1 | ... main () { { let msg = greet (\"Alice\") } }\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpU0xYnk/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn greet < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Di...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpU0xYnk/main.rs:1:204\n  |\n1 | ...ug + Clone > (name : T , age : T) -> T { { \"Hi \" + name + \", you're \" + age + \" years old\" } } fn main () { { let msg = greet (\"Alice\"...\n  |                                             ^^                                               ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn greet < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , age : T) -> T { { \"Hi \" + name + \", you're \" + age + \" years old\" } } fn main () { { let msg = greet (\"Alice\") } }\n1 + use std :: collections :: HashMap ; fn greet < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , age : T) -> T { \"Hi \" + name + \", you're \" + age + \" years old\" } fn main () { { let msg = greet (\"Alice\") } }\n  |\n\nerror[E0369]: cannot add `T` to `&str`\n --> /tmp/.tmpU0xYnk/main.rs:1:212\n  |\n1 | ...std :: fmt :: Debug + Clone > (name : T , age : T) -> T { { \"Hi \" + name + \", you're \" + age + \" years old\" } } fn main () { { let msg...\n  |                                                                ----- ^ ---- T\n  |                                                                |\n  |                                                                &str\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpU0xYnk/main.rs:1:221\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , age : T) -> T { { \"Hi \" + name + \", you're \" + ...\n  |       - expected this type parameter                                                                                                                                               ^^^^^^^^^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpU0xYnk/main.rs:1:241\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , age : T) -> T { { \"Hi \" + name + \", you're \" + age + \" years old\" } ...\n  |       - expected this type parameter                                                                                                                                                                   ^^^^^^^^^^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n\nerror: aborting due to 4 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 10,
          "line_number": 314,
          "code": "// Status: ✅ WORKING\n// ❌ Parameters are read-only\nfun bad_function(x) {\n    x = x + 1  \n    x\n}\n\n// ✅ Create new variables inside functions\nfun good_function(x) {\n    let result = x + 1\n    result\n}\n\nfun main() {\n    println(good_function(5))\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpLypcMt/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn bad_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fm...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpLypcMt/main.rs:1:383\n  |\n1 | ... + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; result } } } fn main () { { println ! (\"{}\" , good_functio...\n  |                                                    ^^                                  ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn bad_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; x } } fn good_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; result } } } fn main () { { println ! (\"{}\" , good_function (5i32)) } }\n1 + use std :: collections :: HashMap ; fn bad_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; x } } fn good_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { let result = x + 1i32 ; result } } fn main () { { println ! (\"{}\" , good_function (5i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpLypcMt/main.rs:1:437\n  |\n1 | ...esult = x + 1i32 ; result } } } fn main () { { println ! (\"{}\" , good_function (5i32)) } }\n  |                                                 ^^                                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn bad_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; x } } fn good_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; result } } } fn main () { { println ! (\"{}\" , good_function (5i32)) } }\n1 + use std :: collections :: HashMap ; fn bad_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; x } } fn good_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; result } } } fn main () { println ! (\"{}\" , good_function (5i32)) }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpLypcMt/main.rs:1:208\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; ...\n  |       -                                                                                                                                                    -   ^^^^ expected type parameter `T`, found `i32`\n  |       |                                                                                                                                                    |\n  |       expected this type parameter                                                                                                                         expected because this is `T`\n  |\n  = note: expected type parameter `T`\n                       found type `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpLypcMt/main.rs:1:404\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; ...\n  |       -                                                                                                                                                               -   ^^^^ expected type parameter `T`, found `i32`\n  |       |                                                                                                                                                               |\n  |       expected this type parameter                                                                                                                                    expected because this is `T`\n  |\n  = note: expected type parameter `T`\n                       found type `i32`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 11,
          "line_number": 344,
          "code": "// Status: ✅ WORKING\nfun add(a, b) {\n    a + b\n}\n\nfun main() {\n    let result = add(10, 20)\n    println(result)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 12,
          "line_number": 437,
          "code": "// Status: ✅ WORKING\n// Personal calculator\nfun celsius_to_fahrenheit(celsius) {\n    (celsius * 9 / 5) + 32\n}\n\nfun calculate_bmi(weight_kg, height_m) {\n    weight_kg / (height_m * height_m)\n}\n\nfun apply_discount(price, discount_percent) {\n    let discount = price * (discount_percent / 100)\n    price - discount\n}\n\n// Text tools\nfun word_count(text) {\n    let words = text.split(\" \")\n    words.len()\n}\n\nfun get_initials(full_name) {\n    let words = full_name.split(\" \")\n    let mut initials = \"\"\n    let mut i = 0\n    while i < words.len() {\n        let word = words[i]\n        initials = initials + word[0]\n        i = i + 1\n    }\n    initials\n}\n\n// Decision makers\nfun recommend_activity(energy_level, available_time) {\n    if energy_level > 7 && available_time > 60 {\n        \"Go for a run or hit the gym!\"\n    } else if energy_level > 5 && available_time > 30 {\n        \"Perfect time for a walk\"\n    } else {\n        \"Maybe just relax and read\"\n    }\n}\n\nfun main() {\n    // Test your functions!\n    println(celsius_to_fahrenheit(20))  // 68\n    println(calculate_bmi(70, 1.75))    // 22.86\n    println(get_initials(\"Alice Johnson\"))  // \"AJ\"\n    println(recommend_activity(8, 45))\n}",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp7KdIv7/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7KdIv7/main.rs:1:213\n  |\n1 | ...td :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Outpu...\n  |                                                      ^^                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { celsius * 9i32 / 5i32 + 32i32 } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7KdIv7/main.rs:1:434\n  |\n1 | ... + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Out...\n  |                                                     ^^                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { weight_kg / height_m * height_m } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7KdIv7/main.rs:1:662\n  |\n1 | ...discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ...\n  |                                 ^^                                                                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { let discount = price * discount_percent / 100i32 ; price - discount } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7KdIv7/main.rs:1:902\n  |\n1 | ...t :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: A...\n  |                                           ^^                                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { let words = text . split (\" \") ; words . len () } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7KdIv7/main.rs:1:1129\n  |\n1 | ... { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } ...\n  |       ^^                                                                                                                                                                                                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7KdIv7/main.rs:1:1243\n  |\n1 | ...ile i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn r...\n  |                             ^^                                                                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7KdIv7/main.rs:1:1547\n  |\n1 | ... { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } ...\n  |       ^^                                                                                                                                                                                                                            ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7KdIv7/main.rs:1:1600\n  |\n1 | ...f energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time...\n  |                                                      ^^                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { \"Go for a run or hit the gym!\" } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7KdIv7/main.rs:1:1695\n  |\n1 | ... if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn ...\n  |                                                        ^^                         ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { \"Perfect time for a walk\" } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7KdIv7/main.rs:1:1734\n  |\n1 | ...e > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to...\n  |                                                       ^^                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { \"Maybe just relax and read\" } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7KdIv7/main.rs:1:225\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / ...\n  |       -                                                                                                                                                      -------   ^^^^ expected type parameter `T`, found `i32`\n  |       |                                                                                                                                                      |\n  |       expected this type parameter                                                                                                                           expected because this is `T`\n  |\n  = note: expected type parameter `T`\n                       found type `i32`\n\nerror[E0369]: cannot divide `T` by `i32`\n --> /tmp/.tmp7KdIv7/main.rs:1:230\n  |\n1 | ... std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Out...\n  |                                                          -------------- ^ ---- i32\n  |                                                          |\n  |                                                          T\n  |\nhelp: consider further restricting type parameter `T` with trait `Div`\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Div<i32> > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |                                                                                                                                                                                              ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7KdIv7/main.rs:1:239\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } ...\n  |       - expected this type parameter                                                                                                                                                 ^^^^^ expected type parameter `T`, found `i32`\n  |\n  = note: expected type parameter `T`\n                       found type `i32`\n\nerror[E0369]: cannot divide `T` by `T`\n --> /tmp/.tmp7KdIv7/main.rs:1:446\n  |\n1 | ...Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add ...\n  |                                                            --------- ^ -------- T\n  |                                                            |\n  |                                                            T\n  |\nhelp: consider further restricting type parameter `T` with trait `Div`\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Div > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++\n\nerror[E0369]: cannot divide `T` by `i32`\n --> /tmp/.tmp7KdIv7/main.rs:1:706\n  |\n1 | ...discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ...\n  |                                                    ------------------------ ^ ------ i32\n  |                                                    |\n  |                                                    T\n  |\nhelp: consider further restricting type parameter `T` with trait `Div`\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Div<i32> > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ++++++++++++++++++++\n\nerror[E0599]: no method named `split` found for type parameter `T` in the current scope\n --> /tmp/.tmp7KdIv7/main.rs:1:925\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\"...\n  |       - method `split` not found for this type parameter                                                                                                                       ^^^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `split`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + BufRead > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  +++++++++\n\nerror[E0599]: no method named `split` found for type parameter `T` in the current scope\n --> /tmp/.tmp7KdIv7/main.rs:1:1157\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\"...\n  |       - method `split` not found for this type parameter                                                                                                                                 ^^^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `split`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + BufRead > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                +++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7KdIv7/main.rs:1:1283\n  |\n1 | ...itials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1...\n  |             -- expected due to this value                                                              ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `str`\n  |\nhelp: consider borrowing here\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = &(initials + word [0i32]) ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ++                      +\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7KdIv7/main.rs:1:1331\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } ...\n  |       - expected this type parameter                                                                                                                     - expected `T` because of return type                                                                                                                                                                         ^^^^^^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&str`\n  = note: the caller chooses a type for `T` which can be different from `&str`\n\nerror[E0369]: binary operation `>` cannot be applied to type `T`\n --> /tmp/.tmp7KdIv7/main.rs:1:1565\n  |\n1 | ... > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!...\n  |                                                           ------------ ^ ---- i32\n  |                                                           |\n  |                                                           T\n  |\nhelp: consider further restricting type parameter `T` with trait `PartialOrd`\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++++++++++++++\n\nerror[E0369]: binary operation `>` cannot be applied to type `T`\n --> /tmp/.tmp7KdIv7/main.rs:1:1590\n  |\n1 | ...vailable_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_l...\n  |                                                          -------------- ^ ----- i32\n  |                                                          |\n  |                                                          T\n  |\nhelp: consider further restricting type parameter `T` with trait `PartialOrd`\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7KdIv7/main.rs:1:1602\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } ...\n  |       - expected this type parameter                                                                                                                                             - expected `T` because of return type                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n  = note: the caller chooses a type for `T` which can be different from `&'static str`\n\nerror[E0369]: binary operation `>` cannot be applied to type `T`\n --> /tmp/.tmp7KdIv7/main.rs:1:1660\n  |\n1 | ...60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } }...\n  |                                                           ------------ ^ ---- i32\n  |                                                           |\n  |                                                           T\n  |\nhelp: consider further restricting type parameter `T` with trait `PartialOrd`\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++++++++++++++\n\nerror[E0369]: binary operation `>` cannot be applied to type `T`\n --> /tmp/.tmp7KdIv7/main.rs:1:1685\n  |\n1 | ...or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just re...\n  |                                                          -------------- ^ ----- i32\n  |                                                          |\n  |                                                          T\n  |\nhelp: consider further restricting type parameter `T` with trait `PartialOrd`\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7KdIv7/main.rs:1:1697\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } ...\n  |       - expected this type parameter                                                                                                                                             - expected `T` because of return type                                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n  = note: the caller chooses a type for `T` which can be different from `&'static str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7KdIv7/main.rs:1:1736\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } ...\n  |       - expected this type parameter                                                                                                                                             - expected `T` because of return type                                                                                                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n  = note: the caller chooses a type for `T` which can be different from `&'static str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7KdIv7/main.rs:1:1881\n  |\n1 | ...\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i...\n  |           -------------  -----   ^^^^^^^ expected `i32`, found `f64`\n  |           |              |\n  |           |              expected all arguments to be this `i32` type because they need to match the type of this parameter\n  |           arguments to this function are incorrect\n  |\nhelp: the return type of this call is `f64` due to the type of the argument passed\n --> /tmp/.tmp7KdIv7/main.rs:1:1858\n  |\n1 | ...) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recomme...\n  |                          ^^^^^^^^^^^^^^^^^^^^^^^-------^\n  |                                                 |\n  |                                                 this argument influences the return type of `calculate_bmi`\nnote: function defined here\n --> /tmp/.tmp7KdIv7/main.rs:1:252\n  |\n1 | ...fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -...\n  |       ^^^^^^^^^^^^^   -                                                                                                                                -------------   ------------ this parameter needs to match the `i32` type of `weight_kg`\n  |                       |                                                                                                                                |\n  |                       `weight_kg` and `height_m` both reference this parameter `T`                                                                     `height_m` needs to match the `i32` type of this parameter\nhelp: change the type of the numeric literal from `f64` to `i32`\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1i32)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nerror[E0277]: cannot add `&str` to `&str`\n --> /tmp/.tmp7KdIv7/main.rs:1:1925\n  |\n1 | ...2 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |                                      ------------  ^^^^^^^^^^^^^^^ no implementation for `&str + &str`\n  |                                      |\n  |                                      required by a bound introduced by this call\n  |\n  = help: the trait `Add<&str>` is not implemented for `&str`\n          but it is implemented for `String`\n  = help: for that trait implementation, expected `String`, found `&str`\nnote: required by a bound in `get_initials`\n --> /tmp/.tmp7KdIv7/main.rs:1:982\n  |\n1 | ...) } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt...\n  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `get_initials`\n\nerror[E0277]: cannot multiply `&str` by `&str`\n --> /tmp/.tmp7KdIv7/main.rs:1:1925\n  |\n1 | ...2 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\")) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |                                      ------------  ^^^^^^^^^^^^^^^ no implementation for `&str * &str`\n  |                                      |\n  |                                      required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `&str`\nnote: required by a bound in `get_initials`\n --> /tmp/.tmp7KdIv7/main.rs:1:1017\n  |\n1 | ...: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T)...\n  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `get_initials`\n\nerror: aborting due to 19 previous errors; 11 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0369, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: split()"
        }
      ]
    },
    "ch01-02-hello-world-tdd": {
      "chapter": "ch01-02-hello-world-tdd",
      "total_examples": 6,
      "working_examples": 6,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 1,
          "line_number": 17,
          "code": "fun main() {\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 2,
          "line_number": 37,
          "code": "fun main() {\n    println(\"Hello,\");\n    println(\"World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 3,
          "line_number": 54,
          "code": "fun main() {\n    let greeting = \"Hello, World!\";\n    println(greeting);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 4,
          "line_number": 100,
          "code": "println(\"Your message here\");",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 5,
          "line_number": 105,
          "code": "let message = \"Your message\";\nprintln(message);",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 6,
          "line_number": 111,
          "code": "println(\"First line\");\nprintln(\"Second line\");",
          "passed": true,
          "status": "working"
        }
      ]
    }
  }
}